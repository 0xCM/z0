| M:Z0.Bits.bfly(Z0.N1,System.Byte)                 | 
            <summary>
            Effects a butterfly permutation on the source that swaps the interior two bits of each 4-bit segment.
            </summary>
            <param name="n">The interior segment width selector</param>
            <param name="x">The bit source</param>
        
| M:Z0.Bits.bfly(Z0.N1,System.UInt16)               | 
            <summary>
            Effects a butterfly permutation on the source that swaps the interior two bits of each 4-bit segment.
            </summary>
            <param name="n">The interior segment width selector</param>
            <param name="x">The bit source</param>
        
| M:Z0.Bits.bfly(Z0.N1,System.UInt32)               | 
            <summary>
            Effects a butterfly permutation on the source that swaps the interior two bits of each 4-bit segment.
            </summary>
            <param name="n">The interior segment width selector</param>
            <param name="x">The bit source</param>
        
| M:Z0.Bits.bfly(Z0.N1,System.UInt64)               | 
            <summary>
            Effects a butterfly permutation on the source that swaps the interior two bits of each 4-bit segment.
            </summary>
            <param name="n">The interior segment width selector</param>
            <param name="x">The bit source</param>
        
| M:Z0.Bits.bfly(Z0.N2,System.Byte)                 | 
            <summary>
            Effects a butterfly permutation on the source that swaps the interior 2-bit segments
            </summary>
            <param name="n">The interior segment width selector</param>
            <param name="x">The bit source</param>
        
| M:Z0.Bits.bfly(Z0.N2,System.UInt16)               | 
            <summary>
            Effects a butterfly permutation on the bit source that swaps the interior 2-bit segments of each 8-bit segment.
            </summary>
            <param name="n">The interior segment width selector</param>
            <param name="x">The bit source</param>
        
| M:Z0.Bits.bfly(Z0.N2,System.UInt32)               | 
            <summary>
            Effects a butterfly permutation on the bit source that swaps the interior 2-bit segments of each 8-bit segment.
            </summary>
            <param name="n">The interior segment width selector</param>
            <param name="x">The bit source</param>
        
| M:Z0.Bits.bfly(Z0.N2,System.UInt64)               | 
            <summary>
            Effects a butterfly permutation on the bit source that swaps the interior 2-bit segments of each 8-bit segment.
            </summary>
            <param name="n">The interior segment width selector</param>
            <param name="x">The bit source</param>
        
| M:Z0.Bits.bfly(Z0.N4,System.UInt16)               | 
            <summary>
            Effects a butterfly permutation on the bit source that swaps the interior 4-bit segments
            </summary>
            <param name="n">The interior segment width selector</param>
            <param name="x">The bit source</param>
            <remarks> [0 1 2 3 ] -&gt; [0 2 1 3] </remarks>
        
| M:Z0.Bits.bfly(Z0.N4,System.UInt32)               | 
            <summary>
            Effects a butterfly permutation on the bit source that swaps the interior 4-bit segments of each 16-bit segment.
            </summary>
            <param name="n">The interior segment width selector</param>
            <param name="x">The bit source</param>
            <remarks> 
            [0 | 1 2 | 3 || 4 | 5 6 | 7] -&gt; [0 | 2 1 | 3 || 4 | 6 5 | 7]
            </remarks>
        
| M:Z0.Bits.bfly(Z0.N4,System.UInt64)               | 
            <summary>
            Effects a butterfly permutation on the bit source that swaps the interior 4-bit segments of each 16-bit segment.
            </summary>
            <param name="n">The interior segment width selector</param>
            <param name="x">The bit source</param>
            <remarks> 
            [0 | 1 2 | 3 || 4 | 5 6 | 7 || 8 | 9 A | B || C | D E | F] -&gt; [0 | 2 1 | 3 || 4 | 6 5 | 7 || 8 | A 9 | B || C | E D | F]
            </remarks>
        
| M:Z0.Bits.bfly(Z0.N8,System.UInt32)               | 
            <summary>
            Effects a butterfly permutation on the bit source that swaps the interior 8-bit segments
            </summary>
            <param name="n">The interior segment width selector</param>
            <param name="x">The bit source</param>
            <remarks>[0 1 2 3] -&gt; [0 2 1 3]</remarks>
        
| M:Z0.Bits.bfly(Z0.N8,System.UInt64)               | 
            <summary>
            Effects a butterfly permutation on the bit source that swaps the interior 8-bit segments of each 32-bit segment.
            </summary>
            <param name="n">The interior segment width selector</param>
            <param name="x">The bit source</param>
            <remarks> [0 1 2 3 | 4 5 6 7] -&gt; [0 2 1 3 | 4 6 5 7]</remarks>
        
| M:Z0.Bits.bfly(Z0.N16,System.UInt64)              | 
            <summary>
            Effects a butterfly permutation on the source that swaps the interior 16-bit segments
            </summary>
            <param name="n">The interior segment width selector</param>
            <param name="x">The bit source</param>
            <remarks>[0 1 2 3] -&gt; [0 2 1 3]</remarks>
        
| M:Z0.Bits.bfly``1(``0,``0,System.Byte)            | 
            <summary>
            Effects a butterfly permutation on the source value, predicated on a supplied mask and shift amount
            </summary>
            <param name="n">The interior segment width selector</param>
            <param name="x">The bit source</param>
            <remarks>The algorithm follows that of Arndt's Matters Computational, bitbutterfly.h.</remarks>
        
| M:Z0.Bits.pindex(System.Int32,Z0.bit)             | 
            <summary>
            Defines a parity index j from a source integer i and a parity bit p, j := i*2 + p
            </summary>
            <param name="i">The source integer</param>
            <param name="p">The parity bit</param>
        
| M:Z0.Bits.blsic(System.Byte)                      | 
            <summary>
            Isolate least set bit and complement, computed by dst := ~src | (src - 1),
            where all bits in the target are set except for the least set bit in the source
            For example, [11101010] |&gt; blisc = [11111101]
            </summary>
            <param name="src">The source vale</param>
        
| M:Z0.Bits.blsic(System.UInt16)                    | 
            <summary>
            Isolate least set bit and complement, computed by dst := ~src | (src - 1),
            where all bits in the target are set except for the least set bit in the source
            For example, [11101010] |&gt; blisc = [11111101]
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.Bits.blsic(System.UInt32)                    | 
            <summary>
            Isolate least set bit and complement, computed by dst := ~src | (src - 1),
            where all bits in the target are set except for the least set bit in the source
            For example, [11101010] |&gt; blisc = [11111101]
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.Bits.blsic(System.UInt64)                    | 
            <summary>
            Isolate least set bit and complement, computed by dst := ~src | (src - 1),
            where all bits in the target are set except for the least set bit in the source
            For example, [11101010] |&gt; blisc = [11111101]
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.Bits.broadcast(System.UInt16,Z0.N32)         | 
            <summary>
            Replicates a 16-bit source over a 32-bit target
            </summary>
            <param name="src">The source value</param>
            <param name="w">The target width</param>
        
| M:Z0.Bits.broadcast(System.Byte,Z0.N64)           | 
            <summary>
            Replicates an 8-bit source over a 64-bit target
            </summary>
            <param name="src">The source value</param>
            <param name="w">The target width</param>
        
| M:Z0.Bits.broadcast(System.UInt16,Z0.N64)         | 
            <summary>
            Replicates a 16-bit source over a 64-bit target
            </summary>
            <param name="src">The source value</param>
            <param name="w">The target width</param>
        
| M:Z0.Bits.broadcast(System.UInt32,Z0.N64)         | 
            <summary>
            Replicates a 32-bit source over a 64-bit target
            </summary>
            <param name="src">The source value</param>
            <param name="w">The target width</param>
        
| M:Z0.Bits.byteclear(System.UInt16,System.Byte)    | 
            <summary>
            Disables a sequence of 8 source bits starting at a specified index
            </summary>
            <param name="src">The bit source</param>
            <param name="index">The index at which to begin clearing bits</param>
        
| M:Z0.Bits.byteclear(System.UInt32,System.Byte)    | 
            <summary>
            Disables a sequence of 8 source bits starting at a specified index
            </summary>
            <param name="src">The bit source</param>
            <param name="index">The index at which to begin clearing bits</param>
        
| M:Z0.Bits.byteclear(System.UInt64,System.Byte)    | 
            <summary>
            Disables a sequence of 8 source bits starting at a specified index
            </summary>
            <param name="src">The bit source</param>
            <param name="index">The index at which to begin clearing bits</param>
        
| M:Z0.Bits.clear(System.Byte,System.Byte,System.Byte)| 
            <summary>
            Disables a sequence of bits starting at a specified index
            </summary>
            <param name="src">The bit source</param>
            <param name="index">The index at which to begin clearing bits</param>
            <param name="count">The number of bits to clear</param>
        
| M:Z0.Bits.clear(System.SByte,System.Byte,System.Byte)| 
            <summary>
            Disables a sequence of bits starting at a specified index
            </summary>
            <param name="src">The bit source</param>
            <param name="index">The index at which to begin clearing bits</param>
            <param name="count">The number of bits to clear</param>
        
| M:Z0.Bits.clear(System.UInt16,System.Byte,System.Byte)| 
            <summary>
            Disables a sequence of bits starting at a specified index
            </summary>
            <param name="src">The bit source</param>
            <param name="index">The index at which to begin clearing bits</param>
            <param name="count">The number of bits to clear</param>
        
| M:Z0.Bits.clear(System.Int16,System.Byte,System.Byte)| 
            <summary>
            Disables a sequence of bits starting at a specified index
            </summary>
            <param name="src">The bit source</param>
            <param name="index">The index at which to begin clearing bits</param>
            <param name="count">The number of bits to clear</param>
        
| M:Z0.Bits.clear(System.UInt32,System.Byte,System.Byte)| 
            <summary>
            Disables a sequence of bits starting at a specified index
            </summary>
            <param name="src">The bit source</param>
            <param name="index">The index at which to begin clearing bits</param>
            <param name="count">The number of bits to clear</param>
        
| M:Z0.Bits.clear(System.Int32,System.Byte,System.Byte)| 
            <summary>
            Disables a sequence of bits starting at a specified index
            </summary>
            <param name="src">The bit source</param>
            <param name="index">The index at which to begin clearing bits</param>
            <param name="count">The number of bits to clear</param>
        
| M:Z0.Bits.clear(System.Int64,System.Byte,System.Byte)| 
            <summary>
            Disables a sequence of bits starting at a specified index
            </summary>
            <param name="src">The bit source</param>
            <param name="index">The index at which to begin clearing bits</param>
            <param name="count">The number of bits to clear</param>
        
| M:Z0.Bits.clear(System.UInt64,System.Byte,System.Byte)| 
            <summary>
            Disables a sequence of bits starting at a specified index
            </summary>
            <param name="src">The bit source</param>
            <param name="index">The index at which to begin clearing bits</param>
            <param name="count">The number of bits to clear</param>
        
| M:Z0.Bits.concat(System.Byte,System.Byte)         | 
            <summary>
            Concatenates the bits of 2 unsigned 8-bit integers to produce an unsigned 16-bit integer
            [a b] -&gt; ab
            </summary>
        
| M:Z0.Bits.concat(System.UInt16,System.UInt16)     | 
            <summary>
            Concatenates the bits of 2 unsigned 16-bit integers to produce and unsigned 32-bit integer
            [a b] -&gt; ab
            </summary>
        
| M:Z0.Bits.concat(System.UInt32@,System.UInt32@)   | 
            <summary>
            Concatenates the bits of 2 unsigned 32-bit integers to produce an unsigned 64-bit integer
            [a b] -&gt; ab
            </summary>
        
| M:Z0.Bits.concat(System.Byte,System.Byte,System.Byte,System.Byte)| 
            <summary>
            Concatenates the bits of 4 unsigned 8-bit integers to produce an unsigned 64-bit integer
            [a b c d] -&gt; abcd
            </summary>
        
| M:Z0.Bits.concat(System.UInt16,System.UInt16,System.UInt16,System.UInt16)| 
            <summary>
            Concatenates the bits of 4 unsigned 16-bit integers to produce an unsigned 64-bit integer
            [a b c d] -&gt; abcd
            </summary>
        
| M:Z0.Bits.concat(System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)| 
            <summary>
            Concatenates the bits of 8 unsigned 8-bit integers to produce an unsigned 64-bit integer
            [a b c d] -&gt; abcd
            </summary>
        
| M:Z0.Bits.copy(System.Byte,System.Byte,System.Byte,System.Byte)| 
            <summary>
            Overwrites a target bit segment dst[index..(start + count)] with the corresponding source segment src[index..(start + count)]
            </summary>
            <param name="src">The source</param>
            <param name="index">The source/target start index</param>
            <param name="count">The number of bits to copy</param>
            <param name="dst">The target</param>
        
| M:Z0.Bits.copy(System.UInt16,System.Byte,System.Byte,System.UInt16)| 
            <summary>
            Overwrites a target bit segment dst[index..(start + count)] with the corresponding source segment src[index..(start + count)]
            </summary>
            <param name="src">The source</param>
            <param name="index">The source/target start index</param>
            <param name="count">The number of bits to copy</param>
            <param name="dst">The target</param>
        
| M:Z0.Bits.copy(System.UInt32,System.Byte,System.Byte,System.UInt32)| 
            <summary>
            Overwrites a target bit segment dst[index..(start + count)] with the corresponding source segment src[index..(start + count)]
            </summary>
            <param name="src">The source</param>
            <param name="index">The source/target start index</param>
            <param name="count">The number of bits to copy</param>
            <param name="dst">The target</param>
        
| M:Z0.Bits.copy(System.UInt64,System.Byte,System.Byte,System.UInt64)| 
            <summary>
            Overwrites a target bit segment dst[index..(start + count)] with the corresponding source segment src[index..(start + count)]
            </summary>
            <param name="src">The source</param>
            <param name="index">The source/target start index</param>
            <param name="count">The number of bits to copy</param>
            <param name="dst">The target</param>
        
| M:Z0.Bits.disable(System.SByte,System.Int32)      | 
            <summary>
            Disables a specified source bit
            </summary>
            <param name="src">The source value to manipulate</param>
            <param name="pos">The position of the bit to disable</param>
        
| M:Z0.Bits.disable(System.Byte,System.Int32)       | 
            <summary>
            Disables a specified source bit
            </summary>
            <param name="src">The source value to manipulate</param>
            <param name="pos">The position of the bit to disable</param>
        
| M:Z0.Bits.disable(System.Int16,System.Int32)      | 
            <summary>
            Disables a specified source bit
            </summary>
            <param name="src">The source value to manipulate</param>
            <param name="pos">The position of the bit to disable</param>
        
| M:Z0.Bits.disable(System.UInt16,System.Int32)     | 
            <summary>
            Disables a specified source bit
            </summary>
            <param name="src">The source value to manipulate</param>
            <param name="pos">The position of the bit to disable</param>
        
| M:Z0.Bits.disable(System.Int32,System.Int32)      | 
            <summary>
            Disables a specified source bit
            </summary>
            <param name="src">The source value to manipulate</param>
            <param name="pos">The position of the bit to disable</param>
        
| M:Z0.Bits.disable(System.UInt32,System.Int32)     | 
            <summary>
            Disables a specified source bit
            </summary>
            <param name="src">The source value to manipulate</param>
            <param name="pos">The position of the bit to disable</param>
        
| M:Z0.Bits.disable(System.Int64,System.Int32)      | 
            <summary>
            Disables a specified source bit
            </summary>
            <param name="src">The source value to manipulate</param>
            <param name="pos">The position of the bit to disable</param>
        
| M:Z0.Bits.disable(System.UInt64,System.Int32)     | 
            <summary>
            Disables a specified source bit
            </summary>
            <param name="src">The source value to manipulate</param>
            <param name="pos">The position of the bit to disable</param>
        
| M:Z0.Bits.disable(System.Single,System.Int32)     | 
            <summary>
            Disables a specified source bit
            </summary>
            <param name="src">The source value to manipulate</param>
            <param name="pos">The position of the bit to disable</param>
        
| M:Z0.Bits.disable(System.Double,System.Int32)     | 
            <summary>
            Disables a specified source bit
            </summary>
            <param name="src">The source value to manipulate</param>
            <param name="pos">The position of the bit to disable</param>
        
| M:Z0.Bits.effsize(System.Byte)                    | 
            <summary>
            Computes the minimum number of bytes required to represent the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.Bits.effsize(System.UInt16)                  | 
            <summary>
            Computes the minimum number of bytes required to represent the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.Bits.effsize(System.UInt32)                  | 
            <summary>
            Computes the minimum number of bytes required to represent the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.Bits.effsize_baseline(System.UInt64)         | 
            <summary>
            Computes the minimum number of bytes required to represent the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.Bits.effsize(System.UInt64)                  | 
            <summary>
            Computes the minimum number of bytes required to represent the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.Bits.effsize(System.SByte)                   | 
            <summary>
            Computes the minimum number of bytes required to represent a value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.Bits.effsize(System.Int16)                   | 
            <summary>
            Computes the minimum number of bytes required to represent the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.Bits.effsize(System.Int32)                   | 
            <summary>
            Computes the minimum number of bytes required to represent the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.Bits.effsize(System.Int64)                   | 
            <summary>
            Computes the minimum number of bytes required to represent the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.Bits.bitcount(System.UInt32)                 | 
            <summary>
            
            </summary>
            <param name="src"></param>
            <Remarks>Adapted from .Net Core project System.Reflection.Metadata, BitArithmetic class</Remarks>
        
| M:Z0.Bits.bitcount(System.UInt64)                 | 
            <summary>
            
            </summary>
            <param name="src"></param>
            <Remarks>Adapted from .Net Core project System.Reflection.Metadata, BitArithmetic class</Remarks>
        
| M:Z0.Bits.effwidth(System.Byte)                   | 
            <summary>
            Computes the minimum number of bits required to represent the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.Bits.effwidth(System.UInt16)                 | 
            <summary>
            Computes the minimum number of bits required to represent the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.Bits.effwidth(System.UInt32)                 | 
            <summary>
            Computes the minimum number of bits required to represent the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.Bits.effwidth(System.UInt64)                 | 
            <summary>
            Computes the minimum number of bits required to represent the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.Bits.enable(System.SByte,System.Int32)       | 
            <summary>
            Enables a specified source bit
            </summary>
            <param name="src">The source value to manipulate</param>
            <param name="pos">The position of the bit to enable</param>
        
| M:Z0.Bits.enable(System.Byte,System.Int32)        | 
            <summary>
            Enables a specified source bit
            </summary>
            <param name="src">The source value to manipulate</param>
            <param name="pos">The position of the bit to enable</param>
        
| M:Z0.Bits.enable(System.Int16,System.Int32)       | 
            <summary>
            Enables a specified source bit
            </summary>
            <param name="src">The source value to manipulate</param>
            <param name="pos">The position of the bit to enable</param>
        
| M:Z0.Bits.enable(System.UInt16,System.Int32)      | 
            <summary>
            Enables a specified source bit
            </summary>
            <param name="src">The source value to manipulate</param>
            <param name="pos">The position of the bit to enable</param>
        
| M:Z0.Bits.enable(System.Int32,System.Int32)       | 
            <summary>
            Enables a specified source bit
            </summary>
            <param name="src">The source value to manipulate</param>
            <param name="pos">The position of the bit to enable</param>
        
| M:Z0.Bits.enable(System.UInt32,System.Int32)      | 
            <summary>
            Enables a specified source bit
            </summary>
            <param name="src">The source value to manipulate</param>
            <param name="pos">The position of the bit to enable</param>
        
| M:Z0.Bits.enable(System.Int64,System.Int32)       | 
            <summary>
            Enables a specified source bit
            </summary>
            <param name="src">The source value to manipulate</param>
            <param name="pos">The position of the bit to enable</param>
        
| M:Z0.Bits.enable(System.UInt64,System.Int32)      | 
            <summary>
            Enables a specified source bit
            </summary>
            <param name="src">The source value to manipulate</param>
            <param name="pos">The position of the bit to enable</param>
        
| M:Z0.Bits.enable(System.Single,System.Int32)      | 
            <summary>
            Enables a specified source bit
            </summary>
            <param name="src">The source value to manipulate</param>
            <param name="pos">The position of the bit to enable</param>
        
| M:Z0.Bits.enable(System.Double,System.Int32)      | 
            <summary>
            Enables a specified source bit
            </summary>
            <param name="src">The source value to manipulate</param>
            <param name="pos">The position of the bit to enable</param>
        
| M:Z0.Bits.extract(System.SByte,System.Byte,System.Byte)| 
            <summary>
            Extracts a contiguous range of bits from the source inclusively between two index positions
            </summary>
            <param name="src">The source value</param>
            <param name="k0">The bit position within the source where extraction should begin</param>
            <param name="k1">The bit position within the source where extraction should end</param>
        
| M:Z0.Bits.extract(System.Byte,System.Byte,System.Byte)| 
            <summary>
            Extracts a contiguous range of bits from the source inclusively between two index positions
            </summary>
            <param name="src">The source value</param>
            <param name="k0">The bit position within the source where extraction should begin</param>
            <param name="k1">The bit position within the source where extraction should end</param>
        
| M:Z0.Bits.extract(System.Int16,System.Byte,System.Byte)| 
            <summary>
            Extracts a contiguous range of bits from the source inclusively between two index positions
            </summary>
            <param name="src">The source value</param>
            <param name="k0">The bit position within the source where extraction should begin</param>
            <param name="k1">The bit position within the source where extraction should end</param>
        
| M:Z0.Bits.extract(System.UInt16,System.Byte,System.Byte)| 
            <summary>
            Extracts a contiguous range of bits from the source inclusively between two index positions
            </summary>
            <param name="src">The source value</param>
            <param name="k0">The bit position within the source where extraction should begin</param>
            <param name="k1">The bit position within the source where extraction should end</param>
        
| M:Z0.Bits.extract(System.UInt32,System.Byte,System.Byte)| 
            <summary>
            Extracts a contiguous range of bits from the source inclusively between two index positions
            </summary>
            <param name="src">The source value</param>
            <param name="k0">The bit position within the source where extraction should begin</param>
            <param name="k1">The bit position within the source where extraction should end</param>
        
| M:Z0.Bits.extract(System.Int32,System.Byte,System.Byte)| 
            <summary>
            Extracts a contiguous range of bits from the source inclusively between two index positions
            </summary>
            <param name="src">The source value</param>
            <param name="k0">The bit position within the source where extraction should begin</param>
            <param name="k1">The bit position within the source where extraction should end</param>
        
| M:Z0.Bits.extract(System.UInt64,System.Byte,System.Byte)| 
            <summary>
            Extracts a contiguous range of bits from the source inclusively between two index positions
            </summary>
            <param name="src">The source value</param>
            <param name="k0">The bit position within the source where extraction should begin</param>
            <param name="k1">The bit position within the source where extraction should end</param>
        
| M:Z0.Bits.extract(System.Int64,System.Byte,System.Byte)| 
            <summary>
            Extracts a contiguous range of bits from the source inclusively between two index positions
            </summary>
            <param name="src">The source value</param>
            <param name="k0">The bit position within the source where extraction should begin</param>
            <param name="k1">The bit position within the source where extraction should end</param>
        
| M:Z0.Bits.extract(System.Single,System.Byte,System.Byte)| 
            <summary>
            Extracts a contiguous range of bits from the source inclusively between two index positions
            </summary>
            <param name="src">The source value</param>
            <param name="k0">The bit position within the source where extraction should begin</param>
            <param name="k1">The bit position within the source where extraction should end</param>
        
| M:Z0.Bits.extract(System.Double,System.Byte,System.Byte)| 
            <summary>
            Extracts a contiguous range of bits from the source inclusively between two index positions
            </summary>
            <param name="src">The source value</param>
            <param name="k0">The bit position within the source where extraction should begin</param>
            <param name="k1">The bit position within the source where extraction should end</param>
        
| M:Z0.Bits.fill(System.Byte,System.Byte,System.Byte)| 
            <summary>
            Enables a contiguous sequence of source bits starting at a specified index
            </summary>
            <param name="src">The bit source</param>
            <param name="index">The index at which to begin</param>
            <param name="count">The number of bits to fill</param>
        
| M:Z0.Bits.fill(System.SByte,System.Byte,System.Byte)| 
            <summary>
            Enables a contiguous sequence of source bits starting at a specified index
            </summary>
            <param name="src">The bit source</param>
            <param name="index">The index at which to begin</param>
            <param name="count">The number of bits to fill</param>
        
| M:Z0.Bits.fill(System.UInt16,System.Byte,System.Byte)| 
            <summary>
            Enables a contiguous sequence of source bits starting at a specified index
            </summary>
            <param name="src">The bit source</param>
            <param name="index">The index at which to begin</param>
            <param name="count">The number of bits to fill</param>
        
| M:Z0.Bits.fill(System.Int16,System.Byte,System.Byte)| 
            <summary>
            Enables a contiguous sequence of source bits starting at a specified index
            </summary>
            <param name="src">The bit source</param>
            <param name="index">The index at which to begin clearing bits</param>
            <param name="count">The number of bits to clear</param>
        
| M:Z0.Bits.fill(System.UInt32,System.Byte,System.Byte)| 
            <summary>
            Enables a contiguous sequence of source bits starting at a specified index
            </summary>
            <param name="src">The bit source</param>
            <param name="index">The index at which to begin</param>
            <param name="count">The number of bits to fill</param>
        
| M:Z0.Bits.fill(System.Int32,System.Byte,System.Byte)| 
            <summary>
            Enables a contiguous sequence of source bits starting at a specified index
            </summary>
            <param name="src">The bit source</param>
            <param name="index">The index at which to begin</param>
            <param name="count">The number of bits to fill</param>
        
| M:Z0.Bits.fill(System.UInt64,System.Byte,System.Byte)| 
            <summary>
            Enables a contiguous sequence of source bits starting at a specified index
            </summary>
            <param name="src">The bit source</param>
            <param name="index">The index at which to begin</param>
            <param name="count">The number of bits to fill</param>
        
| M:Z0.Bits.fill(System.Int64,System.Byte,System.Byte)| 
            <summary>
            Enables a contiguous sequence of source bits starting at a specified index
            </summary>
            <param name="src">The bit source</param>
            <param name="index">The index at which to begin</param>
            <param name="count">The number of bits to fill</param>
        
| M:Z0.Bits.gather(System.Byte,System.Byte)         | 
            <summary>
            unsigned int _pext_u32 (unsigned int a, unsigned int mask) PEXT r32a, r32b, reg/m32
            Copies mask-identified source bits to contiguous low bits in the returned target
            </summary>
            <param name="src">The source value</param>
            <param name="mask">The mask that defines the bits to select</param>
        
| M:Z0.Bits.gather(System.UInt16,System.UInt16)     | 
            <summary>
            unsigned int _pext_u32 (unsigned int a, unsigned int mask) PEXT r32a, r32b, reg/m32
            Copies mask-identified source bits to contiguous low bits in the returned target
            </summary>
            <param name="src">The source value</param>
            <param name="mask">The mask that defines the bits to select</param>
        
| M:Z0.Bits.gather(System.UInt32,System.UInt32)     | 
            <summary>
            unsigned int _pext_u32 (unsigned int a, unsigned int mask) PEXT r32a, r32b, reg/m32
            Copies mask-identified source bits to contiguous low bits in the returned target
            </summary>
            <param name="src">The source value</param>
            <param name="mask">The mask that defines the bits to select</param>
        
| M:Z0.Bits.gather(System.UInt64,System.UInt64)     | 
            <summary>
            __int64 _pext_u64 (unsigned __int64 a, unsigned __int64 mask) PEXT r64a, r64b, reg/m64 
            Copies mask-identified source bits to contiguous low bits in the returned target
            </summary>
            <param name="src">The source value</param>
            <param name="mask">The mask that defines the bits to select</param>
        
| M:Z0.Bits.hi(System.Byte)                         | 
            <summary>
            Extracts the upper 4 bits from the source
            </summary>
            <param name="src">The soruce value</param>
        
| M:Z0.Bits.hi(System.UInt16)                       | 
            <summary>
            Extracts the upper 8 bits from the source
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.Bits.hi(System.UInt32)                       | 
            <summary>
            Extracts the upper 16 bits from the source
            </summary>
            <param name="src">The bit source</param>
        
| M:Z0.Bits.hi(System.UInt64)                       | 
            <summary>
            Extracts the upper 16 bits from the source
            </summary>
            <param name="src">The bit source</param>
        
| M:Z0.Bits.msb(System.Byte)                        | 
            <summary>
            Returns the state of the most significant bit
            </summary>
            <param name="src">The bit source</param>
        
| M:Z0.Bits.msb(System.SByte)                       | 
            <summary>
            Returns the state of the most significant bit
            </summary>
            <param name="src">The bit source</param>
        
| M:Z0.Bits.msb(System.UInt16)                      | 
            <summary>
            Returns the state of the most significant bit
            </summary>
            <param name="src">The bit source</param>
        
| M:Z0.Bits.msb(System.Int16)                       | 
            <summary>
            Returns the state of the most significant bit
            </summary>
            <param name="src">The bit source</param>
        
| M:Z0.Bits.msb(System.UInt32)                      | 
            <summary>
            Returns the state of the most significant bit
            </summary>
            <param name="src">The bit source</param>
        
| M:Z0.Bits.msb(System.Int32)                       | 
            <summary>
            Returns the state of the most significant bit
            </summary>
            <param name="src">The bit source</param>
        
| M:Z0.Bits.msb(System.UInt64)                      | 
            <summary>
            Returns the state of the most significant bit
            </summary>
            <param name="src">The bit source</param>
        
| M:Z0.Bits.msb(System.Int64)                       | 
            <summary>
            Returns the state of the most significant bit
            </summary>
            <param name="src">The bit source</param>
        
| M:Z0.Bits.hipos(System.Byte)                      | 
            <summary>
            Computes the position of the highest enabled source bit, a number between 0 and 7
            </summary>
            <param name="src">The source bit</param>
        
| M:Z0.Bits.hipos(System.UInt16)                    | 
            <summary>
            Computes the position of the highest enabled source bit, a number between 0 and 15
            </summary>
            <param name="src">The source bit</param>
        
| M:Z0.Bits.hipos(System.UInt32)                    | 
            <summary>
            Computes the position of the highest enabled source bit, a number between 0 and 31
            </summary>
            <param name="src">The source bit</param>
        
| M:Z0.Bits.hipos(System.UInt64)                    | 
            <summary>
            Computes the position of the highest enabled source bit, a number between 0 and 63
            </summary>
            <param name="src">The source bit</param>
        
| M:Z0.Bits.lo(System.Byte)                         | 
            <summary>
            Extracts the lower 4 bits from the source
            </summary>
            <param name="src">The soruce value</param>
        
| M:Z0.Bits.lo(System.UInt16)                       | 
            <summary>
            Extracts the lower 8 bits from the source
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.Bits.lo(System.UInt32)                       | 
            <summary>
            Extracts the lower 16 bits from the source
            </summary>
            <param name="src">The bit source</param>
        
| M:Z0.Bits.lo(System.UInt64)                       | 
            <summary>
            Extracts the lower half of the bits from the source
            </summary>
            <param name="src">The bit source</param>
        
| M:Z0.Bits.mix(Z0.N0,System.Byte,System.Byte)      | 
            <summary>
            Blends alternating even operand bits 
            </summary>
            <param name="parity">The parity selector</param>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        
| M:Z0.Bits.mix(Z0.N1,System.Byte,System.Byte)      | 
            <summary>
            Blends alternating odd operand bits 
            </summary>
            <param name="parity">The parity selector</param>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        
| M:Z0.Bits.mix(Z0.N0,System.UInt16,System.UInt16)  | 
            <summary>
            Blends alternating even operand bits 
            </summary>
            <param name="parity">The parity selector</param>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        
| M:Z0.Bits.mix(Z0.N1,System.UInt16,System.UInt16)  | 
            <summary>
            Blends alternating odd operand bits 
            </summary>
            <param name="parity">The parity selector</param>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        
| M:Z0.Bits.mix(Z0.N0,System.UInt32,System.UInt32)  | 
            <summary>
            Blends alternating even operand bits 
            </summary>
            <param name="parity">The parity selector</param>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        
| M:Z0.Bits.mix(Z0.N1,System.UInt32,System.UInt32)  | 
            <summary>
            Blends alternating odd operand bits 
            </summary>
            <param name="parity">The parity selector</param>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        
| M:Z0.Bits.mix(Z0.N0,System.UInt64,System.UInt64)  | 
            <summary>
            Blends alternating even operand bits 
            </summary>
            <param name="parity">The parity selector</param>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        
| M:Z0.Bits.mix(Z0.N1,System.UInt64,System.UInt64)  | 
            <summary>
            Blends alternating odd operand bits 
            </summary>
            <param name="parity">The parity selector</param>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        
| M:Z0.Bits.mix(System.Byte,System.Byte,System.Byte)| 
            <summary>
            Blends alternating operand bits 
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
            <param name="parity">The parity selector</param>
        
| M:Z0.Bits.mix(System.UInt16,System.UInt16,System.UInt16)| 
            <summary>
            Blends alternating operand bits 
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
            <param name="parity">The parity selector</param>
        
| M:Z0.Bits.mix(System.UInt32,System.UInt32,System.UInt32)| 
            <summary>
            Blends alternating operand bits 
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
            <param name="parity">The parity selector</param>
        
| M:Z0.Bits.mix(System.UInt64,System.UInt64,System.UInt64)| 
            <summary>
            Blends alternating operand bits 
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
            <param name="parity">The parity selector</param>
        
| M:Z0.Bits.nlz(System.Byte)                        | 
            <summary>
            Counts the number of leading zero bits in the source
            </summary>
            <param name="src">The bit source</param>
        
| M:Z0.Bits.nlz(System.UInt16)                      | 
            <summary>
            Counts the number of leading zero bits in the source
            </summary>
            <param name="src">The bit source</param>
        
| M:Z0.Bits.nlz(System.UInt32)                      | 
            <summary>
            _lzcnt_u32
            Counts the number of 0 bits prior to the first most significant 1 bit
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.Bits.nlz(System.UInt64)                      | 
            <summary>
            _lzcnt_u64:
            Counts the number of 0 bits prior to the first most significant 1 bit
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.Bits.ntz(System.SByte)                       | 
            <summary>
            int _mm_tzcnt_32 (unsigned int a) TZCNT reg, reg/m32
            Counts the number of trailing zero bits in the source
            </summary>
            <param name="src">The bit source</param>
        
| M:Z0.Bits.ntz(System.Byte)                        | 
            <summary>
            int _mm_tzcnt_32 (unsigned int a) TZCNT reg, reg/m32
            Counts the number of trailing zero bits in the source
            </summary>
            <param name="src">The bit source</param>
        
| M:Z0.Bits.ntz(System.Int16)                       | 
            <summary>
            int _mm_tzcnt_32 (unsigned int a) TZCNT reg, reg/m32
            Counts the number of trailing zero bits in the source
            </summary>
            <param name="src">The bit source</param>
        
| M:Z0.Bits.ntz(System.UInt16)                      | 
            <summary>
            int _mm_tzcnt_32 (unsigned int a) TZCNT reg, reg/m32
            Counts the number of trailing zero bits in the source
            </summary>
            <param name="src">The bit source</param>
        
| M:Z0.Bits.ntz(System.Int32)                       | 
            <summary>
            int _mm_tzcnt_32 (unsigned int a) TZCNT reg, reg/m32
            Counts the number of trailing zero bits in the source
            </summary>
            <param name="src">The bit source</param>
        
| M:Z0.Bits.ntz(System.UInt32)                      | 
            <summary>
            int _mm_tzcnt_32 (unsigned int a) TZCNT reg, reg/m32
            Counts the number of trailing zero bits in the source
            </summary>
            <param name="src">The bit source</param>
        
| M:Z0.Bits.ntz(System.Int64)                       | 
            <summary>
            Counts the number of trailing zero bits in the source
            </summary>
            <param name="src">The bit source</param>
        
| M:Z0.Bits.ntz(System.UInt64)                      | 
            <summary>
            __int64 _mm_tzcnt_64 (unsigned __int64 a) TZCNT reg, reg/m64
            Counts the number of trailing zero bits in the source
            </summary>
            <param name="src">The bit source</param>
        
| M:Z0.Bits.pack(Z0.bit,Z0.bit)                     | 
            <summary>
            Packs 2 bits into the least bits of an unsigned integer
            </summary>
        
| M:Z0.Bits.pack(Z0.bit,Z0.bit,Z0.bit)              | 
            <summary>
            Packs 3 bits into the least bits of an unsigned integer
            </summary>
        
| M:Z0.Bits.pack(Z0.bit,Z0.bit,Z0.bit,Z0.bit)       | 
            <summary>
            Packs 4 bits into the least bits of an unsigned integer
            </summary>
        
| M:Z0.Bits.pack(Z0.bit,Z0.bit,Z0.bit,Z0.bit,Z0.bit)| 
            <summary>
            Packs 5 bits into the least bits of an unsigned integer
            </summary>
        
| M:Z0.Bits.pack(Z0.bit,Z0.bit,Z0.bit,Z0.bit,Z0.bit,Z0.bit,Z0.bit,Z0.bit)| 
            <summary>
            Packs 8 bits into the least bits of an unsigned integer
            </summary>
        
| M:Z0.Bits.part64x1(System.UInt64,System.Span{System.Byte})| 
            <summary>
            Partitions a 64-bit source into 64 8-bit targets of effective width 1
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target span</param>
        
| M:Z0.Bits.part64x1(System.UInt64,System.Span{Z0.bit})| 
            <summary>
            Partitions a 64-bit source value into 64 individual bit values
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target span</param>
        
| M:Z0.Bits.part8x2(System.UInt32,System.Byte@)     | 
            <summary>
            Partitions the first 8 bits of a 32-bit source into 4 target segments each with an effective width of 2
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target memory location</param>
        
| M:Z0.Bits.part8x2(System.Byte,System.Byte@)       | 
            <summary>
            Partitions the source into 4 target segments of physical widht 8 and effective width 2
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target memory location</param>
        
| M:Z0.Bits.part16x2(System.UInt16,System.Byte@)    | 
            <summary>
            Partitions a 16-bit source into 8 target segments each with an effective width of 2
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target memory location</param>
        
| M:Z0.Bits.part32x2(System.UInt32,System.Byte@)    | 
            <summary>
            Partitions a 32-bit source into 16 target segments each with an effective width of 2
            </summary>
            <param name="src">The source value</param>
            <param name="dst">A target span of sufficient length</param>
        
| M:Z0.Bits.part6x3(System.UInt32,System.Byte@)     | 
            <summary>
            Partitions the first 6 bits of a 32-bit source value into 2 target segments each with an effective width of 3
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target memory location</param>
        
| M:Z0.Bits.part9x3(System.UInt32,System.Byte@)     | 
            <summary>
            Partitions the first 9 bits of a 32-bit source value into 3 target segments each with an effective width of 3
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target span</param>
        
| M:Z0.Bits.part12x3(System.UInt32,System.Byte@)    | 
            <summary>
            Partitions the first 12 bits of a 32-bit source into 4 target segments each with an effective width of 3
            </summary>
            <param name="src">The source value</param>
            <param name="dst">A target span of sufficient length</param>
        
| M:Z0.Bits.part15x3(System.UInt16,Z0.NatSpan{Z0.N5,System.Byte}@)| 
            <summary>
            Partitions the first 15 bits of a 16-bit source into 6 target segments each with an effective width of 3
            </summary>
            <param name="src">The source value</param>
            <param name="dst">A target span of sufficient length</param>
        
| M:Z0.Bits.part24x3(System.UInt32,Z0.NatSpan{Z0.N8,System.Byte}@)| 
            <summary>
            Partitions the first 24 bits of a 32-bit source value into 9 8-bit target segments
            </summary>
            <param name="src">The source value</param>
            <param name="dst">A target span of sufficient length</param>
        
| M:Z0.Bits.part27x3(System.UInt32,Z0.NatSpan{Z0.N9,System.Byte}@)| 
            <summary>
            Partitions the first 27 bits of a 32-bit source value into 9 8-bit target segments
            </summary>
            <param name="src">The source value</param>
            <param name="dst">A target span of sufficient length</param>
        
| M:Z0.Bits.part30x3(System.UInt32,Z0.NatSpan{Z0.N10,System.Byte}@)| 
            <summary>
            Partitions the first 30 bits of a 32-bit source value into 10 8-bitt target segments
            </summary>
            <param name="src">The source bits</param>
            <param name="dst">The receiving buffer</param>
        
| M:Z0.Bits.part63x3(System.UInt64,Z0.NatSpan{Z0.N21,System.Byte}@)| 
            <summary>
            Partitions the first 63 bits of a 64 bit source value into 21 8-bit target segments
            </summary>
            <param name="src">The source bits</param>
            <param name="dst">The receiving buffer</param>
        
| M:Z0.Bits.part(System.UInt64,Z0.N63,Z0.N3,Z0.N8,System.Span{System.Byte}@)| 
            <summary>
            Partitions the first 63 bits of a 64 bit source value into 21 8-bit target segments
            </summary>
            <param name="src">The source bits</param>
            <param name="dst">The receiving buffer</param>
        
| M:Z0.Bits.part4x2(System.UInt32,System.Byte@)     | 
            <summary>
            Partitions an 8-bit source value into 2 target segments each with an effective width of 4
            </summary>
            <param name="src">The source value</param>
            <param name="dst">A target span of sufficient length</param>
        
| M:Z0.Bits.part4x2(System.UInt32,Z0.NatSpan{Z0.N2,System.Byte})| 
            <summary>
            Partitions an 8-bit source value into 2 target segments each with an effective width of 4
            </summary>
            <param name="src">The source value</param>
            <param name="dst">A target span of sufficient length</param>
        
| M:Z0.Bits.part4x3(System.UInt32,System.Byte@)     | 
            <summary>
            Partitions the first 12 bits of a 32-bit source value into 3 target segments each with an effective width of 4
            </summary>
            <param name="src">The source value</param>
            <param name="dst">A target span of sufficient length</param>
        
| M:Z0.Bits.part4x3(System.UInt32,Z0.NatSpan{Z0.N3,System.Byte})| 
            <summary>
            Partitions the first 12 bits of a 32-bit source value into 3 target segments each with an effective width of 4
            </summary>
            <param name="src">The source value</param>
            <param name="dst">A target span of sufficient length</param>
        
| M:Z0.Bits.part4x4(System.UInt16,Z0.NatSpan{Z0.N4,System.Byte})| 
            <summary>
            Partitions a 16-bit source value into 4 8-bit target segments
            </summary>
            <param name="src">The source value</param>
            <param name="dst">A target span of sufficient length</param>
        
| M:Z0.Bits.part8x4(System.UInt32,Z0.NatSpan{Z0.N8,System.Byte})| 
            <summary>
            Partitions a 32-bit source value into 8 4-bit segments distributed across 8 bytes
            </summary>
            <param name="src">The bit source</param>
            <param name="dst">A target span of sufficient length</param>
        
| M:Z0.Bits.Part4x5(System.UInt32,Z0.NatSpan{Z0.N4,System.Byte})| 
            <summary>
            Partitions the first 20 bits of a 32-bit source value into 4 8-bit segments of width 5
            </summary>
            <param name="src">The bit source</param>
            <param name="dst">The partition target</param>
        
| M:Z0.Bits.part2x8(System.UInt16,Z0.NatSpan{Z0.N2,System.Byte})| 
            <summary>
            Partitions a 16-bit source value into 2 segments of width 8
            </summary>
            <param name="src">The bit source</param>
            <param name="dst">The partition target</param>
        
| M:Z0.Bits.part4x8(System.UInt32,Z0.NatSpan{Z0.N4,System.Byte})| 
            <summary>
            Partitions a 32-bit source value into 4 segments of width 8
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The partition target</param>
        
| M:Z0.Bits.part8x8(System.UInt64,Z0.NatSpan{Z0.N8,System.Byte})| 
            <summary>
            Partitions a 64-bit source value into 8 segments of width 8
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The partition target</param>
        
| M:Z0.Bits.part32x16(System.UInt32,Z0.NatSpan{Z0.N2,System.UInt16})| 
            <summary>
            Partitions a 64-bit source value into 4 segments of width 16
            </summary>
            <param name="src">The source value</param>
            <param name="dst">A target span of sufficient length</param>
        
| M:Z0.Bits.part64x16(System.UInt64,Z0.NatSpan{Z0.N4,System.UInt16})| 
            <summary>
            Partitions a 64-bit source value into 4 segments of width 16
            </summary>
            <param name="src">The source value</param>
            <param name="dst">A target span of sufficient length</param>
        
| M:Z0.Bits.part64x32(System.UInt64,Z0.NatSpan{Z0.N2,System.UInt32})| 
            <summary>
            Partitions a 64-bit source value into 2 segments of width 32
            </summary>
            <param name="src">The source value</param>
            <param name="dst">A target span of sufficient length</param>
        
| M:Z0.Bits.lsb8x1``1(``0)                          | 
            <summary>
            [00000001 ... 00000001]
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The source type</typeparam>
        
| M:Z0.Bits.lsb32x1``1(``0)                         | 
            <summary>
            [00000000 00000000 00000000 0000001 00000000 00000000 00000000 0000001]
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The source type</typeparam>
        
| M:Z0.Bits.pop(System.SByte)                       | 
            <summary>
            Counts the enabled bits in the source
            </summary>
            <param name="src">The source bits</param>
        
| M:Z0.Bits.pop(System.Byte)                        | 
            <summary>
            Counts the enabled bits in the source
            </summary>
            <param name="src">The source bits</param>
        
| M:Z0.Bits.pop(System.Int16)                       | 
            <summary>
            Counts the enabled bits in the source
            </summary>
            <param name="src">The source bits</param>
        
| M:Z0.Bits.pop(System.UInt16)                      | 
            <summary>
            Counts the enabled bits in the source
            </summary>
            <param name="src">The source bits</param>
        
| M:Z0.Bits.pop(System.Int32)                       | 
            <summary>
            Counts the enabled bits in the source
            </summary>
            <param name="src">The source bits</param>
        
| M:Z0.Bits.pop(System.UInt32)                      | 
            <summary>
            Counts the enabled bits in the source
            </summary>
            <param name="src">The source bits</param>
        
| M:Z0.Bits.pop(System.Int64)                       | 
            <summary>
            Counts the enabled bits in the source
            </summary>
            <param name="src">The source bits</param>
        
| M:Z0.Bits.pop(System.UInt64)                      | 
            <summary>
            Counts the enabled bits in the source
            </summary>
            <param name="src">The source bits</param>
        
| M:Z0.Bits.pop(System.UInt64,System.UInt64,System.UInt64)| 
            <summary>
            Computes the population count of the content of 3 64-bit unsigned integers
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
            <remarks>Reference: https://www.chessprogramming.org/Population_Count</remarks>
        
| M:Z0.Bits.rank(System.Byte,System.Int32)          | 
            <summary>
            Calculates the number of bits set up to and including the specified position
            </summary>
            <param name="src">The bit source</param>
            <param name="pos">The position of the bit for which rank will be calculated</param>
        
| M:Z0.Bits.rank(System.UInt16,System.Int32)        | 
            <summary>
            Calculates the number of bits set up to and including the specified position
            </summary>
            <param name="src">The bit source</param>
            <param name="pos">The position of the bit for which rank will be calculated</param>
        
| M:Z0.Bits.rank(System.UInt32,System.Int32)        | 
            <summary>
            Calculates the number of bits set up to and including the specified position
            </summary>
            <param name="src">The bit source</param>
            <param name="pos">The position of the bit for which rank will be calculated</param>
        
| M:Z0.Bits.rank(System.UInt64,System.Int32)        | 
            <summary>
            Calculates the number of bits set up to and including the specified position
            </summary>
            <param name="src">The bit source</param>
            <param name="pos">The position of the bit for which rank will be calculated</param>
        
| M:Z0.Bits.replicate(System.Byte,System.Byte,System.Byte,System.Int32)| 
            <summary>
            Replicates source bits [from..to] a specified number of times subject to the constraints imposed by the replicant type
            </summary>
            <param name="src">The bit source</param>
            <param name="from">The first source bit</param>
            <param name="to">The last source bit</param>
            <param name="reps">The number of times to clone the defined segment</param>
        
| M:Z0.Bits.replicate(System.UInt16,System.Byte,System.Byte,System.Int32)| 
            <summary>
            Replicates source bits [from..to] a specified number of times subject to the constraints imposed by the replicant type
            </summary>
            <param name="src">The bit source</param>
            <param name="from">The first source bit</param>
            <param name="to">The last source bit</param>
            <param name="reps">The number of times to clone the defined segment</param>
        
| M:Z0.Bits.replicate(System.UInt32,System.Byte,System.Byte,System.Int32)| 
            <summary>
            Replicates source bits [from..to] a specified number of times subject to the constraints imposed by the replicant type
            </summary>
            <param name="src">The bit source</param>
            <param name="from">The first source bit</param>
            <param name="to">The last source bit</param>
            <param name="reps">The number of times to clone the defined segment</param>
        
| M:Z0.Bits.replicate(System.UInt64,System.Byte,System.Byte,System.Int32)| 
            <summary>
            Replicates source bits [from..to] a specified number of times subject to the constraints imposed by the replicant type
            </summary>
            <param name="src">The bit source</param>
            <param name="from">The first source bit</param>
            <param name="to">The last source bit</param>
            <param name="reps">The number of times to clone the defined segment</param>
        
| M:Z0.Bits.reverse(System.Byte)                    | 
            <summary>
            Reverses the bits in a byte
            </summary>
            <param name="src">The source bits</param>
            <reference>https://graphics.stanford.edu/~seander/bithacks.htm</reference>
        
| M:Z0.Bits.reverse(System.UInt16)                  | 
            <summary>
            Reverses the bits in the source
            </summary>
            <param name="src">The source bits</param>
        
| M:Z0.Bits.reverse(System.UInt32)                  | 
            <summary>
            Reverses the bits in the source
            </summary>
            <param name="x"></param>
            <remarks>BAD</remarks>
        
| M:Z0.Bits.reverse(System.UInt64)                  | 
            <summary>
            Reverses the bits in the source
            </summary>
            <param name="src">The source bits</param>
            <remarks>BAD</remarks>
        
| M:Z0.Bits.rotl(System.Byte,System.Byte)           | 
            <summary>
            Rotates the source bits leftward by a specified offset amount
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The magnitude of the rotation</param>
        
| M:Z0.Bits.rotl(System.UInt16,System.Byte)         | 
            <summary>
            Rotates the source bits leftward by a specified offset amount
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The magnitude of the rotation</param>
        
| M:Z0.Bits.rotl(System.UInt32,System.Byte)         | 
            <summary>
            Rotates the source bits leftward by a specified offset amount
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The magnitude of the rotation</param>
        
| M:Z0.Bits.rotl(System.UInt64,System.Byte)         | 
            <summary>
            Rotates the source bits leftward by a specified offset amount
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The magnitude of the rotation</param>
        
| M:Z0.Bits.rotl(System.Byte,System.Byte,System.Int32)| 
            <summary>
            Rotates the source bits leftward by a specified offset amount
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The magnitude of the rotation</param>
            <param name="width">The effective bit-width of the source value</param>
        
| M:Z0.Bits.rotl(System.UInt16,System.Byte,System.Int32)| 
            <summary>
            Rotates the source bits leftward by a specified offset amount
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The magnitude of the rotation</param>
            <param name="width">The effective bit-width of the source value</param>
        
| M:Z0.Bits.rotl(System.UInt32,System.Byte,System.Int32)| 
            <summary>
            Rotates the source bits leftward by a specified offset amount
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The magnitude of the rotation</param>
            <param name="width">The effective bit-width of the source value</param>
        
| M:Z0.Bits.rotl(System.UInt64,System.Byte,System.Int32)| 
            <summary>
            Rotates the source bits leftward by a specified offset amount
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The magnitude of the rotation</param>
            <param name="width">The effective bit-width of the source value</param>
        
| M:Z0.Bits.rotr(System.Byte,System.Byte)           | 
            <summary>
            Rotates the source bits rightward by a specified offset
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The magnitude of the rotation</param>
        
| M:Z0.Bits.rotr(System.UInt16,System.Byte)         | 
            <summary>
            Rotates the source bits rightward by a specified offset
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The magnitude of the rotation</param>
        
| M:Z0.Bits.rotr(System.UInt32,System.Byte)         | 
            <summary>
            Rotates the source bits rightward by a specified offset
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The magnitude of the rotation</param>
        
| M:Z0.Bits.rotr(System.UInt64,System.Byte)         | 
            <summary>
            Rotates the source bits rightward by a specified offset
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The magnitude of the rotation</param>
        
| M:Z0.Bits.rotr(System.Byte,System.Int32,System.Int32)| 
            <summary>
            Rotates the source bits rightward by a specified offset
            </summary>
            <param name="src">The source value</param>
            <param name="shift">The magnitude of the rotation</param>
            <param name="width">The effective bit-width of the source value</param>
        
| M:Z0.Bits.rotr(System.UInt16,System.Int32,System.Int32)| 
            <summary>
            Rotates the source bits rightward by a specified offset
            </summary>
            <param name="src">The source value</param>
            <param name="shift">The magnitude of the rotation</param>
            <param name="width">The effective bit-width of the source value</param>
        
| M:Z0.Bits.rotr(System.UInt32,System.Int32,System.Int32)| 
            <summary>
            Rotates the source bits rightward by a specified offset
            </summary>
            <param name="src">The source value</param>
            <param name="shift">The magnitude of the rotation</param>
            <param name="width">The effective bit-width of the source value</param>
        
| M:Z0.Bits.rotr(System.UInt64,System.Int32,System.Int32)| 
            <summary>
            Rotates the source bits rightward by a specified offset
            </summary>
            <param name="src">The source value</param>
            <param name="shift">The magnitude of the rotation</param>
            <param name="width">The effective bit-width of the source value</param>
        
| M:Z0.Bits.scatter(System.Byte,System.Byte)        | 
            <summary>
            Deposits contiguous low bits from the source across a target according to a mask
            </summary>
            <param name="src">The source value</param>
            <param name="mask">The mask</param>
        
| M:Z0.Bits.scatter(System.UInt16,System.UInt16)    | 
            <summary>
            Deposits contiguous low bits from the source across a target according to a mask
            </summary>
            <param name="src">The source value</param>
            <param name="mask">The mask</param>
        
| M:Z0.Bits.scatter(System.UInt32,System.UInt32)    | 
            <summary>
            unsigned int _pdep_u32 (unsigned int a, unsigned int mask) PDEP r32a, r32b, reg/m32
            Deposits contiguous low bits from the source across a target according to a mask
            </summary>
            <param name="src">The source value</param>
            <param name="mask">The mask</param>
        
| M:Z0.Bits.scatter(System.UInt64,System.UInt64)    | 
            <summary>
            unsigned __int64 _pdep_u64 (unsigned __int64 a, unsigned __int64 mask) PDEP r64a, r64b, reg/m64
            Deposits contiguous low bits from the source across a target according to a mask
            </summary>
            <param name="src">The source value</param>
            <param name="mask">The mask</param>
        
| M:Z0.Bits.setif(System.Byte,System.Int32,System.Byte,System.Int32)| 
            <summary>
            Enaables a bit in the target if it is enabled in the source
            </summary>
            <param name="src">The source value</param>
            <param name="srcpos">The source bit position</param>
            <param name="dst">The target value</param>
            <param name="dstpos">The target bit position</param>
        
| M:Z0.Bits.setif(System.UInt16,System.Int32,System.UInt16,System.Int32)| 
            <summary>
            Enaables a bit in the target if it is enabled in the source
            </summary>
            <param name="src">The source value</param>
            <param name="srcpos">The source bit position</param>
            <param name="dst">The target value</param>
            <param name="dstpos">The target bit position</param>
        
| M:Z0.Bits.setif(System.UInt32,System.Int32,System.UInt32,System.Int32)| 
            <summary>
            Enables a specified bit in the target if a specified bit is enabled in the source
            </summary>
            <param name="src">The source value</param>
            <param name="srcpos">The source bit position</param>
            <param name="dst">The target value</param>
            <param name="dstpos">The target bit position</param>
        
| M:Z0.Bits.setif(System.UInt64,System.Int32,System.UInt64,System.Int32)| 
            <summary>
            Enables a specified bit in the target if a specified bit is enabled in the source
            </summary>
            <param name="src">The source value</param>
            <param name="srcpos">The source bit position</param>
            <param name="dst">The target value</param>
            <param name="dstpos">The target bit position</param>
        
| M:Z0.Bits.slice(System.SByte,System.Byte,System.Byte)| 
            <summary>
            Extracts a contiguous range of bits from the source
            </summary>
            <param name="src">The source value</param>
            <param name="start">The bit posiion within the source where extraction should benin</param>
            <param name="length">The number of bits that should be extracted</param>
        
| M:Z0.Bits.slice(System.Byte,System.Byte,System.Byte)| 
            <summary>
            Extracts a contiguous range of bits from the source
            </summary>
            <param name="src">The source value</param>
            <param name="start">The bit posiion within the source where extraction should benin</param>
            <param name="length">The number of bits that should be extracted</param>
        
| M:Z0.Bits.slice(System.Int16,System.Byte,System.Byte)| 
            <summary>
            Extracts a contiguous range of bits from the source
            </summary>
            <param name="src">The source value</param>
            <param name="start">The bit posiion within the source where extraction should benin</param>
            <param name="length">The number of bits that should be extracted</param>
        
| M:Z0.Bits.slice(System.UInt16,System.Byte,System.Byte)| 
            <summary>
            Extracts a contiguous range of bits from the source
            </summary>
            <param name="src">The source value</param>
            <param name="start">The bit posiion within the source where extraction should benin</param>
            <param name="length">The number of bits that should be extracted</param>
        
| M:Z0.Bits.slice(System.Int32,System.Byte,System.Byte)| 
            <summary>
            Extracts a contiguous range of bits from the source
            </summary>
            <param name="src">The source value</param>
            <param name="start">The bit posiion within the source where extraction should benin</param>
            <param name="length">The number of bits that should be extracted</param>
        
| M:Z0.Bits.slice(System.UInt32,System.Byte,System.Byte)| 
            <summary>
            Extracts a contiguous range of bits from the source
            </summary>
            <param name="src">The source value</param>
            <param name="start">The bit posiion within the source where extraction should benin</param>
            <param name="length">The number of bits that should be extracted</param>
        
| M:Z0.Bits.slice(System.Int64,System.Byte,System.Byte)| 
            <summary>
            Extracts a contiguous range of bits from the source
            </summary>
            <param name="src">The source value</param>
            <param name="start">The bit posiion within the source where extraction should benin</param>
            <param name="length">The number of bits that should be extracted</param>
        
| M:Z0.Bits.slice(System.UInt64,System.Byte,System.Byte)| 
            <summary>
            Extracts a contiguous range of bits from the source
            </summary>
            <param name="src">The source value</param>
            <param name="start">The bit posiion within the source where extraction should benin</param>
            <param name="length">The number of bits that should be extracted</param>
        
| M:Z0.Bits.split(System.UInt16,Z0.N2)              | 
            <summary>
            Splits a 16-bit integer into lo/hi parts
            </summary>
            <param name="src">The source value</param>
            <param name="n">The target partition count</param>
        
| M:Z0.Bits.split(System.UInt32,Z0.N2)              | 
            <summary>
            Splits a 32-bit integer into lo/hi parts
            </summary>
            <param name="src">The source value</param>
            <param name="n">The target partition count</param>
        
| M:Z0.Bits.split(System.UInt32,Z0.N4)              | 
            <summary>
            Splits a 32-bit integer into four parts of equal width, from lo to hi
            </summary>
            <param name="src">The source value</param>
            <param name="n">The target partition count</param>
        
| M:Z0.Bits.split(System.UInt64,Z0.N2)              | 
            <summary>
            Splits a 64-bit integer into hi/lo parts
            </summary>
            <param name="src">The source value</param>
            <param name="n">The target partition count</param>
        
| M:Z0.Bits.split(System.UInt64,Z0.N4)              | 
            <summary>
            Splits a 64-bit integer into four parts of equal width, from lo to hi
            </summary>
            <param name="src">The source value</param>
            <param name="n">The target partition count</param>
        
| M:Z0.Bits.split(System.Byte,System.Int32,System.Byte@,System.Byte@)| 
            <summary>
            Partitions the source value into two parts predicated on an index
            [1010 11111 0011] |&gt; split 4 = [1010 1111] [0011]
            </summary>
            <param name="src">The source value</param>
            <param name="index">The index that partitions the source</param>
            <param name="x0">The lo partition</param>
            <param name="x1">The hi partition</param>
        
| M:Z0.Bits.split(System.UInt16,System.Int32,System.UInt16@,System.UInt16@)| 
            <summary>
            Partitions the source value into two parts predicated on an index
            [1010 11111 0011] |&gt; split 4 = [1010 1111] [0011]
            </summary>
            <param name="src">The source value</param>
            <param name="index">The index that partitions the source</param>
            <param name="x0">The lo partition</param>
            <param name="x1">The hi partition</param>
        
| M:Z0.Bits.split(System.UInt32,System.Int32,System.UInt32@,System.UInt32@)| 
            <summary>
            Partitions the source value into two parts predicated on an index
            [1010 11111 0011] |&gt; split 4 = [1010 1111] [0011]
            </summary>
            <param name="src">The source value</param>
            <param name="index">The index that partitions the source</param>
            <param name="x0">The lo partition</param>
            <param name="x1">The hi partition</param>
        
| M:Z0.Bits.split(System.UInt64,System.Int32,System.UInt64@,System.UInt64@)| 
            <summary>
            Partitions the source value into two parts predicated on an index
            [1010 11111 0011] |&gt; split 4 = [1010 1111] [0011]
            </summary>
            <param name="src">The source value</param>
            <param name="index">The index that partitions the source</param>
            <param name="x0">The lo partition</param>
            <param name="x1">The hi partition</param>
        
| M:Z0.Bits.split(System.Byte,System.Byte@,System.Byte@)| 
            <summary>
            Partitions an 8-bit source upper and lower parts, each with an effective width of 4 bits
            </summary>
            <param name="src">The source value</param>
            <param name="x0">Receives sourc bits [0..3]</param>
            <param name="x1">Receives sourc bits [4..7]</param>
        
| M:Z0.Bits.split(System.UInt16,System.Byte@,System.Byte@)| 
            <summary>
            Partitions a 16-bit source value into upper and lower 8-bit parts
            </summary>
            <param name="src">The source value</param>
            <param name="x0">Receives source bits [0..7]</param>
            <param name="x1">Receives source bits [8..15]</param>
        
| M:Z0.Bits.split(System.UInt32,System.UInt16@,System.UInt16@)| 
            <summary>
            Partitions a 32-bit source value into upper and lower 16-bit parts
            </summary>
            <param name="src">The source value</param>
            <param name="x0">Receives source bits [0..15]</param>
            <param name="x1">Receives source bits [16..31]</param>
        
| M:Z0.Bits.split(System.UInt64,System.UInt16@,System.UInt16@,System.UInt16@,System.UInt16@)| 
            <summary>
            Partitions a 64-bit source value into 4 16-bit parts
            </summary>
            <param name="src">The source value</param>
            <param name="x0">Receives source bits [0..15]</param>
            <param name="x1">Receives source bits [16..31]</param>
            <param name="x2">Receives source bits [32..47]</param>
            <param name="x3">Receives source bits [48..63]</param>
        
| M:Z0.Bits.split(System.UInt32,System.Byte@,System.Byte@,System.Byte@,System.Byte@)| 
            <summary>
            Partitions a 32-bit source value into 4 8-bit parts
            </summary>
            <param name="src">The source value</param>
            <param name="x0">Receives source bits [0..7]</param>
            <param name="x1">Receives source bits [8..15]</param>
            <param name="x2">Receives source bits [16..23]</param>
            <param name="x3">Receives source bits [24..31]</param>
        
| M:Z0.Bits.split(System.UInt64,System.Byte@,System.Byte@,System.Byte@,System.Byte@,System.Byte@,System.Byte@,System.Byte@,System.Byte@)| 
            <summary>
            Partitions a 32-bit source value into 8 8-bit parts
            </summary>
            <param name="src">The source value</param>
            <param name="x0">Receives source bits [0..7]</param>
            <param name="x1">Receives source bits [8..15]</param>
            <param name="x2">Receives source bits [16..23]</param>
            <param name="x3">Receives source bits [24..31]</param>
            <param name="x4">Receives source bits [32..39]</param>
            <param name="x5">Receives source bits [40..47]</param>
            <param name="x6">Receives source bits [48..55]</param>
            <param name="x7">Receives source bits [56..63]</param>
        
| M:Z0.Bits.testbit(System.SByte,System.Byte)       | 
            <summary>
            Returns 1 if an index-identified bit is enabled, 0 otherwise
            </summary>
            <param name="src">The value to test</param>
            <param name="pos">The bit index to chech</param>
        
| M:Z0.Bits.testbit(System.Byte,System.Byte)        | 
            <summary>
            Returns 1 if an index-identified bit is enabled, 0 otherwise
            </summary>
            <param name="src">The value to test</param>
            <param name="pos">The bit index to chech</param>
        
| M:Z0.Bits.testbit(System.Int16,System.Byte)       | 
            <summary>
            Returns 1 if an index-identified bit is enabled, 0 otherwise
            </summary>
            <param name="src">The value to test</param>
            <param name="pos">The bit index to chech</param>
        
| M:Z0.Bits.testbit(System.UInt16,System.Byte)      | 
            <summary>
            Returns 1 if an index-identified bit is enabled, 0 otherwise
            </summary>
            <param name="src">The value to test</param>
            <param name="pos">The bit index to chech</param>
        
| M:Z0.Bits.testbit(System.Int32,System.Byte)       | 
            <summary>
            Returns 1 if an index-identified bit is enabled, 0 otherwise
            </summary>
            <param name="src">The value to test</param>
            <param name="pos">The bit index to chech</param>
        
| M:Z0.Bits.testbit(System.UInt32,System.Byte)      | 
            <summary>
            Returns 1 if an index-identified bit is enabled, 0 otherwise
            </summary>
            <param name="src">The value to test</param>
            <param name="pos">The bit index to chech</param>
        
| M:Z0.Bits.testbit(System.Int64,System.Byte)       | 
            <summary>
            Returns 1 if an index-identified bit is enabled, 0 otherwise
            </summary>
            <param name="src">The value to test</param>
            <param name="pos">The bit index to chech</param>
        
| M:Z0.Bits.testbit(System.UInt64,System.Byte)      | 
            <summary>
            Returns 1 if an index-identified bit is enabled, 0 otherwise
            </summary>
            <param name="src">The value to test</param>
            <param name="pos">The bit index to chech</param>
        
| M:Z0.Bits.testbit(System.Single,System.Byte)      | 
            <summary>
            Returns 1 if an index-identified bit is enabled, false otherwise
            </summary>
            <param name="src">The value to test</param>
            <param name="pos">The bit index to chech</param>
        
| M:Z0.Bits.testbit(System.Double,System.Byte)      | 
            <summary>
            Returns 1 if an index-identified bit is enabled, false otherwise
            </summary>
            <param name="src">The value to test</param>
            <param name="pos">The bit index to chech</param>
        
| M:Z0.Bits.toggle(System.Single,System.Int32)      | 
            <summary>
            Flips an identified source bit
            </summary>
            <param name="src">The bit source</param>
            <param name="pos">The position of the bit to toggle</param>
        
| M:Z0.Bits.toggle(System.Double,System.Int32)      | 
            <summary>
            Flips an identified source bit
            </summary>
            <param name="src">The bit source</param>
            <param name="pos">The position of the bit to toggle</param>
        
| M:Z0.Bits.unpack8x1(System.Byte,System.UInt64@)   | 
            <summary>
            Sends each source bit to to last bit of each 8-bit segment in the target
            </summary>
            <param name="src">The bit source</param>
            <param name="dst">The bit target</param>
        
| M:Z0.Bits.unpack8x1(System.Byte,System.Span{System.Byte})| 
            <summary>
            Sends each source bit to a corresponding target cell
            </summary>
            <param name="src">The bit source</param>
            <param name="dst">The bit target</param>
        
| M:Z0.Bits.unpack16x1(System.UInt16,System.Span{System.Byte})| 
            <summary>
            Sends each source bit to a corresponding target cell
            </summary>
            <param name="src">The bit source</param>
            <param name="dst">The bit target</param>
        
| M:Z0.Bits.unpack32x1(System.UInt32,System.Span{System.Byte})| 
            <summary>
            Sends each source bit to a corresponding target cell
            </summary>
            <param name="src">The bit source</param>
            <param name="dst">The bit target</param>
        
| M:Z0.Bits.unpack64x1(System.UInt64,System.Span{System.Byte})| 
            <summary>
            Sends each source bit to a corresponding target cell
            </summary>
            <param name="src">The bit source</param>
            <param name="dst">The bit target</param>
        
| M:Z0.Bits.unpack16x1(System.UInt16,Z0.Block128{System.Byte}@)| 
            <summary>
            Sends each source bit to a corresponding target cell
            </summary>
            <param name="src">The bit source</param>
            <param name="dst">The bit target</param>
        
| M:Z0.Bits.unpack32x1(System.UInt32,Z0.Block256{System.Byte}@)| 
            <summary>
            Sends each source bit to a corresponding target cell
            </summary>
            <param name="src">The bit source</param>
            <param name="dst">The bit target</param>
        
| M:Z0.Bits.zhi(System.Byte,System.Int32)           | 
            <summary>
            unsigned int _bzhi_u32 (unsigned int a, unsigned int index) BZHI r32a, reg/m32, r32b
            Replicates the source bits to the target and disables the high target bits starting at a specified index.
            </summary>
            <param name="src">The bit source</param>
        
| M:Z0.Bits.zhi(System.UInt16,System.Int32)         | 
            <summary>
            unsigned int _bzhi_u32 (unsigned int a, unsigned int index) BZHI r32a, reg/m32, r32b
            Replicates the source bits to the target and disables the high target bits starting at a specified index.
            </summary>
            <param name="src">The bit source</param>
        
| M:Z0.Bits.zhi(System.UInt32,System.Int32)         | 
            <summary>
            unsigned int _bzhi_u32 (unsigned int a, unsigned int index) BZHI r32a, reg/m32, r32b
            Replicates the source bits to the target and disables the high target bits starting at a specified index.
            </summary>
            <param name="src">The bit source</param>
        
| M:Z0.Bits.zhi(System.UInt64,System.Int32)         | 
            <summary>
            unsigned __int64 _bzhi_u64 (unsigned __int64 a, unsigned int index) BZHI r64a,reg/m32, r64b 
            Disables the high target bits starting at a specified index.
            </summary>
            <param name="src">The bit source</param>
            <param name="index">The index at which to begin disabling bits</param>
        
| M:Z0.gbits.bfly``1(Z0.N1,``0)                     | 
            <summary>
            Effects a butterfly permutation on the source that swaps the interior two bits of each 4-bit segment.
            </summary>
            <param name="n">The interior segment width selector</param>
            <param name="x">The bit source</param>
        
| M:Z0.gbits.bfly``1(Z0.N2,``0)                     | 
            <summary>
            Effects a butterfly permutation on the source that swaps the interior 2-bit segments of each 8-bit segment.
            </summary>
            <param name="n">The interior segment width selector</param>
            <param name="x">The bit source</param>
        
| M:Z0.gbits.bfly``1(Z0.N4,``0)                     | 
            <summary>
            [0 1 2 3 | 4 5 6 7 ] -&gt; [0 2 1 3 | 4 6 5 7 ]
            Swaps the interior 4-bit segments of each 16-bit segment.
            </summary>
            <param name="n">The interior segment width selector</param>
            <param name="x">The bit source</param>
        
| M:Z0.gbits.bfly``1(Z0.N8,``0)                     | 
            <summary>
            [0 1 2 3 | 4 5 6 7] -&gt; [0 2 1 3 | 4 6 5 7]
            Swaps the interior 8-bit segments of each 32-bit segment.
            </summary>
            <param name="n">The interior segment width selector</param>
            <param name="x">The bit source</param>
        
| M:Z0.gbits.bfly``1(Z0.N16,``0)                    | 
            <summary>
            Effects a butterfly permutation on the source that swaps the interior 16-bit segments
            </summary>
            <param name="n">The interior segment width selector</param>
            <param name="x">The bit source</param>
        
| M:Z0.gbits.bitcell``1(System.Span{``0},Z0.BitPos{``0})| 
            <summary>
            Queries/manipulates a source cell that covers a position-identified bit
            </summary>
            <param name="src">The bit source</param>
            <param name="pos">The sequence-relative position of the target bit</param>
            <typeparam name="T">The cell type</typeparam>
        
| M:Z0.gbits.bitcell``1(System.ReadOnlySpan{``0},Z0.BitPos{``0})| 
            <summary>
            Queries/manipulates a source cell that covers a position-identified bit
            </summary>
            <param name="src">The bit source</param>
            <param name="pos">The sequence-relative position of the target bit</param>
            <typeparam name="T">The cell type</typeparam>
        
| M:Z0.gbits.bitmap``1(``0,``0,System.Byte,System.Byte)| 
            <summary>
            Maps bits from a source segment src[0..(count-1)] to a target segment dst[index..(index+count)]
            </summary>
            <param name="src">The bit source</param>
            <param name="dst">The target</param>
            <param name="count">The number bits to read from the source an replace in the target</param>
            <param name="index">The target-relative index at which to begin the overwrite</param>
            <typeparam name="T">The primal scalar type</typeparam>
        
| M:Z0.gbits.bitmatch``2(``0,System.Byte,``1,System.Byte)| 
            <summary>
            Determines whether identified bits in the operands agree.
            </summary>
            <param name="a">The first bit source</param>
            <param name="i">The first bit position</param>
            <param name="b">The second bit source</param>
            <param name="j">The second bit position</param>
            <typeparam name="S">The left operand type</typeparam>
            <typeparam name="T">The right operand type</typeparam>
        
| M:Z0.gbits.bitpos``1(System.Int32)                | 
            <summary>
            Defines a bit position, relative to a T-valued sequence, predicated on a linear index
            </summary>
            <param name="index">The sequence-relative index of the target bit</param>
            <typeparam name="T">The sequence element type</typeparam>
        
| M:Z0.gbits.blsic``1(``0)                          | 
            <summary>
            Isolate least set bit and complement, computed by dst := ~src | (src - 1),
            where all bits in the target are set except for the least set bit in the source
            For example, [11101010] |&gt; blisc = [11111101]
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.gbits.clearbyte``1(``0,System.Byte)          | 
            <summary>
            Disables a sequence of 8 source bits starting at a specified index
            </summary>
            <param name="src">The bit source</param>
            <param name="index">The index at which to begin clearing bits</param>
            <typeparam name="T">The primal type</typeparam>
        
| M:Z0.gbits.clear``1(``0,System.Byte,System.Byte)  | 
            <summary>
            Disables a sequence of bits starting at a specified index
            </summary>
            <param name="src">The bit source</param>
            <param name="index">The index at which to begin clearing bits</param>
            <param name="count">The number of bits to clear</param>
            <typeparam name="T">The primal type</typeparam>
        
| M:Z0.gbits.copy``1(``0,System.Byte,System.Byte,``0)| 
            <summary>
            Overwrites a target bit segment dst[index..(start + count)] with a corresponding 
            segment src[index..(start + count)] in the source
            </summary>
            <param name="src">The bit source</param>
            <param name="index">The source/target start index</param>
            <param name="count">The number of bits to copy</param>
            <param name="dst">The bit target</param>
            <typeparam name="T">The numeric type</typeparam>
        
| M:Z0.gbits.copy``1(``0,System.Byte,System.Byte,``0@)| 
            <summary>
            Overwrites a target bit segment dst[index..(start + count)] with a corresponding 
            segment src[index..(start + count)] in the source
            </summary>
            <param name="src">The bit source</param>
            <param name="index">The source/target start index</param>
            <param name="count">The number of bits to copy</param>
            <param name="dst">The bit target</param>
            <typeparam name="T">The numeric type</typeparam>
        
| M:Z0.gbits.copy``1(``0,System.Byte,System.Byte,System.Byte,``0)| 
            <summary>
            Overwrites a target bit segment dst[dstidx..(dstidx + count)] with a corresponding 
            segment src[srcidx..(srcidx + count)] in the source
            </summary>
            <param name="src">The bit source</param>
            <param name="srcidx">The source start index</param>
            <param name="dstidx">The target start index</param>
            <param name="count">The number of bits to copy</param>
            <param name="dst">The bit target</param>
            <typeparam name="T">The numeric type</typeparam>
        
| M:Z0.gbits.copy``1(``0,System.Byte,System.Byte,System.Byte,``0@)| 
            <summary>
            Overwrites a target bit segment dst[dstidx..(dstidx + count)] with a corresponding 
            segment src[srcidx..(srcidx + count)] in the source
            </summary>
            <param name="src">The bit source</param>
            <param name="srcidx">The source start index</param>
            <param name="dstidx">The target start index</param>
            <param name="count">The number of bits to copy</param>
            <param name="dst">The bit target</param>
            <typeparam name="T">The numeric type</typeparam>
        
| M:Z0.gbits.disable``1(``0,System.Int32)           | 
            <summary>
            Disables an identified source bit
            </summary>
            <param name="src">The source segment</param>
            <param name="pos">The 0-based index of the bit to change</param>
            <typeparam name="T">The source element type</typeparam>
        
| M:Z0.gbits.dot``1(``0,``0)                        | 
            <summary>
            Pretends that the operands are bitvectors and computes their scalar product
            </summary>
            <param name="x">The left scalar</param>
            <param name="y">The right scalar</param>
            <typeparam name="T">The primal unsigned integral type</typeparam>
        
| M:Z0.gbits.effsize``1(``0)                        | 
            <summary>
            Computes the minimum number of butes required to represent the source value
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The source type</typeparam>
        
| M:Z0.gbits.effwidth``1(``0)                       | 
            <summary>
            Computes the minimum number of bits required to represent the source value
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The source type</typeparam>
        
| M:Z0.gbits.enable``1(``0,System.Int32)            | 
            <summary>
            Enables an index-identified source bit
            </summary>
            <param name="src">The source segment</param>
            <param name="pos">The 0-based index of the bit to change</param>
            <typeparam name="T">The source element type</typeparam>
        
| M:Z0.gbits.eraser``1(System.Byte,System.Byte)     | 
            <summary>
            Defines a mask that disables a sequence of bits
            </summary>
            <param name="start">The index at which to begin</param>
            <param name="count">The number of bits to disable</param>
            <typeparam name="T">The primal type over which the mask is defined</typeparam>
        
| M:Z0.gbits.extract``1(``0,System.Byte,System.Byte)| 
            <summary>
            Extracts a contiguous range of bits from a primal source inclusively between two index positions
            </summary>
            <param name="src">The bit source</param>
            <param name="rhs">The left bit position</param>
            <param name="dst">The right bit position</param>
            <typeparam name="T">The primal type</typeparam>
        
| M:Z0.gbits.extract``1(``0,System.Byte,System.Byte,System.Span{System.Byte},System.Int32)| 
            <summary>
            Extracts a contiguous sequence of bits from a source and deposits the result to a caller-supplied target
            </summary>
            <param name="a">The bit source</param>
            <param name="first">The 0-based index of the first selected bit</param>
            <param name="last">The 0-based index of the last selected bit</param>
            <param name="dst">The target that receives the sequence</param>
            <param name="offset">The target offset</param>
            <typeparam name="T">The primal bit source type</typeparam>
        
| M:Z0.gbits.extract``1(System.Span{``0},Z0.BitPos{``0},Z0.BitPos{``0})| 
            <summary>
            Extracts a T-valued segment, cross-cell or same-cell, from the source as determined by an inclusive position range
            </summary>
            <param name="src">The bit source</param>
            <param name="firstpos">The sequence-relative position of the first bit</param>
            <param name="lastpos">The sequence-relative position of the last bit</param>
            <typeparam name="T">The cell type</typeparam>
        
| M:Z0.gbits.extract``1(System.Span{``0},System.Int32,System.Int32)| 
            <summary>
            Extracts a T-valued segment, cross-cell or same-cell, from the source as determined by 
            an inclusive linear index range
            </summary>
            <param name="src">The bit source</param>
            <param name="firstidx">The sequence-relative index of the first bit</param>
            <param name="lastidx">The sequence-relative index of the last bit</param>
            <typeparam name="T">The cell type</typeparam>
        
| M:Z0.gbits.fill``1(``0,System.Byte,System.Byte)   | 
            <summary>
            Enables a contiguous sequence of source bits starting at a specified index
            </summary>
            <param name="src">The bit source</param>
            <param name="index">The index at which to begin</param>
            <param name="count">The number of bits to fill</param>
        
| M:Z0.gbits.gather``1(``0,``0)                     | 
            <summary>
            Extracts mask-identified bits from the source and deposits the result to the contiguous low bits of a zero-initialied target 
            </summary>
            <param name="src">The source vale</param>
            <typeparam name="T">The source type</typeparam>
        
| M:Z0.gbits.hi``1(``0)                             | 
            <summary>
            Extracts the upper source bits
            </summary>
            <param name="src">The bit source</param>
        
| M:Z0.gbits.hipos``1(``0)                          | 
            <summary>
            Computes the position of the highest enabled source bit, a number in the inclusive range [0 , bitsize[T] - 1]
            </summary>
            <param name="src">The source bit</param>
        
| M:Z0.gbits.lo``1(``0)                             | 
            <summary>
            Extracts the lower source bits
            </summary>
            <param name="src">The bit source</param>
        
| M:Z0.gbits.mix``1(Z0.N0,``0,``0)                  | 
            <summary>
            Blends alternating even operand bits 
            </summary>
            <param name="parity">The parity selector</param>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
            <typeparam name="T">The primal type</typeparam>
        
| M:Z0.gbits.mix``1(Z0.N1,``0,``0)                  | 
            <summary>
            Blends alternating odd operand bits 
            </summary>
            <param name="parity">The parity selector</param>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
            <typeparam name="T">The primal type</typeparam>
        
| M:Z0.gbits.nlz``1(``0)                            | 
            <summary>
            Counts the number of leading zero bits the source
            </summary>
            <param name="src">The bit source</param>
        
| M:Z0.gbits.ntz``1(``0)                            | 
            <summary>
            Counts the number of trailing zero bits in the source
            </summary>
            <param name="src">The bit source</param>
            <typeparam name="T">The primal type</typeparam>
        
| M:Z0.gbits.pop``1(``0)                            | 
            <summary>
            Counts the number enabled source bits
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The source value type</typeparam>
        
| M:Z0.gbits.pop``1(``0,``0,``0)                    | 
            <summary>
            Counts the number of enabled primal operand bits
            </summary>
            <typeparam name="T">The primal type</typeparam>
        
| M:Z0.gbits.pop``1(``0,``0,``0,``0)                | 
            <summary>
            Counts the number of enabled primal operand bits
            </summary>
            <typeparam name="T">The primal type</typeparam>
        
| M:Z0.gbits.pop``1(``0,``0,``0,``0,``0,``0,``0,``0)| 
            <summary>
            Counts the number of enabled primal operand bits
            </summary>
            <typeparam name="T">The primal type</typeparam>
        
| M:Z0.gbits.rank``1(``0,System.Int32)              | 
            <summary>
            Calculates the number of bits set up to and including the current bit
            </summary>
            <param name="src">The bit source</param>
            <param name="pos">The position of the bit for which rank will be calculated</param>
        
| M:Z0.gbits.replicate``1(``0,System.Byte,System.Byte,System.Int32)| 
            <summary>
            Replicates an index-defined bitpattern a specified number of times
            </summary>
            <param name="src">The bit source</param>
            <param name="i0">The index of the first bit to include in the pattern</param>
            <param name="i1">The index of the last bit to include in the pattern</param>
            <param name="reps">The number of times to repeat the pattern</param>
            <typeparam name="T">The source/target type</typeparam>
        
| M:Z0.gbits.replicate``1(``0)                      | 
            <summary>
            [000...000101] -&gt; [101101...101101]
            Replicates a source bit pattern, determined by the most significant enabled bit,  throughout the range of the type
            </summary>
            <param name="src">The value defining the pattern to replicate</param>
            <typeparam name="T">The source/target type</typeparam>
        
| M:Z0.gbits.replicate``1(System.Byte)              | 
            <summary>
            Replicates the bit pattern defined by a byte either 2,4 or 8 times as determined by the primal target type
            </summary>
            <param name="src">The bit source</param>
            <param name="t">A target type representative</param>
            <typeparam name="T">The target type</typeparam>
        
| M:Z0.gbits.reverse``1(``0)                        | 
            <summary>
            Reverses the bits in the source
            </summary>
            <param name="src">The bit source</param>
            <remarks>BAD</remarks>
        
| M:Z0.gbits.rotl``1(``0@,System.Byte,``0@,System.Int32)| 
            <summary>
            Rotates source cells leftward and deposits the result in a caller-supplied target
            </summary>
            <param name="src">The leading source cell</param>
            <param name="offset">The amount to rotate</param>
            <param name="dst">The leading target cell</param>
            <param name="count">The cell count</param>
            <typeparam name="T">The primal cell type</typeparam>
        
| M:Z0.gbits.rotl``1(``0,System.Byte)               | 
            <summary>
            Rotates the source bits leftward by a specified shift amount
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The magnitude of the rotation</param>
        
| M:Z0.gbits.rotl``1(``0,System.Byte,System.Int32)  | 
            <summary>
            Rotates the source bits leftward by a specified shift amount
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The magnitude of the rotation</param>
            <param name="width">The effective bit-width of the source value</param>
        
| M:Z0.gbits.rotr``1(``0@,System.Byte,``0@,System.Int32)| 
            <summary>
            Rotates source cells rightward and deposits the result in a caller-supplied target
            </summary>
            <param name="src">The leading source cell</param>
            <param name="offset">The amount to rotate</param>
            <param name="dst">The leading target cell</param>
            <param name="count">The cell count</param>
            <typeparam name="T">The primal cell type</typeparam>
        
| M:Z0.gbits.rotr``1(``0,System.Byte)               | 
            <summary>
            Rotates bits in the source rightwards by a specified shift amount
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The magnitude of the rotation</param>
            <typeparam name="T">The source type</typeparam>
        
| M:Z0.gbits.rotr``1(``0,System.Byte,System.Byte)   | 
            <summary>
            Rotates bits in the source rightwards by a specified shift amount
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The magnitude of the rotation</param>
            <typeparam name="T">The source type</typeparam>
        
| M:Z0.gbits.scatter``1(``0,``0)                    | 
            <summary>
            Scatters contiguous low bits from the source across a target according to a mask
            </summary>
            <param name="src">The bit source</param>
            <param name="mask">The scatter spec</param>
            <typeparam name="T">The identifiying mask</typeparam>
        
| M:Z0.gbits.setbit``1(``0,System.Int32,Z0.bit)     | 
            <summary>
            Sets an identified bit to a supplied value
            </summary>
            <param name="src">The source segment</param>
            <param name="pos">The bit position</param>
            <param name="value">The value to be applied</param>
            <typeparam name="T">The source element type</typeparam>
        
| M:Z0.gbits.slice``1(``0,System.Byte,System.Byte)  | 
            <summary>
            Extracts a contiguous range of bits from the source
            </summary>
            <param name="src">The source value</param>
            <param name="start">The bit posiion within the source where extraction should begin</param>
            <param name="length">The number of bits that should be extracted</param>
        
| M:Z0.gbits.split``1(``0,System.Int32,``0@,``0@)   | 
            <summary>
            Partitions the source value into two parts predicated on an index
            [1010 11111 0011] |&gt; split 4 = [1010 1111] [0011]
            </summary>
            <param name="src">The source value</param>
            <param name="index">The index that partitions the source</param>
            <param name="x0">The lo partition</param>
            <param name="x1">The hi partition</param>
        
| M:Z0.gbits.testbit``1(``0,System.Byte)            | 
            <summary>
            Returns 1 if an index-identified bit is enabled, false otherwise
            </summary>
            <param name="src">The value to test</param>
            <param name="pos">The bit index to chech</param>
        
| M:Z0.gbits.testbits``1(``0,System.Span{System.Byte},System.Int32)| 
            <summary>
            Constructs a bitsequence by interrogating the source with bit state tests 
            and populates a caller-supplied target with the result
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The primal source type</typeparam>
        
| M:Z0.gbits.testbits``1(``0)                       | 
            <summary>
            Calculates a bit sequence and populates an allocated target with the result
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The primal source type</typeparam>
        
| M:Z0.gbits.toggle``1(``0,System.Int32)            | 
            <summary>
            Inverts an index-identified source bit
            </summary>
            <param name="src">The source value</param>
            <param name="pos">The bit position</param>
            <typeparam name="T">The source type</typeparam>
        
| M:Z0.gbits.unpack``1(System.Span{``0},System.Span{Z0.bit})| 
            <summary>
            Extracts each bit from each source element into caller-supplied target at the corresponding index
            </summary>
            <param name="src">The source values to be unpacked</param>
            <param name="dst">The target span of length at least bitsize[T]*length(Span[T])</param>
            <typeparam name="T">The source value type</typeparam>
        
| M:Z0.gbits.unpack``1(System.Span{``0},Z0.bit[])   | 
            <summary>
            Extracts each bit from each source element into caller-supplied target at the corresponding index
            </summary>
            <param name="src">The source values to be unpacked</param>
            <param name="dst">The target array of length at least bitsize[T]*length(Span[T])</param>
            <typeparam name="T">The source value type</typeparam>
        
| M:Z0.gbits.unpack``2(``0,System.Span{``1},System.Int32)| 
            <summary>
            Projects each bit from a source value into target span element at the corresponding index
            </summary>
            <param name="src">The bit soure</param>
            <param name="dst">The bit target</param>
            <typeparam name="T">The bit source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        
| M:Z0.gbits.unpack``2(System.ReadOnlySpan{``0},System.Span{``1})| 
            <summary>
            Projects each source bit from each source element into an element of the target span at the corresponding index
            </summary>
            <param name="src">The bit soure</param>
            <param name="dst">The bit target</param>
            <typeparam name="T">The bit source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        
| M:Z0.gbits.zhi``1(``0,System.Int32)               | 
            <summary>
            Replicates the source bits to the target and disables the high target bits starting at a specified index.
            </summary>
            <param name="src">The source bits</param>
            <param name="index">The index at which to begin disabling target bits</param>
            <typeparam name="T">The primal type</typeparam>
        
| M:Z0.BitCalcs.bytecount(System.Int32,System.Int32)| 
            <summary>
            Computes the number of bytes covered by a specified number of cells of a given width
            </summary>
            <param name="cells">The number of allocated cells</param>
            <param name="cw">The bit-width of a cell</param>
        
| M:Z0.BitCalcs.bytecount``1(System.Int32)          | 
            <summary>
            Computes the number of bytes that can be covered by a specified number of cells of parametric type
            </summary>
            <param name="cells">The number of cells</param>
            <typeparam name="T">The cell type</typeparam>
        
| M:Z0.BitCalcs.minbytes(System.Int32)              | 
            <summary>
            Computes the minimum numbet of bytes required to hold a specified number of bits
            </summary>
            <param name="bc">The number of bits for which storage is required</param>
        
| M:Z0.BitCalcs.mincells(System.UInt64,System.UInt64)| 
            <summary>
            Computes the minimum number of cells required to store a specified number of bits
            </summary>
            <param name="w">The cell width</param>
            <param name="n">The bit count/number of matrix columns</param>
        
| M:Z0.BitCalcs.mincells``1(System.UInt64)          | 
            <summary>
            Computes the minimum number of cells required to store data of a given bit width
            </summary>
            <param name="bc">The number of bits for which storage is required</param>
            <typeparam name="T">The storage cell type</typeparam>
        
| M:Z0.BitCalcs.mincells``2(``0,``1)                | 
            <summary>
            Computes the minimum number of T-cells required to store N bits
            </summary>
            <param name="n">The bit count representative</param>
            <param name="t">A cell type representative</param>
            <typeparam name="N">The bit count type</typeparam>
            <typeparam name="T">The cell type</typeparam>
        
| M:Z0.BitCalcs.tablecells(System.UInt64,System.UInt64,System.Int32)| 
            <summary>
            Computes the number of packed cells required to cover a rectangular area
            </summary>
            <param name="rows">The grid row count</param>
            <param name="cols">The grid col count</param>
            <param name="cw">The storage cell width</param>
        
| M:Z0.BitCalcs.bitindex(System.Int32,System.Int32,System.Int32)| 
            <summary>
            Computes the 0-based linear index determined by column width and a row/col coordinate
            </summary>
            <param name="colwidth">The bit-width of a grid column</param>
            <param name="row">The 0-based row index</param>
            <param name="col">The 0-based col index</param>
        
| M:Z0.BitCalcs.bitindex``1(System.Int32,System.Int32,``0)| 
            <summary>
            Computes the 0-based linear index determined by a row/col coordinate and natural column width
            </summary>
            <param name="row">The grid row</param>
            <param name="col">The grid columns</param>
            <typeparam name="N">The grid column type</typeparam>
        
| M:Z0.BitCalcs.tablesize(System.Int32,System.Int32)| 
            <summary>
            Computes the number of bytes required to cover a grid, predicated on row/col counts
            </summary>
            <param name="rows">The number of grid rows</param>
            <param name="cols">The number of grid columns</param>
        
| M:Z0.BitCalcs.tablesize(System.UInt64,System.UInt64)| 
            <summary>
            Computes the number of bytes required to cover a grid, predicated on row/col counts
            </summary>
            <param name="rows">The number of grid rows</param>
            <param name="cols">The number of grid columns</param>
        
| M:Z0.BitCalcs.tablesize``1(``0,``0)               | 
            <summary>
            Computes the number of bytes required to cover a grid, predicated on row/col counts
            </summary>
            <param name="rows">The number of grid rows</param>
            <param name="cols">The number of grid columns</param>
        
| M:Z0.BitCalcs.tablecells``1(System.Int32,System.Int32)| 
            <summary>
            Computes the number of cells required to cover a rectangular region predicated on the 
            parametric cell type and supplied row/col dimensions
            </summary>
            <param name="rows">The number of rows in the grid</param>
            <param name="cols">The number of columns in the grid</param>
            <typeparam name="T">The storage cell type</typeparam>
        
| M:Z0.BitCalcs.tableblocks``1(Z0.N256,System.Int32,System.Int32)| 
            <summary>
            Calculates the number of 256-bit blocks reqired to cover a grid with a specified number of rows/cols
            </summary>
            <param name="w">The block width selctor</param>
            <param name="rows">The row count</param>
            <param name="cols">The col count</param>
            <typeparam name="T">The cell type</typeparam>
        
| M:Z0.BitCalcs.tablesize``2(``0,``1)               | 
            <summary>
            Computes the number of bytes required to cover a rectangular area, predicated on natural row/col counts
            </summary>
            <param name="m">The row count representative</param>
            <param name="n">The col count representative</param>
            <typeparam name="M">The row type</typeparam>
            <typeparam name="N">The col type</typeparam>
        
| M:Z0.BitCalcs.tablebits``2(``0,``1)               | 
            <summary>
            Computes the number of bits covered by a rectangular region and predicated on natural dimensions
            </summary>
            <param name="rows">The grid row count</param>
            <param name="cols">The grid col count</param>
        
| M:Z0.BitCalcs.tablecells``3(``0,``1,``2)          | 
            <summary>
            Computes the number of segments required cover a grid as characterized by parametric type information
            </summary>
            <param name="m">The row count representative</param>
            <param name="n">The col count representative</param>
            <param name="t">The segment type zero representative</param>
            <typeparam name="M">The row type</typeparam>
            <typeparam name="N">The col type</typeparam>
            <typeparam name="T">The storage segment type</typeparam>
        
| M:Z0.BitCalcs.tableblocks``3(Z0.N256,``0,``1,``2) | 
            <summary>
            Calculates the number of 256-bit blocks reqired to cover a grid with natural dimensions
            </summary>
            <param name="w">The block width selctor</param>
            <param name="m">The row count representative</param>
            <param name="n">The col count representative</param>
            <param name="t">The cell type representative</param>
            <typeparam name="M">The row count type</typeparam>
            <typeparam name="N">The col count type</typeparam>
            <typeparam name="T">The cell type</typeparam>
        
| M:Z0.BitLogixOps.eval(Z0.BinaryLogicKind,Z0.bit,Z0.bit)| 
            <summary>
            Evaluates a binary operator without lookup/delegate indirection
            </summary>
            <param name="op">The operator classifier</param>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <param name="c">The third operand</param>
        
| M:Z0.BitLogixOps.lookup(Z0.BinaryLogicKind)       | 
            <summary>
            Returns a kind-indentified binary operator
            </summary>
            <param name="kind">The operator kind</param>
        
| M:Z0.BitLogixOps.eval(Z0.TernaryBitLogic,Z0.bit,Z0.bit,Z0.bit)| 
            <summary>
            Evaluates an identified ternary operator
            </summary>
            <param name="op">The ternary operator classifier</param>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <param name="c">The third operand</param>
        
| M:Z0.BitLogixOps.lookup(Z0.TernaryBitLogic)       | 
            <summary>
            Returns a kind-indentified ternary operator
            </summary>
            <param name="kind">The operator kind</param>
        
| M:Z0.XTend.BitSeg``1(System.Span{``0},System.Int32,System.Int32)| 
            <summary>
            Retrieves, at most, one cell's worth of bits defined by an inclusive bit index range
            </summary>
            <param name="first">The linear index of the first bit</param>
            <param name="last">The linear index of the last bit</param>
        
| M:Z0.BitPos.FromBitIndex(System.Byte,System.UInt32)| 
            <summary>
            Defines a bit position predicated on the width of a storage cell and the 0-based linear bit index
            </summary>
            <param name="w">The storage cell width</param>
            <param name="index">The linear bit index</param>
        
| M:Z0.BitPos.FromCellIndex(System.Byte,System.UInt16,System.Byte)| 
            <summary>
            Defines a bit position predicated on the width and container-relative index of a storage cell and a cell-relative bit offset
            </summary>
            <param name="w">The storage cell width</param>
            <param name="cellindex">The container-relative cell index</param>
            <param name="offset">The cell-relative bit offset</param>
        
| M:Z0.BitPos.FromCellIndex``1(System.UInt16,System.Byte)| 
            <summary>
            Defines a bit position predicated on a parametric cell type and a cell-relative bit offset
            </summary>
            <param name="cellindex">The container-relative cell index</param>
            <param name="offset">The cell-relative bit offset</param>
        
| M:Z0.BitPos.FromBitIndex``1(System.UInt32)        | 
            <summary>
            Defines a bit position predicated on a parametric cell type and linear bit index
            </summary>
            <param name="index">The linear bit index</param>
        
| M:Z0.BitPos.CalcCellIndex(System.Byte,System.UInt32)| 
            <summary>
            Computes the cell index of a linear bit index
            </summary>
            <param name="w">The width of a storage cell</param>
            <param name="index">The linear bit index</param>
        
| M:Z0.BitPos.CalcBitOffset(System.Byte,System.UInt32)| 
            <summary>
            Computes the offset of a linear bit index over storage cells of specified width
            </summary>
            <param name="w">The storage cell width</param>
            <param name="index">The linear bit index</param>
        
| M:Z0.BitPos.CalcBitIndex(System.Byte,System.UInt32,System.Byte)| 
            <summary>
            Computes a linear bit index from a cell index and cell-relative offset
            </summary>
            <param name="w">The cell capacity</param>
            <param name="cellindex">The cell index</param>
            <param name="offset">The cell-relative offset of the bit</param>
        
| M:Z0.BitPos.Distance(Z0.BitPos,Z0.BitPos)         | 
            <summary>
            Computes the order-invariant absolute distance between two positions
            </summary>
            <param name="lhs">The left position</param>
            <param name="rhs">The right position</param>
        
| F:Z0.BitPos.CellIndex                             | 
            <summary>
            The container-relative 0-based offset of the cell
            </summary>
        
| F:Z0.BitPos.BitOffset                             | 
            <summary>
            The cell-relative offset of the bit
            </summary>
        
| F:Z0.BitPos.CellWidth                             | 
            <summary>
            The bit-width of a cell
            </summary>
        
| P:Z0.BitPos.BitIndex                              | 
            <summary>
            The linear/absolute bit index of the represented position
            </summary>
        
| T:Z0.BitPos`1                                     | 
            <summary>
            Identifies a bit position within a contiguous sequence of T-element values together with their cell index/bit offsets 
            </summary>
        
| F:Z0.BitPos`1.CellIndex                           | 
            <summary>
            The container-relative 0-based offset of the segment
            </summary>
        
| F:Z0.BitPos`1.BitOffset                           | 
            <summary>
            The segment-relative offset of the bit
            </summary>
        
| P:Z0.BitPos`1.Zero                                | 
            <summary>
            The zero position
            </summary>
        
| P:Z0.BitPos`1.CellWidth                           | 
            <summary>
            Specifies the number of bits that can be placed in one segment
            </summary>
        
| M:Z0.BitPos`1.FromBitIndex(System.UInt32)         | 
            <summary>
            Constructs a bit position from a linear/absolute index
            </summary>
            <param name="bitindex">The linear index</param>
        
| M:Z0.Mux.mux(System.Byte,System.Byte)             | 
            <summary>
            Uses the first three bits of the control operand to select one of 8 bits from the input operand
            </summary>
            <param name="control">Specifies the output selection</param>
            <param name="src">The input from which a bit will be selected</param>
        
| M:Z0.Mux.mux(System.UInt16,System.Byte)           | 
            <summary>
            Uses the four bits of the control operand to select one of 16 bits from the input operand
            </summary>
            <param name="src">The input from which a bit will be selected</param>
            <param name="control">Specifies the output selection</param>
        
| M:Z0.Mux.mux(System.UInt32,System.Byte)           | 
            <summary>
            Uses the first 5 bits of the control operand to select one of 32 bits from the input operand
            </summary>
            <param name="src">The input from which a bit will be selected</param>
            <param name="control">Specifies the output selection</param>
        
| M:Z0.Mux.mux(System.UInt64,System.Byte)           | 
            <summary>
            Uses the first 6 bits of the control operand to select one of 64 bits from the source operand
            </summary>
            <param name="src">The input from which a bit will be selected</param>
            <param name="control">Specifies the output selection</param>
        
| T:Z0.BitLogix                                     | 
            <summary>
            Defines logical operations over 1, 2 or 3 bits
            </summary>
        
| P:Z0.BitLogix.UnaryOpKinds                        | 
            <summary>
            Advertises the supported unary opeators
            </summary>
        
| P:Z0.BitLogix.BinaryOpKinds                       | 
            <summary>
            Advertises the supported binary opeators
            </summary>
        
| P:Z0.BitLogix.TernaryOpKinds                      | 
            <summary>
            Advertises the supported ternary opeators
            </summary>
        
| M:Z0.BitLogix.Lookup(Z0.UnaryBitLogic)            | 
            <summary>
            Returns a kind-indentified unary operator
            </summary>
            <param name="kind">The operator kind</param>
        
| M:Z0.BitLogix.Lookup(Z0.BinaryBitLogic)           | 
            <summary>
            Returns a kind-indentified unary operator
            </summary>
            <param name="kind">The operator kind</param>
        
| M:Z0.BitLogix.Lookup(Z0.BinaryLogicKind)          | 
            <summary>
            Returns a kind-indentified binary operator
            </summary>
            <param name="kind">The operator kind</param>
        
| M:Z0.BitLogix.Lookup(Z0.TernaryBitLogic)          | 
            <summary>
            Returns a kind-indentified ternary operator
            </summary>
            <param name="kind">The operator kind</param>
        
| M:Z0.BitLogix.Evaluate(Z0.UnaryBitLogic,Z0.bit)   | 
            <summary>
            Evaluates a unary operator over a supplied operand
            </summary>
            <param name="kind">The operaor kind</param>
            <param name="a">The operand</param>        
        
| M:Z0.BitLogix.Evaluate(Z0.BinaryLogicKind,Z0.bit,Z0.bit)| 
            <summary>
            Evaluates a bianry operator over supplied operands
            </summary>
            <param name="kind">The operaor kind</param>
            <param name="a">The operand</param>        
        
| M:Z0.BitLogix.Evaluate(Z0.BinaryBitLogic,Z0.bit,Z0.bit)| 
            <summary>
            Evaluates a bianry operator over supplied operands
            </summary>
            <param name="kind">The operaor kind</param>
            <param name="a">The operand</param>        
        
| M:Z0.BitLogix.Evaluate(Z0.TernaryBitLogic,Z0.bit,Z0.bit,Z0.bit)| 
            <summary>
            Evaluates a ternary operator over supplied operands
            </summary>
            <param name="kind">The operaor kind</param>
            <param name="a">The operand</param>        
        
| T:Z0.BinaryBitLogic                               | 
            <summary>
            Classifies binary boolean and bitwise logical operations
            </summary>    
        
| F:Z0.BinaryBitLogic.False                         | 
            <summary>
            Classifies a logical  binary operator false(a,b) := bv(0000)
            </summary>
            <remarks>
            bv(0000) = id(True)
            </remarks>
        
| F:Z0.BinaryBitLogic.And                           | 
            <summary>
            Identifies the operator and(a,b) := bv(1000)
            </summary>
            <remarks>
            bv(1000) = id(Nor)
            0 0 0
            1 0 0
            0 1 0
            1 1 1
            </remarks>
        
| F:Z0.BinaryBitLogic.CNonImpl                      | 
            <summary>
            Identifies the operator cnotimply(a,b) := and(a, ~b) = bv(0010)
            </summary>
            <remarks>
            bv(0010) = id(ConverseNonimplication)
            Truth table:
            0 0 0
            1 0 1
            0 1 0
            1 1 0
            </remarks>
        
| F:Z0.BinaryBitLogic.LProject                      | 
            <summary>
            Classifes a logical binary operator left(a,b) := a = bv(1010)
            </summary>
            <remarks>
            bv(1010) = id(RightNot)
            Truth Table:
            0 0 0
            1 0 1
            0 1 0
            1 1 1
            </remarks>
        
| F:Z0.BinaryBitLogic.NonImpl                       | 
            <summary>
            Identifies a logical binary operator notimply(a,b) := and(~a, b) = bv(0100)
            </summary>
            <remarks>
            bv(0100) = id(Nonimplication)
            Truth table:
            0 0 0
            1 0 0
            0 1 1
            1 1 0
            </remarks>
        
| F:Z0.BinaryBitLogic.RProject                      | 
            <summary>
            Identifies the operator right(a,b) := b = bv(1100)
            </summary>
            <remarks>
            bv(1100) = id(LeftNot)
            Truth table:
            0 0 0
            1 0 0
            0 1 1
            1 1 1
            </remarks>
        
| F:Z0.BinaryBitLogic.Xor                           | 
            <summary>
            Identifies the operator xor(a,b) := bv(0110)
            </summary>
            <remarks>
            bv(0110) = id(XOr)
            Truth Table:
            0 0 0
            1 0 1
            0 1 1
            1 1 0
            </remarks>
        
| F:Z0.BinaryBitLogic.Or                            | 
            <summary>
            Identifies the operator or(a,b) := bv(1110)
            </summary>
            <remarks>
            bv(1110) = id(Nand)
            Truth Table:
            0 0 0
            1 0 1
            0 1 1
            1 1 1
            </remarks>
        
| F:Z0.BinaryBitLogic.Nor                           | 
            <summary>
            Identifies the operator that computes nor(a,b) := not(or(a,b)) = bv(0001)
            </summary>
            <remarks>
            bv(0001) = id(And)
            Truth Table:
            0 0 1
            1 0 0
            0 1 0
            1 1 0
            </remarks>
        
| F:Z0.BinaryBitLogic.Xnor                          | 
            <summary>
            Classifies a binary operator xnor(a,b) := not(xor(a,b)) = bv(1001)
            </summary>
            <remarks>
            bv(1001) = id(Xnor)
            Truth Table:
            0 0 1
            1 0 0
            0 1 0
            1 1 1
            </remarks>
        
| F:Z0.BinaryBitLogic.RNot                          | 
            <summary>
            Classifes a logical binary operator rnot(a,b) := not(b) = bv(0011)
            </summary>
            <remarks>
            bv(0011) = id(LeftProject)
            Truth table:
            0 0 1
            1 0 1
            0 1 0
            1 1 0
            </remarks>
        
| F:Z0.BinaryBitLogic.Impl                          | 
            <summary>
            Identifies the operator imply(a,b) := or(a, not(b)) = bv(1011)
            </summary>
            <remarks>
            bv(1011) = id(Implication)
            Truth table:
            0 0 1
            1 0 1
            0 1 0
            1 1 1
            </remarks>
        
| F:Z0.BinaryBitLogic.LNot                          | 
            <summary>
            Identifies the operator lnot(a,b) := not(a) = bv(0101)
            </summary>
            <remarks>
            bv(0101) = id(RightProject)
            Truth table:
            0 0 1
            1 0 0
            0 1 1
            1 1 0
            </remarks>
        
| F:Z0.BinaryBitLogic.CImpl                         | 
            <summary>
            Identifies the operator cimply(a,b) := or(not(a), b) = bv(1101)
            </summary>
            bv(1101) = id(ConverseImplication)
            <remarks>
            Truth table:
            0 0 1
            1 0 0
            0 1 1
            1 1 1
            </remarks>
        
| F:Z0.BinaryBitLogic.Nand                          | 
            <summary>
            Identifies the operator nand(a,b) := not(and(a,b)) = bv(0111)
            </summary>
            <remarks>
            bv(0111) = id(Or)
            Truth Table:
            0 0 1
            1 0 1
            0 1 1
            1 1 0
            </remarks>
        
| F:Z0.BinaryBitLogic.True                          | 
            <summary>
            Identifies the operator true(a,b) = bv(1111)
            </summary>
            <remarks>
            bv(1111) = id(False)
            </remarks>
        
| T:Z0.TernaryBitLogic                              | 
            <summary>
            Classifies ternary logic and bitwise operators
            </summary>
        
| F:Z0.TernaryBitLogic.None                         | 
            <summary>
            The empty identity
            </summary>
        
| F:Z0.TernaryBitLogic.X01                          | 
            <summary>
            nor(a, or(b,c))
            </summary>
        
| F:Z0.TernaryBitLogic.X02                          | 
            <summary>
            and(c, nor(b,a))
            </summary>
        
| F:Z0.TernaryBitLogic.X03                          | 
            <summary>
            nor(b,a)
            </summary>
        
| F:Z0.TernaryBitLogic.X04                          | 
            <summary>
            and(b, nor(a,c))
            </summary>
        
| F:Z0.TernaryBitLogic.X05                          | 
            <summary>
            nor(c,a)
            </summary>
        
| F:Z0.TernaryBitLogic.X06                          | 
            <summary>
            and(not(a), xor(b,c))
            </summary>
        
| F:Z0.TernaryBitLogic.X07                          | 
            <summary>
            nor(a, and(b,c))
            </summary>
        
| F:Z0.TernaryBitLogic.X08                          | 
            <summary>
            and(and(not(a),b), c)
            </summary>
        
| F:Z0.TernaryBitLogic.X09                          | 
            <summary>
             nor(a, xor(b,c))
            </summary>
        
| F:Z0.TernaryBitLogic.X0A                          | 
            <summary>
            and(c, not(a))
            </summary>
        
| F:Z0.TernaryBitLogic.X0B                          | 
            <summary>
            and(not(a), or(not(b),  c))
            </summary>
        
| F:Z0.TernaryBitLogic.X0C                          | 
            <summary>
            and(b, not(a))
            </summary>
        
| F:Z0.TernaryBitLogic.X0D                          | 
            <summary>
            and(not(a), or(b, not(c)))
            </summary>
        
| F:Z0.TernaryBitLogic.X0E                          | 
            <summary>
            and(not(a),or(b,c))
            </summary>
        
| F:Z0.TernaryBitLogic.X0F                          | 
            <summary>
            not(a)
            </summary>
        
| F:Z0.TernaryBitLogic.X10                          | 
            <summary>
            and(a, nor(b, c))
            </summary>
        
| F:Z0.TernaryBitLogic.X11                          | 
            <summary>
            nor(c,b)
            </summary>
        
| F:Z0.TernaryBitLogic.X12                          | 
            <summary>
            and(not(b), xor(a,c))
            </summary>
        
| F:Z0.TernaryBitLogic.X13                          | 
            <summary>
            nor(b, and(a,c))
            </summary>
        
| F:Z0.TernaryBitLogic.X14                          | 
            <summary>
            and(not(c), xor(a,b))
            </summary>
        
| F:Z0.TernaryBitLogic.X15                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X16                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X17                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X18                          | 
            <summary>
            and(xor(a,b), xor(a,c))
            </summary>
        
| F:Z0.TernaryBitLogic.X19                          | 
            <summary>
            xor(xor(b,c), and(a, and(b,c)))
            </summary>
        
| F:Z0.TernaryBitLogic.X1A                          | 
            <summary>
            not(and(and(a,b), xor(a, c)))
            </summary>
        
| F:Z0.TernaryBitLogic.X1B                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X1C                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X1D                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X1E                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X1F                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X20                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X21                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X22                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X23                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X24                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X25                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X26                          | 
            <summary>
            and(not(and(a,b)), xor(a, not(c)));
            </summary>
        
| F:Z0.TernaryBitLogic.X27                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X28                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X29                          | 
            <summary>
            select(c, xor(b,a), nor(b,a))
            </summary>
        
| F:Z0.TernaryBitLogic.X2A                          | 
            <summary>
            and(c, nand(b,a))
            </summary>
        
| F:Z0.TernaryBitLogic.X2B                          | 
            <summary>
            select(c, nand(b,a), nor(b,a))
            </summary>
        
| F:Z0.TernaryBitLogic.X2C                          | 
            <summary>
            and(or(b,c), xor(a,b))
            </summary>
        
| F:Z0.TernaryBitLogic.X2D                          | 
            <summary>
             xor(a,(or(b,not(c))))
            </summary>
        
| F:Z0.TernaryBitLogic.X2E                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X2F                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X30                          | 
            <summary>
            cnotimply(a,b)
            </summary>
        
| F:Z0.TernaryBitLogic.X31                          | 
            <summary>
            and(not(b), or(a,not(c)))
            </summary>
        
| F:Z0.TernaryBitLogic.X32                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X33                          | 
            <summary>
            not(b)
            </summary>
        
| F:Z0.TernaryBitLogic.X34                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X35                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X36                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X37                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X38                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X39                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X3A                          | 
            <summary>
            select(a, not(b), c)
            </summary>
        
| F:Z0.TernaryBitLogic.X3B                          | 
            <summary>
            or(and(not(a),c),not(b))
            </summary>
        
| F:Z0.TernaryBitLogic.X3C                          | 
            <summary>
            xor(b,a)
            </summary>
        
| F:Z0.TernaryBitLogic.X3D                          | 
            <summary>
            or(xor(b,a),nor(a,c))
            </summary>
        
| F:Z0.TernaryBitLogic.X3E                          | 
            <summary>
            or(and(not(a),c),xor(a,b))
            </summary>
        
| F:Z0.TernaryBitLogic.X3F                          | 
            <summary>
            nand(b,a)
            </summary>
        
| F:Z0.TernaryBitLogic.X40                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X41                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X42                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X43                          | 
            <summary>
            and(not(and(a,c)), xor(a,not(b)))
            </summary>
        
| F:Z0.TernaryBitLogic.X44                          | 
            <summary>
            cnotimply(b,c)
            </summary>
        
| F:Z0.TernaryBitLogic.X45                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X46                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X47                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X48                          | 
            <summary>
            and(b,xor(a,c))
            </summary>
        
| F:Z0.TernaryBitLogic.X49                          | 
            <summary>
            select(b,xor(a,c),nor(a,c))
            </summary>
        
| F:Z0.TernaryBitLogic.X4A                          | 
            <summary>
            and(or(b,c), xor(a,c))
            </summary>
        
| F:Z0.TernaryBitLogic.X4B                          | 
            <summary>
            xor(a, or(not(b), c))
            </summary>
        
| F:Z0.TernaryBitLogic.X4C                          | 
            <summary>
            and(b, nand(a,c))
            </summary>
        
| F:Z0.TernaryBitLogic.X4D                          | 
            <summary>
            select(b, nand(a,c),nor(a,c))
            </summary>
        
| F:Z0.TernaryBitLogic.X4E                          | 
            <summary>
            select(c, not(a), b)
            </summary>
        
| F:Z0.TernaryBitLogic.X4F                          | 
            <summary>
            or(not(a), andnot(b,c))
            </summary>
        
| F:Z0.TernaryBitLogic.X50                          | 
            <summary>
            cnotimply(a,c)
            </summary>
        
| F:Z0.TernaryBitLogic.X51                          | 
            <summary>
            and(not(c),or(a,not(b)))
            </summary>
        
| F:Z0.TernaryBitLogic.X52                          | 
            <summary>
            and(not(and(b,c)),xor(a,c))
            </summary>
        
| F:Z0.TernaryBitLogic.X53                          | 
            <summary>
            select(a, not(c), not(b))
            </summary>
        
| F:Z0.TernaryBitLogic.X54                          | 
            <summary>
            and(not(c), or(a,b))
            </summary>
        
| F:Z0.TernaryBitLogic.X55                          | 
            <summary>
            not(c)
            </summary>
        
| F:Z0.TernaryBitLogic.X56                          | 
            <summary>
            xor(c,or(b,a))
            </summary>
        
| F:Z0.TernaryBitLogic.X57                          | 
            <summary>
            nand(c,or(b,a))
            </summary>
        
| F:Z0.TernaryBitLogic.X58                          | 
            <summary>
            and(or(a,b),xor(a,c))
            </summary>
        
| F:Z0.TernaryBitLogic.X59                          | 
            <summary>
            xor(c, or(a,xor1(b)))
            </summary>
        
| F:Z0.TernaryBitLogic.X5A                          | 
            <summary>
            xor(c,a)
            </summary>
        
| F:Z0.TernaryBitLogic.X5B                          | 
            <summary>
            or(xor(a,c), xor(or(a,b),on)) 
            </summary>
        
| F:Z0.TernaryBitLogic.X5C                          | 
            <summary>
            select(a,not(c), b)
            </summary>
        
| F:Z0.TernaryBitLogic.X5D                          | 
            <summary>
            or(not(c), and(not(a), b))
            </summary>
        
| F:Z0.TernaryBitLogic.X5E                          | 
            <summary>
            or(and(not(c),b),(xor(a,c)))
            </summary>
        
| F:Z0.TernaryBitLogic.X5F                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X60                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X61                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X62                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X63                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X64                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X65                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X66                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X67                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X68                          | 
            <summary>
            
            </summary>
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X69                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X6A                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X6B                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X6C                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X6D                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X6E                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X6F                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X70                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X71                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X72                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X73                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X74                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X75                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X76                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X77                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X78                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X79                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X7A                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X7B                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X7C                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X7D                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X7E                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X7F                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X80                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X81                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X82                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X83                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X84                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X85                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X86                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X87                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X88                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X89                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X8A                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X8B                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X8C                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X8D                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X8E                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X8F                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X90                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X91                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X92                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X93                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X94                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X95                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X96                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X97                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X98                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X99                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X9A                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X9B                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X9C                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X9D                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X9E                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.X9F                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XA0                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XA1                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XA2                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XA3                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XA4                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XA5                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XA6                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XA7                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XA8                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XA9                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XAA                          | 
            <summary>
            third(a,b,c) := c
            </summary>
        
| F:Z0.TernaryBitLogic.XAB                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XAC                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XAD                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XAE                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XAF                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XB0                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XB1                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XB2                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XB3                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XB4                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XB5                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XB6                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XB7                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XB8                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XB9                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XBA                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XBB                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XBC                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XBD                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XBE                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XBF                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XC0                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XC1                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XC2                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XC3                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XC4                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XC5                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XC6                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XC7                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XC8                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XC9                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XCA                          | 
            <summary>
            select(a,b,c)
            </summary>
        
| F:Z0.TernaryBitLogic.XCB                          | 
            <summary>
            second(a,b,c) := b
            </summary>
        
| F:Z0.TernaryBitLogic.XCC                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XCD                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XCE                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XCF                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XD0                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XD1                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XD2                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XD3                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XD4                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XD5                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XD6                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XD7                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XD8                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XD9                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XDA                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XDB                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XDC                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XDD                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XDE                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XDF                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XE0                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XE1                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XE2                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XE3                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XE4                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XE5                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XE6                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XE7                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XE8                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XE9                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XEA                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XEB                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XEC                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XED                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XEE                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XEF                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XF0                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XF1                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XF2                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XF3                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XF4                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XF5                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XF6                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XF7                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XF8                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XF9                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XFA                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XFB                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XFC                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XFD                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XFE                          | 
            <summary>
            
            </summary>
        
| F:Z0.TernaryBitLogic.XFF                          | 
            <summary>
             Pervasive and invariant truth
            </summary>
        
| T:Z0.UnaryBitLogic                                | 
            <summary>
            Classifies unary logic operators
            </summary>
        
| F:Z0.UnaryBitLogic.False                          | 
            <summary>
            The unary operator that always returns false
            </summary>
        
| F:Z0.UnaryBitLogic.Not                            | 
            <summary>
            Logial NOT
            </summary>
        
| F:Z0.UnaryBitLogic.Identity                       | 
            <summary>
            The identity operator
            </summary>
        
| F:Z0.UnaryBitLogic.True                           | 
            <summary>
            The unary operator that always returns true
            </summary>
        
| T:Z0.BinaryArithmeticKind                         | 
            <summary>
            Identifies binary arithmetic operators classes
            </summary>
        
| F:Z0.BinaryArithmeticKind.None                    | 
            <summary>
            The empty identity
            </summary>
        
| T:Z0.BinaryComparisonKind                         | 
            <summary>
            Identifies binary comparison predicates
            </summary>
        
| F:Z0.BinaryComparisonKind.None                    | 
            <summary>
            The empty identity
            </summary>
        
| F:Z0.BinaryComparisonKind.Eq                      | 
            <summary>
            Classifies a binary operator that returns true iff its operands are equal
            </summary>
        
| F:Z0.BinaryComparisonKind.Lt                      | 
            <summary>
            Classifies a binary operator that returns true if the left operand is strictly smaller than the left operand
            </summary>
        
| F:Z0.BinaryComparisonKind.LtEq                    | 
            <summary>
            Classifies a binary operator that returns true if the left operand is smaller than or equal to the left operand
            </summary>
        
| F:Z0.BinaryComparisonKind.Gt                      | 
            <summary>
            Classifies a binary operator that returns true if the left operand is strictly greater than the left operand
            </summary>
        
| F:Z0.BinaryComparisonKind.GtEq                    | 
            <summary>
            Classifies a binary operator that returns true if the left operand is greater than or equal to the left operand
            </summary>
        
| F:Z0.BinaryComparisonKind.Neq                     | 
            <summary>
            Classifies a binary operator that returns true iff its operands are not equal
            </summary>
        
| T:Z0.BinaryLogicKind                              | 
            <summary>
            Classifies binary boolean and bitwise logical operations
            </summary>    
        
| F:Z0.BinaryLogicKind.None                         | 
            <summary>
            The empty identity which, unfortunately conflicts with the inescapable defintion of 'False'
            </summary>
        
| F:Z0.BinaryLogicKind.False                        | 
            <summary>
            Classifies a logical  binary operator false(a,b) := bv(0000)
            </summary>
            <remarks>
            bv(0000) = id(True)
            </remarks>
        
| F:Z0.BinaryLogicKind.And                          | 
            <summary>
            Classifies a logical binary operator and(a,b) := bv(1000)
            </summary>
            <remarks>
            bv(1000) = id(Nor)
            0 0 0
            1 0 0
            0 1 0
            1 1 1
            </remarks>
        
| F:Z0.BinaryLogicKind.CNonImpl                     | 
            <summary>
            Classifies a logical binary operator cnotimply(a,b) := and(a, ~b) = bv(0010)
            </summary>
            <remarks>
            bv(0010) = id(ConverseNonimplication)
            Truth table:
            0 0 0
            1 0 1
            0 1 0
            1 1 0
            </remarks>
        
| F:Z0.BinaryLogicKind.LProject                     | 
            <summary>
            Classifes a logical binary operator left(a,b) := a = bv(1010)
            </summary>
            <remarks>
            bv(1010) = id(RightNot)
            Truth Table:
            0 0 0
            1 0 1
            0 1 0
            1 1 1
            </remarks>
        
| F:Z0.BinaryLogicKind.NonImpl                      | 
            <summary>
            Identifies a logical binary operator notimply(a,b) := and(~a, b) = bv(0100)
            </summary>
            <remarks>
            bv(0100) = id(Nonimplication)
            Truth table:
            0 0 0
            1 0 0
            0 1 1
            1 1 0
            </remarks>
        
| F:Z0.BinaryLogicKind.RProject                     | 
            <summary>
            Classifies a logical binary operator right(a,b) := b = bv(1100)
            </summary>
            <remarks>
            bv(1100) = id(LeftNot)
            Truth table:
            0 0 0
            1 0 0
            0 1 1
            1 1 1
            </remarks>
        
| F:Z0.BinaryLogicKind.Xor                          | 
            <summary>
            Classifies a logical binary operator xor(a,b) := bv(0110)
            </summary>
            <remarks>
            bv(0110) = id(XOr)
            Truth Table:
            0 0 0
            1 0 1
            0 1 1
            1 1 0
            </remarks>
        
| F:Z0.BinaryLogicKind.Or                           | 
            <summary>
            Classifies a logical binary operator or(a,b) := bv(1110)
            </summary>
            <remarks>
            bv(1110) = id(Nand)
            Truth Table:
            0 0 0
            1 0 1
            0 1 1
            1 1 1
            </remarks>
        
| F:Z0.BinaryLogicKind.Nor                          | 
            <summary>
            Classifies a logical binary operator that computes nor(a,b) := not(or(a,b)) = bv(0001)
            </summary>
            <remarks>
            bv(0001) = id(And)
            Truth Table:
            0 0 1
            1 0 0
            0 1 0
            1 1 0
            </remarks>
        
| F:Z0.BinaryLogicKind.Xnor                         | 
            <summary>
            Classifies a binary operator xnor(a,b) := not(xor(a,b)) = bv(1001)
            </summary>
            <remarks>
            bv(1001) = id(Xnor)
            Truth Table:
            0 0 1
            1 0 0
            0 1 0
            1 1 1
            </remarks>
        
| F:Z0.BinaryLogicKind.RNot                         | 
            <summary>
            Classifes a logical binary operator rnot(a,b) := not(b) = bv(0011)
            </summary>
            <remarks>
            bv(0011) = id(LeftProject)
            Truth table:
            0 0 1
            1 0 1
            0 1 0
            1 1 0
            </remarks>
        
| F:Z0.BinaryLogicKind.Impl                         | 
            <summary>
            Classifies a logical binary operator imply(a,b) := or(a, not(b)) = bv(1011)
            </summary>
            <remarks>
            bv(1011) = id(Implication)
            Truth table:
            0 0 1
            1 0 1
            0 1 0
            1 1 1
            </remarks>
        
| F:Z0.BinaryLogicKind.LNot                         | 
            <summary>
            Classifies a logical binary operator lnot(a,b) := not(a) = bv(0101)
            </summary>
            <remarks>
            bv(0101) = id(RightProject)
            Truth table:
            0 0 1
            1 0 0
            0 1 1
            1 1 0
            </remarks>
        
| F:Z0.BinaryLogicKind.CImpl                        | 
            <summary>
            Classifies a logical binary operator cimply(a,b) := or(not(a), b) = bv(1101)
            </summary>
            bv(1101) = id(ConverseImplication)
            <remarks>
            Truth table:
            0 0 1
            1 0 0
            0 1 1
            1 1 1
            </remarks>
        
| F:Z0.BinaryLogicKind.Nand                         | 
            <summary>
            Classifies a logical binary operator nand(a,b) := not(and(a,b)) = bv(0111)
            </summary>
            <remarks>
            bv(0111) = id(Or)
            Truth Table:
            0 0 1
            1 0 1
            0 1 1
            1 1 0
            </remarks>
        
| F:Z0.BinaryLogicKind.True                         | 
            <summary>
            Classifies a logical binary operator true(a,b) = bv(1111)
            </summary>
            <remarks>
            bv(1111) = id(False)
            </remarks>
        
| T:Z0.UnaryArithmeticKind                          | 
            <summary>
            Classifies unary arithmetic operators
            </summary>
        
| T:Z0.BinaryPred`1                                 | 
            <summary>
            Defines the canonical shape of a 2-argument function over a parametric domain and boolean codomain
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <typeparam name="T">The domain over which the predicate is evaluated</typeparam>
        
| T:Z0.Shifter`1                                    | 
            <summary>
            Defines the canonical shape of a bitwise shift function
            </summary>
            <param name="a">The source value</param>
            <param name="count">The shift amount, typically in bits</param>
            <typeparam name="T">The operand type</typeparam>
        
| P:Z0.NumericLogixHost.UnaryLogicKinds             | 
            <summary>
            Advertises the supported unary bitlogic operators
            </summary>
        
| P:Z0.NumericLogixHost.BinaryLogicKinds            | 
            <summary>
            Advertises the supported binary bitlogic operators
            </summary>
        
| P:Z0.NumericLogixHost.TernaryLogicKinds           | 
            <summary>
            Advertises the supported ternary bitlogic opeators
            </summary>
        
| P:Z0.NumericLogixHost.UnaryAritmeticKinds         | 
            <summary>
            Advertises the supported unary arithmetic operators
            </summary>
        
| P:Z0.NumericLogixHost.BinaryArithmeticKinds       | 
            <summary>
            Advertises the supported binary arithmetic operators
            </summary>
        
| P:Z0.NumericLogixHost.BinaryComparisonKinds       | 
            <summary>
            Advertises the supported comparison operators
            </summary>
        
| M:Z0.NumericLogixHost.eval``1(Z0.TernaryBitLogic,``0,``0,``0)| 
            <summary>
            Evaluates an identified ternary operator
            </summary>
            <param name="op">The ternary operator classifier</param>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <param name="c">The third operand</param>
        
| P:Z0.IScalarBits`1.Scalar                         | 
            <summary>
            The value over which the bitvector is defined
            </summary>
        
| M:Z0.BitEdit.Over``1(``0@)                        | 
            <summary>
            Wraps a bitview around a generic reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The generic type</typeparam>
        
| T:Z0.BitEdit`1                                    | 
            <summary>
            Represents a value as an ordered sequence of bits/bytes
            </summary>
        
| F:Z0.BitEdit`1.Bytes                              | 
            <summary>
            The data over which the view is constructed
            </summary>
        
| P:Z0.BitEdit`1.ByteCount                          | 
            <summary>
            The total number of represented bytes
            </summary>
        
| P:Z0.BitEdit`1.BitCount                           | 
            <summary>
            The total number of represented bits
            </summary>
        
| P:Z0.BitEdit`1.Item(Z0.ByteSize)                  | 
            <summary>
            Selects an offset-identified byte
            </summary>
        
| P:Z0.BitEdit`1.Item(Z0.ByteSize,System.Byte)      | 
            <summary>
            Queries/Manipulates the source at the bit-level
            </summary>
        
| M:Z0.BitView.Over``1(``0@)                        | 
            <summary>
            Wraps a bitview around a generic reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The generic type</typeparam>
        
| T:Z0.BitView`1                                    | 
            <summary>
            Represents a value as an ordered sequence of bits/bytes
            </summary>
        
| F:Z0.BitView`1.Bytes                              | 
            <summary>
            The data over which the view is constructed
            </summary>
        
| P:Z0.BitView`1.ByteCount                          | 
            <summary>
            The total number of represented bytes
            </summary>
        
| P:Z0.BitView`1.BitCount                           | 
            <summary>
            The total number of represented bits
            </summary>
        
| P:Z0.BitView`1.Item(Z0.ByteSize)                  | 
            <summary>
            Selects an offset-identified byte
            </summary>
        
| P:Z0.BitView`1.Item(Z0.ByteSize,System.Byte)      | 
            <summary>
            Queries/Manipulates the source at the bit-level
            </summary>
        
