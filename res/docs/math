| M:Z0.math.abs(System.SByte)                       | 
            <summary>
            Computes the absolute value of the source without branching
            </summary>
            <param name="a">The source value</param>
        
| M:Z0.math.abs(System.Int16)                       | 
            <summary>
            Computes the absolute value of the source without branching
            </summary>
            <param name="a">The source value</param>
        
| M:Z0.math.abs(System.Int32)                       | 
            <summary>
            Computes the absolute value of the source without branching
            </summary>
            <param name="a">The source value</param>
        
| M:Z0.math.abs(System.Int64)                       | 
            <summary>
            Computes the absolute value of the source without branching
            </summary>
            <param name="a">The source value</param>
        
| M:Z0.math.avgz(System.Byte,System.Byte)           | 
            <summary>
            Computes the average of the operands, rounding toward zero
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <remarks>Algorithm adapted from Arndt, Matters Computational</remarks>
        
| M:Z0.math.avgz(System.UInt16,System.UInt16)       | 
            <summary>
            Takes the average of the operands, rounding toward zero
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <remarks>Algorithm adapted from Arndt, Matters Computational</remarks>
        
| M:Z0.math.avgz(System.UInt32,System.UInt32)       | 
            <summary>
            Takes the average of the operands, rounding toward zero
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <remarks>Algorithm adapted from Arndt, Matters Computational</remarks>
        
| M:Z0.math.avgz(System.UInt64,System.UInt64)       | 
            <summary>
            Takes the average of the operands, rounding toward zero
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <remarks>Algorithm adapted from Arndt, Matters Computational</remarks>
        
| M:Z0.math.avgi(System.Byte,System.Byte)           | 
            <summary>
            Takes the average of the operands, rounding toward infinity
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <remarks>Algorithm adapted from Arndt, Matters Computational</remarks>
        
| M:Z0.math.avgi(System.UInt16,System.UInt16)       | 
            <summary>
            Takes the average of the operands, rounding toward infinity
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <remarks>Algorithm adapted from Arndt, Matters Computational</remarks>
        
| M:Z0.math.avgi(System.UInt32,System.UInt32)       | 
            <summary>
            Takes the average of the operands, rounding toward infinity
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <remarks>Algorithm adapted from Arndt, Matters Computational</remarks>
        
| M:Z0.math.avgi(System.UInt64,System.UInt64)       | 
            <summary>
            Takes the average of the operands, rounding toward infinity
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <remarks>Algorithm adapted from Arndt, Matters Computational</remarks>
        
| M:Z0.math.clamp(System.SByte,System.SByte)        | 
            <summary>
            Clamps the source value to an inclusive maximum
            </summary>
            <param name="src">The source value</param>
            <param name="max">The maximum value</param>
        
| M:Z0.math.clamp(System.Byte,System.Byte)          | 
            <summary>
            Clamps the source value to an inclusive maximum
            </summary>
            <param name="src">The source value</param>
            <param name="max">The maximum value</param>
        
| M:Z0.math.clamp(System.Int16,System.Int16)        | 
            <summary>
            Clamps the source value to an inclusive maximum
            </summary>
            <param name="src">The source value</param>
            <param name="max">The maximum value</param>
        
| M:Z0.math.clamp(System.UInt16,System.UInt16)      | 
            <summary>
            Clamps the source value to an inclusive maximum
            </summary>
            <param name="src">The source value</param>
            <param name="max">The maximum value</param>
        
| M:Z0.math.clamp(System.Int32,System.Int32)        | 
            <summary>
            Clamps the source value to an inclusive maximum
            </summary>
            <param name="src">The source value</param>
            <param name="max">The maximum value</param>
        
| M:Z0.math.clamp(System.UInt32,System.UInt32)      | 
            <summary>
            Clamps the source value to an inclusive maximum
            </summary>
            <param name="src">The source value</param>
            <param name="max">The maximum value</param>
        
| M:Z0.math.clamp(System.Int64,System.Int64)        | 
            <summary>
            Clamps the source value to an inclusive maximum
            </summary>
            <param name="src">The source value</param>
            <param name="max">The maximum value</param>
        
| M:Z0.math.clamp(System.UInt64,System.UInt64)      | 
            <summary>
            Clamps the source value to an inclusive maximum
            </summary>
            <param name="src">The source value</param>
            <param name="max">The maximum value</param>
        
| M:Z0.math.dec(System.SByte)                       | 
            <summary>
            Decrements the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.math.dec(System.Byte)                        | 
            <summary>
            Decrements the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.math.dec(System.Int16)                       | 
            <summary>
            Decrements the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.math.dec(System.UInt16)                      | 
            <summary>
            Decrements the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.math.dec(System.Int32)                       | 
            <summary>
            Decrements the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.math.dec(System.UInt32)                      | 
            <summary>
            Decrements the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.math.dec(System.Int64)                       | 
            <summary>
            Decrements the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.math.dec(System.UInt64)                      | 
            <summary>
            Decrements the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.math.dist(System.Byte,System.Byte)           | 
            <summary>
            Computes the nonnegative distance between two numbers
            </summary>
            <param name="a">The first number</param>
            <param name="b">The second number</param>
        
| M:Z0.math.dist(System.SByte,System.SByte)         | 
            <summary>
            Computes the nonnegative distance between two numbers
            </summary>
            <param name="a">The first number</param>
            <param name="b">The second number</param>
        
| M:Z0.math.dist(System.Int16,System.Int16)         | 
            <summary>
            Computes the nonnegative distance between two numbers
            </summary>
            <param name="a">The first number</param>
            <param name="b">The second number</param>
        
| M:Z0.math.dist(System.UInt16,System.UInt16)       | 
            <summary>
            Computes the nonnegative distance between two numbers
            </summary>
            <param name="a">The first number</param>
            <param name="b">The second number</param>
        
| M:Z0.math.dist(System.Int32,System.Int32)         | 
            <summary>
            Computes the nonnegative distance between two numbers
            </summary>
            <param name="a">The first number</param>
            <param name="b">The second number</param>
        
| M:Z0.math.dist(System.UInt32,System.UInt32)       | 
            <summary>
            Computes the nonnegative distance between two numbers
            </summary>
            <param name="a">The first number</param>
            <param name="b">The second number</param>
        
| M:Z0.math.dist(System.Int64,System.Int64)         | 
            <summary>
            Computes the nonnegative distance between two numbers
            </summary>
            <param name="a">The first number</param>
            <param name="b">The second number</param>
        
| M:Z0.math.dist(System.UInt64,System.UInt64)       | 
            <summary>
            Computes the nonnegative distance between two numbers
            </summary>
            <param name="a">The first number</param>
            <param name="b">The second number</param>
        
| M:Z0.math.divmod(System.SByte,System.SByte)       | 
            <summary>
            Computes dst = (div(a,b), mod(a,b))
            </summary>
            <param name="a">The dividend</param>
            <param name="b">The divisor</param>
        
| M:Z0.math.divmod(System.Byte,System.Byte)         | 
            <summary>
            Computes dst = (div(a,b), mod(a,b))
            </summary>
            <param name="a">The dividend</param>
            <param name="b">The divisor</param>
        
| M:Z0.math.divmod(System.Int16,System.Int16)       | 
            <summary>
            Computes dst = (div(a,b), mod(a,b))
            </summary>
            <param name="a">The dividend</param>
            <param name="b">The divisor</param>
        
| M:Z0.math.divmod(System.UInt16,System.UInt16)     | 
            <summary>
            Computes dst = (div(a,b), mod(a,b))
            </summary>
            <param name="a">The dividend</param>
            <param name="b">The divisor</param>
        
| M:Z0.math.divmod(System.Int32,System.Int32)       | 
            <summary>
            Computes dst = (div(a,b), mod(a,b))
            </summary>
            <param name="a">The dividend</param>
            <param name="b">The divisor</param>
        
| M:Z0.math.divmod(System.UInt32,System.UInt32)     | 
            <summary>
            Computes dst = (div(a,b), mod(a,b))
            </summary>
            <param name="a">The dividend</param>
            <param name="b">The divisor</param>
        
| M:Z0.math.divmod(System.Int64,System.Int64)       | 
            <summary>
            Computes dst = (div(a,b), mod(a,b))
            </summary>
            <param name="a">The dividend</param>
            <param name="b">The divisor</param>
        
| M:Z0.math.divmod(System.UInt64,System.UInt64)     | 
            <summary>
            Computes dst = (div(a,b), mod(a,b))
            </summary>
            <param name="a">The dividend</param>
            <param name="b">The divisor</param>
        
| M:Z0.math.gcdbin(System.UInt32,System.UInt32)     | 
            <summary>
            Binary gcd, Wikipedia version
            </summary>
            <param name="u"></param>
            <param name="v"></param>
            <remarks>See https://en.wikipedia.org/wiki/Binary_GCD_algorithm</remarks>
        
| M:Z0.math.gcdbin(System.UInt64,System.UInt64)     | 
            <summary>
            Binary gcd, Wikipedia version
            </summary>
            <param name="u"></param>
            <param name="v"></param>
            <remarks>See https://en.wikipedia.org/wiki/Binary_GCD_algorithm</remarks>
        
| M:Z0.math.inc(System.SByte)                       | 
            <summary>
            Increments the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.math.inc(System.Byte)                        | 
            <summary>
            Increments the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.math.inc(System.Int16)                       | 
            <summary>
            Increments the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.math.inc(System.UInt16)                      | 
            <summary>
            Increments the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.math.inc(System.Int32)                       | 
            <summary>
            Increments the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.math.inc(System.UInt32)                      | 
            <summary>
            Increments the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.math.inc(System.Int64)                       | 
            <summary>
            Increments the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.math.inc(System.UInt64)                      | 
            <summary>
            Increments the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.math.ispow2(System.SByte)                    | 
            <summary>
            Returns 1 if the source value is a power of 2 and 0 otherwise
            </summary>
            <param name="x">The value to test</param>
        
| M:Z0.math.ispow2(System.Byte)                     | 
            <summary>
            Returns 1 if the source value is a power of 2 and 0 otherwise
            </summary>
            <param name="x">The value to test</param>
        
| M:Z0.math.ispow2(System.Int16)                    | 
            <summary>
            Returns 1 if the source value is a power of 2 and 0 otherwise
            </summary>
            <param name="x">The value to test</param>
        
| M:Z0.math.ispow2(System.UInt16)                   | 
            <summary>
            Returns 1 if the source value is a power of 2 and 0 otherwise
            </summary>
            <param name="x">The value to test</param>
        
| M:Z0.math.ispow2(System.Int32)                    | 
            <summary>
            Returns 1 if the source value is a power of 2 and 0 otherwise
            </summary>
            <param name="x">The value to test</param>
        
| M:Z0.math.ispow2(System.UInt32)                   | 
            <summary>
            Returns 1 if the source value is a power of 2 and 0 otherwise
            </summary>
            <param name="x">The value to test</param>
        
| M:Z0.math.ispow2(System.Int64)                    | 
            <summary>
            Returns 1 if the source value is a power of 2 and 0 otherwise
            </summary>
            <param name="x">The value to test</param>
        
| M:Z0.math.ispow2(System.UInt64)                   | 
            <summary>
            Returns 1 if the source value is a power of 2 and 0 otherwise
            </summary>
            <param name="x">The value to test</param>
        
| M:Z0.math.log2(System.Byte)                       | 
            <summary>
            Computes floor(log(src,2))
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.math.log2(System.UInt16)                     | 
            <summary>
            Computes floor(log(src,2))
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.math.log2(System.UInt32)                     | 
            <summary>
            Computes floor(log(src,2))
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.math.log2(System.UInt64)                     | 
            <summary>
            Computes floor(log(src,2))
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.math.mod(System.SByte,System.SByte)          | 
            <summary>
            Computes b := a % m
            </summary>
            <param name="a">The source value</param>
            <param name="m">The modulus</param>
        
| M:Z0.math.mod(System.Byte,System.Byte)            | 
            <summary>
            Computes b := a % m
            </summary>
            <param name="a">The source value</param>
            <param name="m">The modulus</param>
        
| M:Z0.math.mod(System.Int16,System.Int16)          | 
            <summary>
            Computes b := a % m
            </summary>
            <param name="a">The source value</param>
            <param name="m">The modulus</param>
        
| M:Z0.math.mod(System.UInt16,System.UInt16)        | 
            <summary>
            Computes b := a % m
            </summary>
            <param name="a">The source value</param>
            <param name="m">The modulus</param>
        
| M:Z0.math.mod(System.Int32,System.Int32)          | 
            <summary>
            Computes b := a % m
            </summary>
            <param name="a">The source value</param>
            <param name="m">The modulus</param>
        
| M:Z0.math.mod(System.UInt32,System.UInt32)        | 
            <summary>
            Computes b := a % m
            </summary>
            <param name="a">The source value</param>
            <param name="m">The modulus</param>
        
| M:Z0.math.mod(System.Int64,System.Int64)          | 
            <summary>
            Computes b := a % m
            </summary>
            <param name="a">The source value</param>
            <param name="m">The modulus</param>
        
| M:Z0.math.mod(System.UInt64,System.UInt64)        | 
            <summary>
            Computes b := a % m
            </summary>
            <param name="a">The source value</param>
            <param name="m">The modulus</param>
        
| M:Z0.math.modmul(System.SByte,System.SByte,System.SByte)| 
            <summary>
            Computes z := (a*b) mod m
            </summary>
            <param name="a">The first factor</param>
            <param name="b">The second factor</param>
            <param name="m">The modulus</param>
        
| M:Z0.math.modmul(System.Byte,System.Byte,System.Byte)| 
            <summary>
            Computes z := (a*b) mod m
            </summary>
            <param name="a">The first factor</param>
            <param name="b">The second factor</param>
            <param name="m">The modulus</param>
        
| M:Z0.math.modmul(System.Int16,System.Int16,System.Int16)| 
            <summary>
            Computes z := (a*b) mod m
            </summary>
            <param name="a">The first factor</param>
            <param name="b">The second factor</param>
            <param name="m">The modulus</param>
        
| M:Z0.math.modmul(System.UInt16,System.UInt16,System.UInt16)| 
            <summary>
            Computes z := (a*b) mod m
            </summary>
            <param name="a">The first factor</param>
            <param name="b">The second factor</param>
            <param name="m">The modulus</param>
        
| M:Z0.math.modmul(System.Int32,System.Int32,System.Int32)| 
            <summary>
            Computes z := (a*b) mod m
            </summary>
            <param name="a">The first factor</param>
            <param name="b">The second factor</param>
            <param name="m">The modulus</param>
        
| M:Z0.math.modmul(System.UInt32,System.UInt32,System.UInt32)| 
            <summary>
            Computes z := (a*b) mod m
            </summary>
            <param name="a">The first factor</param>
            <param name="b">The second factor</param>
            <param name="m">The modulus</param>
        
| M:Z0.math.modmul(System.Int64,System.Int64,System.Int64)| 
            <summary>
            Computes z := (a*b) mod m
            </summary>
            <param name="a">The first factor</param>
            <param name="b">The second factor</param>
            <param name="m">The modulus</param>
        
| M:Z0.math.modmul(System.UInt64,System.UInt64,System.UInt64)| 
            <summary>
            Computes z := (a*b) mod m
            </summary>
            <param name="a">The first factor</param>
            <param name="b">The second factor</param>
            <param name="m">The modulus</param>
        
| M:Z0.math.mul32x64(Z0.Pair{System.UInt32}@,Z0.Pair{System.UInt32}@)| 
            <summary>
            Computes the full 64-bit product between two unsigned 32-bit integers
            </summary>
            <param name="src">The source integers</param>
            <param name="dst">The multiplication result, partitioned into lo/hi parts</param>
        
| M:Z0.math.mul64x128(Z0.Pair{System.UInt64}@,Z0.Pair{System.UInt64}@)| 
            <summary>
            Computes the full 128-bit product between two unsigned 64-bit integers
            </summary>
            <param name="src">The source integers</param>
            <param name="dst">The multiplication result, partitioned into lo/hi parts</param>
        
| M:Z0.math.mul32x64(Z0.Pair{System.UInt32}@)       | 
            <summary>
            Computes the full 64-bit product between two unsigned 32-bit integers
            </summary>
            <param name="src">The source integers</param>
            <param name="dst">The multiplication result, partitioned into lo/hi parts</param>
        
| M:Z0.math.mul64x128(Z0.Pair{System.UInt64}@)      | 
            <summary>
            Computes the full 128-bit product between two unsigned 64-bit integers
            </summary>
            <param name="src">The source integers</param>
            <param name="dst">The multiplication result, partitioned into lo/hi parts</param>
        
| M:Z0.math.mul64x128(System.UInt64@,System.UInt64@,Z0.Pair{System.UInt64}@)| 
            <summary>
            Computes the full 128-bit product between two unsigned 64-bit integers
            </summary>
            <param name="src">The source integers</param>
            <param name="z">The multiplication result, partitioned into lo/hi parts</param>
        
| M:Z0.math.mul64x128(System.ReadOnlySpan{System.UInt64},System.ReadOnlySpan{System.UInt64},System.Span{Z0.Pair{System.UInt64}})| 
            <summary>
            Computes the full 128-bit products between corresponding 64-bit span elements
            </summary>
            <param name="xs">The left operands</param>
            <param name="xs">The right operands</param>
            <param name="zs">The multiplication result, partitioned into lo/hi parts</param>
        
| M:Z0.math.mul64x128(System.ReadOnlySpan{System.UInt64},System.UInt64,System.Span{Z0.Pair{System.UInt64}})| 
            <summary>
            Computes the full 128-bit products between 64-bit span elements and a 64-bit scalar
            </summary>
            <param name="xs">The left operands</param>
            <param name="xs">The scalar value</param>
            <param name="zs">The multiplication result, partitioned into lo/hi parts</param>
        
| M:Z0.math.negate(System.SByte)                    | 
            <summary>
            Negates the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.math.negate(System.Byte)                     | 
            <summary>
            Computes the two's complement negation of the source value
            For example, -3 = -0b00000010 = 0b11111101
            </summary>
            <param name="src">The source value</param>
            <remarks>See https://en.wikipedia.org/wiki/Two%27s_complement</remarks>
        
| M:Z0.math.negate(System.Int16)                    | 
            <summary>
            Negates the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.math.negate(System.UInt16)                   | 
            <summary>
            Computes the two's complement negation of the source value
            </summary>
            <param name="src">The source value</param>
            <remarks>See https://en.wikipedia.org/wiki/Two%27s_complement</remarks>
        
| M:Z0.math.negate(System.Int32)                    | 
            <summary>
            Negates the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.math.negate(System.UInt32)                   | 
            <summary>
            Computes the two's complement negation of the source value
            </summary>
            <param name="src">The source value</param>
            <remarks>See https://en.wikipedia.org/wiki/Two%27s_complement</remarks>
        
| M:Z0.math.negate(System.Int64)                    | 
            <summary>
            Negates the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.math.negate(System.UInt64)                   | 
            <summary>
            Computes the two's complement negation of the source value
            </summary>
            <param name="src">The source value</param>
            <remarks>See https://en.wikipedia.org/wiki/Two%27s_complement</remarks>
        
| M:Z0.math.negate(System.Single)                   | 
            <summary>
            Negates the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.math.negate(System.Double)                   | 
            <summary>
            Negates the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.math.even(System.SByte)                      | 
            <summary>
            Returns true if the test value is even by examining the least significant bit
            </summary>
            <param name="test">The value to test</param>
        
| M:Z0.math.even(System.Byte)                       | 
            <summary>
            Returns true if the test value is even by examining the least significant bit
            </summary>
            <param name="test">The value to test</param>
        
| M:Z0.math.even(System.Int16)                      | 
            <summary>
            Returns true if the test value is even by examining the least significant bit
            </summary>
            <param name="test">The value to test</param>
        
| M:Z0.math.even(System.Int32)                      | 
            <summary>
            Returns true if the test value is even by examining the least significant bit
            </summary>
            <param name="test">The value to test</param>
        
| M:Z0.math.even(System.UInt16)                     | 
            <summary>
            Returns true if the test value is even by examining the least significant bit
            </summary>
            <param name="test">The value to test</param>
        
| M:Z0.math.even(System.UInt32)                     | 
            <summary>
            Returns true if the test value is even by examining the least significant bit
            </summary>
            <param name="test">The value to test</param>
        
| M:Z0.math.even(System.Int64)                      | 
            <summary>
            Returns true if the test value is even by examining the least significant bit
            </summary>
            <param name="test">The value to test</param>
        
| M:Z0.math.even(System.UInt64)                     | 
            <summary>
            Returns true if the test value is even by examining the least significant bit
            </summary>
            <param name="test">The value to test</param>
        
| M:Z0.math.odd(System.SByte)                       | 
            <summary>
            Returns true if the test value is odd by examining the least significant bit
            </summary>
            <param name="test">The value to test</param>
        
| M:Z0.math.odd(System.Byte)                        | 
            <summary>
            Returns true if the test value is odd by examining the least significant bit
            </summary>
            <param name="test">The value to test</param>
        
| M:Z0.math.odd(System.Int16)                       | 
            <summary>
            Returns true if the test value is odd by examining the least significant bit
            </summary>
            <param name="test">The value to test</param>
        
| M:Z0.math.odd(System.UInt16)                      | 
            <summary>
            Returns true if the test value is odd by examining the least significant bit
            </summary>
            <param name="test">The value to test</param>
        
| M:Z0.math.odd(System.Int32)                       | 
            <summary>
            Returns true if the test value is odd by examining the least significant bit
            </summary>
            <param name="test">The value to test</param>
        
| M:Z0.math.odd(System.UInt32)                      | 
            <summary>
            Returns true if the test value is odd by examining the least significant bit
            </summary>
            <param name="test">The value to test</param>
        
| M:Z0.math.odd(System.Int64)                       | 
            <summary>
            Returns true if the test value is odd by examining the least significant bit
            </summary>
            <param name="test">The value to test</param>
        
| M:Z0.math.odd(System.UInt64)                      | 
            <summary>
            Returns true if the test value is odd by examining the least significant bit
            </summary>
            <param name="test">The value to test</param>
        
| M:Z0.math.cimpl(System.SByte,System.SByte)        | 
            <summary>
            Computes the converse implication c := ~a | b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.cimpl(System.Byte,System.Byte)          | 
            <summary>
            Computes the converse implication c := ~a | b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.cimpl(System.Int16,System.Int16)        | 
            <summary>
            Computes the converse implication c := ~a | b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.cimpl(System.UInt16,System.UInt16)      | 
            <summary>
            Computes the converse implication c := ~a | b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.cimpl(System.Int32,System.Int32)        | 
            <summary>
            Computes the converse implication c := ~a | b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.cimpl(System.UInt32,System.UInt32)      | 
            <summary>
            Computes the converse implication c := ~a | b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.cimpl(System.Int64,System.Int64)        | 
            <summary>
            Computes the converse implication c := ~a | b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.cimpl(System.UInt64,System.UInt64)      | 
            <summary>
            Computes the converse implication c := ~a | b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.impl(System.SByte,System.SByte)         | 
            <summary>
            Computes the material implication c := a | ~b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.impl(System.Byte,System.Byte)           | 
            <summary>
            Computes the material implication c := a | ~b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.impl(System.Int16,System.Int16)         | 
            <summary>
            Computes the material implication c := a | ~b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.impl(System.UInt16,System.UInt16)       | 
            <summary>
            Computes the material implication c := a | ~b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.impl(System.Int32,System.Int32)         | 
            <summary>
            Computes the material implication c := a | ~b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.impl(System.UInt32,System.UInt32)       | 
            <summary>
            Computes the material implication c := a | ~b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.impl(System.Int64,System.Int64)         | 
            <summary>
            Computes the material implication c := a | ~b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.impl(System.UInt64,System.UInt64)       | 
            <summary>
            Computes the material implication c := a | ~b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.nor(System.SByte,System.SByte)          | 
            <summary>
            Computes the bitwise nor c := ~(a | b) for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.nor(System.Byte,System.Byte)            | 
            <summary>
            Computes the bitwise nor c := ~(a | b) for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.nor(System.Int16,System.Int16)          | 
            <summary>
            Computes the bitwise nor c := ~(a | b) for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.nor(System.UInt16,System.UInt16)        | 
            <summary>
            Computes the bitwise nor c := ~(a | b) for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.nor(System.Int32,System.Int32)          | 
            <summary>
            Computes the bitwise nor c := ~(a | b) for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.nor(System.UInt32,System.UInt32)        | 
            <summary>
            Computes the bitwise nor c := ~(a | b) for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.nor(System.Int64,System.Int64)          | 
            <summary>
            Computes the bitwise nor c := ~(a | b) for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.nor(System.UInt64,System.UInt64)        | 
            <summary>
            Computes the bitwise nor c := ~(a | b) for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.sal(System.SByte,System.Byte)           | 
            <summary>
            Shifts the source value arithmetically leftwards by a specified offset
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The offset</param>
            <typeparam name="T">The primal type</typeparam>
        
| M:Z0.math.sal(System.Byte,System.Byte)            | 
            <summary>
            Shifts the source value arithmetically leftwards by a specified offset
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The offset</param>
            <typeparam name="T">The primal type</typeparam>
        
| M:Z0.math.sal(System.Int16,System.Byte)           | 
            <summary>
            Shifts the source value arithmetically leftwards by a specified offset
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The offset</param>
            <typeparam name="T">The primal type</typeparam>
        
| M:Z0.math.sal(System.UInt16,System.Byte)          | 
            <summary>
            Shifts the source value arithmetically leftwards by a specified offset
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The offset</param>
            <typeparam name="T">The primal type</typeparam>
        
| M:Z0.math.sal(System.Int32,System.Byte)           | 
            <summary>
            Shifts the source value arithmetically leftwards by a specified offset
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The offset</param>
            <typeparam name="T">The primal type</typeparam>
        
| M:Z0.math.sal(System.UInt32,System.Byte)          | 
            <summary>
            Shifts the source value arithmetically leftwards by a specified offset
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The offset</param>
            <typeparam name="T">The primal type</typeparam>
        
| M:Z0.math.sal(System.Int64,System.Byte)           | 
            <summary>
            Shifts the source value arithmetically leftwards by a specified offset
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The offset</param>
            <typeparam name="T">The primal type</typeparam>
        
| M:Z0.math.sal(System.UInt64,System.Byte)          | 
            <summary>
            Shifts the source value arithmetically leftwards by a specified offset
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The offset</param>
            <typeparam name="T">The primal type</typeparam>
        
| M:Z0.math.sra(System.SByte,System.Byte)           | 
            <summary>
            Computes the arithmetic right shift z := src &gt;&gt; offset
            </summary>
            <param name="src">The source operand</param>
            <param name="offset">The number of bits to shift</param>
        
| M:Z0.math.sra(System.Byte,System.Byte)            | 
            <summary>
            Computes the arithmetic right shift z := src &gt;&gt; offset
            </summary>
            <param name="src">The source operand</param>
            <param name="offset">The number of bits to shift</param>
        
| M:Z0.math.sra(System.Int16,System.Byte)           | 
            <summary>
            Computes the arithmetic right shift z := src &gt;&gt; offset
            </summary>
            <param name="src">The source operand</param>
            <param name="offset">The number of bits to shift</param>
        
| M:Z0.math.sra(System.UInt16,System.Byte)          | 
            <summary>
            Computes the arithmetic right shift z := src &gt;&gt; offset
            </summary>
            <param name="src">The source operand</param>
            <param name="offset">The number of bits to shift</param>
        
| M:Z0.math.sra(System.Int32,System.Byte)           | 
            <summary>
            Computes the arithmetic right shift z := src &gt;&gt; offset
            </summary>
            <param name="src">The source operand</param>
            <param name="offset">The number of bits to shift</param>
        
| M:Z0.math.sra(System.UInt32,System.Byte)          | 
            <summary>
            Computes the arithmetic right shift z := src &gt;&gt; offset
            </summary>
            <param name="src">The source operand</param>
            <param name="offset">The number of bits to shift</param>
        
| M:Z0.math.sra(System.Int64,System.Byte)           | 
            <summary>
            Computes the arithmetic right shift z := src &gt;&gt; offset
            </summary>
            <param name="src">The source operand</param>
            <param name="offset">The number of bits to shift</param>
        
| M:Z0.math.sra(System.UInt64,System.Byte)          | 
            <summary>
            Computes the arithmetic right shift z := src &gt;&gt; offset
            </summary>
            <param name="src">The source operand</param>
            <param name="offset">The number of bits to shift</param>
        
| M:Z0.math.sll(System.SByte,System.Byte)           | 
            <summary>
            Applies a logical left shift to the source value
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The number of bits to shift leftwards</param>
        
| M:Z0.math.sll(System.Byte,System.Byte)            | 
            <summary>
            Applies a logical left shift to the source value
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The number of bits to shift leftwards</param>
        
| M:Z0.math.sll(System.Int16,System.Byte)           | 
            <summary>
            Applies a logical left shift to the source value
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The number of bits to shift leftwards</param>
        
| M:Z0.math.sll(System.UInt16,System.Byte)          | 
            <summary>
            Applies a logical left shift to the source value
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The number of bits to shift leftwards</param>
        
| M:Z0.math.sll(System.Int32,System.Byte)           | 
            <summary>
            Applies a logical left shift to the source value
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The number of bits to shift leftwards</param>
        
| M:Z0.math.sll(System.UInt32,System.Byte)          | 
            <summary>
            Applies a logical left shift to the source value
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The number of bits to shift leftwards</param>
        
| M:Z0.math.sll(System.Int64,System.Byte)           | 
            <summary>
            Applies a logical left shift to the source value
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The number of bits to shift leftwards</param>
        
| M:Z0.math.sll(System.UInt64,System.Byte)          | 
            <summary>
            Applies a logical left shift to the source value
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The number of bits to shift leftwards</param>
        
| M:Z0.math.srl(System.SByte,System.Byte)           | 
            <summary>
            Applies a logical right shift to the source value
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The number of bits to shift rightwards</param>
        
| M:Z0.math.srl(System.Byte,System.Byte)            | 
            <summary>
            Applies a logical right shift to the source value
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The number of bits to shift rightwards</param>
        
| M:Z0.math.srl(System.Int16,System.Byte)           | 
            <summary>
            Applies a logical right shift to the source value
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The number of bits to shift rightwards</param>
        
| M:Z0.math.srl(System.UInt16,System.Byte)          | 
            <summary>
            Applies a logical right shift to the source value
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The number of bits to shift rightwards</param>
        
| M:Z0.math.srl(System.Int32,System.Byte)           | 
            <summary>
            Applies a logical right shift to the source value
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The number of bits to shift rightwards</param>
        
| M:Z0.math.srl(System.UInt32,System.Byte)          | 
            <summary>
            Applies a logical right shift to the source value
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The number of bits to shift rightwards</param>
        
| M:Z0.math.srl(System.Int64,System.Byte)           | 
            <summary>
            Applies a logical right shift to the source value
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The number of bits to shift rightwards</param>
        
| M:Z0.math.srl(System.UInt64,System.Byte)          | 
            <summary>
            Applies a logical right shift to the source value
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The number of bits to shift rightwards</param>
        
| M:Z0.math.xorsr(System.Byte,System.Byte)          | 
            <summary>
            Computes a^(a &gt;&gt; offset)
            </summary>
            <param name="a">The source value</param>
            <param name="offset">The number of bits to shift the source value rightwards</param>
        
| M:Z0.math.xorsr(System.SByte,System.Byte)         | 
            <summary>
            Computes a^(a &gt;&gt; offset)
            </summary>
            <param name="a">The source value</param>
            <param name="offset">The number of bits to shift the source value rightwards</param>
        
| M:Z0.math.xorsr(System.Int16,System.Byte)         | 
            <summary>
            Computes a^(a &gt;&gt; offset)
            </summary>
            <param name="a">The source value</param>
            <param name="offset">The number of bits to shift the source value rightwards</param>
        
| M:Z0.math.xorsr(System.UInt16,System.Byte)        | 
            <summary>
            Computes a^(a &gt;&gt; offset)
            </summary>
            <param name="a">The source value</param>
            <param name="offset">The number of bits to shift the source value rightwards</param>
        
| M:Z0.math.xorsr(System.Int32,System.Byte)         | 
            <summary>
            Computes a^(a &gt;&gt; offset)
            </summary>
            <param name="a">The source value</param>
            <param name="offset">The number of bits to shift the source value rightwards</param>
        
| M:Z0.math.xorsr(System.UInt32,System.Byte)        | 
            <summary>
            Computes a^(a &gt;&gt; offset)
            </summary>
            <param name="a">The source value</param>
            <param name="offset">The number of bits to shift the source value rightwards</param>
        
| M:Z0.math.xorsr(System.Int64,System.Byte)         | 
            <summary>
            Computes a^(a &gt;&gt; offset)
            </summary>
            <param name="a">The source value</param>
            <param name="offset">The number of bits to shift the source value rightwards</param>
        
| M:Z0.math.xorsr(System.UInt64,System.Byte)        | 
            <summary>
            Computes a^(a &gt;&gt; offset)
            </summary>
            <param name="a">The source value</param>
            <param name="offset">The number of bits to shift the source value rightwards</param>
        
| M:Z0.math.eq(System.SByte,System.SByte)           | 
            <summary>
            Defines the test eq:bit := a == b, succeeding if the first operand is equal to the second
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.eq(System.Byte,System.Byte)             | 
            <summary>
            Defines the test eq:bit := a == b, succeeding if the first operand is equal to the second
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.eq(System.Int16,System.Int16)           | 
            <summary>
            Defines the test eq:bit := a == b, succeeding if the first operand is equal to the second
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.eq(System.UInt16,System.UInt16)         | 
            <summary>
            Defines the test eq:bit := a == b, succeeding if the first operand is equal to the second
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.eq(System.Int32,System.Int32)           | 
            <summary>
            Defines the test eq:bit := a == b, succeeding if the first operand is equal to the second
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.eq(System.UInt32,System.UInt32)         | 
            <summary>
            Defines the test eq:bit := a == b, succeeding if the first operand is equal to the second
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.eq(System.Int64,System.Int64)           | 
            <summary>
            Defines the test eq:bit := a == b, succeeding if the first operand is equal to the second
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.eq(System.UInt64,System.UInt64)         | 
            <summary>
            Defines the test eq:bit := a == b, succeeding if the first operand is equal to the second
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.eqb(System.SByte,System.SByte)          | 
            <summary>
            Defines a binary operator that returns 1 if the operands are equal 0 otherwise
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.eqb(System.Byte,System.Byte)            | 
            <summary>
            Defines a binary operator that returns 1 if the operands are equal 0 otherwise
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.eqb(System.Int16,System.Int16)          | 
            <summary>
            Defines a binary operator that returns 1 if the operands are equal 0 otherwise
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.eqb(System.UInt16,System.UInt16)        | 
            <summary>
            Defines a binary operator that returns 1 if the operands are equal 0 otherwise
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.eqb(System.Int32,System.Int32)          | 
            <summary>
            Defines a binary operator that returns 1 if the operands are equal 0 otherwise
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.eqb(System.UInt32,System.UInt32)        | 
            <summary>
            Defines a binary operator that returns 1 if the operands are equal 0 otherwise
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.eqb(System.Int64,System.Int64)          | 
            <summary>
            Defines a binary operator that returns 1 if the operands are equal 0 otherwise
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.eqb(System.UInt64,System.UInt64)        | 
            <summary>
            Defines a binary operator that returns 1 if the operands are equal 0 otherwise
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.eqz(System.SByte,System.SByte)          | 
            <summary>
            Defines the operator eqz(a,b) := a == b ? Min : Zero
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.eqz(System.Byte,System.Byte)            | 
            <summary>
            Defines the operator eqz(a,b) := a == b ? Min : Zero
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.eqz(System.Int16,System.Int16)          | 
            <summary>
            Defines the operator eqz(a,b) := a == b ? Min : Zero
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.eqz(System.UInt16,System.UInt16)        | 
            <summary>
            Defines the operator eqz(a,b) := a == b ? Min : Zero
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.eqz(System.Int32,System.Int32)          | 
            <summary>
            Defines the operator eqz(a,b) := a == b ? Min : Zero
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.eqz(System.UInt32,System.UInt32)        | 
            <summary>
            Defines the operator eqz(a,b) := a == b ? Min : Zero
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.eqz(System.Int64,System.Int64)          | 
            <summary>
            Defines the operator eqz(a,b) := a == b ? Min : Zero
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.eqz(System.UInt64,System.UInt64)        | 
            <summary>
            Defines the operator eqz(a,b) := a == b ? Min : Zero
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.gt(System.SByte,System.SByte)           | 
            <summary>
            Defines the test gt:bit := a &gt; b, succeeding if the left operand is larger than the right operand
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        
| M:Z0.math.gt(System.Byte,System.Byte)             | 
            <summary>
            Defines the test gt:bit := a &gt; b, succeeding if the left operand is larger than the right operand
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        
| M:Z0.math.gt(System.Int16,System.Int16)           | 
            <summary>
            Defines the test gt:bit := a &gt; b, succeeding if the left operand is larger than the right operand
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        
| M:Z0.math.gt(System.UInt16,System.UInt16)         | 
            <summary>
            Defines the test gt:bit := a &gt; b, succeeding if the left operand is larger than the right operand
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        
| M:Z0.math.gt(System.Int32,System.Int32)           | 
            <summary>
            Defines the test gt:bit := a &gt; b, succeeding if the left operand is larger than the right operand
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        
| M:Z0.math.gt(System.UInt32,System.UInt32)         | 
            <summary>
            Defines the test gt:bit := a &gt; b, succeeding if the left operand is larger than the right operand
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        
| M:Z0.math.gt(System.Int64,System.Int64)           | 
            <summary>
            Defines the test gt:bit := a &gt; b, succeeding if the left operand is larger than the right operand
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        
| M:Z0.math.gt(System.UInt64,System.UInt64)         | 
            <summary>
            Defines the test gt:bit := a &gt; b, succeeding if the left operand is larger than the right operand
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        
| M:Z0.math.gteq(System.SByte,System.SByte)         | 
            <summary>
            Defines the test gt:bit := a &gt;= b, succeeding if the first operand is larger than or equal to the second
            </summary>
            <param name="a">The first operand</param>
            <param name="a">The second operand</param>
        
| M:Z0.math.gteq(System.Byte,System.Byte)           | 
            <summary>
            Defines the test gt:bit := a &gt;= b, succeeding if the first operand is larger than or equal to the second
            </summary>
            <param name="a">The first operand</param>
            <param name="a">The second operand</param>
        
| M:Z0.math.gteq(System.Int16,System.Int16)         | 
            <summary>
            Defines the test gt:bit := a &gt;= b, succeeding if the first operand is larger than or equal to the second
            </summary>
            <param name="a">The first operand</param>
            <param name="a">The second operand</param>
        
| M:Z0.math.gteq(System.UInt16,System.UInt16)       | 
            <summary>
            Defines the test gt:bit := a &gt;= b, succeeding if the first operand is larger than or equal to the second
            </summary>
            <param name="a">The first operand</param>
            <param name="a">The second operand</param>
        
| M:Z0.math.gteq(System.Int32,System.Int32)         | 
            <summary>
            Defines the test gt:bit := a &gt;= b, succeeding if the first operand is larger than or equal to the second
            </summary>
            <param name="a">The first operand</param>
            <param name="a">The second operand</param>
        
| M:Z0.math.gteq(System.UInt32,System.UInt32)       | 
            <summary>
            Defines the test gt:bit := a &gt;= b, succeeding if the first operand is larger than or equal to the second
            </summary>
            <param name="a">The first operand</param>
            <param name="a">The second operand</param>
        
| M:Z0.math.gteq(System.Int64,System.Int64)         | 
            <summary>
            Defines the test gt:bit := a &gt;= b, succeeding if the first operand is larger than or equal to the second
            </summary>
            <param name="a">The first operand</param>
            <param name="a">The second operand</param>
        
| M:Z0.math.gteq(System.UInt64,System.UInt64)       | 
            <summary>
            Defines the test gt:bit := a &gt;= b, succeeding if the first operand is larger than or equal to the second
            </summary>
            <param name="a">The first operand</param>
            <param name="a">The second operand</param>
        
| M:Z0.math.negative(System.SByte)                  | 
            <summary>
            Returns true if the source value is less than zero, false otherwise
            </summary>
            <param name="x">The value to inspect</param>
        
| M:Z0.math.negative(System.Int16)                  | 
            <summary>
            Returns true if the source value is less than zero, false otherwise
            </summary>
            <param name="x">The value to inspect</param>
        
| M:Z0.math.negative(System.Int32)                  | 
            <summary>
            Returns true if the source value is less than zero, false otherwise
            </summary>
            <param name="x">The value to inspect</param>
        
| M:Z0.math.negative(System.Int64)                  | 
            <summary>
            Returns true if the source value is less than zero, false otherwise
            </summary>
            <param name="x">The value to inspect</param>
        
| M:Z0.math.neq(System.SByte,System.SByte)          | 
            <summary>
            Defines the test neq:bit := a != b, succeeding if the operands are not equal
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.neq(System.Byte,System.Byte)            | 
            <summary>
            Defines the test neq:bit := a != b, succeeding if the operands are not equal
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.neq(System.Int16,System.Int16)          | 
            <summary>
            Defines the test neq:bit := a != b, succeeding if the operands are not equal
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.neq(System.UInt16,System.UInt16)        | 
            <summary>
            Defines the test neq:bit := a != b, succeeding if the operands are not equal
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.neq(System.Int32,System.Int32)          | 
            <summary>
            Defines the test neq:bit := a != b, succeeding if the operands are not equal
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.neq(System.UInt32,System.UInt32)        | 
            <summary>
            Defines the test neq:bit := a != b, succeeding if the operands are not equal
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.neq(System.Int64,System.Int64)          | 
            <summary>
            Defines the test neq:bit := a != b, succeeding if the operands are not equal
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.neq(System.UInt64,System.UInt64)        | 
            <summary>
            Defines the test neq:bit := a != b, succeeding if the operands are not equal
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        
| M:Z0.math.nonz(System.SByte,System.SByte)         | 
            <summary>
            Defines the operator nonz(src,alt) := nonz(src) ? alt : src, returning the alternate 
            value if the nonz test succeeds and the source value otherwise
            </summary>
            <param name="src">The test value</param>
            <param name="alt">The alternative value to return if the test succeeds</param>
        
| M:Z0.math.nonz(System.Byte,System.Byte)           | 
            <summary>
            Defines the operator nonz(src,alt) := nonz(src) ? alt : src, returning the alternate 
            value if the nonz test succeeds and the source value otherwise
            </summary>
            <param name="src">The test value</param>
            <param name="alt">The alternative value to return if the test succeeds</param>
        
| M:Z0.math.nonz(System.Int16,System.Int16)         | 
            <summary>
            Defines the operator nonz(src,alt) := nonz(src) ? alt : src, returning the alternate 
            value if the nonz test succeeds and the source value otherwise
            </summary>
            <param name="src">The test value</param>
            <param name="alt">The alternative value to return if the test succeeds</param>
        
| M:Z0.math.nonz(System.UInt16,System.UInt16)       | 
            <summary>
            Defines the operator nonz(src,alt) := nonz(src) ? alt : src, returning the alternate 
            value if the nonz test succeeds and the source value otherwise
            </summary>
            <param name="src">The test value</param>
            <param name="alt">The alternative value to return if the test succeeds</param>
        
| M:Z0.math.nonz(System.Int32,System.Int32)         | 
            <summary>
            Defines the operator nonz(src,alt) := nonz(src) ? alt : src, returning the alternate 
            value if the nonz test succeeds and the source value otherwise
            </summary>
            <param name="src">The test value</param>
            <param name="alt">The alternative value to return if the test succeeds</param>
        
| M:Z0.math.nonz(System.UInt32,System.UInt32)       | 
            <summary>
            Defines the operator nonz(src,alt) := nonz(src) ? alt : src, returning the alternate 
            value if the nonz test succeeds and the source value otherwise
            </summary>
            <param name="src">The test value</param>
            <param name="alt">The alternative value to return if the test succeeds</param>
        
| M:Z0.math.nonz(System.Int64,System.Int64)         | 
            <summary>
            Defines the operator nonz(src,alt) := nonz(src) ? alt : src, returning the alternate 
            value if the nonz test succeeds and the source value otherwise
            </summary>
            <param name="src">The test value</param>
            <param name="alt">The alternative value to return if the test succeeds</param>
        
| M:Z0.math.nonz(System.UInt64,System.UInt64)       | 
            <summary>
            Defines the operator nonz(src,alt) := nonz(src) ? alt : src, returning the alternate 
            value if the nonz test succeeds and the source value otherwise
            </summary>
            <param name="src">The test value</param>
            <param name="alt">The alternative value to return if the test succeeds</param>
        
| M:Z0.math.nonz(System.SByte)                      | 
            <summary>
            Defines the test nonz:bit := src != 0, succeeding if the source operand is nonzero
            </summary>
            <param name="src">The value to test</param>
        
| M:Z0.math.nonz(System.Byte)                       | 
            <summary>
            Defines the test nonz:bit := src != 0, succeeding if the source operand is nonzero
            </summary>
            <param name="src">The value to test</param>
        
| M:Z0.math.nonz(System.Int16)                      | 
            <summary>
            Defines the test nonz:bit := src != 0, succeeding if the source operand is nonzero
            </summary>
            <param name="src">The value to test</param>
        
| M:Z0.math.nonz(System.UInt16)                     | 
            <summary>
            Defines the test nonz:bit := src != 0, succeeding if the source operand is nonzero
            </summary>
            <param name="src">The value to test</param>
        
| M:Z0.math.nonz(System.Int32)                      | 
            <summary>
            Defines the test nonz:bit := src != 0, succeeding if the source operand is nonzero
            </summary>
            <param name="src">The value to test</param>
        
| M:Z0.math.nonz(System.UInt32)                     | 
            <summary>
            Defines the test nonz:bit := src != 0, succeeding if the source operand is nonzero
            </summary>
            <param name="src">The value to test</param>
        
| M:Z0.math.nonz(System.Int64)                      | 
            <summary>
            Defines the test nonz:bit := src != 0, succeeding if the source operand is nonzero
            </summary>
            <param name="src">The value to test</param>
        
| M:Z0.math.nonz(System.UInt64)                     | 
            <summary>
            Defines the test nonz:bit := src != 0, succeeding if the source operand is nonzero
            </summary>
            <param name="src">The value to test</param>
        
| M:Z0.math.positive(System.SByte)                  | 
            <summary>
            Returns true if the source value is greater than zero, false otherwise
            </summary>
            <param name="a">The value to inspect</param>
        
| M:Z0.math.positive(System.Byte)                   | 
            <summary>
            Returns true if the source value is greater than zero, false otherwise
            </summary>
            <param name="a">The value to inspect</param>
        
| M:Z0.math.positive(System.Int16)                  | 
            <summary>
            Returns true if the source value is greater than zero, false otherwise
            </summary>
            <param name="a">The value to inspect</param>
        
| M:Z0.math.positive(System.UInt16)                 | 
            <summary>
            Returns true if the source value is greater than zero, false otherwise
            </summary>
            <param name="a">The value to inspect</param>
        
| M:Z0.math.positive(System.Int32)                  | 
            <summary>
            Returns true if the source value is greater than zero, false otherwise
            </summary>
            <param name="a">The value to inspect</param>
        
| M:Z0.math.positive(System.UInt32)                 | 
            <summary>
            Returns true if the source value is greater than zero, false otherwise
            </summary>
            <param name="a">The value to inspect</param>
        
| M:Z0.math.positive(System.Int64)                  | 
            <summary>
            Returns true if the source value is greater than zero, false otherwise
            </summary>
            <param name="a">The value to inspect</param>
        
| M:Z0.math.positive(System.UInt64)                 | 
            <summary>
            Returns true if the source value is greater than zero, false otherwise
            </summary>
            <param name="a">The value to inspect</param>
        
| F:Z0.FpErrorMode.Raise                            | 
            <summary>
            Raise exceptions upon error
            </summary>
        
| F:Z0.FpErrorMode.Suppress                         | 
            <summary>
            Suppress exceptions upon error
            </summary>
        
| F:Z0.FpRoundDir.Default                           | 
            <summary>
            _MM_FROUND_TO_NEAREST_INT, the default mode effects rounding to the nearest integer
            </summary>
        
| F:Z0.FpRoundDir.NegInf                            | 
            <summary>
            _MM_FROUND_TO_NEG_INF, Round toward negative infinity
            </summary>
        
| F:Z0.FpRoundDir.PosInf                            | 
            <summary>
            _MM_FROUND_TO_POS_INF, Round toward positive infinity
            </summary>
        
| F:Z0.FpRoundDir.Zero                              | 
            <summary>
            _MM_FROUND_TO_ZERO, round toward 0
            </summary>
        
| F:Z0.FpRoundDir.Current                           | 
            <summary>
            _MM_FROUND_CUR_DIRECTION, round toward the current direction as specified by __MM_SET_ROUNDING_MODE
            </summary>
        
| F:Z0.FpRoundDir.Ceil                              | 
            <summary>
            _MM_FROUND_CEIL, round toward positive infinity and do not suppress exceptions
            </summary>
        
| F:Z0.FpRoundDir.Floor                             | 
            <summary>
            _MM_FROUND_FLOOR, round toward negative infinity and do not suppress exceptions
            </summary>
        
| F:Z0.FpRoundDir.Trunc                             | 
            <summary>
            _MM_FROUND_TRUNC, Round toward zero and do not supress exceptions
            </summary>
        
| F:Z0.FpRoundDir.Nearby                            | 
            <summary>
            _MM_FROUND_NEARBYINT, round toward the current direction and suppress exceptions
            </summary>
        
| T:Z0.FpCmpMode                                    | 
            <summary>
            Floating point comparison mode
            </summary>
        
| F:Z0.FpCmpMode.EQ_OQ                              | 
            <summary>
            0: ordered, equal, non-signaling
            </summary>
        
| F:Z0.FpCmpMode.OrderedEqualNonSignaling           | 
            <summary>
            Overly-verbose alias for EQ_OQ
            </summary>
        
| F:Z0.FpCmpMode.LT_OS                              | 
            <summary>
            1: ordered, less than, signaling
            </summary>
        
| F:Z0.FpCmpMode.OrderedLessThanSignaling           | 
            <summary>
            Overly-verbose alias for LT_OS
            </summary>
        
| F:Z0.FpCmpMode.LE_OS                              | 
            <summary>
            2: ordered, less than or equal, signaling
            </summary>
        
| F:Z0.FpCmpMode.OrderedLessThanOrEqualSignaling    | 
            <summary>
            Overly-verbose alias for LE_OS
            </summary>
        
| F:Z0.FpCmpMode.UNORD_Q                            | 
            <summary>
            3: unordered, non-signaling
            </summary>
        
| F:Z0.FpCmpMode.UnorderedNonSignaling              | 
            <summary>
            Overly-verbose alias for UNORD_Q
            </summary>
        
| F:Z0.FpCmpMode.NEQ_UQ                             | 
            <summary>
            4: unordered, not equal, non-signaling
            </summary>
        
| F:Z0.FpCmpMode.UnorderedNotEqualNonSignaling      | 
            <summary>
            Overly-verbose alias for NEQ_UQ
            </summary>
        
| F:Z0.FpCmpMode.NLT_US                             | 
            <summary>
            5: unordered, not less than, signaling
            </summary>
        
| F:Z0.FpCmpMode.UnorderedNotLessThanSignaling      | 
            <summary>
            Overly-verbose alias for NLT_US
            </summary>
        
| F:Z0.FpCmpMode.NLE_US                             | 
            <summary>
            6: unordered, not less than or equal, signaling
            </summary>
        
| F:Z0.FpCmpMode.UnorderedNotLessThanOrEqualSignaling| 
            <summary>
            Ridiculously verbose alias for NLE_US
            </summary>
        
| F:Z0.FpCmpMode.ORD_Q                              | 
            <summary>
            7: ordered, non-signaling
            </summary>
        
| F:Z0.FpCmpMode.OrderedNonSignaling                | 
            <summary>
            Overly-verbose alias for ORD_Q
            </summary>
        
| F:Z0.FpCmpMode.EQ_UQ                              | 
            <summary>
            8: unordered, equal, non-signaling
            </summary>
        
| F:Z0.FpCmpMode.UnorderedEqualNonSignaling         | 
            <summary>
            Overly-verbose alias for EQ_UQ
            </summary>
        
| F:Z0.FpCmpMode.NGE_US                             | 
            <summary>
            9: unordered, not greater than or equal, signaling
            </summary>
        
| F:Z0.FpCmpMode.UnorderedNotGreaterThanOrEqualSignaling| 
            <summary>
            Ridiculously verbose alias for NGE_US
            </summary>
        
| F:Z0.FpCmpMode.NGT_US                             | 
            <summary>
            9:unordered, not greater than, signaling
            </summary>
        
| F:Z0.FpCmpMode.UnorderedNotGreaterThanSignaling   | 
            <summary>
            Ridiculously verbose alias for NGT_US
            </summary>
        
| F:Z0.FpCmpMode.FALSE_OQ                           | 
            <summary>
            10: ordered, false, non-signaling
            </summary>
        
| F:Z0.FpCmpMode.OrderedFalseNonSignaling           | 
            <summary>
            Overly-verbose alias for FALSE_OQ
            </summary>
        
| F:Z0.FpCmpMode.NEQ_OQ                             | 
            <summary>
            12: ordered, not equal, non-signaling
            </summary>
        
| F:Z0.FpCmpMode.OrderedNotEqualNonSignaling        | 
            <summary>
            Overly-verbose alias for NGT_US
            </summary>
        
| F:Z0.FpCmpMode.GE_OS                              | 
            <summary>
            13: ordered, greater than or equal, signaling
            </summary>
        
| F:Z0.FpCmpMode.OrderedGreaterThanOrEqualSignaling | 
            <summary>
            Ridiculously verbose alias for GE_OS
            </summary>
        
| F:Z0.FpCmpMode.GT_OS                              | 
            <summary>
            14: ordered, greater than, signaling
            </summary>
        
| F:Z0.FpCmpMode.OrderedGreaterThanSignaling        | 
            <summary>
            Overly-verbose alias for GT_OS
            </summary>
        
| F:Z0.FpCmpMode.TRUE_UQ                            | 
            <summary>
            15: unordered, true, non-signaling
            </summary>
        
| F:Z0.FpCmpMode.UnorderedTrueNonSignaling          | 
            <summary>
            Overly-verbose alias for TRUE_UQ
            </summary>
        
| F:Z0.FpCmpMode.EQ_OS                              | 
            <summary>
            16: ordered, equal, signaling
            </summary>
        
| F:Z0.FpCmpMode.OrderedEqualSignaling              | 
            <summary>
            Overly-verbose alias for EQ_OS
            </summary>
        
| F:Z0.FpCmpMode.LT_OQ                              | 
            <summary>
            17: ordered, less than, non-signaling
            </summary>
        
| F:Z0.FpCmpMode.OrderedLessThanNonSignaling        | 
            <summary>
            Overly-verbose alias for LT_OQ
            </summary>
        
| F:Z0.FpCmpMode.LE_OQ                              | 
            <summary>
            18: ordered, less than or equal, non-signaling
            </summary>
        
| F:Z0.FpCmpMode.OrderedLessThanOrEqualNonSignaling | 
            <summary>
            Ridiculously verbose alias for LE_OQ
            </summary>
        
| F:Z0.FpCmpMode.UNORD_S                            | 
            <summary>
            19: unordered, signaling
            </summary>
        
| F:Z0.FpCmpMode.UnorderedSignaling                 | 
            <summary>
            Overly-verbose alias for LE_OQ
            </summary>
        
| F:Z0.FpCmpMode.NEQ_US                             | 
            <summary>
            20: unordered, not equal, signaling
            </summary>
        
| F:Z0.FpCmpMode.UnorderedNotEqualSignaling         | 
            <summary>
            Overly-verbose alias for NEQ_US
            </summary>
        
| F:Z0.FpCmpMode.NLT_UQ                             | 
            <summary>
            21: unordered, not less, non-signaling
            </summary>
        
| F:Z0.FpCmpMode.UnorderedNotLessThanNonSignaling   | 
            <summary>
            Ridicuously verbose alias for NLT_UQ
            </summary>
        
| F:Z0.FpCmpMode.NLE_UQ                             | 
            <summary>
            22: unordered, not less than or equal, non-signaling
            </summary>
        
| F:Z0.FpCmpMode.UnorderedNotLessThanOrEqualNonSignaling| 
            <summary>
            Ridiculously verbose alias for NLE_UQ
            </summary>
        
| F:Z0.FpCmpMode.ORD_S                              | 
            <summary>
            23: ordered, signaling
            </summary>
        
| F:Z0.FpCmpMode.OrderedSignaling                   | 
            <summary>
            Overly-verbose alias for ORD_S
            </summary>
        
| F:Z0.FpCmpMode.EQ_US                              | 
            <summary>
            24: unordered,equal, signaling
            </summary>
        
| F:Z0.FpCmpMode.UnorderedEqualSignaling            | 
            <summary>
            Overly-verbose alias for EQ_US
            </summary>
        
| F:Z0.FpCmpMode.NGE_UQ                             | 
            <summary>
            25: unordered, not greater than or equan, non-signaling
            </summary>
        
| F:Z0.FpCmpMode.UnorderedNotGreaterThanOrEqualNonSignaling| 
            <summary>
            Infuriatingly verbose alias for NGE_UQ
            </summary>
        
| F:Z0.FpCmpMode.NGT_UQ                             | 
            <summary>
            26: unordered, not greater than, non-signaling
            </summary>
        
| F:Z0.FpCmpMode.UnorderedNotGreaterThanNonSignaling| 
            <summary>
            Infuriatingly verbose alias for NGT_UQ
            </summary>
        
| F:Z0.FpCmpMode.FALSE_OS                           | 
            <summary>
            27: ordered, false, signaling
            </summary>
        
| F:Z0.FpCmpMode.OrderedFalseSignaling              | 
            <summary>
            Overly-verbose alias for FALSE_OS
            </summary>
        
| F:Z0.FpCmpMode.NEQ_OS                             | 
            <summary>
            28: ordered, not equal, signaling
            </summary>
        
| F:Z0.FpCmpMode.OrderedNotEqualSignaling           | 
            <summary>
            Overly-verbose alias for NEQ_OS
            </summary>
        
| F:Z0.FpCmpMode.GE_OQ                              | 
            <summary>
            29: ordered, greater than or equal, non-signaling
            </summary>
        
| F:Z0.FpCmpMode.OrderedGreaterThanOrEqualNonSignaling| 
            <summary>
            Infuriatingly verbose alias for LE_OQ
            </summary>
        
| F:Z0.FpCmpMode.GT_OQ                              | 
            <summary>
            30: ordered, greater than, non-signaling
            </summary>
        
| F:Z0.FpCmpMode.OrderedGreaterThanNonSignaling     | 
            <summary>
            Overly-verbose alias for GT_OQ
            </summary>
        
| F:Z0.FpCmpMode.TRUE_US                            | 
            <summary>
            31: ordered, true, signaling
            </summary>
        
| F:Z0.FpCmpMode.UnorderedTrueSignaling             | 
            <summary>
            Overly-verbose alias for TRUE_US
            </summary>
        
| T:Z0.fmath                                        | 
            <summary>
            Defines floating-point operations
            </summary>
        
| M:Z0.fmath.abs(System.Single)                     | 
            <summary>
            Computes the absolute value of the source
            </summary>
            <param name="a">The source value</param>
        
| M:Z0.fmath.abs(System.Double)                     | 
            <summary>
            Computes the absolute value of the source
            </summary>
            <param name="a">The source value</param>
        
| M:Z0.fmath.dec(System.Single)                     | 
            <summary>
            Decrements the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.fmath.dec(System.Double)                     | 
            <summary>
            Decrements the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.fmath.inc(System.Single)                     | 
            <summary>
            Increments the operand
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.fmath.inc(System.Double)                     | 
            <summary>
            Increments the operand
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.fmath.negate(System.Single)                  | 
            <summary>
            Negates the operand
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.fmath.negate(System.Double)                  | 
            <summary>
            Negates the operand
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.fmath.add(System.Single,System.Single)       | 
            <summary>
            Computes the arithmetic sum of the source operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        
| M:Z0.fmath.add(System.Double,System.Double)       | 
            <summary>
            Computes the arithmetic sum of the source operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        
| M:Z0.fmath.sub(System.Single,System.Single)       | 
            <summary>
            Computes the arithmetic difference between the first operand and the second
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        
| M:Z0.fmath.sub(System.Double,System.Double)       | 
            <summary>
            Computes the arithmetic difference between the first operand and the second
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        
| M:Z0.fmath.mul(System.Single,System.Single)       | 
            <summary>
            Computes the arithmetic product of the operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        
| M:Z0.fmath.mul(System.Double,System.Double)       | 
            <summary>
            Computes the arithmetic product of the operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        
| M:Z0.fmath.div(System.Single,System.Single)       | 
            <summary>
            Computes the arithmetic quotient of the first operand over the second
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        
| M:Z0.fmath.div(System.Double,System.Double)       | 
            <summary>
            Computes the arithmetic quotient of the first operand over the second
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        
| M:Z0.fmath.mod(System.Single,System.Single)       | 
            <summary>
            Computes the modulus of the first operand over the second
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        
| M:Z0.fmath.mod(System.Double,System.Double)       | 
            <summary>
            Computes the modulus of the first operand over the second
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        
| M:Z0.fmath.modmul(System.Single,System.Single,System.Single)| 
            <summary>
            Computes z := (a*b) mod m
            </summary>
            <param name="a">The first factor</param>
            <param name="b">The second factor</param>
            <param name="m">The modulus</param>
        
| M:Z0.fmath.modmul(System.Double,System.Double,System.Double)| 
            <summary>
            Computes z := (a*b) mod m
            </summary>
            <param name="a">The first factor</param>
            <param name="b">The second factor</param>
            <param name="m">The modulus</param>
        
| M:Z0.fmath.divmod(System.Single,System.Single)    | 
            <summary>
            Computes dst = (div(a,b), mod(a,b))
            </summary>
            <param name="a">The dividend</param>
            <param name="b">The divisor</param>
        
| M:Z0.fmath.divmod(System.Double,System.Double)    | 
            <summary>
            Computes dst = (div(a,b), mod(a,b))
            </summary>
            <param name="a">The dividend</param>
            <param name="b">The divisor</param>
        
| M:Z0.fmath.ceil(System.Single)                    | 
            <summary>
            Computes the smallest integral value greater than or equal to the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.fmath.ceil(System.Double)                    | 
            <summary>
            Computes the smallest integral value greater than or equal to the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.fmath.floor(System.Single)                   | 
            <summary>
            Computes the largest integral value less than or equal to the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.fmath.floor(System.Double)                   | 
            <summary>
            Computes the largest integral value less than or equal to the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.fmath.clamp(System.Single,System.Single)     | 
            <summary>
            Clamps the source value to an inclusive maximum
            </summary>
            <param name="src">The source value</param>
            <param name="max">The maximum value</param>
        
| M:Z0.fmath.clamp(System.Double,System.Double)     | 
            <summary>
            Clamps the source value to an inclusive maximum
            </summary>
            <param name="src">The source value</param>
            <param name="max">The maximum value</param>
        
| M:Z0.fmath.dist(System.Single,System.Single)      | 
            <summary>
            Computes the nonnegative distance between two values
            </summary>
            <param name="a">The first number</param>
            <param name="b">The second number</param>
        
| M:Z0.fmath.dist(System.Double,System.Double)      | 
            <summary>
            Computes the nonnegative distance between two values
            </summary>
            <param name="a">The first number</param>
            <param name="b">The second number</param>
        
| M:Z0.fmath.fmod(System.Single,System.Single)      | 
            <summary>
            Computes the remainder of the quotient of the operands
            </summary>
            <param name="a">The dividend</param>
            <param name="b">The divisor</param>
        
| M:Z0.fmath.fmod(System.Double,System.Double)      | 
            <summary>
            Computes the remainder of the quotient of the operands
            </summary>
            <param name="a">The dividend</param>
            <param name="b">The divisor</param>
        
| M:Z0.fmath.signum(System.Single)                  | 
            <summary>
            Computes the sign of the operand
            </summary>
            <param name="src">The operand</param>
        
| M:Z0.fmath.signum(System.Double)                  | 
            <summary>
            Computes the sign of the operand
            </summary>
            <param name="src">The operand</param>
        
| M:Z0.fmath.sqrt(System.Single)                    | 
            <summary>
            Computes the square root of the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.fmath.sqrt(System.Double)                    | 
            <summary>
            Computes the square root of the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.fmath.positive(System.Single)                | 
            <summary>
            Returns true if the source value is greater than zero, false otherwise
            </summary>
            <param name="a">The value to inspect</param>
        
| M:Z0.fmath.positive(System.Double)                | 
            <summary>
            Returns true if the source value is greater than zero, false otherwise
            </summary>
            <param name="a">The value to inspect</param>
        
| M:Z0.fmath.negative(System.Single)                | 
            <summary>
            Returns true if the source value is less than zero, false otherwise
            </summary>
            <param name="x">The value to inspect</param>
        
| M:Z0.fmath.negative(System.Double)                | 
            <summary>
            Returns true if the source value is less than zero, false otherwise
            </summary>
            <param name="x">The value to inspect</param>
        
| M:Z0.fmath.between(System.Single,System.Single,System.Single)| 
            <summary>
            Returns true if the the test value lies in the closed interval formed by lower and upper bounds
            </summary>
            <param name="x">The test value</param>
            <param name="a">The lower bound</param>
            <param name="b">The uppper bound</param>
        
| M:Z0.fmath.between(System.Double,System.Double,System.Double)| 
            <summary>
            Returns true if the the test value lies in the closed interval formed by lower and upper bounds
            </summary>
            <param name="x">The test value</param>
            <param name="a">The lower bound</param>
            <param name="b">The uppper bound</param>
        
| M:Z0.fmath.cbrt(System.Single)                    | 
            <summary>
            Computes the cube root of the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.fmath.cbrt(System.Double)                    | 
            <summary>
            Computes the cube root of the source value
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.fmath.exp(System.Single)                     | 
            <summary>
            Raises e to a specified exponent
            </summary>
            <param name="pow">The exponent</param>
        
| M:Z0.fmath.exp(System.Double)                     | 
            <summary>
            Raises e to a specified exponent
            </summary>
            <param name="pow">The exponent</param>
        
| M:Z0.fmath.relerr(System.Single,System.Single)    | 
            <summary>
            Computes the relative error between a one floating-point calculation and another
            </summary>
            <param name="lhs">The result of the first calculation</param>
            <param name="rhs">The result of the second calculation</param>
        
| M:Z0.fmath.relerr(System.Double,System.Double)    | 
            <summary>
            Computes the relative error between a one floating-point calculation and another
            </summary>
            <param name="lhs">The result of the first calculation</param>
            <param name="rhs">The result of the second calculation</param>
        
| M:Z0.fmath.fcsum(System.Double@,System.Double@,System.Double@)| 
            <summary>
            Impelements compensated floating-point summation
            </summary>
            <param name="src">The value to add to the total</param>
            <param name="delta">The last compensation amount</param>
            <param name="total">The running total</param>
            <remarks>See https://en.wikipedia.org/wiki/Kahan_summation_algorithm</remarks>
        
| M:Z0.fmath.log2(System.Single)                    | 
            <summary>
            Computes the base-2 log of the operand
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.fmath.log2(System.Double)                    | 
            <summary>
            Computes the base-2 log of the operand
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.fmath.ln(System.Single)                      | 
            <summary>
            Computes the base-e log of the operand
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.fmath.ln(System.Double)                      | 
            <summary>
            Computes the base-e log of the operand
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.fmath.log(System.Single,System.Nullable{System.Single})| 
            <summary>
            Computes the log of the source value relative to an optionally-specified base
            which otherwise defaults to base-10
            </summary>
            <param name="src">The source value</param>
            <param name="b">The log base</param>
        
| M:Z0.fmath.log(System.Double,System.Nullable{System.Double})| 
            <summary>
            Computes the log of the source value relative to an optionally-specified base
            which otherwise defaults to base-10
            </summary>
            <param name="src">The source value</param>
            <param name="b">The log base</param>
        
| M:Z0.fmathx.IsNaN(System.Single)                  | 
            <summary>
            Returns true if a value is the NaN representative
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.fmathx.IsNaN(System.Double)                  | 
            <summary>
            Returns true if a value is the NaN representative
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.fmathx.Infinite(System.Single)               | 
            <summary>
            Returns true if a floating point value represents an infinite value, false otherwise
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.fmathx.Infinite(System.Double)               | 
            <summary>
            Returns true if a floating point value represents an infinite value, false otherwise
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.fmathx.Finite(System.Single)                 | 
            <summary>
            Returns true if a floating point value is non-infinite
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.fmathx.Finite(System.Double)                 | 
            <summary>
            Returns true if a floating point value is non-infinite
            </summary>
            <param name="src">The source value</param>
        
| M:Z0.BmiMul.lo_ref(System.UInt64,System.UInt64)   | 
            <summary>
            Computes the lo part of the full 128-bit product of two unsigned 64-bit integers
            </summary>
            <param name="a">The first integer</param>
            <param name="b">The second integer</param>
        
| M:Z0.BmiMul.mul(System.UInt32,System.UInt32)      | 
            <summary>
            Computes the unsigned 64-bit product of two unsigned 32-bit integers
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        
| P:Z0.ScalarPairs.Zero                             | 
            <summary>
            Zero, the the one and only.
            </summary>
        
| P:Z0.ScalarPairs.One                              | 
            <summary>
            One, just.
            </summary>
        
| P:Z0.ScalarPairs.Ones                             | 
            <summary>
            One, so many
            </summary>
        
| M:Z0.ScalarPairs.not(Z0.ConstPair{System.UInt64}@)| 
            <summary>
            Computes the bitwise complement of a 128-bit integer
            </summary>
            <param name="x">The integer, represented via paired hi/lo components</param>
        
| M:Z0.ScalarPairs.and(Z0.ConstPair{System.UInt64}@,Z0.ConstPair{System.UInt64}@)| 
            <summary>
            Computes the bitwise AND of two 128-bit integers
            </summary>
            <param name="x">The first integer, represented via paired hi/lo components</param>
            <param name="y">The second integer, represented via paired hi/lo components</param>
        
| M:Z0.ScalarPairs.nand(Z0.ConstPair{System.UInt64}@,Z0.ConstPair{System.UInt64}@)| 
            <summary>
            Computes the bitwise NAND of two 128-bit integers
            </summary>
            <param name="x">The first integer, represented via paired hi/lo components</param>
            <param name="y">The second integer, represented via paired hi/lo components</param>
        
| M:Z0.ScalarPairs.or(Z0.ConstPair{System.UInt64}@,Z0.ConstPair{System.UInt64}@)| 
            <summary>
            Computes the bitwise OR of two 128-bit integers
            </summary>
            <param name="x">The first integer, represented via paired hi/lo components</param>
            <param name="y">The second integer, represented via paired hi/lo components</param>
        
| M:Z0.ScalarPairs.nor(Z0.ConstPair{System.UInt64}@,Z0.ConstPair{System.UInt64}@)| 
            <summary>
            Computes the bitwise NOR of two 128-bit integers
            </summary>
            <param name="x">The first integer, represented via paired hi/lo components</param>
            <param name="y">The second integer, represented via paired hi/lo components</param>
        
| M:Z0.ScalarPairs.xor(Z0.ConstPair{System.UInt64}@,Z0.ConstPair{System.UInt64}@)| 
            <summary>
            Computes the bitwise XOR of two 128-bit integers
            </summary>
            <param name="x">The first integer, represented via paired hi/lo components</param>
            <param name="y">The second integer, represented via paired hi/lo components</param>
        
| M:Z0.ScalarPairs.xnor(Z0.ConstPair{System.UInt64}@,Z0.ConstPair{System.UInt64}@)| 
            <summary>
            Computes the bitwise XNOR of two 128-bit integers
            </summary>
            <param name="x">The first integer, represented via paired hi/lo components</param>
            <param name="y">The second integer, represented via paired hi/lo components</param>
        
| M:Z0.ScalarPairs.same(Z0.ConstPair{System.UInt64}@,Z0.ConstPair{System.UInt64}@)| 
            <summary>
            Determines whether the left and right operands define the same value
            </summary>
            <param name="x">The first integer, represented via paired hi/lo components</param>
            <param name="y">The second integer, represented via paired hi/lo components</param>
        
| M:Z0.ScalarPairs.lt(Z0.ConstPair{System.UInt64}@,Z0.ConstPair{System.UInt64}@)| 
            <summary>
            Determines whether the left operand is less than the right operand
            </summary>
            <param name="x">The first integer, represented via paired hi/lo components</param>
            <param name="y">The second integer, represented via paired hi/lo components</param>
            <remarks>Follows https://github.com/chfast/intx/include/intx/int128.hpp</remarks>
        
| M:Z0.ScalarPairs.lteq(Z0.ConstPair{System.UInt64}@,Z0.ConstPair{System.UInt64}@)| 
            <summary>
            Determines whether the left operand is less than or equal the right operand
            </summary>
            <param name="x">The first integer, represented via paired hi/lo components</param>
            <param name="y">The second integer, represented via paired hi/lo components</param>
            <remarks>Follows https://github.com/chfast/intx/include/intx/int128.hpp</remarks>
        
| M:Z0.ScalarPairs.gt(Z0.ConstPair{System.UInt64}@,Z0.ConstPair{System.UInt64}@)| 
            <summary>
            Determines whether the left operand is greater than the right operand
            </summary>
            <param name="x">The first integer, represented via paired hi/lo components</param>
            <param name="y">The second integer, represented via paired hi/lo components</param>
            <remarks>Follows https://github.com/chfast/intx/include/intx/int128.hpp</remarks>
        
| M:Z0.ScalarPairs.gteq(Z0.ConstPair{System.UInt64}@,Z0.ConstPair{System.UInt64}@)| 
            <summary>
            Determines whether the left operand is greater than or equal the right operand
            </summary>
            <param name="x">The first integer, represented via paired hi/lo components</param>
            <param name="y">The second integer, represented via paired hi/lo components</param>
            <remarks>Follows https://github.com/chfast/intx/include/intx/int128.hpp</remarks>
        
| M:Z0.ScalarPairs.add(Z0.ConstPair{System.UInt64}@,Z0.ConstPair{System.UInt64}@)| 
            <summary>
            Computes the sum of two 128-bit integers
            </summary>
            <param name="x">The first integer, represented via paired hi/lo components</param>
            <param name="y">The second integer, represented via paired hi/lo components</param>
            <remarks>Follows https://github.com/chfast/intx/include/intx/int128.hpp</remarks>
        
| M:Z0.ScalarPairs.add(System.UInt64@,System.UInt64@,System.UInt64@)| 
            <summary>
            Computes the sum c := a + b of 128-bit unsigned integers a and b
            </summary>
            <param name="a">A reference to the left 128-bits</param>
            <param name="b">A reference to the right 128-bits</param>
            <param name="c">A reference to the target 128-bits</param>
            <remarks>Follows https://github.com/chfast/intx/include/intx/int128.hpp</remarks>
        
| M:Z0.ScalarPairs.sub(Z0.ConstPair{System.UInt64}@,Z0.ConstPair{System.UInt64}@)| 
            <summary>
            Computes the difference of two 128-bit integers
            </summary>
            <param name="x">The first integer, represented via paired hi/lo components</param>
            <param name="y">The second integer, represented via paired hi/lo components</param>
            <remarks>Follows https://github.com/chfast/intx/include/intx/int128.hpp</remarks>
        
| M:Z0.ScalarPairs.sub(System.UInt64@,System.UInt64@,System.UInt64@)| 
            <summary>
            Computes the difference c := a - b between 128-bit unsigned integers a and b
            </summary>
            <param name="a">A reference to the left 128-bits</param>
            <param name="b">A reference to the right 128-bits</param>
            <param name="c">A reference to the target 128-bits</param>
            <remarks>Follows https://github.com/chfast/intx/include/intx/int128.hpp</remarks>
        
| M:Z0.ScalarPairs.negate(Z0.ConstPair{System.UInt64})| 
            <summary>
            Computes the two's complement of a 128-bit integer
            </summary>
            <param name="x">The integer, represented via paired hi/lo components</param>
        
| M:Z0.ScalarPairs.sll(Z0.ConstPair{System.UInt64}@,System.Byte)| 
            <summary>
            Shifts the source integer leftwards
            </summary>
            <param name="x">The integer, represented via paired hi/lo components</param>
            <param name="offset">The number of bits to shift letward</param>
            <remarks>Follows https://github.com/chfast/intx/include/intx/int128.hpp</remarks>
        
| M:Z0.ScalarPairs.srl(Z0.ConstPair{System.UInt64}@,System.Byte)| 
            <summary>
            Shifts the source integer leftwards
            </summary>
            <param name="x">The integer, represented via paired hi/lo components</param>
            <param name="offset">The number of bits to shift letward</param>
            <remarks>Follows https://github.com/chfast/intx/include/intx/int128.hpp</remarks>
        
| M:Z0.ScalarPairs.mul_ref(System.UInt64,System.UInt64)| 
            <summary>
            64x64 -&gt; 128 multiplication, reference implementation
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns>
            Taken from https://github.com/chfast/intx/blob/master/include/intx/int128.hpp
            </returns>
        
| M:Z0.ScalarPairs.lo_ref(System.UInt64,System.UInt64)| 
            <summary>
            Computes the lo part of the full 128-bit product of two unsigned 64-bit integers
            </summary>
            <param name="a">The first integer</param>
            <param name="b">The second integer</param>
        
| M:Z0.ScalarPairs.mul(System.UInt32,System.UInt32) | 
            <summary>
            Computes the unsigned 64-bit product of two unsigned 32-bit integers
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        
| M:Z0.ScalarPairs.add(System.UInt64@,System.UInt64@,System.UInt64)| 
            <summary>
            Add src to the 128 bits contained in dst. Ignores overflow, that is, the addition is done modulo 2^128.
            </summary>
            <remarks>Taken from IntUtils.cs / Microsoft Machine Learning repository</remarks>
        
| M:Z0.ScalarPairs.add(System.UInt64@,System.UInt64@,System.UInt64,System.UInt64)| 
            <summary>
            Add src to dst. Ignores overflow, that is, the addition is done modulo 2^128.
            </summary>
            <remarks>Taken from IntUtils.cs / Microsoft Machine Learning repository</remarks>
        
| M:Z0.ScalarPairs.sub(System.UInt64@,System.UInt64@,System.UInt64)| 
            <summary>
            Subtract src from the 128 bits contained in dst. Ignores overflow, that is, the subtraction is
            done modulo 2^128.
            </summary>
            <remarks>Taken from IntUtils.cs / Microsoft Machine Learning repository</remarks>
        
| M:Z0.ScalarPairs.sub(System.UInt64,System.UInt64,System.UInt64@,System.UInt64@)| 
            <summary>
            Subtract src from dst. Ignores overflow, that is, the subtraction is done modulo 2^128.
            </summary>
            <remarks>Taken from IntUtils.cs / Microsoft Machine Learning repository</remarks>
        
