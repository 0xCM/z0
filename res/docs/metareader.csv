Type        | Z0.MS.EncodingHelper                                                  | Provides helpers to decode strings from unmanaged memory to System.String while avoiding             intermediate allocation.                         This has three components:                           (1) Light-up Encoding.GetString(byte*, int) via reflection and resurface it as extension                   method.                               This is a new API that will provide API convergence across all platforms for                   this scenario. It is already on .NET 4.6+ and ASP.NET vNext, but not yet available                   on every platform we support. See below for how we fall back.                           (2) Deal with WinRT prefixes.                              When reading managed winmds with projections enabled, the metadata   reader needs to prepend                  a WinRT prefix in some case . Doing this without allocation poses a problem                  as we don't have the prefix and input in contiguous data that we can pass to the                  Encoding.GetString. We handle this case using pooled managed scratch buffers where we copy                  the prefix and input and decode using Encoding.GetString(byte[], int, int).                           (3) Deal with platforms that don't yet have Encoding.GetString(byte*, int).                              If we're running on a .NET Framework earlier than 4.6, we will bind to the internal                  String.CreateStringFromEncoding which is equivalent and Encoding.GetString is just a trivial                  wrapper around it in .NET 4.6. This means that we always have the fast path on every                  .NET Framework version we support.                              If we can't bind to it via reflection, then we emulate it using what is effectively (2) and                  with an empty prefix.                         For both (2) and (3), the pooled buffers have a fixed size deemed large enough for the             vast majority of metadata strings. In the rare worst case (byteCount &gt; threshold and             (lightUpAttemptFailed || prefix != null), we give up and allocate a temporary array,             copy to it, decode, and throw it away.
Type        | Z0.MS.MetadataFlags.HandleType                                        | These constants are all in the byte range and apply to the interpretation of <see cref="!:Handle.VType" />,
Field       | Z0.MS.MetadataFlags.HandleType.VirtualBit                             | Use the highest bit to mark tokens that are virtual (synthesized).            We create virtual tokens to represent projected WinMD entities.
Field       | Z0.MS.MetadataFlags.HandleType.NonVirtualStringTypeMask               | In the case of string handles, the two lower bits that (in addition to the            virtual bit not included in this mask) encode how to obtain the string value.
Field       | Z0.MS.MetadataFlags.TokenTypeIds.VirtualBit                           | Use the highest bit to mark tokens that are virtual (synthesized).            We create virtual tokens to represent projected WinMD entities.
Method      | Z0.MS.MetadataFlags.TokenTypeIds.IsEntityOrUserStringToken(System.UInt32)| Returns true if the token value can escape the metadata reader.             We don't allow virtual tokens and heap tokens other than UserString to escape             since the token type ids are internal to the reader and not specified by ECMA spec.                         Spec (Partition III, 1.9 Metadata tokens):             Many CIL instructions are followed by a "metadata token". This is a 4-byte value, that specifies a row in a             metadata table, or a starting byte offset in the User String heap.                         For example, a value of 0x02 specifies the TypeDef table; a value of 0x70 specifies the User             String heap.The value corresponds to the number assigned to that metadata table (see Partition II for the full             list of tables) or to 0x70 for the User String heap.The least-significant 3 bytes specify the target row within that             metadata table, or starting byte offset within the User String heap.
Type        | Z0.MS.ImmutableByteArrayInterop                                       | Provides tools for using <see cref="T:System.Collections.Immutable.ImmutableArray`1" /> in interop scenarios.
Method      | Z0.MS.ImmutableByteArrayInterop.DangerousCreateFromUnderlyingArray(System.Byte[]@)| Creates a new instance of <see cref="T:System.Collections.Immutable.ImmutableArray`1" /> using a given mutable array as the backing            field, without creating a defensive copy. It is the responsibility of the caller to ensure no other mutable            references exist to the array.  Do not mutate the array after calling this method.
Method      | Z0.MS.ImmutableByteArrayInterop.DangerousGetUnderlyingArray(System.Collections.Immutable.ImmutableArray{System.Byte})| Access the backing mutable array instance for the given <see cref="T:System.Collections.Immutable.ImmutableArray`1" />, without            creating a defensive copy.  It is the responsibility of the caller to ensure the array is not modified            through the returned mutable reference.  Do not mutate the returned array.
Method      | Z0.MS.MemoryBlock.PeekCompressedInteger(System.Int32,System.Int32@)   | Decodes a compressed integer value starting at offset.            See Metadata Specification section II.23.2: Blobs and signatures.
Method      | Z0.MS.MemoryBlock.PeekUtf8NullTerminated(System.Int32,System.Byte[],System.Reflection.Metadata.MetadataStringDecoder,System.Int32@,System.Char)| Read UTF8 at the given offset up to the given terminator, null terminator, or end-of-block.
Method      | Z0.MS.MemoryBlock.GetUtf8NullTerminatedLength(System.Int32,System.Int32@,System.Char)| Get number of bytes from offset to given terminator, null terminator, or end-of-block (whichever comes first).            Returned length does not include the terminator, but numberOfBytesRead out parameter does.
Method      | Z0.MS.MemoryBlock.BinarySearchForSlot(System.Int32,System.Int32,System.Int32,System.UInt32,System.Boolean)| In a table that specifies children via a list field (e.g. TypeDef.FieldList, TypeDef.MethodList),            searches for the parent given a reference to a child.
Method      | Z0.MS.MemoryBlock.BinarySearchReference(System.Int32,System.Int32,System.Int32,System.UInt32,System.Boolean)| In a table ordered by a column containing entity references searches for a row with the specified reference.
Method      | Z0.MS.MemoryBlock.BinarySearchReferenceRange(System.Int32,System.Int32,System.Int32,System.UInt32,System.Boolean,System.Int32@,System.Int32@)| Calculates a range of rows that have specified value in the specified column in a table that is sorted by that column.
Method      | Z0.MS.MemoryBlock.BinarySearchReferenceRange(System.Int32[],System.Int32,System.Int32,System.UInt32,System.Boolean,System.Int32@,System.Int32@)| Calculates a range of rows that have specified value in the specified column in a table that is sorted by that column.
Type        | Z0.MS.ObjectPool`1                                                    | Generic implementation of object pooling pattern with predefined pool size limit. The main             purpose is that limited number of frequently used objects can be kept in the pool for             further recycling.                         Notes:             1) it is not the goal to keep all returned objects. Pool is not meant for storage. If there                is no space in the pool, extra returned objects will be dropped.                         2) it is implied that if object was obtained from a pool, the caller will return it back in                a relatively short time. Keeping checked out objects for long durations is ok, but                reduces usefulness of pooling. Just new up your own.                         Not returning objects to the pool in not detrimental to the pool's work, but is a bad practice.             Rationale:                If there is no intent for reusing the object, do not use pool - just use "new".
Method      | Z0.MS.ObjectPool`1.Allocate                                           | Produces an instance.
Method      | Z0.MS.ObjectPool`1.Free(`0)                                           | Returns objects to the pool.
Method      | Z0.Reflex.type``1                                                     | Produces the parametrically-identified reflected system type
