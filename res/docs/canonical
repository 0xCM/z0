| T:Z0.IAdditiveOps`1                               | 
            <summary>
            Characterizes a type for which commutative additivity can be defined
            </summary>
            <typeparam name="T">The operand type</typeparam>
        
| M:Z0.IAdditiveOps`1.Add(`0,`0)                    | 
            <summary>
            Alias for commutative semigroup composition operator
            </summary>
            <param name="lhs">The first element</param>
            <param name="rhs">The second element</param>
        
| T:Z0.IAdditive`1                                  | 
            <summary>
            Characterizes a structure that supports semigroup additivity
            </summary>
            <typeparam name="S">The structure type</typeparam>
        
| M:Z0.ISuccessive`2.Next                           | 
            <summary>
            Given an A-value, computes the next B-value
            </summary>
            <param name="a">The source vlue</param>
        
| M:Z0.IAntecedant`2.Prior                          | 
            <summary>
            Given an A-value, computes the prior B-value
            </summary>
            <param name="a">The source vlue</param>
        
| T:Z0.IAdjacency`2                                 | 
            <summary>
            Characterizes a bidirectional association between types for which
            the exists notions successors and antecedants
            </summary>
            <typeparam name="A">The type that succeeds B</typeparam>
            <typeparam name="B">The type that precedes A</typeparam>
        
| T:Z0.IBitwiseOps`1                                | 
            <summary>
            Characterizes bitwise operations over an operand
            </summary>
        
| M:Z0.IBitwiseOps`1.And(`0,`0)                     | 
            <summary>
            Computes the bitwise AND
            </summary>
            <param name="a">The left value</param>
            <param name="b">The right value</param>
        
| M:Z0.IBitwiseOps`1.Or(`0,`0)                      | 
            <summary>
            Computes the bitwise OR
            </summary>
            <param name="a">The left value</param>
            <param name="b">The right value</param>
        
| M:Z0.IBitwiseOps`1.XOr(`0,`0)                     | 
            <summary>
            Computes the bitwise XOR
            </summary>
            <param name="a">The left value</param>
            <param name="b">The right value</param>
        
| M:Z0.IBitwiseOps`1.Not(`0)                        | 
            <summary>
            Computes the bitwise complement
            </summary>
            <param name="a">The operand</param>
        
| M:Z0.IShiftOps`1.RotL(`0,System.Int32)            | 
            <summary>
            Rotates bits rightwards, from MSB -&gt; LSB
            </summary>
            <param name="lhs">The value to rotate</param>
            <param name="offset">The magnitude of the rotation</param>
        
| M:Z0.IShiftOps`1.RotR(`0,System.Int32)            | 
            <summary>
            Rotates bits leftwards, from LSB -&gt; MSB
            </summary>
            <param name="lhs">The value to rotate</param>
            <param name="rotl">The magnitude of the rotation</param>
        
| M:Z0.IShiftable`1.RotL(System.Int32)              | 
            <summary>
            Rotates bits rightwards, from MSB -&gt; LSB
            </summary>
            <param name="rhs">The magnitude of the rotation</param>
        
| M:Z0.IShiftable`1.RotR(System.Int32)              | 
            <summary>
            Rotates bits leftwards, from LSB -&gt; MSB
            </summary>
            <param name="rhs">The magnitude of the rotation</param>
        
| T:Z0.ICommutativeOps`1                            | 
            <summary>
            Characterizes commutative operations
            </summary>
            <typeparam name="T">The operand type</typeparam>
        
| T:Z0.ICommutative`1                               | 
            <summary>
            Characterizes structural commutativity
            </summary>
            <typeparam name="S">The structure type</typeparam>
        
| T:Z0.IComplex`3                                   | 
            <summary>
            Characterizes a structure that represents a complex number
            </summary>
            <typeparam name="S">The structure type</typeparam>
            <typeparam name="T">The underlying numeric component type</typeparam>
            <typeparam name="C">The complex number type</typeparam>
        
| P:Z0.IComplex`3.Re                                | 
            <summary>
            The real part
            </summary>
        
| P:Z0.IComplex`3.Im                                | 
            <summary>
            The imaginary part
            </summary>
        
| T:Z0.ICurrencyOps`1                               | 
            <summary>
            Characterizes a bounded fractional operation provider
            </summary>
            <typeparam name="T">The primitive type</typeparam>
        
| T:Z0.ICurrency`1                                  | 
            <summary>
            Characterizes structural reifications of Currency 
            </summary>
            <typeparam name="S">The structural reification type</typeparam>
        
| M:Z0.ILeftDistributiveOps`1.Distribute(`0,System.ValueTuple{`0,`0})| 
            <summary>
            Characterizes a type that defines an operator that left-distributes
            multiplication over addition
            </summary>
            <typeparam name="X">The operand type</typeparam>
        
| T:Z0.IRightDistributiveOps`1                      | 
            <summary>
            Characterizes a type that defines an operator that right-distributes
            multiplication over addition
            </summary>
            <typeparam name="T">The operand type</typeparam>
        
| T:Z0.IDistributiveOps`1                           | 
            <summary>
            Characterizes a type that defines both left and right distribution
            over addition
            </summary>
        
| M:Z0.ILeftDistributive`1.LeftDistribute(System.ValueTuple{`0,`0})| 
            <summary>
            Characterizes a type that defines an operator that left-distributes
            multiplication over addition
            </summary>
            <typeparam name="X">The operand type</typeparam>
        
| M:Z0.IRightDistributive`1.RightDistribute(System.ValueTuple{`0,`0})| 
            <summary>
            Characterizes a type that defines an operator that left-distributes
            multiplication over addition
            </summary>
            <typeparam name="X">The operand type</typeparam>
        
| T:Z0.IIntegralDomainOps`1                         | 
            <summary>
            Characterizes an integral domain, which is a nonzero commutative ring
            such that for every pair of nonzero elements a and b, the product
            ab is nonzero, i.e., ab = 0 iff a = 0 or b = 0
            </summary>
            <typeparam name="T">The individual type</typeparam>
            <remarks>See https://en.wikipedia.org/wiki/Integral_domain</remarks>
        
| T:Z0.IGcdDomainOps`1                              | 
            <summary>
            Characterizes a GCD domain
            </summary>
            <typeparam name="T">The individual type</typeparam>
            <remarks>See https://en.wikipedia.org/wiki/GCD_domain</remarks>
        
| T:Z0.IUniqueFactorDomainOps`1                     | 
            <summary>
            Characterizes a **unique** factorization domain
            </summary>
            <typeparam name="T">The individual type</typeparam>
        
| T:Z0.IPrincipalIdealDomainOps`1                   | 
            <summary>
            Characterizes a principal ideal domain
            </summary>
            <typeparam name="T">The individual type</typeparam>
        
| T:Z0.IEuclideanDomainOps`1                        | 
            <summary>
            Characterizes a Euclidean domain
            </summary>
            <typeparam name="T">The individual type</typeparam>
        
| T:Z0.IDiscreteEqivalenceClass`2                   | 
            <summary>
            Characterizes a constructive equivalence class, i.e. an equivalence class 
            with enumerable content
            </summary>
            <typeparam name="T">The content type</typeparam>
        
| T:Z0.IFiniteEquivalenceClass`2                    | 
            <summary>
            Characterizes an equivalence class, i.e. a segment of a partition effected via 
            an equivalence relation
            </summary>
            <typeparam name="T">The classified type</typeparam>
        
| T:Z0.IDiscreteGroup`2                             | 
            <summary>
            Characterizes a discrete group structure
            </summary>
            <typeparam name="T">The operational type</typeparam>
            <typeparam name="S">The structure type</typeparam>
        
| T:Z0.IFloatingOps`1                               | 
            <summary>
            Characterizes an operation provider for floating point values
            </summary>
            <typeparam name="T">The underlying numeric type</typeparam>
        
| P:Z0.IFloatingOps`1.Epsilon                       | 
            <summary>
            The minimal resolution of the data type
            </summary>
        
| M:Z0.IFloatingOps`1.Sqrt(`0)                      | 
            <summary>
            Calculates the square root of the input
            </summary>
            <param name="x">The input value</param>
        
| T:Z0.IFiniteFloatOps`1                            | 
            <summary>
            Characterizes an operation provider for bounded floating point values
            </summary>
            <typeparam name="T">The underlying numeric type</typeparam>
        
| T:Z0.IFiniteFloatOps`2                            | 
            <summary>
            Characterizes operational reifications of RealFiniteUInt 
            </summary>
            <typeparam name="R">The reification type</typeparam>
            <typeparam name="T">The operand type</typeparam>
        
| T:Z0.IFloating`2                                  | 
            <summary>
            Characterizes a structure for a floating point number
            </summary>
            <typeparam name="T">The underlying numeric type</typeparam>
        
| T:Z0.IGroupOps`1                                  | 
            <summary>
            Characterizes group operations over a type
            </summary>
            <typeparam name="T">The operand type</typeparam>
        
| T:Z0.IGroupAOps`1                                 | 
            <summary>
            Characterizes additive/abelian group operations
            </summary>
        
| M:Z0.IGroupA`1.Invert                             | 
            <summary>
            Unary structural negation
            </summary>
        
| T:Z0.IGroupLike`2                                 | 
            <summary>
            Characterizes a group structure
            </summary>
            <typeparam name="T">The type over which the structure is defind</typeparam>
            <typeparam name="S">The structure type</typeparam>
        
| T:Z0.IGroupM`2                                    | 
            <summary>
            Characterizes a multiplicative group structure
            </summary>
            <typeparam name="T">The type over which the structure is defind</typeparam>
            <typeparam name="S">The structure type</typeparam>
        
| T:Z0.IGroupA`2                                    | 
            <summary>
            Characterizes an additive group structure
            </summary>
            <typeparam name="T">The type over which the structure is defind</typeparam>
            <typeparam name="S">The structure type</typeparam>
        
| T:Z0.IConcatenableOps`1                           | 
            <summary>
            Characterizes an operator that merges two elements into one with preservation
            of constituent order if such an ordering is defined. In the situation where
            no ordering exist, the concatenation operator is effectively reduced to
            an addition operator
            </summary>
            <typeparam name="T">The element type</typeparam>
        
| T:Z0.ISetAspect                                   | 
            <summary>
            Defines attributes common to set representations
            </summary>
        
| P:Z0.ISetAspect.IsEmpty                           | 
            <summary>
            Specifies whether the set is void of elements
            </summary>
        
| P:Z0.ISetAspect.IsFinite                          | 
            <summary>
            Specifies whether the set is finite
            </summary>
        
| P:Z0.ISetAspect.IsDiscrete                        | 
            <summary>
            Specifies whether the set is discrete
            </summary>
        
| T:Z0.IInfiniteSet`1                               | 
            <summary>
            Characterizes a type that represents an infinite number of values
            </summary>
            <typeparam name="T">The member type</typeparam>
        
| T:Z0.IInfiniteSet`2                               | 
            <summary>
            Characterizes a type that represents an infinite number of values
            </summary>
            <typeparam name="T">The member type</typeparam>
        
| T:Z0.IInfiniteOps`1                               | 
            <summary>
            Characterizes operations over operands for which a given reification may be infinite
            </summary>
            <typeparam name="T">The operand type</typeparam>
        
| T:Z0.IIntegerOps`1                                | 
            <summary>
            Characterizes operations over an integer type
            </summary>
            <typeparam name="T">The operand type</typeparam>
        
| T:Z0.IInfiniteIntOps`1                            | 
            <summary>
            Characterizes operations over unbound integers
            </summary>
        
| T:Z0.ISignableOps`1                               | 
            <summary>
            Characterizes a sign adjudication operation
            </summary>
            <typeparam name="T">The operand type</typeparam>
        
| M:Z0.ISignableOps`1.Sign(`0)                      | 
            <summary>
            Determines the sign of the supplied value
            </summary>
        
| T:Z0.ISignedIntOps`1                              | 
            <summary>
            Characterizes operations over a signed interal type
            </summary>
            <typeparam name="T">The operand type</typeparam>
        
| T:Z0.IFiniteSignedIntOps`1                        | 
            <summary>
            Characterizes operations over a signed, finite interal type
            </summary>
            <typeparam name="T">The operand type</typeparam>
        
| T:Z0.IInfiniteSignedIntOps`1                      | 
            <summary>
            Characterizes operations over an unbound signed integral type
            </summary>
            <typeparam name="T">The operand type</typeparam>
        
| T:Z0.IInteger`2                                   | 
            <summary>
            Characterizes a reification structure over an integer type
            </summary>
            <typeparam name="S">The reification type</typeparam>
            <typeparam name="T">The underlying type</typeparam>
        
| T:Z0.IInvertiveOps`1                              | 
            <summary>
            Characterizes operational inversion
            </summary>
            <typeparam name="T">The operand type</typeparam>
        
| T:Z0.InvertiveMOps`1                              | 
            <summary>
            Characterizes operational multiplicative inversion
            </summary>
            <typeparam name="T">The operand type</typeparam>
        
| M:Z0.InvertiveMOps`1.InvertM(`0)                  | 
            <summary>
            Multiplicative inversion
            </summary>
            <param name="x">The value to invert</param>
        
| T:Z0.InvertiveA`1                                 | 
            <summary>
            Characterizes operational additive inversion
            </summary>
            <typeparam name="T">The operand type</typeparam>
        
| M:Z0.InvertiveA`1.InvertA(`0)                     | 
            <summary>
            Additive inversion
            </summary>
            <param name="x">The value to invert</param>
        
| T:Z0.IInvertive`1                                 | 
            <summary>
            Characterizes structural inversion
            </summary>
            <typeparam name="T">The type over which the structrue is defined</typeparam>
        
| T:Z0.IInvertiveM`1                                | 
            <summary>
            Characterizes structural multiplicative inversion
            </summary>
            <typeparam name="S">The reification type</typeparam>
        
| M:Z0.IInvertiveM`1.InvertM                        | 
            <summary>
            Effects multiplicative inversion
            </summary>
        
| T:Z0.IInvertiveA`1                                | 
            <summary>
            Characterizes structural additive inversion
            </summary>
            <typeparam name="S">The reification type</typeparam>
        
| M:Z0.IInvertiveA`1.InvertA                        | 
            <summary>
            Effects additive inversion
            </summary>
        
| T:Z0.ILogarithmicOps`1                            | 
            <summary>
            Characterizes a type that supports primitive logarithmic operations
            </summary>
            <typeparam name="T">The type of the underlying primitive</typeparam>
        
| M:Z0.ILogarithmicOps`1.Ln(`0)                     | 
            <summary>
            Computes the natural logarithm 
            </summary>
            <param name="x">The input value</param>
        
| M:Z0.ILogarithmicOps`1.Log(`0)                    | 
            <summary>
            Computes the base-10 logarithm
            </summary>
            <param name="x">The input value</param>
        
| M:Z0.ILogarithmicOps`1.LogB(`0,`0)                | 
            <summary>
            Computes a logarithm at a specified base
            </summary>
            <param name="x">The input value</param>
            <param name="@base">The logarithm base</param> 
        
| M:Z0.ILogarithmic`1.Ln                            | 
            <summary>
            Computes the natural logarithm 
            </summary>
            <param name="x">The input value</param>
        
| M:Z0.ILogarithmic`1.Log                           | 
            <summary>
            Computes the base-10 logarithm
            </summary>
            <param name="x">The input value</param>
        
| M:Z0.ILogarithmic`1.LogB(`0)                      | 
            <summary>
            Computes a logarithm at a specified base
            </summary>
            <param name="x">The input value</param>
            <param name="@base">The logarithm base</param> 
        
| M:Z0.ILeftModule`2.LeftScale(`0)                  | 
            <summary>
            Effects scalar multiplication from the left
            </summary>
            <param name="r">The ring individual type, i.e., the scalar type</param>
            <param name="m">The group individual type</param>
        
| M:Z0.IRightModule`2.RightScale(`1)                | 
            <summary>
            Effects scalar multiplication from the right
            </summary>
            <param name="r">The ring individual type, i.e., the scalar type</param>
            <param name="m">The group individual type</param>
        
| T:Z0.IGroupAction`2                               | 
            <summary>
            Characterizes a group action on a set
            </summary>
            <typeparam name="G">The type of the acting group</typeparam>
            <typeparam name="R">The type of the target set</typeparam>
            <remarks>
            For an instance to be law-abiding, the act function must satisfy g(act(h,t)) = act(hg,t) and
            act(1,t) = t for all g,h in G and t in T
            Also, see https://en.wikipedia.org/wiki/Group_with_operators
            </remarks>
        
| M:Z0.IGroupAction`2.Act(`0,`1)                    | 
            <summary>
            Applies a G-element to a T-element
            </summary>
            <param name="g">The group element</param>
            <param name="t">The target element</param>
        
| T:Z0.ILeftModuleOps`2                             | 
            <summary>
            Characterizes a left module over a commtative unital ring
            </summary>
            <typeparam name="G">The group individual type</typeparam>
            <typeparam name="R">The ring individual type</typeparam>
        
| M:Z0.ILeftModuleOps`2.LeftScale(`0,`1)            | 
            <summary>
            Effects left scalar multiplication
            </summary>
            <param name="r">The ring individual type, i.e., the scalar type</param>
            <param name="m">The group individual type</param>
        
| T:Z0.IRightModuleOps`2                            | 
            <summary>
            Characterizes a right module over a commtative unital ring
            </summary>
            <typeparam name="G">The group individual type</typeparam>
            <typeparam name="R">The ring individual type</typeparam>
        
| M:Z0.IRightModuleOps`2.RightScale(`0,`1)          | 
            <summary>
            Effects right scalar multiplication
            </summary>
            <param name="m">The group individual type</param>
            <param name="r">The ring individual type, i.e., the scalar type</param>
        
| T:Z0.INullaryOps`1                                | 
            <summary>
            Characterizes operations over a nullary type
            </summary>
            <typeparam name="T">The unit type</typeparam>
            <remarks>
            It is tempting to subclass Additive here, but there are cases where
            it makese sense for something have a zero element and yet not be
            additive, e.g. a string can be empty, and they can be added (via concatentation)
            but consider the set of singleton/atomic strings over some alphabet. In
            this case, there can be no (closed) concatenation operation and yet
            the concept of nothingness (the empty string) is still meaningful
            </remarks>
        
| T:Z0.IMonoidOps`1                                 | 
            <summary>
            Characterizes monoidal operations
            </summary>
            <typeparam name="T">The operand type</typeparam>
        
| T:Z0.IMonoidMOps`1                                | 
            <summary>
            Characterizes multiplicative monoidal operations
            </summary>
            <typeparam name="T">The operand type</typeparam>
        
| T:Z0.IMonoidAOps`1                                | 
            <summary>
            Characterizes additive monoidal operations
            </summary>
            <typeparam name="T">The operand type</typeparam>
        
| T:Z0.IMonoidM`2                                   | 
            <summary>
            Characterizes multiplicative monoidal structure
            </summary>
            <typeparam name="S">The classified structure</typeparam>
            <typeparam name="T">The underlying type</typeparam>
        
| T:Z0.IMonoidA`2                                   | 
            <summary>
            Characterizes additive monoidal structure
            </summary>
            <typeparam name="S">The classified structure</typeparam>
            <typeparam name="T">The underlying type</typeparam>
        
| M:Z0.Monoidial.foldA``1(System.Collections.Generic.IEnumerable{``0})| 
            <summary>
            Reduces a stream to a single value via an additive monoid
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The stream element type</typeparam>
        
| M:Z0.Monoidial.foldM``1(System.Collections.Generic.IEnumerable{``0})| 
            <summary>
            Reduces a stream to a single value via a multiplicative monoid
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The stream element type</typeparam>
        
| M:Z0.Monoidial.fold``1(System.Collections.Generic.IEnumerable{``0},Z0.IMonoidalOps{``0})| 
            <summary>
            Reduces a stream to a single value via a specified monoid
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The stream element type</typeparam>
        
| T:Z0.IMultiplicativeOps`1                         | 
            <summary>
            Characterizes operational multiplication
            </summary>
            <typeparam name="T">The type subject to multiplication</typeparam>
        
| T:Z0.IFiniteNaturalOps`1                          | 
            <summary>
            Characterizes an operation provider for bounded natural types
            </summary>
            <typeparam name="T">The type over which operations are defined</typeparam>
        
| T:Z0.IFiniteNaturalOps`2                          | 
            <summary>
            Characterizes operational reifications of RealFiniteUInt 
            </summary>        
            <typeparam name="R">The reification type</typeparam>
            <typeparam name="T">The operand type</typeparam>
        
| T:Z0.INatural`1                                   | 
            <summary>
            Characterizes a reification structure over natural types S where
            s:S =&gt; s ∈ {1, … n} where n is some natural number subject to the
            bounds implied by the underlying data structure
            </summary>
            <typeparam name="S">The type of the realizing structure</typeparam>
        
| M:Z0.INegatableOps`1.Negate(`0)                   | 
            <summary>
            Unary negation of input
            </summary>
            <param name="x">The input value</param>
        
| T:Z0.INonNegativeOps`1                            | 
            <summary>
            Characterizes operations over nonnegative operands
            </summary>
            <typeparam name="T">The operand type</typeparam>
        
| T:Z0.INonNegative`1                               | 
            <summary>
            Characterizes a structure whose values are nonnegative
            </summary>
            <typeparam name="S">The reifying structure</typeparam>
        
| T:Z0.INumberOps`1                                 | 
            <summary>
            Defines the minimal aspects for a value to be considered a "real number"
            The dual contract, that subsumes every possible aspect of number, is 
            defined via the Real trait. Note that every Number can be parameterized 
            by any underlying primitive numeric type
            </summary>
            <typeparam name="T">The operand type</typeparam>
        
| T:Z0.INumber`1                                    | 
            <summary>
            Characterizes a structral number
            </summary>
            <typeparam name="S">The structure type</typeparam>
            <typeparam name="T">The underlying operand type</typeparam>
        
| T:Z0.ICNumber`1                                   | 
            <summary>
            Characterizes a structural number in the C adaptation context
            </summary>
            <typeparam name="S">The reifying type</typeparam>
        
| P:Z0.ICNumber`1.BitSize                           | 
            <summary>
            Specifies the (fixed) number of bits required to represent the numeric value
            </summary>
        
| T:Z0.ICNumber`2                                   | 
            <summary>
            Characterizes a structural number reification in the C adaptation context
            </summary>
            <typeparam name="S">The reifying type</typeparam>
        
| M:Z0.ICNumber`2.Wrap(System.Collections.Generic.IEnumerable{`1})| 
            <summary>
            Elevates a primitive to a structure
            </summary>
            <param name="src">The primitive source</param>
        
| M:Z0.ICNumber`2.Unwrap(System.Collections.Generic.IEnumerable{`0})| 
            <summary>
            Unwraps a lifted primitivie
            </summary>
            <param name="src">The lifted source</param>
        
| T:Z0.IOrderedNumberOps`1                          | 
            <summary>
            Characterizes numeric operations in the presence of order
            </summary>
            <typeparam name="T"></typeparam>
        
| T:Z0.IOrderedNumber`2                             | 
            <summary>
            Characterizes a structural number with order
            </summary>
            <typeparam name="S">The reification type</typeparam>
            <typeparam name="T">The underlying type</typeparam>
        
| T:Z0.IPartialOrderOps`1                           | 
            <summary>
            Characterizes a partial order, i.e. a reflexive, transitive and 
            antisymmetric binary operator
            </summary>
            <typeparam name="T">The relation domain</typeparam>
            <remarks>See https://en.wikipedia.org/wiki/Partially_ordered_set</remarks>
        
| T:Z0.IPosetOps`1                                  | 
            <summary>
            Characterizes a set equipped with a partial order
            </summary>
            <typeparam name="T"></typeparam>
            <remarks>See https://en.wikipedia.org/wiki/Partially_ordered_set </remarks>
        
| M:Z0.IPosetOps`1.Comparable(`0,`0)                | 
            <summary>
            Determines whether order may be adjudicated between two particluar elements
            </summary>
            <param name="x">The left element</param>
            <param name="y">The right element</param>
            <returns>Returns true if either a ~ b or b ~ a and false oterwise</returns>
        
| T:Z0.IPoweredOps`2                                | 
            <summary>
            Characterizes an exponentiation operation
            </summary>
            <typeparam name="B">The base type</typeparam>
            <typeparam name="E">The exponent type</typeparam>
        
| T:Z0.IPreorderOps`1                               | 
            <summary>
            Characterizes a preorder, i.e. a reflexive and transitive
            binary relation over its domain
            </summary>
            <typeparam name="T">The preorder domain</typeparam>
            <remarks>See https://en.wikipedia.org/wiki/Preorder </remarks>
        
| T:Z0.IProsetOps`1                                 | 
            <summary>
            Characterizes a set equipped with a preorder
            </summary>
            <typeparam name="T">The element type</typeparam>
            <remarks>See https://en.wikipedia.org/wiki/Preorder </remarks>
        
| T:Z0.ISetoid`2                                    | 
            <summary>
            Characterizes a discrete partition over a discrete set and, consequently, 
            is a constructive presentation of an equivalence relation. In this context, a parition
            is a collection of mutually disjoint subsets of a given set whose union
            is recovers the original set
            </summary>
            <typeparam name="T">The element type</typeparam>
            <remarks>See https://en.wikipedia.org/wiki/Setoid</remarks>
        
| T:Z0.IFractionalOps`1                             | 
            <summary>
            Characterizes fractional operations
            </summary>
            <typeparam name="T">The operand type</typeparam>
        
| T:Z0.IFractional`2                                | 
            <summary>
            Characterizes a fractional structure
            </summary>
            <typeparam name="T">The operand type</typeparam>
        
| M:Z0.IRational`1.Over                             | 
            <summary>
            The dividend
            </summary>
        
| M:Z0.IRational`1.Under                            | 
            <summary>
            The divisor
            </summary>
        
| T:Z0.IRational`3                                  | 
            <summary>
            Charactrizes a rational number
            </summary>
        
| T:Z0.IBoundRealOps`1                              | 
            <summary>
            Characterizes operations over (ordered) values that 
            exist between upper and lower bounds
            </summary>
            <typeparam name="T">The operand type</typeparam>
        
| T:Z0.IRealNumber`1                                | 
            <summary>
            Characterizes a structured real
            </summary>
            <typeparam name="S">The reification type</typeparam>
        
| T:Z0.IRealNumber`2                                | 
            <summary>
            Characterizes a reification structure over real numbers
            </summary>
            <typeparam name="S">The reification type</typeparam>
            <typeparam name="T">The underlying type</typeparam>
        
| M:Z0.IReciprocativeOps`1.Recip(`0)                | 
            <summary>
            Calculates the multiplicative inverse of a given element
            </summary>
            <param name="x">The individual for which an inverse will be calculated</param>
        
| T:Z0.IReciprocative`1                             | 
            <summary>
            Characterizes a multiplicative and unitial structure S such that
            s:S =&gt; s * recip(s) = 1
            </summary>
            <typeparam name="S"></typeparam>
        
| M:Z0.IReciprocative`1.Recip                       | 
            <summary>
            Calculates the structure's multiplicative inverse
            </summary>
        
| T:Z0.IBinaryRelationOps`1                         | 
            <summary>
            Characterizes a relation over a set
            </summary>
            <typeparam name="T">The element type</typeparam>
        
| T:Z0.IReflexiveOps`1                              | 
            <summary>
            Spcifies that a ~ a for every a:T
            </summary>
            <typeparam name="T">The element type</typeparam>
        
| T:Z0.ISymmetricOps`1                              | 
            <summary>
            Spcifies that a ~ b iff b ~ a for every a,b:T
            </summary>
            <typeparam name="T">The element type</typeparam>
        
| T:Z0.IEquivalenceOps`1                            | 
            <summary>
             Characterizes a reflexive, symmetric and transitive binary relation over a set 
            \that, consequently, effects a partition over the set
            </summary>
            <typeparam name="T">The element type</typeparam>
            <remarks>See https://en.wikipedia.org/wiki/Equivalence_relation</remarks>
        
| T:Z0.IResignableOps`1                             | 
            <summary>
            Characterizes a sign-reversal operation
            </summary>
            <typeparam name="T">The operand type</typeparam>
        
| M:Z0.IResignableOps`1.Resign(`0,Z0.SignKind)      | 
            <summary>
            Aligns the value with a specified sign
            </summary>
        
| T:Z0.IReversibleOps`1                             | 
            <summary>
            Characterizes operational reversiblity
            </summary>
            <typeparam name="T">The type for which a reverse operator is defined</typeparam>
        
| T:Z0.IRingOps`1                                   | 
            <summary>
            Characterizes a (unital) ring
            </summary>
        
| T:Z0.ICommutativeRingOps`1                        | 
            <summary>
            Characterizes a commutative, unital ring
            </summary>
        
| M:Z0.ISemigroupOps`1.Equals(`0,`0)                | 
            <summary>
            Adjudicates equality between semigroup members
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
        
| M:Z0.IImplicitSemigroup`2.Comparer(System.Func{`1,System.Int32})| 
            <summary>
            Gets an equality comparer that can determine whether to semigroup elements are equal
            </summary>
            <param name="hasher">The hash function to use, if specified</param>
        
| T:Z0.ISemiringOps`1                               | 
            <summary>
            Characterizes semiring operations
            </summary>
            <typeparam name="T">The individual type</typeparam>
        
| T:Z0.ISemiring`1                                  | 
            <summary>
            Characterizes a semiring structure
            </summary>
            <typeparam name="S">The structure type</typeparam>
        
| T:Z0.IStepwiseOps`1                               | 
            <summary>
            Characterizes a type that realizes both incrementing and decrementing operations
            </summary>
            <typeparam name="T">The target type</typeparam>
        
| T:Z0.ISubtractiveOps`1                            | 
            <summary>
            Characterizes operational negation and subtraction
            </summary>
            <typeparam name="T">The individual type</typeparam>
        
| M:Z0.ISubtractiveOps`1.Sub(`0,`0)                 | 
            <summary>
            Combines the first operand with the negation of the second
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
            <returns></returns>
        
| M:Z0.ISubtractive`1.Sub(`0)                       | 
            <summary>
            Structural subtraction
            </summary>
            <param name="rhs">The right operand</param>
        
| T:Z0.ITrigonmetricOps`1                           | 
            <summary>
            Characterizes trigonometric operations over a type
            </summary>
            <typeparam name="T">The operand type</typeparam>
        
| T:Z0.Unit                                         | 
            <summary>
            Defines a slot in the type system for an "empty" type
            In this way, void functions can be considered
            to yield a value and participate in functional/monadic expressions
            </summary>
        
| M:Z0.Unit.op_Explicit(System.Action)~Z0.Unit      | 
            <summary>
            Executes the action and returns the unit value
            </summary>
            <param name="a">The action to execute</param>
        
| T:Z0.IUnitalOps`1                                 | 
            <summary>
            Characterizes operations over a unital type
            </summary>
            <typeparam name="T">The characterized type</typeparam>
        
| P:Z0.IUnitalOps`1.One                             | 
            <summary>
            The unital value
            </summary>
        
