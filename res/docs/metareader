| T:Z0.MS.EncodingHelper                            | 
             <summary>
             Provides helpers to decode strings from unmanaged memory to System.String while avoiding
             intermediate allocation.
            
             This has three components:
            
               (1) Light-up Encoding.GetString(byte*, int) via reflection and resurface it as extension
                   method.
            
                   This is a new API that will provide API convergence across all platforms for
                   this scenario. It is already on .NET 4.6+ and ASP.NET vNext, but not yet available
                   on every platform we support. See below for how we fall back.
            
               (2) Deal with WinRT prefixes.
            
                  When reading managed winmds with projections enabled, the metadata   reader needs to prepend
                  a WinRT prefix in some case . Doing this without allocation poses a problem
                  as we don't have the prefix and input in contiguous data that we can pass to the
                  Encoding.GetString. We handle this case using pooled managed scratch buffers where we copy
                  the prefix and input and decode using Encoding.GetString(byte[], int, int).
            
               (3) Deal with platforms that don't yet have Encoding.GetString(byte*, int).
            
                  If we're running on a .NET Framework earlier than 4.6, we will bind to the internal
                  String.CreateStringFromEncoding which is equivalent and Encoding.GetString is just a trivial
                  wrapper around it in .NET 4.6. This means that we always have the fast path on every
                  .NET Framework version we support.
            
                  If we can't bind to it via reflection, then we emulate it using what is effectively (2) and
                  with an empty prefix.
            
             For both (2) and (3), the pooled buffers have a fixed size deemed large enough for the
             vast majority of metadata strings. In the rare worst case (byteCount &gt; threshold and
             (lightUpAttemptFailed || prefix != null), we give up and allocate a temporary array,
             copy to it, decode, and throw it away.
             </summary>
        
| T:Z0.MS.MetadataFlags.HandleType                  | 
            <summary>
            These constants are all in the byte range and apply to the interpretation of <see cref="!:Handle.VType" />,
            </summary>
        
| F:Z0.MS.MetadataFlags.HandleType.VirtualBit       | 
            <summary>
            Use the highest bit to mark tokens that are virtual (synthesized).
            We create virtual tokens to represent projected WinMD entities.
            </summary>
        
| F:Z0.MS.MetadataFlags.HandleType.NonVirtualStringTypeMask| 
            <summary>
            In the case of string handles, the two lower bits that (in addition to the
            virtual bit not included in this mask) encode how to obtain the string value.
            </summary>
        
| F:Z0.MS.MetadataFlags.TokenTypeIds.VirtualBit     | 
            <summary>
            Use the highest bit to mark tokens that are virtual (synthesized).
            We create virtual tokens to represent projected WinMD entities.
            </summary>
        
| M:Z0.MS.MetadataFlags.TokenTypeIds.IsEntityOrUserStringToken(System.UInt32)| 
             <summary>
             Returns true if the token value can escape the metadata reader.
             We don't allow virtual tokens and heap tokens other than UserString to escape
             since the token type ids are internal to the reader and not specified by ECMA spec.
            
             Spec (Partition III, 1.9 Metadata tokens):
             Many CIL instructions are followed by a "metadata token". This is a 4-byte value, that specifies a row in a
             metadata table, or a starting byte offset in the User String heap.
            
             For example, a value of 0x02 specifies the TypeDef table; a value of 0x70 specifies the User
             String heap.The value corresponds to the number assigned to that metadata table (see Partition II for the full
             list of tables) or to 0x70 for the User String heap.The least-significant 3 bytes specify the target row within that
             metadata table, or starting byte offset within the User String heap.
             </summary>
        
| T:Z0.MS.ImmutableByteArrayInterop                 | 
             <summary>
             Provides tools for using <see cref="T:System.Collections.Immutable.ImmutableArray`1" /> in interop scenarios.
             </summary>
             <remarks>
             *** WARNING ***
            
             If you decide to copy this code elsewhere, please retain the documentation here
             and the Dangerous prefixes in the API names. This will help track down and audit
             other places where this technique (with dangerous consequences when misused) may
             be applied.
            
             A generic version of this API was once public in a pre-release of immutable
             collections, but  it was deemed to be too subject to abuse when available publicly.
            
             This implementation is scoped to byte arrays as that is all that the metadata reader needs.
            
             Also, since we don't have access to immutable collection internals, we use a trick involving
             overlapping a <see cref="T:System.Collections.Immutable.ImmutableArray`1" /> with an array reference. While
             unverifiable, it is valid. See ECMA-335, section II.10.7 Controlling instance layout:
            
             "It is possible to overlap fields in this way, though offsets occupied by an object reference
             shall not overlap with offsets occupied by a built-in value type or a part of
             another object reference. While one object reference can completely overlap another, this is
             unverifiable."
            
             Furthermore, the fact that <see cref="T:System.Collections.Immutable.ImmutableArray`1" /> backed by a single byte array
             field is something inherent to the design of ImmutableArray in order to get its performance
             characteristics and therefore something we (Microsoft) are comfortable defining as a contract that
             can be depended upon as below.
             </remarks>
        
| M:Z0.MS.ImmutableByteArrayInterop.DangerousCreateFromUnderlyingArray(System.Byte[]@)| 
            <summary>
            Creates a new instance of <see cref="T:System.Collections.Immutable.ImmutableArray`1" /> using a given mutable array as the backing
            field, without creating a defensive copy. It is the responsibility of the caller to ensure no other mutable
            references exist to the array.  Do not mutate the array after calling this method.
            </summary>
            <param name="array">The mutable array to use as the backing field. The incoming reference is set to null
            since it should not be retained by the caller.</param>
            <remarks>
            Users of this method should take extra care to ensure that the mutable array given as a parameter
            is never modified. The returned <see cref="T:System.Collections.Immutable.ImmutableArray`1" /> will use the given array as its backing
            field without creating a defensive copy, so changes made to the given mutable array will be observable
            on the returned <see cref="T:System.Collections.Immutable.ImmutableArray`1" />.  Instance and static methods of <see cref="T:System.Collections.Immutable.ImmutableArray`1" />
            and <see cref="T:System.Collections.Immutable.ImmutableArray" /> may malfunction if they operate on an <see cref="T:System.Collections.Immutable.ImmutableArray`1" /> instance
            whose underlying backing field is modified.
            </remarks>
            <returns>An immutable array.</returns>
        
| M:Z0.MS.ImmutableByteArrayInterop.DangerousGetUnderlyingArray(System.Collections.Immutable.ImmutableArray{System.Byte})| 
            <summary>
            Access the backing mutable array instance for the given <see cref="T:System.Collections.Immutable.ImmutableArray`1" />, without
            creating a defensive copy.  It is the responsibility of the caller to ensure the array is not modified
            through the returned mutable reference.  Do not mutate the returned array.
            </summary>
            <param name="array">The <see cref="T:System.Collections.Immutable.ImmutableArray`1" /> from which to retrieve the backing field.</param>
            <remarks>
            Users of this method should take extra care to ensure that the returned mutable array is never modified.
            The returned mutable array continues to be used as the backing field of the given <see cref="T:System.Collections.Immutable.ImmutableArray`1" />
            without creating a defensive copy, so changes made to the returned mutable array will be observable
            on the given <see cref="T:System.Collections.Immutable.ImmutableArray`1" />.  Instance and static methods of <see cref="T:System.Collections.Immutable.ImmutableArray`1" />
            and <see cref="T:System.Collections.Immutable.ImmutableArray" /> may malfunction if they operate on an <see cref="T:System.Collections.Immutable.ImmutableArray`1" /> instance
            whose underlying backing field is modified.
            </remarks>
            <returns>The underlying array, or null if <see cref="P:System.Collections.Immutable.ImmutableArray`1.IsDefault" /> is true.</returns>
        
| M:Z0.MS.MemoryBlock.PeekCompressedInteger(System.Int32,System.Int32@)| 
            <summary>
            Decodes a compressed integer value starting at offset.
            See Metadata Specification section II.23.2: Blobs and signatures.
            </summary>
            <param name="offset">Offset to the start of the compressed data.</param>
            <param name="numberOfBytesRead">Bytes actually read.</param>
            <returns>
            Value between 0 and 0x1fffffff, or <see cref="!:BlobReader.InvalidCompressedInteger" /> if the value encoding is invalid.
            </returns>
        
| M:Z0.MS.MemoryBlock.PeekUtf8NullTerminated(System.Int32,System.Byte[],System.Reflection.Metadata.MetadataStringDecoder,System.Int32@,System.Char)| 
            <summary>
            Read UTF8 at the given offset up to the given terminator, null terminator, or end-of-block.
            </summary>
            <param name="offset">Offset in to the block where the UTF8 bytes start.</param>
            <param name="prefix">UTF8 encoded prefix to prepend to the bytes at the offset before decoding.</param>
            <param name="utf8Decoder">The UTF8 decoder to use that allows user to adjust fallback and/or reuse existing strings without allocating a new one.</param>
            <param name="numberOfBytesRead">The number of bytes read, which includes the terminator if we did not hit the end of the block.</param>
            <param name="terminator">A character in the ASCII range that marks the end of the string.
            If a value other than '\0' is passed we still stop at the null terminator if encountered first.</param>
            <returns>The decoded string.</returns>
        
| M:Z0.MS.MemoryBlock.GetUtf8NullTerminatedLength(System.Int32,System.Int32@,System.Char)| 
            <summary>
            Get number of bytes from offset to given terminator, null terminator, or end-of-block (whichever comes first).
            Returned length does not include the terminator, but numberOfBytesRead out parameter does.
            </summary>
            <param name="offset">Offset in to the block where the UTF8 bytes start.</param>
            <param name="terminator">A character in the ASCII range that marks the end of the string.
            If a value other than '\0' is passed we still stop at the null terminator if encountered first.</param>
            <param name="numberOfBytesRead">The number of bytes read, which includes the terminator if we did not hit the end of the block.</param>
            <returns>Length (byte count) not including terminator.</returns>
        
| M:Z0.MS.MemoryBlock.BinarySearchForSlot(System.Int32,System.Int32,System.Int32,System.UInt32,System.Boolean)| 
            <summary>
            In a table that specifies children via a list field (e.g. TypeDef.FieldList, TypeDef.MethodList),
            searches for the parent given a reference to a child.
            </summary>
            <returns>Returns row number [0..RowCount).</returns>
        
| M:Z0.MS.MemoryBlock.BinarySearchReference(System.Int32,System.Int32,System.Int32,System.UInt32,System.Boolean)| 
            <summary>
            In a table ordered by a column containing entity references searches for a row with the specified reference.
            </summary>
            <returns>Returns row number [0..RowCount) or -1 if not found.</returns>
        
| M:Z0.MS.MemoryBlock.BinarySearchReferenceRange(System.Int32,System.Int32,System.Int32,System.UInt32,System.Boolean,System.Int32@,System.Int32@)| 
            <summary>
            Calculates a range of rows that have specified value in the specified column in a table that is sorted by that column.
            </summary>
        
| M:Z0.MS.MemoryBlock.BinarySearchReferenceRange(System.Int32[],System.Int32,System.Int32,System.UInt32,System.Boolean,System.Int32@,System.Int32@)| 
            <summary>
            Calculates a range of rows that have specified value in the specified column in a table that is sorted by that column.
            </summary>
        
| T:Z0.MS.ObjectPool`1                              | 
             <summary>
             Generic implementation of object pooling pattern with predefined pool size limit. The main
             purpose is that limited number of frequently used objects can be kept in the pool for
             further recycling.
            
             Notes:
             1) it is not the goal to keep all returned objects. Pool is not meant for storage. If there
                is no space in the pool, extra returned objects will be dropped.
            
             2) it is implied that if object was obtained from a pool, the caller will return it back in
                a relatively short time. Keeping checked out objects for long durations is ok, but
                reduces usefulness of pooling. Just new up your own.
            
             Not returning objects to the pool in not detrimental to the pool's work, but is a bad practice.
             Rationale:
                If there is no intent for reusing the object, do not use pool - just use "new".
             </summary>
        
| M:Z0.MS.ObjectPool`1.Allocate                     | 
            <summary>
            Produces an instance.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically
            reducing how far we will typically search.
            </remarks>
        
| M:Z0.MS.ObjectPool`1.Free(`0)                     | 
            <summary>
            Returns objects to the pool.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically
            reducing how far we will typically search in Allocate.
            </remarks>
        
| M:Z0.Reflex.type``1                               | 
            <summary>
            Produces the parametrically-identified reflected system type
            </summary>
            <typeparam name="T">The source type</typeparam>
        
