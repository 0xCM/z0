# ADCX - Unsigned Integer Addition of Two Operands with Carry Flag

## Description

Performs an unsigned addition of the destination operand (first operand), the source operand (second operand) and 
the carry-flag (CF) and stores the result in the destination operand. The destination operand is a general-purpose register, 
whereas the source operand can be a general-purpose register or memory location. The state of CF can represent a carry from 
a previous addition. The instruction sets the CF flag with the carry generated by the unsigned addition of the operands.

The ADCX instruction is executed in the context of multi-precision addition, where we add a series of operands with 
a carry-chain. At the beginning of a chain of additions, we need to make sure the CF is in a desired initial state. Often, 
this initial state needs to be 0, which can be achieved with an instruction to zero the CF (e.g. XOR).

This instruction is supported in real mode and virtual-8086 mode. The operand size is always 32 bits if not in 64-bit mode.

In 64-bit mode, the default operation size is 32 bits. Using a REX Prefix in the form of REX.R permits access to 
additional registers (R8-15). Using REX Prefix in the form of REX.W promotes operation to 64 bits.

ADCX executes normally either inside or outside a transaction region.

## Operation

IF OperandSize is 64-bit
    THEN CF:DEST[63:0] ← DEST[63:0] + SRC[63:0] + CF;
    ELSE CF:DEST[31:0] ← DEST[31:0] + SRC[31:0] + CF;
FI;

## Encoding
----------------------------------------------------------------------------------------------------------------------------
| Op/En | Operand 1        | Operand 2     | Operand 3 | Operand 4 |
| RM    | ModRM:reg (r, w) | ModRM:r/m (r) | NA        | NA        |

## Flags

CF is updated based on result. OF, SF, ZF, AF and PF flags are unmodified.

## Intel C/C++ Compiler Intrinsic Equivalent 

unsigned char _addcarryx_u32 (unsigned char c_in, unsigned int src1, unsigned int src2, unsigned int *sum_out);
unsigned char _addcarryx_u64 (unsigned char c_in, unsigned __int64 src1, unsigned __int64 src2, unsigned __int64 *sum_out);