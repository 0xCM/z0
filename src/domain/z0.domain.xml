<?xml version="1.0"?>
<doc>
    <assembly>
        <name>z0.domain</name>
    </assembly>
    <members>
        <member name="M:Z0.ApiCode.accepts(Z0.ApiCodeBlock,Z0.NumericKind)">
            <summary>
            Determines whether an operation accepts an argument of specified numeric kind
            </summary>
            <param name="src">The encoded operation</param>
            <param name="match">The kind to match</param>
        </member>
        <member name="M:Z0.ApiCode.arity(Z0.ApiCodeBlock)">
            <summary>
            Determines the arity of the encoded operation
            </summary>
            <param name="src">The encoded operation</param>
        </member>
        <member name="M:Z0.ApiCode.accepts(System.Collections.Generic.IEnumerable{Z0.ApiCodeBlock},Z0.NumericKind,Z0.NumericKind)">
            <summary>
            Excludes source operations that do not accept two parameters of specified numeric kind
            </summary>
            <param name="src">The data source</param>
            <param name="k1">The first parameter kind</param>
            <param name="k2">The second parameter kind</param>
        </member>
        <member name="P:Z0.ApiCodeBlockIndex.EntryCount">
            <summary>
            The number of indexed functions
            </summary>
        </member>
        <member name="P:Z0.ApiCodeBlockIndex.Locations">
            <summary>
            The base addresses that identify entries in the index
            </summary>
        </member>
        <member name="P:Z0.ApiCodeBlockIndex.MemberCode">
            <summary>
            All indexed code
            </summary>
        </member>
        <member name="P:Z0.ApiCodeBlockIndex.Identities">
            <summary>
            Operation identifiers, each of which are associated with one or more code blocks
            </summary>
        </member>
        <member name="P:Z0.ApiCodeBlockIndex.Hosts">
            <summary>
            Hosts with at least one archived code block
            </summary>
        </member>
        <member name="P:Z0.ApiCodeBlockIndex.NonemptyHosts">
            <summary>
            Hosts with at least one archived code block
            </summary>
        </member>
        <member name="M:Z0.BuildArchives.create(Z0.IWfShell,Z0.FS.FolderPath)">
            <summary>
            Creates an archive over the output of a build
            </summary>
            <param name="root">The archive root</param>
        </member>
        <member name="M:Z0.ModuleArchive.create(Z0.FS.FolderPath)">
            <summary>
            Creates an archive over both managed and unmanaged modules
            </summary>
            <param name="root">The archive root</param>
        </member>
        <member name="P:Z0.FixedBuffer`1.BufferAddress">
            <summary>
            Specifies the address of the buffer, not its content
            </summary>
        </member>
        <member name="T:Z0.BufferSegment`2">
            <summary>
            Defines a segment over a buffer
            </summary>
        </member>
        <member name="T:Z0.BufferSegments`1">
            <summary>
            Defines a segmented partition over a contiguous buffer
            </summary>
        </member>
        <member name="T:Z0.BufferSegment`1">
            <summary>
            Defines a segment over a buffer
            </summary>
        </member>
        <member name="T:Z0.IFixedBuffer`1">
            <summary>
            Characterizes a buffer with an invariant address
            </summary>
            <typeparam name="T">The buffer cell type</typeparam>
        </member>
        <member name="P:Z0.IFixedBuffer`1.BufferAddress">
            <summary>
            The buffer's address which should remain unchanged throughout its lifetime
            </summary>
            <value></value>
        </member>
        <member name="P:Z0.IFixedBuffer`1.CellCount">
            <summary>
            The number of cells held in the buffer
            </summary>
        </member>
        <member name="F:Z0.CpuBuffer.BufferSize">
            <summary>
            The number of bytes covered by the buffer
            </summary>
        </member>
        <member name="F:Z0.CpuBuffer.Buffer16">
            <summary>
            The number of 16-bit elements covered by the buffer
            </summary>
        </member>
        <member name="F:Z0.CpuBuffer.Buffer32">
            <summary>
            The number of 32-bit elements covered by the buffer
            </summary>
        </member>
        <member name="F:Z0.CpuBuffer.Buffer64">
            <summary>
            The number of 64-bit elements covered by the buffer
            </summary>
        </member>
        <member name="F:Z0.CpuBuffer.Buffer128">
            <summary>
            The number of 128-bit elements covered by the buffer
            </summary>
        </member>
        <member name="F:Z0.CpuBuffer.Buffer256">
            <summary>
            The number of 256-bit elements covered by the buffer
            </summary>
        </member>
        <member name="F:Z0.CpuBuffer.Buffer512">
            <summary>
            The number of 512-bit elements covered by the buffer
            </summary>
        </member>
        <member name="T:Z0.FixedBuffer256`1">
            <summary>
            A buffer that contains 256 <typeparamref name='T'/> cells
            </summary>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="T:Z0.CliAssemblyReference">
            <summary>
            Captures <see cref='T:System.Reflection.Metadata.AssemblyReference'/> data in usable form
            </summary>
        </member>
        <member name="T:Z0.CliManifestResourceInfo">
            <summary>
            Captures <see cref='T:System.Reflection.Metadata.ManifestResource'/> data in usable form
            </summary>
        </member>
        <member name="T:Z0.CliMethodDefinition">
            <summary>
            Captures <see cref='T:System.Reflection.Metadata.MethodDefinition'/> data in usable form
            </summary>
        </member>
        <member name="T:Z0.CliMethodImport">
            <summary>
            Captures <see cref='T:System.Reflection.Metadata.MethodImport'/> data in usable form
            </summary>
        </member>
        <member name="M:Z0.PeTableReader.open(Z0.FS.FilePath)">
            <summary>
            Allocates a <see cref='T:Z0.PeTableReader'/> for a specified file
            </summary>
            <param name="src">The source path</param>
        </member>
        <member name="T:Z0.LocatedImage">
            <summary>
            Describes a PE image from the perspective of process entry point
            </summary>
        </member>
        <member name="F:Z0.LocatedImage.ImagePath">
            <summary>
            The image source path
            </summary>
        </member>
        <member name="F:Z0.LocatedImage.PartId">
            <summary>
            The image part identifier, if any
            </summary>
        </member>
        <member name="F:Z0.LocatedImage.EntryAddress">
            <summary>
            The process entry point
            </summary>
        </member>
        <member name="F:Z0.LocatedImage.BaseAddress">
            <summary>
            The image's memory base
            </summary>
        </member>
        <member name="F:Z0.LocatedImage.Size">
            <summary>
            The image size
            </summary>
        </member>
        <member name="P:Z0.LocatedImage.Name">
            <summary>
            The <see cref='F:Z0.LocatedImage.ImagePath'/> filename without the extension
            </summary>
        </member>
        <member name="P:Z0.LocatedImage.EndAddress">
            <summary>
            The terminal address as determined by <see cref='F:Z0.LocatedImage.BaseAddress'/> + <see cref='F:Z0.LocatedImage.Size'/>
            </summary>
        </member>
        <member name="P:Z0.LocatedImage.Range">
            <summary>
            The memory range occupied by the image
            </summary>
        </member>
        <member name="F:Z0.LocatedImage`1.ImagePath">
            <summary>
            The image source path
            </summary>
        </member>
        <member name="F:Z0.LocatedImage`1.StartAddress">
            <summary>
            The address at which image data begins
            </summary>
        </member>
        <member name="F:Z0.LocatedImage`1.EndAddress">
            <summary>
            The address at which image data ends
            </summary>
        </member>
        <member name="M:Z0.ProcessImages.locate(System.Diagnostics.ProcessModule)">
            <summary>
            Creates a <see cref='T:Z0.LocatedImage'/> description from a specified <see cref='T:System.Diagnostics.ProcessModule'/>
            </summary>
            <param name="src">The source module</param>
        </member>
        <member name="M:Z0.ProcessImages.structured(System.Reflection.Assembly,System.String)">
            <summary>
            Searches for an embedded document with a matching identifier and, if found,
            returns the first match; otherwise returns an empty document
            </summary>
            <param name="match">The resource identifier to match</param>
        </member>
        <member name="T:Z0.CorSigParser">
            <summary>
            Defines a CLI signature parser
            </summary>
            <remarks>
            [CliSpec, II.23.2] The value of the first byte of a Signature 'blob' indicates what kind of Signature it is. Its lowest 4 bits hold one of the following:
            <see cref='F:Z0.Cor.CorUnmanagedCallingConvention.IMAGE_CEE_CS_CALLCONV_C'/>
            <see cref='F:Z0.Cor.CorCallingConvention.IMAGE_CEE_CS_CALLCONV_DEFAULT'/>
            <see cref='F:Z0.Cor.CorUnmanagedCallingConvention.IMAGE_CEE_UNMANAGED_CALLCONV_FASTCALL'/>
            <see cref='F:Z0.Cor.CorUnmanagedCallingConvention.IMAGE_CEE_CS_CALLCONV_STDCALL'/>
            <see cref='F:Z0.Cor.CorUnmanagedCallingConvention.IMAGE_CEE_CS_CALLCONV_THISCALL'/>
            <see cref='F:Z0.Cor.CorCallingConvention.IMAGE_CEE_CS_CALLCONV_VARARG'/>
            </remarks>
        </member>
        <member name="T:Z0.CorSigParser.MethodDef">
            <summary>
            Parses a method signature without VARARG
            </summary>
        </member>
        <member name="T:Z0.CorSigParser.MethodRef">
            <summary>
            Parses a method signature with VARARG calls
            </summary>
        </member>
        <member name="T:Z0.Cor">
            <summary>
            Transpiled from corhdr.h
            </summary>
        </member>
        <member name="T:Z0.Cor.CorElementType">
            <summary>
            Runtime element classifier
            </summary>
            <remarks>CLI spec, Partition II, section 23.1.16</remarks>
        </member>
        <member name="M:Z0.Signatures.duplicates(Z0.OpIdentity[])">
            <summary>
            Returns the duplicate identities found in the source stream, if any; otherwise, returns an empty array
            </summary>
            <param name="src">The identities to search for duplicates</param>
        </member>
        <member name="M:Z0.Signatures.define(System.String)">
            <summary>
            Defines an identity, bypassing validation
            </summary>
            <param name="src">The identity text</param>
        </member>
        <member name="M:Z0.Signatures.define(System.String,System.String,System.String,System.Boolean,System.Boolean,System.String[])">
            <summary>
            Defines an operation identifier with all aspects explicitly specified
            </summary>
            <param name="text">The identity text</param>
            <param name="name">The operation name</param>
            <param name="suffix">The operaion suffix</param>
            <param name="generic">The operation's generic status</param>
            <param name="imm">Specifies whether the operation requires one or more immediate values</param>
            <param name="components">The identity components</param>
        </member>
        <member name="M:Z0.Signatures.vsfunc(ApiClass,Z0.TypeWidth,Z0.NumericKind,System.Boolean)">
            <summary>
            Produces an identifier for a kinded vectorized structural function
            </summary>
            <param name="k">The operation kind id</param>
            <param name="w">The vector width</param>
            <param name="nk">The cell numeric kind</param>
            <param name="generic">Whether the produced identity has a generic marker</param>
        </member>
        <member name="M:Z0.Signatures.vsfunc``1(ApiClass,Z0.TypeWidth,``0,System.Boolean)">
            <summary>
            Produces an identifier for a kinded vectorized structural function
            </summary>
            <param name="k">The operation kind id</param>
            <param name="w">The vector width</param>
            <param name="nk">The cell numeric kind</param>
            <param name="generic">Whether the produced identity has a generic marker</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.Signatures.vsfunc``2(ApiClass,``0,``1,System.Boolean)">
            <summary>
            Produces an identifier for a kinded vectorized structural function
            </summary>
            <param name="k">The operation kind id</param>
            <param name="w">A vector width representative</param>
            <param name="t">A cell type representative</param>
            <param name="generic">Whether the produced identity has a generic marker</param>
            <typeparam name="W">The vector width type</typeparam>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.Signatures.sfunc``1(ApiClass,Z0.TypeWidth,``0,System.Boolean)">
            <summary>
            Produces an identifier for a kinded structural function of segmented type
            </summary>
            <param name="k">The operation kind id</param>
            <param name="w">A segment width representative</param>
            <param name="t">A cell type representative</param>
            <param name="generic">Whether the produced identity has a generic marker</param>
        </member>
        <member name="M:Z0.Signatures.sfunc``2(ApiClass,``0,``1,System.Boolean)">
            <summary>
            Produces an identifier for a kinded structural function of segmented type
            </summary>
            <param name="k">The operation kind id</param>
            <param name="w">A segment width representative</param>
            <param name="t">A cell type representative</param>
            <param name="generic">Whether the produced identity has a generic marker</param>
            <typeparam name="W">The width type</typeparam>
            <typeparam name="T">The numeric type</typeparam>
        </member>
        <member name="M:Z0.Signatures.sfunc``1(ApiClass,``0)">
            <summary>
            Produces an identifier for a kinded numeric structural function
            </summary>
            <param name="k">The operation kind id</param>
            <typeparam name="T">The numeric type</typeparam>
        </member>
        <member name="M:Z0.Signatures.sfunc(ApiClass,Z0.NumericKind)">
            <summary>
            Produces an identifier for a kinded numeric structural function
            </summary>
            <param name="k">The operation kind id</param>
            <param name="nk">The operation numeric kind</param>
        </member>
        <member name="M:Z0.Signatures.sfunc(ApiClass,Z0.TypeWidth,Z0.NumericKind,System.Boolean)">
            <summary>
            Produces an identifier for a kinded structural function of segmented type
            </summary>
            <param name="k">The operation kind id</param>
            <param name="w">A segment width representative</param>
            <param name="t">A cell type representative</param>
            <param name="generic">Whether the produced identity has a generic marker</param>
        </member>
        <member name="M:Z0.Signatures.NumericOp(ApiClass,Z0.NumericKind[])">
            <summary>
            Defines kinded identifiers for nongeneric numeric functions
            </summary>
            <param name="id">The operation kind id</param>
            <param name="kinds">The numeric argument kinds</param>
        </member>
        <member name="M:Z0.Signatures.numeric(Z0.NumericKind)">
            <summary>
            Defines a scalar type identity
            </summary>
            <param name="width">The scalar bit-width</param>
        </member>
        <member name="M:Z0.Signatures.numeric``1(ApiClass,``0,System.Boolean)">
            <summary>
            Produces an identifer for a kinded numeric operation
            </summary>
            <param name="k">The operation kind id</param>
            <param name="generic">Whether the produced identity has a generic marker</param>
            <typeparam name="T">The operation numeric kind</typeparam>
        </member>
        <member name="M:Z0.Signatures.segmented(Z0.OpIdentity,System.Int32)">
            <summary>
            Extracts an index-identified segmented identity part from an operation identity
            </summary>
            <param name="src">The source identity</param>
            <param name="index">The 0-based part index</param>
        </member>
        <member name="M:Z0.Signatures.segmented(System.String,Z0.TypeWidth,Z0.NumericKind)">
            <summary>
            Defines a segmented type identity predicated on type width numeric kind specifications
            </summary>
            <param name="name">The type name</param>
            <param name="wk">The width kind</param>
            <param name="nk">The numeric kind</param>
        </member>
        <member name="M:Z0.Signatures.resource(System.String,Z0.ITypeWidth,Z0.NumericKind)">
            <summary>
            Defines a type resource identity
            </summary>
            <param name="basename">The base name of the resource</param>
            <param name="w">The resource bit width</param>
            <param name="kind">The numeric kind of the resource</param>
        </member>
        <member name="M:Z0.Signatures.resource(System.String,Z0.ITypeWidth,Z0.ITypeWidth,Z0.NumericKind)">
            <summary>
            Defines a type resource identity
            </summary>
            <param name="basename">The base name of the resource</param>
            <param name="w1">The first bit width</param>
            <param name="w2">The second bit width</param>
            <param name="kind">The numeric kind of the resource</param>
        </member>
        <member name="M:Z0.Signatures.resource(System.String,Z0.ITypeNat,Z0.NumericKind)">
            <summary>
            Defines a type resource identity
            </summary>
            <param name="basename">The base name of the resource</param>
            <param name="w">The resource bit width</param>
            <param name="kind">The numeric kind of the resource</param>
        </member>
        <member name="M:Z0.Signatures.resource(System.String,Z0.ITypeNat,Z0.ITypeNat,Z0.NumericKind)">
            <summary>
            Defines a type resource identity
            </summary>
            <param name="basename">The base name of the resource</param>
            <param name="w1">The first bit width</param>
            <param name="w2">The second bit width</param>
            <param name="kind">The numeric kind of the resource</param>
        </member>
        <member name="M:Z0.Signatures.vgeneric``2(ApiClass,``0,``1)">
            <summary>
            Produces an identifier for a kinded generic vectorized operation
            </summary>
            <param name="k">The operation kind id</param>
            <param name="w">The vector operand width</param>
            <typeparam name="W">The vector operand width</typeparam>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.Signatures.vectorized(ApiClass,Z0.TypeWidth,Z0.NumericKind,System.Boolean)">
            <summary>
            Produces an identifier for a kinded vectorized operation
            </summary>
            <param name="k">The operation kind id</param>
            <param name="w">The vector operand width</param>
            <param name="nk">The vector cell kind</param>
            <param name="generic">Whether the produced identity has a generic marker</param>
        </member>
        <member name="M:Z0.Signatures.vdirect``1(ApiClass,Z0.TypeWidth,``0)">
            <summary>
            Produces an identifier for a kinded nongeneric vectorized operation
            </summary>
            <param name="k">The operation kind id</param>
            <param name="w">The vector operand width</param>
            <typeparam name="W">The vector operand width</typeparam>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.Signatures.vdirect``2(ApiClass,``0,``1)">
            <summary>
            Produces an identifier for a kinded nongeneric vectorized operation
            </summary>
            <param name="k">The operation kind id</param>
            <param name="w">The vector operand width</param>
            <typeparam name="W">The vector operand width</typeparam>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.Signatures.numeric(ApiClass,Z0.NumericKind,System.Boolean)" -->
        <member name="M:Z0.Signatures.NumericOp``1(System.String,Z0.NK{``0},System.Boolean)">
            <summary>
            Produces an identifier of the form {opname}_g{kind}{u | i | f}
            </summary>
            <param name="opname">The base operator name</param>
            <param name="t">A primal type representative</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.Signatures.WithoutGeneric(Z0.OpIdentity)">
            <summary>
            Disables the generic indicator
            </summary>
        </member>
        <member name="P:Z0.ToolArchive`1.ToolId">
            <summary>
            The tool identifier
            </summary>
        </member>
        <member name="P:Z0.ToolArchive`1.ToolOutput">
            <summary>
            The tool output directory
            </summary>
        </member>
        <member name="P:Z0.ToolArchive`1.Processed">
            <summary>
            The process root folder
            </summary>
        </member>
        <member name="T:Z0.ToolFlag">
            <summary>
            Reprents a tool command operand that accepts no arguments; the presence of a flag is the argument
            </summary>
        </member>
        <member name="T:Z0.ToolFlag`1">
            <summary>
            Reprents a tool command operand that accepts no arguments; the presence of a flag is the argument
            </summary>
        </member>
        <member name="F:Z0.ToolOption.Name">
            <summary>
            The option name
            </summary>
        </member>
        <member name="F:Z0.ToolOption.Value">
            <summary>
            The option value
            </summary>
        </member>
        <member name="M:Z0.Cmd.arg(System.String,System.String)">
            <summary>
            Defines a <see cref='T:Z0.CmdArg'/>
            </summary>
            <param name="name">The option name</param>
            <param name="value">The option value</param>
        </member>
        <member name="M:Z0.Cmd.arg``1(System.String,``0)">
            <summary>
            Defines a <see cref='T:Z0.CmdArg`1'/>
            </summary>
            <param name="name">The option identifier</param>
            <param name="value">The option value</param>
            <typeparam name="T">The option value type</typeparam>
        </member>
        <member name="M:Z0.Cmd.arg``2(``0,``1)">
            <summary>
            Defines a <see cref='T:Z0.CmdArg`2'/>
            </summary>
            <param name="kind"></param>
            <param name="value"></param>
            <typeparam name="K">The option kind</typeparam>
            <typeparam name="T">The option value type</typeparam>
        </member>
        <member name="M:Z0.Cmd.args(Z0.CmdArg[])">
            <summary>
            Creates a <see cref='T:Z0.CmdArgs'/> collection from an array
            </summary>
            <param name="src">The source array</param>
        </member>
        <member name="M:Z0.Cmd.data``1(Z0.CmdArg{``0}@)">
            <summary>
            Populates a <see cref='T:Z0.CmdArg'/> structure from a specified source
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The option value type</typeparam>
        </member>
        <member name="M:Z0.Cmd.data``1(Z0.CmdArg{``0}@,Z0.CmdArg@)">
            <summary>
            Populates a <see cref='T:Z0.CmdArg'/> structure from a specified source
            </summary>
            <param name="src">The data source</param>
            <param name="dst">The data target</param>
            <typeparam name="T">The option value type</typeparam>
        </member>
        <member name="M:Z0.Cmd.data``2(Z0.CmdArg{``0,``1}@)">
            <summary>
            Populates a <see cref='T:Z0.CmdArg'/> structure from a specified source
            </summary>
            <param name="src">The data source</param>
            <typeparam name="K">The option kind type</typeparam>
            <typeparam name="T">The option value type</typeparam>
        </member>
        <member name="M:Z0.Cmd.data``2(Z0.CmdArg{``0,``1}@,Z0.CmdArg@)">
            <summary>
            Populates a <see cref='T:Z0.CmdArg'/> structure from a specified source
            </summary>
            <param name="src">The data source</param>
            <param name="dst">The data target</param>
            <typeparam name="K">The option kind type</typeparam>
            <typeparam name="T">The option value type</typeparam>
        </member>
        <member name="M:Z0.Cmd.format(Z0.CmdArg@)">
            <summary>
            Renders a specified option as text
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.Cmd.format``1(Z0.CmdArg{``0}@)">
            <summary>
            Renders a specified option as text
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The option value type</typeparam>
        </member>
        <member name="M:Z0.Cmd.format``2(Z0.CmdArg{``0,``1}@)">
            <summary>
            Renders a specified option as text
            </summary>
            <param name="src">The data source</param>
            <typeparam name="K">The option kind</typeparam>
            <typeparam name="T">The option value type</typeparam>
        </member>
        <member name="M:Z0.Cmd.id(System.String)">
            <summary>
            Parses a <see cref='T:Z0.CmdId'/> from a command identifier
            </summary>
            <param name="src">The command identifier</param>
        </member>
        <member name="M:Z0.Cmd.pattern(System.String,System.String)">
            <summary>
            Creates a <see cref='T:Z0.CmdArgs'/> collection from an array
            </summary>
            <param name="src">The source array</param>
        </member>
        <member name="M:Z0.Cmd.process(Z0.IWfShell,Z0.CmdLine,Z0.CmdProcessOptions)">
            <summary>
            Creates a command process
            </summary>
            <param variable="commandLine">The command line to run as a subprocess</param>
            <param variable="options">Options for the process</param>
        </member>
        <member name="M:Z0.Cmd.script(System.String,System.Int32)">
            <summary>
            Allocates a <see cref='T:Z0.CmdScript'/> of specified length
            </summary>
            <param name="length">The script length</param>
        </member>
        <member name="M:Z0.Cmd.script(Z0.CmdExpr[])">
            <summary>
            Creates an anonymous <see cref='T:Z0.CmdScript'/> from a <see cref='T:Z0.CmdExpr'/> sequence
            </summary>
            <param name="src">The source expressions</param>
        </member>
        <member name="M:Z0.Cmd.script(System.String,Z0.CmdExpr[])">
            <summary>
            Creates an identifiable <see cref='T:Z0.CmdScript'/> from a <see cref='T:Z0.CmdExpr'/> sequence
            </summary>
            <param name="id">The identifier to assign</param>
            <param name="src">The source expressions</param>
        </member>
        <member name="M:Z0.Cmd.script(Z0.asci32@,Z0.CmdExpr[])">
            <summary>
            Creates an identifiable <see cref='T:Z0.CmdScript'/> from a <see cref='T:Z0.CmdExpr'/> sequence
            </summary>
            <param name="id">The identifier to assign</param>
            <param name="src">The source expressions</param>
        </member>
        <member name="M:Z0.Cmd.tool(Z0.ToolId,Z0.ToolFlag[])">
            <summary>
            Creates a <see cref='T:Z0.ToolSpec'/>
            </summary>
            <param name="tool">The tool identifier</param>
            <param name="flags"></param>
        </member>
        <member name="M:Z0.Cmd.toolid``1">
            <summary>
            Creates a parametrically-predicated tool identifier
            </summary>
            <typeparam name="T">The tool type</typeparam>
        </member>
        <member name="P:Z0.IToolArchive.ToolId">
            <summary>
            The identifier of the owning tool
            </summary>
        </member>
        <member name="P:Z0.IToolArchive.ToolOutput">
            <summary>
            The tool output directory
            </summary>
        </member>
        <member name="P:Z0.IToolArchive.Processed">
            <summary>
            The process root folder
            </summary>
        </member>
        <member name="P:Z0.IToolArchive`1.Owner">
            <summary>
            The tool that owns the archive
            </summary>
        </member>
        <member name="P:Z0.ICmdProcess.StartTime">
            <summary>
            Gets the time the process started.
            </summary>
        </member>
        <member name="P:Z0.ICmdProcess.HasExited">
            <summary>
            Gets a value indicating whether the process has exited.
            </summary>
        </member>
        <member name="P:Z0.ICmdProcess.ExitTime">
            <summary>
            Gets the time the processed Exited.  (HasExited should be <see langword="true"/> before calling)
            </summary>
        </member>
        <member name="P:Z0.ICmdProcess.Duration">
            <summary>
            Gets the duration of the command (HasExited should be <see langword="true"/> before calling)
            </summary>
        </member>
        <member name="P:Z0.ICmdProcess.ExitCode">
            <summary>
            Gets the process exit code for the subprocess.  (HasExited should be <see langword="true"/> before calling)
            Often this does not need to be checked because Command.Run will throw an exception
            if it is not zero.   However it is useful if the CommandOptions.NoThrow property
            was set.
            </summary>
        </member>
        <member name="P:Z0.ICmdProcess.Output">
            <summary>
            Gets the standard output and standard error output from the command.  This
            is accumulated in real time so it can vary if the process is still running.
            This property is NOT available if the CommandOptions.OutputFile or CommandOptions.OutputStream
            is specified since the output is being redirected there.   If a large amount of output is
            expected (> 1Meg), the Run.AddOutputStream(Stream) is recommended for retrieving it since
            the large string is never materialized at one time.
            </summary>
        </member>
        <member name="M:Z0.ICmdProcess.Wait">
            <summary>
            Wait for a started process to complete (HasExited will be <see langword="true"/> on return)
            </summary>
            <returns>Wait returns that 'this' pointer.</returns>
        </member>
        <member name="M:Z0.ICmdProcess.ThrowCommandFailure(System.String)">
            <summary>
            Throw a error if the command exited with a non-zero exit code
            printing useful diagnostic information along with the thrown message.
            This is useful when NoThrow is specified, and after post-processing
            you determine that the command really did fail, and an normal
            Command.Run failure was the appropriate action.
            </summary>
            <param name="message">An additional message to print in the throw.</param>
        </member>
        <member name="M:Z0.ICmdProcess.Kill">
            <summary>
            Kill the process (and any child processses (recursively) associated with the
            running command).   Note that it may not be able to kill everything it should
            if the child-parent' chain is broken by a child that creates a subprocess and
            then dies itself.   This is reasonably uncommon, however.
            </summary>
        </member>
        <member name="T:Z0.ArgPosKind">
            <summary>
            Defines argument position indicators for up to 7 arguments
            </summary>
        </member>
        <member name="F:Z0.ArgPosKind.Pos0">
            <summary>
            Identifies the first position
            </summary>
        </member>
        <member name="F:Z0.ArgPosKind.Pos1">
            <summary>
            Identifies the second position
            </summary>
        </member>
        <member name="F:Z0.ArgPosKind.Pos2">
            <summary>
            Identifies the third position
            </summary>
        </member>
        <member name="F:Z0.ArgPosKind.Pos3">
            <summary>
            Identifies the fourth position
            </summary>
        </member>
        <member name="F:Z0.ArgPosKind.Pos4">
            <summary>
            Identifies the fifth position
            </summary>
        </member>
        <member name="F:Z0.ArgPosKind.Pos5">
            <summary>
            Identifies the sixth position
            </summary>
        </member>
        <member name="F:Z0.ArgPosKind.Pos6">
            <summary>
            Identifies the seventh position
            </summary>
        </member>
        <member name="F:Z0.ArgValidityState.Valid">
            <summary>
            Indicates that a valid argument was supplied
            </summary>
        </member>
        <member name="F:Z0.ArgValidityState.Invalid">
            <summary>
            Indicates that an invalid argument was supplied
            </summary>
        </member>
        <member name="F:Z0.ArgValidityState.Pos0">
            <summary>
            The position indicator for the first argument
            </summary>
        </member>
        <member name="F:Z0.ArgValidityState.Pos1">
            <summary>
            The position indicator for a second argument
            </summary>
        </member>
        <member name="F:Z0.ArgValidityState.Pos2">
            <summary>
            The position indicator for a third argument
            </summary>
        </member>
        <member name="F:Z0.ArgValidityState.Pos3">
            <summary>
            The position indicator for a fourth argument
            </summary>
        </member>
        <member name="F:Z0.ArgValidityState.Pos4">
            <summary>
            The position indicator for a fifth argument
            </summary>
        </member>
        <member name="F:Z0.ArgValidityState.Pos5">
            <summary>
            The position indicator for a sixth argument
            </summary>
        </member>
        <member name="F:Z0.ArgValidityState.Pos6">
            <summary>
            The position indicator for a seventh argument
            </summary>
        </member>
        <member name="F:Z0.ArgValidityState.NonNull">
            <summary>
            Requires an argument to be non-null
            </summary>
        </member>
        <member name="F:Z0.ArgValidityState.NonNeg">
            <summary>
            Requires an argument to be non-negative
            </summary>
        </member>
        <member name="F:Z0.ArgValidityState.Z">
            <summary>
            Requires an argument or consraint to have a zero evaluation
            </summary>
        </member>
        <member name="F:Z0.ArgValidityState.Nz">
            <summary>
            Requires an argument or consraint to have a nonzero evaluation
            </summary>
        </member>
        <member name="F:Z0.ArgValidityState.Eq">
            <summary>
            Specifies that an equality constraint was unsatisfied
            </summary>
        </member>
        <member name="F:Z0.ArgValidityState.NEq">
            <summary>
            Specifies that a non-equality constraint was unsatisfied
            </summary>
        </member>
        <member name="F:Z0.ArgValidityState.Lt">
            <summary>
            Requires satisfaction of a less-than constraint
            </summary>
        </member>
        <member name="F:Z0.ArgValidityState.NLt">
            <summary>
            Requires satisfaction of a not less-than constraint
            </summary>
        </member>
        <member name="F:Z0.ArgValidityState.Gt">
            <summary>
            Requires satisfaction of a greater than constraint
            </summary>
        </member>
        <member name="F:Z0.ArgValidityState.NGt">
            <summary>
            Requires satisfaction of a not greater than constraint
            </summary>
        </member>
        <member name="F:Z0.ArgValidityState.LtEq">
            <summary>
            Requires satisfaction of a less than or equal to constraint
            </summary>
        </member>
        <member name="F:Z0.ArgValidityState.NLtEq">
            <summary>
            Requires satisfaction of a not than or equal to constraint
            </summary>
        </member>
        <member name="F:Z0.ArgValidityState.GtEq">
            <summary>
            Requires satisfaction of a greater than or equal to constraint
            </summary>
        </member>
        <member name="F:Z0.ArgValidityState.NGtEq">
            <summary>
            Requires satisfaction of a not greater than or equal to constraint
            </summary>
        </member>
        <member name="T:Z0.ArgValidityStatus">
            <summary>
            Gives boolean form to a validity state
            </summary>
        </member>
        <member name="F:Z0.ArgValidityStatus.Valid">
            <summary>
            Indicates a valid state
            </summary>
        </member>
        <member name="F:Z0.ArgValidityStatus.Invalid">
            <summary>
            Indicates an invalid state
            </summary>
        </member>
        <member name="T:Z0.CmdArgPos">
            <summary>
            Captures a 0-based argument index
            </summary>
        </member>
        <member name="T:Z0.CmdArgValidity">
            <summary>
            Captures argument validation outcome
            </summary>
        </member>
        <member name="P:Z0.CmdArgValidity.State">
            <summary>
            The validation result
            </summary>
        </member>
        <member name="M:Z0.CmdArgValidity.require(System.Boolean,Z0.ArgValidityState)">
            <summary>
            Requires invariant satisfaction
            </summary>
            <param name="invariant">The outcome of invariant evaluation</param>
            <param name="failed">The state to yield if the invariant does not hold</param>
        </member>
        <member name="T:Z0.CmdLine">
            <summary>
            Captures the content of a command-line
            </summary>
        </member>
        <member name="F:Z0.ToolCmdSpec.ToolPath">
            <summary>
            The path to the tool executable
            </summary>
        </member>
        <member name="F:Z0.ToolCmdSpec.Args">
            <summary>
            The arguments to pass to the tool
            </summary>
        </member>
        <member name="F:Z0.ToolCmdSpec.WorkingDir">
            <summary>
            The working folder, if any
            </summary>
        </member>
        <member name="F:Z0.ToolCmdSpec.Vars">
            <summary>
            Environment variables to use, if any
            </summary>
        </member>
        <member name="M:Z0.CmdLogger.Log(Z0.LogLevel,System.Object[])">
            <summary>
            Log a line of text to the logging file, with string.Format arguments.
            </summary>
        </member>
        <member name="M:Z0.CmdLogger.Log(Z0.LogLevel,System.String)">
            <summary>
            Log a line of text to the logging file.
            </summary>
            <param name="kind">The message kind</param>
            <param name="content">The message content</param>
        </member>
        <member name="T:Z0.CmdProcessOptions">
            <summary>
            CommandOptions is a helper class for the Command class.  It stores options
            that affect the behavior of the execution of ETWCommands and is passes as a
            parapeter to the constuctor of a Command.
            It is useful for these options be be on a separate class (rather than
            on Command itself), because it is reasonably common to want to have a set
            of options passed to several commands, which is not easily possible otherwise.
            </summary>
        </member>
        <member name="F:Z0.CmdProcessOptions.Infinite">
            <summary>
            Can be assigned to the Timeout Property to indicate infinite timeout.
            </summary>
        </member>
        <member name="M:Z0.CmdProcessOptions.#ctor">
            <summary>
            CommanOptions holds a set of options that can be passed to the constructor
            to the Command Class as well as Command.Run*.
            </summary>
        </member>
        <member name="M:Z0.CmdProcessOptions.Clone">
            <summary>
            Return a copy an existing set of command options.
            </summary>
            <returns>The copy of the command options.</returns>
        </member>
        <member name="P:Z0.CmdProcessOptions.NoThrow">
            <summary>
            Normally commands will throw if the subprocess returns a non-zero
            exit code.  NoThrow suppresses this.
            </summary>
        </member>
        <member name="M:Z0.CmdProcessOptions.AddNoThrow">
            <summary>
            Updates the NoThrow property and returns the updated commandOptions.
            <returns>Updated command options</returns>
            </summary>
        </member>
        <member name="P:Z0.CmdProcessOptions.Start">
            <summary>
            ShortHand for UseShellExecute and NoWait.
            </summary>
        </member>
        <member name="M:Z0.CmdProcessOptions.AddStart">
            <summary>
            Updates the Start property and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Z0.CmdProcessOptions.UseShellExecute">
            <summary>
            Normally commands are launched with CreateProcess.  However it is
            also possible use the Shell Start API.  This causes Command to look
            up the executable differently.
            </summary>
        </member>
        <member name="M:Z0.CmdProcessOptions.AddUseShellExecute">
            <summary>
            Updates the Start property and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Z0.CmdProcessOptions.NoWindow">
            <summary>
            Indicates that you want to hide any new window created.
            </summary>
        </member>
        <member name="M:Z0.CmdProcessOptions.AddNoWindow">
            <summary>
            Updates the NoWindow property and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Z0.CmdProcessOptions.Elevate">
            <summary>
            Gets or sets a value indicating whether the command must run at elevated Windows privledges (causes a new command window).
            </summary>
        </member>
        <member name="M:Z0.CmdProcessOptions.AddElevate">
            <summary>
            Updates the Elevate property and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Z0.CmdProcessOptions.Timeout">
            <summary>
            By default commands have a 10 minute timeout (600,000 msec), If this
            is inappropriate, the Timeout property can change this.  Like all
            timouts in .NET, it is in units of milliseconds, and you can use
            CommandOptions.Infinite to indicate no timeout.
            </summary>
        </member>
        <member name="M:Z0.CmdProcessOptions.AddTimeout(System.Int32)">
            <summary>
            Updates the Timeout property and returns the updated commandOptions.
            CommandOptions.Infinite can be used for infinite.
            </summary>
        </member>
        <member name="P:Z0.CmdProcessOptions.Input">
            <summary>
            Indicates the string will be sent to Console.In for the subprocess.
            </summary>
        </member>
        <member name="M:Z0.CmdProcessOptions.AddInput(System.String)">
            <summary>
            Updates the Input property and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Z0.CmdProcessOptions.CurrentDirectory">
            <summary>
            Indicates the current directory the subProcess will have.
            </summary>
        </member>
        <member name="M:Z0.CmdProcessOptions.AddCurrentDirectory(System.String)">
            <summary>
            Updates the CurrentDirectory property and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Z0.CmdProcessOptions.OutputFile">
            <summary>
            Indicates the standard output and error of the command should be redirected
            to a archiveFile rather than being stored in Memory in the 'Output' property of the
            command.
            </summary>
        </member>
        <member name="M:Z0.CmdProcessOptions.AddOutputFile(System.String)">
            <summary>
            Updates the OutputFile property and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Z0.CmdProcessOptions.OutputStream">
            <summary>
            Indicates the standard output and error of the command should be redirected
            to a a TextWriter rather than being stored in Memory in the 'Output' property
            of the command.
            </summary>
        </member>
        <member name="M:Z0.CmdProcessOptions.AddOutputStream(System.IO.TextWriter)">
            <summary>
            Updates the OutputStream property and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Z0.CmdProcessOptions.EnvironmentVariables">
            <summary>
            Gets the Environment variables that will be set in the subprocess that
            differ from current process's environment variables.  Any time a string
            of the form %VAR% is found in a value of a environment variable it is
            replaced with the value of the environment variable at the time the
            command is launched.  This is useful for example to update the PATH
            environment variable eg. "%PATH%;someNewPath".
            </summary>
        </member>
        <member name="M:Z0.CmdProcessOptions.AddEnvironmentVariable(System.String,System.String)">
            <summary>
            Adds the environment variable with the give value to the set of
            environment variables to be passed to the sub-process and returns the
            updated commandOptions.   Any time a string
            of the form %VAR% is found in a value of a environment variable it is
            replaced with the value of the environment variable at the time the
            command is launched.  This is useful for example to update the PATH
            environment variable eg. "%PATH%;someNewPath".
            </summary>
        </member>
        <member name="T:Z0.CmdProcess">
            <summary>
            Command represents a running of a command lineNumber process.  It is basically
            a wrapper over System.Diagnostics.Process, which hides the complexity
            of System.Diagnostics.Process, and knows how to capture output and otherwise
            makes calling commands very easy.
            </summary>
        </member>
        <member name="M:Z0.CmdProcess.create(Z0.CmdLine,Z0.CmdProcessOptions)">
            <summary>
            Run 'commandLine' as a subprocess
            Output is captured and placed in the 'Output' property of the returned Command
            structure.
            </summary>
            <param variable="commandLine">The command lineNumber to run as a subprocess</param>
            <param variable="options">Additional qualifiers that control how the process is run</param>
            <returns>A Command structure that can be queried to determine ExitCode, Output, etc.</returns>
        </member>
        <member name="P:Z0.CmdProcess.Options">
            <summary>
            Gets that CommandOptions structure that holds all the options that affect
            the running of the command (like Timeout, Input ...)
            </summary>
        </member>
        <member name="P:Z0.CmdProcess.Process">
            <summary>
            Gets the underlying process object.  Generally not used.
            </summary>
        </member>
        <member name="P:Z0.CmdProcess.StartTime">
            <summary>
            Gets the time the process started.
            </summary>
        </member>
        <member name="P:Z0.CmdProcess.HasExited">
            <summary>
            Gets a value indicating whether the process has exited.
            </summary>
        </member>
        <member name="P:Z0.CmdProcess.ExitTime">
            <summary>
            Gets the time the processed Exited.  (HasExited should be <see langword="true"/> before calling)
            </summary>
        </member>
        <member name="P:Z0.CmdProcess.Duration">
            <summary>
            Gets the duration of the command (HasExited should be <see langword="true"/> before calling)
            </summary>
        </member>
        <member name="P:Z0.CmdProcess.ProcessId">
            <summary>
            Gets the operating system ID for the subprocess.
            </summary>
        </member>
        <member name="P:Z0.CmdProcess.ExitCode">
            <summary>
            Gets the process exit code for the subprocess.  (HasExited should be <see langword="true"/> before calling)
            Often this does not need to be checked because Command.Run will throw an exception
            if it is not zero.   However it is useful if the CommandOptions.NoThrow property
            was set.
            </summary>
        </member>
        <member name="P:Z0.CmdProcess.Output">
            <summary>
            Gets the standard output and standard error output from the command.  This
            is accumulated in real time so it can vary if the process is still running.
            This property is NOT available if the CommandOptions.OutputFile or CommandOptions.OutputStream
            is specified since the output is being redirected there.   If a large amount of output is
            expected (> 1Meg), the Run.AddOutputStream(Stream) is recommended for retrieving it since
            the large string is never materialized at one time.
            </summary>
        </member>
        <member name="M:Z0.CmdProcess.#ctor(Z0.CmdLine,Z0.CmdProcessOptions)">
            <summary>
            Launch a new command and returns the Command object that can be used to monitor
            the restult.  It does not wait for the command to complete, however you
            can call 'Wait' to do that, or use the 'Run' or 'RunToConsole' methods. */
            </summary>
            <param variable="commandLine">The command lineNumber to run as a subprocess</param>
            <param variable="options">Additional qualifiers that control how the process is run</param>
            <returns>A Command structure that can be queried to determine ExitCode, Output, etc.</returns>
        </member>
        <member name="M:Z0.CmdProcess.#ctor(System.String)">
            <summary>
            Create a subprocess to run 'commandLine' with no special options.
            <param variable="commandLine">The command lineNumber to run as a subprocess</param>
            </summary>
        </member>
        <member name="M:Z0.CmdProcess.Wait">
            <summary>
            Wait for a started process to complete (HasExited will be <see langword="true"/> on return)
            </summary>
            <returns>Wait returns that 'this' pointer.</returns>
        </member>
        <member name="M:Z0.CmdProcess.ThrowCommandFailure(System.String)">
            <summary>
            Throw a error if the command exited with a non-zero exit code
            printing useful diagnostic information along with the thrown message.
            This is useful when NoThrow is specified, and after post-processing
            you determine that the command really did fail, and an normal
            Command.Run failure was the appropriate action.
            </summary>
            <param name="message">An additional message to print in the throw.</param>
        </member>
        <member name="M:Z0.CmdProcess.Kill">
            <summary>
            Kill the process (and any child processses (recursively) associated with the
            running command).   Note that it may not be able to kill everything it should
            if the child-parent' chain is broken by a child that creates a subprocess and
            then dies itself.   This is reasonably uncommon, however.
            </summary>
        </member>
        <member name="M:Z0.CmdProcess.Quote(System.String)">
            <summary>
            Put double quotes around 'str' if necessary (handles quotes quotes.
            </summary>
        </member>
        <member name="M:Z0.CmdProcess.FindOnPath(System.String)">
            <summary>
            Given a string 'commandExe' look for it on the path the way cmd.exe would.
            Returns <see langword="null"/> if it was not found.
            </summary>
        </member>
        <member name="T:Z0.MemoryIndexMetrics">
            <summary>
            Collects statistics of encoded data known to a <see cref='T:Z0.ApiCodeBlockIndex'/>
            </summary>
        </member>
        <member name="M:Z0.DataLayouts.width(System.ReadOnlySpan{Z0.DataLayout})">
            <summary>
            Computes the aggregate width of a <see cref='T:Z0.DataLayout'/> sequence
            </summary>
            <param name="src">The source sequence</param>
        </member>
        <member name="M:Z0.DataLayouts.width(System.ReadOnlySpan{Z0.LayoutPartition})">
            <summary>
            Computes the aggregate width of a <see cref='T:Z0.LayoutPartition'/> sequence
            </summary>
            <param name="src">The source sequence</param>
        </member>
        <member name="M:Z0.DataLayouts.width``1(System.ReadOnlySpan{Z0.LayoutPartition{``0}})">
            <summary>
            Computes the aggregate width of a <see cref='T:Z0.LayoutPartition`1'/> sequence
            </summary>
            <param name="src">The source sequence</param>
            <typeparam name="T">The partition kind</typeparam>
        </member>
        <member name="T:Z0.BitFieldIndex">
            <summary>
            Defines a sequence of contiguous bitfield segments
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Z0.LayoutIdentity" -->
        <!-- Badly formed XML comment ignored for member "T:Z0.LayoutIdentity`1" -->
        <member name="P:Z0.LayoutPartition.Id">
            <summary>
            Defines enclosure-relative partition identity
            </summary>
        </member>
        <member name="P:Z0.LayoutPartition.Index">
            <summary>
            The enclosure-relative partition index
            </summary>
        </member>
        <member name="T:Z0.LayoutPartition`1">
            <summary>
            Defines a <typeparamref name='T'/> kinded segment partition
            </summary>
        </member>
        <member name="P:Z0.LayoutPartition`1.Index">
            <summary>
            The enclosure-relative partition index
            </summary>
        </member>
        <member name="P:Z0.LayoutPartition`1.Left">
            <summary>
            The inclusive lower index
            </summary>
        </member>
        <member name="P:Z0.LayoutPartition`1.Right">
            <summary>
            The inclusive upper index
            </summary>
        </member>
        <member name="P:Z0.LayoutPartition`1.Width">
            <summary>
            The partition width determined by <see cref='P:Z0.LayoutPartition`1.Right'/> - <see cref='P:Z0.LayoutPartition`1.Left'/>
            </summary>
        </member>
        <member name="T:Z0.LayoutRange">
            <summary>
            Defines the range of a layout segment
            </summary>
        </member>
        <member name="F:Z0.LayoutRange.Left">
            <summary>
            The postion of the least-significant bit
            </summary>
        </member>
        <member name="F:Z0.LayoutRange.Right">
            <summary>
            The postion of the most-significant bit
            </summary>
        </member>
        <member name="T:Z0.Credits">
            <summary>
            Defines document reference specification operations
            </summary>
        </member>
        <member name="M:Z0.Credits.define(Z0.CreditTypes.Vendor,Z0.CreditTypes.Volume,Z0.CreditTypes.Chapter,Z0.CreditTypes.Section,Z0.CreditTypes.Topic,Z0.ContentRef)">
            <summary>
            Defines a reference to a topic in a chapter
            </summary>
            <param name="v">The document vendor</param>
            <param name="vol">The referenced volume</param>
            <param name="c">The referenced chapter</param>
            <param name="s">The referenced section</param>
            <param name="t">The referenced topic</param>
        </member>
        <member name="M:Z0.Credits.define(Z0.CreditTypes.Vendor,Z0.CreditTypes.Volume,Z0.CreditTypes.Appendix,Z0.CreditTypes.Section,Z0.CreditTypes.Topic,Z0.ContentRef)">
            <summary>
            Defines a reference to a topic in an appendix
            </summary>
            <param name="v">The document vendor</param>
            <param name="vol">The referenced volume</param>
            <param name="a">The referenced appendix</param>
            <param name="s">The referenced section</param>
            <param name="t">The referenced topic</param>
        </member>
        <member name="M:Z0.Credits.define(Z0.CreditTypes.Vendor,Z0.CreditTypes.Volume,Z0.CreditTypes.Division,Z0.CreditTypes.Section,Z0.CreditTypes.Topic,Z0.ContentRef)">
            <summary>
            Defines a reference to a topic in either a chapter or appendix
            </summary>
            <param name="v">The document vendor</param>
            <param name="vol">The referenced volume</param>
            <param name="d">The referenced chapter or appendix</param>
            <param name="s">The referenced section</param>
            <param name="t">The referenced topic</param>
        </member>
        <member name="M:Z0.Credits.vendor(Z0.DocRef)">
            <summary>
            Extracts the Vendor segment value
            </summary>
            <param name="src">The bitfield source</param>
        </member>
        <member name="M:Z0.Credits.vendor(Z0.CreditTypes.Vendor)">
            <summary>
            Initializes an empty bitfield with a Vendor segment value
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.Credits.volume(Z0.DocRef)">
            <summary>
            Extracts the Volume segment value
            </summary>
            <param name="src">The bitfield source</param>
        </member>
        <member name="M:Z0.Credits.volume(Z0.CreditTypes.Volume)">
            <summary>
            Initializes an empty bitfield with a Volume segment value
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.Credits.division(Z0.DocRef)">
            <summary>
            Extracts the Division segment value
            </summary>
            <param name="src">The bitfield source</param>
        </member>
        <member name="M:Z0.Credits.division(Z0.CreditTypes.Division)">
            <summary>
            Initializes an empty bitfield with a Division segment value
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.Credits.chapter(Z0.DocRef)">
            <summary>
            Extracts the Chapter segment value
            </summary>
            <param name="src">The bitfield source</param>
        </member>
        <member name="M:Z0.Credits.chapter(Z0.CreditTypes.Chapter)">
            <summary>
            Initializes an empty bitfield with a Chapter segment value
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.Credits.appendix(Z0.DocRef)">
            <summary>
            Extracts the Appendix segment value
            </summary>
            <param name="src">The bitfield source</param>
        </member>
        <member name="M:Z0.Credits.appendix(Z0.CreditTypes.Appendix)">
            <summary>
            Initializes an empty bitfield with an Appendix segment value
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.Credits.section(Z0.DocRef)">
            <summary>
            Extracts the Section segment value
            </summary>
            <param name="src">The bitfield source</param>
        </member>
        <member name="M:Z0.Credits.section(Z0.CreditTypes.Section)">
            <summary>
            Initializes an empty bitfield with a Section segment value
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.Credits.topic(Z0.DocRef)">
            <summary>
            Extracts the Topic segment value
            </summary>
            <param name="src">The bitfield source</param>
        </member>
        <member name="M:Z0.Credits.topic(Z0.CreditTypes.Topic)">
            <summary>
            Initializes an empty bitfield with a Topic segment value
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="T:Z0.ContentRef">
            <summary>
            Defines a reference to specialized content within a document, such as figures and tables
            that often, as a flagrant display of idiocy, have numbering schemes that are content-type
            independent and even document-location independent
            </summary>
        </member>
        <member name="P:Z0.ContentRef.Level0">
            <summary>
            The level-0 content number
            </summary>
        </member>
        <member name="P:Z0.ContentRef.Level1">
            <summary>
            The level-1 content number (if any)
            </summary>
        </member>
        <member name="P:Z0.ContentRef.Level2">
            <summary>
            The level-2 content number (if any)
            </summary>
        </member>
        <member name="P:Z0.ContentRef.ContentType">
            <summary>
            The type of referenced content
            </summary>
        </member>
        <member name="T:Z0.DocRef">
            <summary>
            Defines a reference to document content
            </summary>
        </member>
        <member name="T:Z0.CreditTypes.Appendix">
            <summary>
            Defines appendix reference component values
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Appendix.AppendixA">
            <summary>
            Appendix A
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Appendix.AppendixB">
            <summary>
            Appendix B
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Appendix.AppendixC">
            <summary>
            Appendix C
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Appendix.AppendixD">
            <summary>
            Appendix D
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Appendix.AppendixE">
            <summary>
            Appendix E
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Appendix.AppendixF">
            <summary>
            Appendix F
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Appendix.AppendixG">
            <summary>
            Appendix G
            </summary>
        </member>
        <member name="T:Z0.CreditTypes.Chapter">
            <summary>
            Defines chapter reference component values
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Chapter.Chapter1">
            <summary>
            Chapter 1
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Chapter.Chapter2">
            <summary>
            Chapter 2
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Chapter.Chapter3">
            <summary>
            Chapter 3
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Chapter.Chapter4">
            <summary>
            Chapter 4
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Chapter.Chapter5">
            <summary>
            Chapter 5
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Chapter.Chapter6">
            <summary>
            Chapter 6
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Chapter.Chapter7">
            <summary>
            Chapter 7
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Chapter.Chapter8">
            <summary>
            Chapter 8
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Chapter.Chapter9">
            <summary>
            Chapter 9
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Chapter.Chapter10">
            <summary>
            Chapter 10
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Chapter.Chapter11">
            <summary>
            Chapter 11
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Chapter.Chapter12">
            <summary>
            Chapter a2
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Chapter.Chapter13">
            <summary>
            Chapter 13
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Chapter.Chapter14">
            <summary>
            Chapter 14
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Chapter.Chapter15">
            <summary>
            Chapter 15
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Chapter.Chapter16">
            <summary>
            Chapter 16
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Chapter.Chapter17">
            <summary>
            Chapter 17
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Chapter.Chapter18">
            <summary>
            Chapter 18
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Chapter.Chapter19">
            <summary>
            Chapter 19
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Chapter.Chapter20">
            <summary>
            Chapter 20
            </summary>
        </member>
        <member name="T:Z0.CreditTypes.ContentField">
            <summary>
            Defines literals that isolate content reference components
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.ContentField.SegWidth">
            <summary>
            Defines the (uniform) bitfield segment width
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.ContentField.L0">
            <summary>
            Defines the L0 bitfield segment
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.ContentField.L1">
            <summary>
            Defines the L1 bitfield segment
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.ContentField.L2">
            <summary>
            Defines the L2 bitfield segment
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.ContentField.Type">
            <summary>
            Defines the Type bitfield segment
            </summary>
        </member>
        <member name="T:Z0.CreditTypes.ContentLevel">
            <summary>
            Defines level hierarchy component values
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.ContentLevel.L0">
            <summary>
            type: [a].b.c
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.ContentLevel.L1">
            <summary>
            type: a.[b].c
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.ContentLevel.L2">
            <summary>
            type: a.b.[c]
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.ContentLevel.Type">
            <summary>
            [type]: a.b.c
            </summary>
        </member>
        <member name="T:Z0.CreditTypes.ContentNumber">
            <summary>
            Defines level-relative content number components
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.ContentNumber.d1">
            <summary>
            1, decimal
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.ContentNumber.d2">
            <summary>
            2, decimal
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.ContentNumber.d3">
            <summary>
            3, decimal
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.ContentNumber.d4">
            <summary>
            4, decimal
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.ContentNumber.d5">
            <summary>
            5, decimal
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.ContentNumber.d6">
            <summary>
            6, decimal
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.ContentNumber.d7">
            <summary>
            7, decimal
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.ContentNumber.d8">
            <summary>
            8, decimal
            </summary>
        </member>
        <member name="T:Z0.CreditTypes.ContentType">
            <summary>
            Defines content type classifiers, and occupies at most 3 bits
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.ContentType.Text">
            <summary>
            Text content
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.ContentType.Table">
            <summary>
            A table
            </summary>
        </member>
        <member name="T:Z0.CreditTypes.Division">
            <summary>
            Defines division reference component values
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Division.Chapter1">
            <summary>
            Chapter 1
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Division.Chapter2">
            <summary>
            Chapter 2
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Division.Chapter3">
            <summary>
            Chapter 3
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Division.Chapter4">
            <summary>
            Chapter 4
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Division.Chapter5">
            <summary>
            Chapter 5
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Division.Chapter6">
            <summary>
            Chapter 6
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Division.Chapter7">
            <summary>
            Chapter 7
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Division.Chapter8">
            <summary>
            Chapter 8
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Division.Chapter9">
            <summary>
            Chapter 9
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Division.Chapter10">
            <summary>
            Chapter 10
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Division.Chapter11">
            <summary>
            Chapter 11
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Division.Chapter12">
            <summary>
            Chapter 12
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Division.Chapter13">
            <summary>
            Chapter 13
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Division.Chapter14">
            <summary>
            Chapter 14
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Division.Chapter15">
            <summary>
            Chapter 15
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Division.AppendixA">
            <summary>
            Appendix A
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Division.AppendixB">
            <summary>
            Appendix B
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Division.AppendixC">
            <summary>
            Appendix C
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Division.AppendixD">
            <summary>
            Appendix D
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Division.AppendixE">
            <summary>
            Appendix E
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Division.AppendixF">
            <summary>
            Appendix F
            </summary>
        </member>
        <member name="T:Z0.CreditTypes.DocField">
            <summary>
            Defines literals that isolate reference components
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.DocField.SegWidth">
            <summary>
            Defines the (uniform) bitfield segment width
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.DocField.Vendor">
            <summary>
            Defines the Vendor bitfield segment
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.DocField.Volume">
            <summary>
            Defines the Volume bitfield segment
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.DocField.Division">
            <summary>
            Defines the Division bitfield segment
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.DocField.Chapter">
            <summary>
            Defines the Chapter bitfield segment
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.DocField.Appendix">
            <summary>
            Defines the Appendix bitfield segment
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.DocField.Section">
            <summary>
            Defines the Section bitfield segment
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.DocField.Topic">
            <summary>
            Defines the Topic bitfield segment
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.DocField.Content">
            <summary>
            Defines the Content bitfield segment
            </summary>
        </member>
        <member name="T:Z0.CreditTypes.DocFieldDelimiter">
            <summary>
            Defines document field parts
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.DocFieldDelimiter.Vendor">
            <summary>
            The vendor component
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.DocFieldDelimiter.Volume">
            <summary>
            The volume component
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.DocFieldDelimiter.Division">
            <summary>
            The Division component
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.DocFieldDelimiter.Chapter">
            <summary>
            The Chapter component
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.DocFieldDelimiter.Appendix">
            <summary>
            The Appendix component
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.DocFieldDelimiter.Section">
            <summary>
            The Section component
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.DocFieldDelimiter.Topic">
            <summary>
            The Topic component
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.DocFieldDelimiter.Content">
            <summary>
            The content reference component
            </summary>
        </member>
        <member name="T:Z0.CreditTypes.Section">
            <summary>
            Defines section reference component values
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Section.Section1">
            <summary>
            Chapter/appendix section 1
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Section.Section2">
            <summary>
            Chapter/appendix section 2
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Section.Section3">
            <summary>
            Chapter/appendix section 3
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Section.Section4">
            <summary>
            Chapter/appendix section 4
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Section.Section5">
            <summary>
            Chapter/appendix section 5
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Section.Section6">
            <summary>
            Chapter/appendix section 6
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Section.Section7">
            <summary>
            Chapter/appendix section 7
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Section.Section8">
            <summary>
            Chapter/appendix section 8
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Section.Section9">
            <summary>
            Chapter/appendix section 9
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Section.Section10">
            <summary>
            Chapter/appendix section 10
            </summary>
        </member>
        <member name="T:Z0.CreditTypes.Topic">
            <summary>
            Defines topic reference component values
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Topic.Topic1">
            <summary>
            Section topic 1
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Topic.Topic2">
            <summary>
            Section topic 2
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Topic.Topic3">
            <summary>
            Section topic 3
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Topic.Topic4">
            <summary>
            Section topic 4
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Topic.Topic5">
            <summary>
            Section topic 5
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Topic.Topic6">
            <summary>
            Section topic 6
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Topic.Topic7">
            <summary>
            Section topic 7
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Topic.Topic8">
            <summary>
            Section topic 8
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Topic.Topic9">
            <summary>
            Section topic 9
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Topic.Topic10">
            <summary>
            Section topic 10
            </summary>
        </member>
        <member name="T:Z0.CreditTypes.Vendor">
            <summary>
            Defines vendor reference component values
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Vendor.Intel">
            <summary>
            Intel documentation
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Vendor.Amd">
            <summary>
            AMD documentation
            </summary>
        </member>
        <member name="T:Z0.CreditTypes.Volume">
            <summary>
            Defines volume reference component values
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Volume.V1">
            <summary>
            Volume 1
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Volume.V2">
            <summary>
            Volume 2
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Volume.V3">
            <summary>
            Volume 3
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Volume.V4">
            <summary>
            Volume 4
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Volume.V5">
            <summary>
            Volume 5
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Volume.V6">
            <summary>
            Volume 6
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Volume.V7">
            <summary>
            Volume 7
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Volume.Vol1">
            <summary>
            Volume 1
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Volume.Vol2A">
            <summary>
            Volume 2A
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Volume.Vol2B">
            <summary>
            Volume 2B
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Volume.Vol2C">
            <summary>
            Volume 2C
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Volume.Vol2D">
            <summary>
            Volume 2D
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Volume.Vol3A">
            <summary>
            Volume 3A
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Volume.Vol3B">
            <summary>
            Volume 3B
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Volume.Vol3C">
            <summary>
            Volume 3C
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Volume.Vol4">
            <summary>
            Volume 4
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Volume.VPA">
            <summary>
            Volume Part A
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Volume.VPB">
            <summary>
            Volume Part B
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Volume.VPC">
            <summary>
            Volume Part C
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Volume.VPD">
            <summary>
            Volume Part D
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.Volume.VPE">
            <summary>
            Volume Part E
            </summary>
        </member>
        <member name="T:Z0.CreditTypes.VolumePart">
            <summary>
            Defines volume segmentation classes
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.VolumePart.VA">
            <summary>
            Volume part A
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.VolumePart.VB">
            <summary>
            Volume part B
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.VolumePart.VC">
            <summary>
            Volume part C
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.VolumePart.VD">
            <summary>
            Volume part D
            </summary>
        </member>
        <member name="F:Z0.CreditTypes.VolumePart.VE">
            <summary>
            Volume part E
            </summary>
        </member>
        <member name="T:Z0.EventEmitter`1">
            <summary>
            Base type for event type-specific event originators
            </summary>
        </member>
        <member name="T:Z0.FsmFx.InputReceipt`1">
            <summary>
            Delegate for event that fires when an input event has been received
            </summary>
            <param name="input">The input event</param>
            <typeparam name="E">The input event type</typeparam>
        </member>
        <member name="T:Z0.FsmFx.Transitioned`1">
            <summary>
            Delegate for event that fires when a state transition occurs
            </summary>
            <param name="source">The source/antecedent state</param>
            <param name="target">The target state</param>
            <typeparam name="S">The state type</typeparam>
        </member>
        <member name="T:Z0.FsmFx.Completed">
            <summary>
            Delegate for event that fires when a machine attains endstate
            </summary>
            <param name="endstate"></param>
            <param name="asPlanned"></param>
            <typeparam name="S"></typeparam>
        </member>
        <member name="T:Z0.FsmFx.MachineError">
            <summary>
            Delegate for error event
            </summary>
            <param name="error">The trapped exception</param>
        </member>
        <member name="T:Z0.FsmFx.StateEntry`2">
            <summary>
            Delegate that fires upon state entry
            </summary>
            <param name="entry"></param>
            <typeparam name="S">The state type</typeparam>
            <typeparam name="A">The action type</typeparam>
        </member>
        <member name="T:Z0.FsmFx.StateExit`2">
            <summary>
            Delegate that fires upon state exit
            </summary>
            <param name="entry"></param>
            <typeparam name="S">The state type</typeparam>
            <typeparam name="A">The action type</typeparam>
        </member>
        <member name="T:Z0.Heartbeat">
            <summary>
            Captures an instant in time with respect to a server/agent
            </summary>
        </member>
        <member name="F:Z0.Heartbeat.ServerId">
            <summary>
            The originating server
            </summary>
        </member>
        <member name="F:Z0.Heartbeat.AgentId">
            <summary>
            The originating agent
            </summary>
        </member>
        <member name="F:Z0.Heartbeat.Timestamp">
            <summary>
            Represents the time at which the event originated
            </summary>
        </member>
        <member name="T:Z0.IntrinsicEvents">
            <summary>
            Defines identifiers for intrinsic system events
            </summary>
        </member>
        <member name="M:Z0.SystemEventWriter.Receive(Z0.PulseEvent)">
            <summary>
            Writes a system heartbeat event
            </summary>
            <param name="e">The event to write</param>    
        </member>
        <member name="T:Z0.PulseEmitter">
            <summary>
            Produces a periodic pulse event
            </summary>
        </member>
        <member name="T:Z0.PulseEmitterConfig">
            <summary>
            Defines configuration parameters for pulse emission
            </summary>
        </member>
        <member name="P:Z0.PulseEmitterConfig.Frequency">
            <summary>
            Specifies the emission frequency
            </summary>
        </member>
        <member name="T:Z0.PulseEvent">
            <summary>
            Represents a pulse/tick/heartbeat relative to some frequency
            </summary>
        </member>
        <member name="T:Z0.SourcedEvent">
            <summary>
            Identifies an application-level/logical event
            </summary>
        </member>
        <member name="T:Z0.SourcedEventEmitter">
            <summary>
            Defines base type for event originators
            </summary>
        </member>
        <member name="T:Z0.SourcedEvent`1">
            <summary>
            Represents an application-level/logical event with which data specific to an event class is associated
            </summary>
        </member>
        <member name="F:Z0.SourcedEvent`1.Payload">
            <summary>
            Data specific to an event class
            </summary>
        </member>
        <member name="M:Z0.SourcedEvent`1.materialize(System.Span{System.Byte})">
            <summary>
            Reconstitutes an event from a sequence of bytes
            </summary>
        </member>
        <member name="M:Z0.SourcedEvent`1.Serialize">
            <summary>
            Renders the event as a sequence of bytes
            </summary>
        </member>
        <member name="T:Z0.DelimitedSplitter`1">
            <summary>
            Partitions T-cell sequences predicated on a supplied delimiter
            </summary>
        </member>
        <member name="M:Z0.TableContentProvider.structured(System.String)">
            <summary>
            Searches for an embedded document with a matching identifier and, if found,
            returns the first match; otherwise returns an empty document
            </summary>
            <param name="match">The resource identifier to match</param>
        </member>
        <member name="M:Z0.Generate.BitSetGenerator.TypeNameLiteral(System.Byte,System.Byte)">
            <summary>
            Generates public const string TypeName = "B{m}{n}";
            </summary>
            <param name="m"></param>
            <param name="n"></param>
        </member>
        <member name="M:Z0.Generate.BitSetGenerator.ValueNameLiteral(System.Byte,System.Byte)">
            <summary>
            Generates: public const string ValueName = "b{m}{n}";
            </summary>
            <param name="m"></param>
            <param name="n"></param>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Z0.ProjectModel.OpenTagFormat" -->
        <!-- Badly formed XML comment ignored for member "F:Z0.ProjectModel.CloseTagFormat" -->
        <!-- Badly formed XML comment ignored for member "F:Z0.ProjectModel.TagFormat" -->
        <member name="T:Z0.ProjectFile">
            <summary>
            Represents a path to a file that defines a project
            </summary>
        </member>
        <member name="T:Z0.BuildVersion">
            <summary>
            Defines a symver-aligned build/publication version specifier
            </summary>
        </member>
        <member name="T:Z0.FormatPattern">
            <summary>
            Captures an untyped format pattern
            </summary>
        </member>
        <member name="T:Z0.FormatPattern`1">
            <summary>
            Captures an untyped format pattern
            </summary>
        </member>
        <member name="T:Z0.FormatPattern`2">
            <summary>
            Captures an untyped format pattern
            </summary>
        </member>
        <member name="T:Z0.FormatPattern`3">
            <summary>
            Captures an untyped format pattern
            </summary>
        </member>
        <member name="T:Z0.FormatSlot">
            <summary>
            Represents a slot within a format pattern
            </summary>
        </member>
        <member name="T:Z0.FormatSlot`1">
            <summary>
            Represents a slot within a format pattern
            </summary>
        </member>
        <member name="T:Z0.FileEmission">
            <summary>
            Defines a file emission payload
            </summary>
        </member>
        <member name="P:Z0.FileEmission.Target">
            <summary>
            The emission target
            </summary>
        </member>
        <member name="F:Z0.EmitStringRecordsStep.PartCount">
            <summary>
            The number of processed parts
            </summary>
        </member>
        <member name="F:Z0.EmitStringRecordsStep.EmissionCount">
            <summary>
            The number of emitted records after the run step has completed
            </summary>
        </member>
        <member name="T:Z0.IntelIntrinsicsDoc.Parameter">
            <summary>
            [parameter type="unsigned char" varname="c_in" etype="UI8"]
            </summary>
        </member>
        <member name="T:Z0.IntelIntrinsicsDoc.Return">
            <summary>
            [return type="unsigned char" varname="c_in" etype="UI8"]
            </summary>
        </member>
        <member name="T:Z0.IntelIntrinsicsDoc.instruction">
            <summary>
            [instruction name="ADCX" form="r32, r32" xed="ADCX_GPR32d_GPR32d"
            </summary>
        </member>
        <member name="T:Z0.IntelIntrinsicsDoc.intrinsic">
            <summary>
            [intrinsic tech="Other" name="_addcarryx_u32">]
            </summary>
        </member>
        <member name="T:Z0.IntelIntrinsicsDocReader">
            <summary>
            [intrinsics_list version="3.5.3" date="06/30/2020">]
            </summary>
        </member>
        <member name="T:Z0.AgentEventId">
            <summary>
            Defines logical event identity
            </summary>
        </member>
        <member name="F:Z0.AgentEventId.ServerId">
            <summary>
            The originating server
            </summary>
        </member>
        <member name="F:Z0.AgentEventId.AgentId">
            <summary>
            The originating agent
            </summary>
        </member>
        <member name="F:Z0.AgentEventId.Timestamp">
            <summary>
            Represents the time at which the event originated
            </summary>
        </member>
        <member name="F:Z0.AgentEventId.EventKind">
            <summary>
            The event classifier/discriminator
            </summary>        
        </member>
        <member name="M:Z0.AgentEventId.define(System.UInt32,System.UInt32,System.UInt64,System.UInt64)">
            <summary>
            Constructs an event identity from a (kind,server,agent,time) tuple
            </summary>
            <param name="loc">The location of occurence</param>
            <param name="time">The time of occurrence</param>
            <param name="kind">The kind of event that occurred</param>
        </member>
        <member name="P:Z0.AgentEventId.Origin">
            <summary>
            Specifies the spacetime event origin
            </summary>
        </member>
        <member name="T:Z0.AgentEventOrigin">
            <summary>
            Captures an instant in time with respect to a server/agent,
            real or simulated
            </summary>
        </member>
        <member name="F:Z0.AgentEventOrigin.Location">
            <summary>
            Uniquely identifies the logical event source
            </summary>
        </member>
        <member name="F:Z0.AgentEventOrigin.Timestamp">
            <summary>
            The time of occurrence, expressed as number of elapsed ticks 
            from some fixed point in time
            </summary>
        </member>
        <member name="M:Z0.AgentEventOrigin.op_Implicit(System.ValueTuple{System.UInt64,System.UInt64})~Z0.AgentEventOrigin">
            <summary>
            Constructs an origin from an ordered pair of location and timestamp
            </summary>
            <param name="loc">The location of occurrence</param>
            <param name="time">The time of occurrence</param>
        </member>
        <member name="M:Z0.AgentEventOrigin.op_Implicit(System.ValueTuple{System.UInt32,System.UInt32,System.UInt64})~Z0.AgentEventOrigin">
            <summary>
            Constructs an origin from an ordered triple of server, agent and timestamp
            </summary>
            <param name="loc">The location of occurrence</param>
            <param name="time">The time of occurrence</param>
        </member>
        <member name="P:Z0.AgentEventOrigin.Server">
            <summary>
            The originating server
            </summary>
        </member>
        <member name="P:Z0.AgentEventOrigin.Agent">
            <summary>
            The originating agent / application
            </summary>
        </member>
        <member name="T:Z0.IAgentControl">
            <summary>
            Defines a means by which agents can be queried and directed
            </summary>
        </member>
        <member name="T:Z0.IServerEvent">
            <summary>
            Bears witness to an occurrence of something of identifiable interest
            at a unique point in spacetime. The (Location,Timestamp,EventKind) triplet
            confers upon the event a logical identity that identifies it across all spacetime.
            The implicit invariant that this construct confers upon an event source, which has
            a fixed location, is that the source many not produce two events of the same kind
            at the same moment in time, relative to timestamp resolution
            </summary>
        </member>
        <member name="P:Z0.IServerEvent.Identity">
            <summary>
            Identifies a system event with respect to time/space/subject
            </summary>
        </member>
        <member name="P:Z0.IServerEvent.EventKind">
            <summary>
            Specifies an event classifier that can be used to aggregate/distinguish sorts of events
            </summary>
        </member>
        <member name="P:Z0.IServerEvent.ServerId">
            <summary>
            Identifies the server that originated the event
            </summary>
        </member>
        <member name="P:Z0.IServerEvent.AgentId">
            <summary>
            Identifies the server-owned agent that originated the event
            </summary>
        </member>
        <member name="P:Z0.IServerEvent.LocationId">
            <summary>
            A value that uniquely identifies the logical event source, predicated
            on server and agent identity
            </summary>
        </member>
        <member name="P:Z0.IServerEvent.Timestamp">
            <summary>
            The time of occurrence, expressed as number of elapsed units
            from some fixed point in time
            </summary>
        </member>
        <member name="T:Z0.IEventEmitter">
            <summary>
            Characterizes an event orignator
            </summary>
        </member>
        <member name="T:Z0.ISystemAgent">
            <summary>
            Characterizes a thread of control with independent volition
            </summary>
        </member>
        <member name="P:Z0.ISystemAgent.ServerId">
            <summary>
            Identifies the server on which the agent is executing
            </summary>
        </member>
        <member name="P:Z0.ISystemAgent.AgentId">
            <summary>
            Identifies the agent relative to the hosting server
            </summary>
        </member>
        <member name="M:Z0.ISystemAgent.Start">
            <summary>
            Starts agent execution
            </summary>
        </member>
        <member name="M:Z0.ISystemAgent.Stop">
            <summary>
            Stops agent execution
            </summary>
        </member>
        <member name="P:Z0.ISystemAgent.State">
            <summary>
            The agent state
            </summary>
        </member>
        <member name="E:Z0.ISystemAgent.StateChanged">
            <summary>
            Signals when the agents transitions from its current state to a different state
            </summary>
        </member>
        <member name="P:Z0.ISystemAgent.Identity">
            <summary>
            The global agent identity
            </summary>
            <param name="agent">The agent</param>
        </member>
        <member name="T:Z0.AgentIdentity">
            <summary>
            Uniquely identifies an agent throughout a server complex
            </summary>
        </member>
        <member name="F:Z0.AgentIdentity.ServerId">
            <summary>
            Uniquely identifies a server
            </summary>
        </member>
        <member name="F:Z0.AgentIdentity.AgentId">
            <summary>
            Identifies an agent relative to a server
            </summary>
        </member>
        <member name="P:Z0.AgentIdentity.Identifier">
            <summary>
            Uniquely identifies an agent by composing the host on which it resides
            and the host-relative identifier
            </summary>
        </member>
        <member name="M:Z0.AgentIdentity.op_Implicit(System.ValueTuple{System.UInt32,System.UInt32})~Z0.AgentIdentity">
            <summary>
            Constructs an identity from server and agent id's
            </summary>
            <param name="loc">The location of occurence</param>
            <param name="time">The time of occurrence</param>
        </member>
        <member name="T:Z0.AgentStatus">
            <summary>
            Defines canonical states in the lifecycle of an agent
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Z0.AgentStatus.Created" -->
        <member name="F:Z0.AgentStatus.Configuring">
            <summary>
            The state in which the agent is consuming configuration data and adusting
            internal state accordingly and, upon successful completion, transitions to the
            <see cref='F:Z0.AgentStatus.Configured'/> state
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Z0.AgentStatus.Configured" -->
        <!-- Badly formed XML comment ignored for member "F:Z0.AgentStatus.Starting" -->
        <member name="F:Z0.AgentStatus.Started">
            <summary>
            The state in which the agent has been initialized and, once entered, immediately transitions to
            the <see cref='F:Z0.AgentStatus.Running'/> state unless the agent is configured to be inactive; if inactive,
            the agent remains in this state until the agent receives an administrative-level event
            that specifies the next state
            </summary>
        </member>
        <member name="F:Z0.AgentStatus.Running">
            <summary>
            The state in which the agent is working, querying for work or listening to events that define/imply
            work. The agent will remain in this state until a stop event is received, an unrecoverable eror
            occurs or other.
            </summary>
        </member>
        <member name="F:Z0.AgentStatus.Stopping">
            <summary>
            The state in which the agent is gracefully terminating the run-loop
            </summary>
        </member>
        <member name="T:Z0.AgentTransition">
            <summary>
            Specifies a transition that occurred 
            </summary>
        </member>
        <member name="F:Z0.AgentTransition.Agent">
            <summary>
            Specifies the agent that experienced the transition
            </summary>
        </member>
        <member name="F:Z0.AgentTransition.Timestamp">
            <summary>
            Indicates the relative time at which the transition ocurred
            </summary>
        </member>
        <member name="F:Z0.AgentTransition.SourceState">
            <summary>
            Specifies the state of the agent before the transition
            </summary>
        </member>
        <member name="F:Z0.AgentTransition.TargetState">
            <summary>
            Specifies the state of the agent ater the transition
            </summary>
        </member>
        <member name="T:Z0.AgentContext">
            <summary>
            Defines a shared context for a set of agents
            </summary>
        </member>
        <member name="T:Z0.ServerAgent">
            <summary>
            Defines a logical server
            </summary>
        </member>
        <member name="T:Z0.ServerComplex">
            <summary>
            Agent that manages a collection of servers
            </summary>
        </member>
        <member name="M:Z0.ServerComplex.Start(Z0.AgentContext)">
            <summary>
            Starts a new complex or returns the existing complex
            </summary>
            <param name="context">The context that the complex will inherit</param>
            <param name="servers"></param>
        </member>
        <member name="T:Z0.ServerConfig">
            <summary>
            Defines a server configuration record
            </summary>
        </member>
        <member name="F:Z0.ServerConfig.ServerId">
            <summary>
            Identifes the server to which the configuration applies
            </summary>        
        </member>
        <member name="F:Z0.ServerConfig.ServerName">
            <summary>
            A descriptive name
            </summary>
        </member>
        <member name="F:Z0.ServerConfig.CoreNumber">
            <summary>
            The CPU core to which the server is assigned
            </summary>
        </member>
        <member name="T:Z0.ServerProcess">
            <summary>
            Responsible for managing agents owned by a server
            </summary>
        </member>
        <member name="M:Z0.ServerProcess.create(Z0.IAgentContext,System.UInt32,System.UInt32,Z0.ISystemAgent[])">
            <summary>
            Creates and configures, but does not start, a server process
            </summary>
            <param name="Context">The context to which the server process will be assigned</param>
            <param name="ServerId">The server id</param>
            <param name="ServerAgents">The agents to be managed on behalf of the server</param>
        </member>
        <member name="P:Z0.ServerProcess.ServerAgents">
            <summary>
            Exposes a readonly stream of the agents under management on behalf of the server
            </summary>
        </member>
        <member name="M:Z0.ServiceIdentityPool.NextAgentId(System.UInt32)">
            <summary>
            Retrieves the next server-relative agent identity
            </summary>
            <param name="ServerId">The owning server</param>
        </member>
        <member name="M:Z0.ServiceIdentityPool.NextServerId">
            <summary>
            Retrieves the next server id 
            </summary>
        </member>
        <member name="T:Z0.SystemAgent">
            <summary>
            Defines base system agent abstraction
            </summary>
        </member>
        <member name="P:Z0.SystemAgent.ServerId">
            <summary>
            Identifies the server to which the agent belongs
            </summary>
        </member>
        <member name="P:Z0.SystemAgent.AgentId">
            <summary>
            Identifies the agent relative to the server
            </summary>
            <remarks>
            There are three special cases to note:
            1. The server itself is a service agent and will always be assigned and Id of 0
            2. The server process, which more or less serves the same role as the Windows SCM,
            is always assigned an agent id of 1
            3. The server complex, which serves as the bounding box for synthetic servers, agents,
            etc, is also a service agent. It will be assigned UInt32.MaxValue which will be considered
            an invalid id for any other agent
            </remarks>
        </member>
        <member name="P:Z0.SystemAgent.State">
            <summary>
            Specifies the current agent status
            </summary>
        </member>
        <member name="M:Z0.SystemAgent.Terminate">
            <summary>
            Terminates the agent,releasing any captured resources
            </summary>
        </member>
        <member name="M:Z0.SystemAgent.Configure(System.Object)">
            <summary>
            Configures the agent prior to a run
            </summary>
            <param name="config">The agent-specific configuration data</param>
        </member>
        <member name="M:Z0.SystemAgent.Start">
            <summary>
            Starts the agent from a running state
            </summary>
        </member>
        <member name="M:Z0.SystemAgent.Stop">
            <summary>
            Starts the agent from a stopped state
            </summary>
        </member>
        <member name="M:Z0.SystemAgent.Dispose">
            <summary>
            Terminates the agent
            </summary>
        </member>
        <member name="M:Z0.SystemAgent.OnStart">
            <summary>
            May be specialized to perform service-specific initialization/precondition operations
            </summary>
        </member>
        <member name="M:Z0.SystemAgent.OnTerminate">
            <summary>
            May be specialized to perform service-specific cleanup/postcondition operations
            </summary>
        </member>
        <member name="P:Z0.IFsmActionRule`1.Action">
            <summary>
            The action invoked
            </summary>
        </member>
        <member name="P:Z0.IFsmActionRule`2.Source">
            <summary>
            The state upon which the rule is predicated
            </summary>
        </member>
        <member name="T:Z0.IFsmContext">
            <summary>
            Defines context specialization for FSM
            </summary>
        </member>
        <member name="T:Z0.IFsmEventRule`1">
            <summary>
             Characterizes a state machine rule predicated wholly or in part on an input event
            </summary>
        </member>
        <member name="P:Z0.IFsmEventRule`1.Trigger">
            <summary>
            The triggering event
            </summary>
        </member>
        <member name="T:Z0.IFsmFunc">
            <summary>
            Characterizes a state machine partial function
            </summary>
        </member>
        <member name="T:Z0.IFsmRule`2">
            <summary>
             Characterizes a state machine rule predicated on an input event and source state
            </summary>
            <typeparam name="E">The input event type</typeparam>
            <typeparam name="S">The source state</typeparam>
        </member>
        <member name="P:Z0.IFsmRule`2.Key">
            <summary>
            The rule key for hash-based lookups
            </summary>
        </member>
        <member name="T:Z0.IFsmStateRule`1">
            <summary>
             Characterizes a state machine rule predicated wholly or in part on a source state
            </summary>
        </member>
        <member name="P:Z0.IFsmStateRule`1.Source">
            <summary>
            The source state
            </summary>
        </member>
        <member name="T:Z0.IOutputRule`3">
            <summary>
             Characterizes a rule of the form (input : E, source : S) -> output : S 
            </summary>
            <typeparam name="S">The state type</typeparam>
            <typeparam name="O">The output type</typeparam>
        </member>
        <member name="P:Z0.IOutputRule`3.Output">
            <summary>
            The output produced
            </summary>
        </member>
        <member name="P:Z0.IRuleKey`2.Trigger">
            <summary>
            The triggering event
            </summary>
        </member>
        <member name="P:Z0.IRuleKey`2.Source">
            <summary>
            The source state
            </summary>
        </member>
        <member name="T:Z0.ITransitionRule`2">
            <summary>
             Characterizes a rule of the form (input : E, source : S) -> target : S 
            </summary>
            <typeparam name="E">The input event type</typeparam>
            <typeparam name="S">The source state</typeparam>
        </member>
        <member name="P:Z0.ITransitionRule`2.Target">
            <summary>
            The target state
            </summary>
        </member>
        <member name="M:Z0.Fsm.context(Z0.IPolyrand,System.Nullable{System.UInt64})">
            <summary>
            Creates a machine context
            </summary>
            <param name="random">The random source</param>
        </member>
        <member name="M:Z0.Fsm.primal``1(System.String,``0,``0,``0,``0,System.UInt64)">
            <summary>
            Defines a primal state machine
            </summary>
            <param name="classifier">An identifier that defines a membership class that is propagaged to all machines predicated on the specification</param>
            <param name="states">The number of states the machine will support</param>
            <param name="events">The number of events the machine will recognize</param>
            <param name="minSamples">The minimum number of events that will be sampled for each state</param>
            <param name="maxSamples">The maximum number of events that will be sampled for each state</param>
            <param name="maxReceipts">The maximum number of events that the machine will accept</param>
            <typeparam name="T">A scalar type of sufficient size to accommodate specified characteristics</typeparam>
        </member>
        <member name="M:Z0.Fsm.create``1(Z0.PrimalFsmSpec{``0},System.UInt64,System.UInt64)">
            <summary>
            Creates a primal FSM according to a supplied spec with a specified random seed and stream index
            </summary>
            <param name="spec">The FSM definition</param>
            <param name="seed">The rng seed</param>
            <param name="index">The rng stream index</param>
            <typeparam name="T">The primal fsm type</typeparam>
        </member>
        <member name="M:Z0.Fsm.create``1(Z0.IWfShell,Z0.PrimalFsmSpec{``0},System.UInt64,System.UInt64)">
            <summary>
            Creates a primal FSM according to a supplied spec with a specified random seed and stream index
            </summary>
            <param name="spec">The FSM definition</param>
            <param name="seed">The rng seed</param>
            <param name="index">The rng stream index</param>
            <typeparam name="T">The primal fsm type</typeparam>
        </member>
        <member name="M:Z0.Fsm.create``1(Z0.IWfShell,Z0.IPolyrand,Z0.PrimalFsmSpec{``0})">
            <summary>
            Creates a primal FSM according to a supplied spec with a specified random seed and stream index
            </summary>
            <param name="spec">The FSM definition</param>
            <typeparam name="T">The primal fsm type</typeparam>
        </member>
        <member name="M:Z0.Fsm.run``1(Z0.PrimalFsmSpec{``0},System.Int32,System.Boolean)">
            <summary>
            Executes one or more primal state machines
            </summary>
            <param name="spec">The FSM spec that determines machine characteristics </param>
            <param name="machineCount">The number of machines to execute</param>
            <param name="sequential">Specifies whether the machines will be executed sequentially</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.Fsm.concurrent``1(Z0.PrimalFsmSpec{``0},System.Span{System.UInt64},System.Span{System.UInt64})">
            <summary>
            Executes the specified machines concurrently
            </summary>
            <param name="spec">The machine definition</param>
            <param name="seeds">The rng seeds that determine initial states of the randomizers</param>
            <param name="indices">The rng stream position indices</param>
            <typeparam name="T">The primal FSM type</typeparam>
        </member>
        <member name="M:Z0.Fsm.sequential``1(Z0.PrimalFsmSpec{``0},System.Span{System.UInt64},System.Span{System.UInt64})">
            <summary>
            Executes the specified machines sequentially
            </summary>
            <param name="spec">The machine definition</param>
            <param name="seeds">The rng seeds that determine initial states of the randomizers</param>
            <param name="indices">The rng stream position indices</param>
            <typeparam name="T">The primal FSM type</typeparam>
        </member>
        <member name="M:Z0.Fsm.transition``2(``0,``1,``1)">
            <summary>
            Defines a single state transition rule of the form (trigger : E, source : S) -> target : S
            </summary>
            <param name="trigger">The incoming event</param>
            <param name="source">The source state</param>
            <param name="target">The target state</param>
            <typeparam name="E">The event type</typeparam>
            <typeparam name="S">The state type</typeparam>
        </member>
        <member name="M:Z0.Fsm.transition``2(System.Collections.Generic.IEnumerable{Z0.ITransitionRule{``0,``1}})">
            <summary>
            Defines a machine transition function (trigger : E, source: S) -> target : S
            that determines machine transition behavior
            </summary>
            <param name="rules">The rules that comprise the function</param>
            <typeparam name="E">The event type</typeparam>
            <typeparam name="S">The state type</typeparam>
        </member>
        <member name="M:Z0.Fsm.output``3(``0,``1,``2)">
            <summary>
            Defines an output rule of the form (trigger : E, source : S) -> output : O
            that specifies that output to emit when an input is received when in the source state
            </summary>
            <param name="trigger">The triggering event</param>
            <param name="source">The source state</param>
            <param name="output">The output value</param>
            <typeparam name="E">The event type</typeparam>
            <typeparam name="S">The state type</typeparam>
        </member>
        <member name="M:Z0.Fsm.output``3(System.Collections.Generic.IEnumerable{Z0.IOutputRule{``0,``1,``2}})">
            <summary>
            Defines a machine transition function (trigger : E, source: S) -> target : S
            that determines machine transition behavior
            </summary>
            <param name="rules"></param>
            <typeparam name="E">The event type</typeparam>
            <typeparam name="S">The state type</typeparam>
        </member>
        <member name="M:Z0.Fsm.entry``2(``0,``1)">
            <summary>
            Defines an action that fires upon state entry
            </summary>
            <param name="source">The source state</param>
            <param name="target">The the entry action</param>
            <typeparam name="S">The state type</typeparam>
            <typeparam name="A">The action type</typeparam>
        </member>
        <member name="M:Z0.Fsm.entry``2(System.Collections.Generic.IEnumerable{Z0.IFsmActionRule{``0,``1}})">
            <summary>
            Defines an entry action function
            </summary>
            <param name="rules">The state entry rules</param>
            <typeparam name="S">The state type</typeparam>
            <typeparam name="A">The action type</typeparam>
        </member>
        <member name="M:Z0.Fsm.exit``2(``0,``1)">
            <summary>
            Defines an action that fires upon state exit
            </summary>
            <param name="source">The source state</param>
            <param name="target">The the exit action</param>
            <typeparam name="S">The state type</typeparam>
            <typeparam name="A">The action type</typeparam>
        </member>
        <member name="M:Z0.Fsm.exit``2(System.Collections.Generic.IEnumerable{Z0.IFsmActionRule{``0,``1}})">
            <summary>
            Defines an exit action function
            </summary>
            <param name="rules">The state exit rules</param>
            <typeparam name="S">The state type</typeparam>
            <typeparam name="A">The action type</typeparam>
        </member>
        <member name="M:Z0.Fsm.machine``2(System.String,Z0.IFsmContext,``1,``1,Z0.MachineTransition{``0,``1})">
            <summary>
            Defines the most basic FSM, predicated only on ground-state, end-state and transition function
            </summary>
            <param name="id">Identifies the machine within the context of the executing process</param>
            <param name="s0">The ground-state</param>
            <param name="sZ">The end-state</param>
            <param name="f">The transition function</param>
            <typeparam name="E">The event type</typeparam>
            <typeparam name="S">The state type</typeparam>
        </member>
        <member name="M:Z0.Fsm.machine``2(System.String,Z0.IWfShell,Z0.IPolyrand,``1,``1,Z0.MachineTransition{``0,``1},System.Nullable{System.UInt64})">
            <summary>
            Defines the most basic FSM, predicated only on ground-state, end-state and transition function
            </summary>
            <param name="id">Identifies the machine within the context of the executing process</param>
            <param name="s0">The ground-state</param>
            <param name="sZ">The end-state</param>
            <param name="f">The transition function</param>
            <typeparam name="E">The event type</typeparam>
            <typeparam name="S">The state type</typeparam>
        </member>
        <member name="M:Z0.Fsm.outKey``2(``0,``1)">
            <summary>
            Defines an output rule key
            </summary>
            <param name="source">The antecedent state</param>
            <param name="input">The output value</param>
            <typeparam name="S">The state type</typeparam>
        </member>
        <member name="M:Z0.Fsm.entryKey``1(``0)">
            <summary>
            Defines an entry rule key
            </summary>
            <param name="source">The antecedent state</param>
            <param name="input">The output value</param>
            <typeparam name="E">The input event type</typeparam>
            <typeparam name="S">The state type</typeparam>
        </member>
        <member name="M:Z0.Fsm.exitKey``1(``0)">
            <summary>
            Defines an exit rule key
            </summary>
            <param name="source">The antecedent state</param>
            <param name="input">The output value</param>
            <typeparam name="E">The input event type</typeparam>
            <typeparam name="S">The state type</typeparam>
        </member>
        <member name="M:Z0.Fsm.transitionKey``2(``0,``1)">
            <summary>
            Defines a key for a transition rule
            </summary>
            <param name="trigger">The triggering event</param>
            <param name="source">The source state</param>
            <typeparam name="E">The event type</typeparam>
            <typeparam name="S">The state type</typeparam>
        </member>
        <member name="M:Z0.Fsm.machine``3(System.String,Z0.IWfShell,Z0.IPolyrand,``1,``1,Z0.MachineTransition{``0,``1},Z0.EntryFunction{``1,``2},Z0.ExitFunction{``1,``2},System.Nullable{System.UInt64})">
            <summary>
            Defines a machine that supports entry/exit actions on a per-state basis
            </summary>
            <param name="id">Identifies the machine within the context of the executing process</param>
            <param name="s0">The ground-state</param>
            <param name="sZ">The end-state</param>
            <param name="t">The transition function</param>
            <param name="entry">The entry function</param>
            <param name="exit">The exit function</param>
            <typeparam name="E">The event type</typeparam>
            <typeparam name="S">The state type</typeparam>
            <typeparam name="A">The entry action type</typeparam>
        </member>
        <member name="M:Z0.Fsm.observer``2(Z0.Fsm{``0,``1},System.Nullable{Z0.ObserverTrace})">
            <summary>
            Creates a default machine observer
            </summary>
            <param name="fsm">The machine under observation</param>
            <param name="trace">Whether to emit trace messages</param>
            <typeparam name="E">The event type</typeparam>
            <typeparam name="S">The state type</typeparam>
        </member>
        <member name="M:Z0.Fsm.run``2(Z0.Fsm{``0,``1})">
            <summary>
            Runs a machine
            </summary>
            <param name="context">The machine context</param>
            <param name="machine">The specified machine</param>
            <typeparam name="E">The event type</typeparam>
            <typeparam name="S">The state type</typeparam>
        </member>
        <member name="M:Z0.Fsm.transition``2(Z0.TransitionRule{``0,``1}[])">
            <summary>
            Forms a transition function from a sequence of transition rules
            </summary>
            <param name="rules">The individual rules that will comprise the function</param>
            <typeparam name="E">The input event type</typeparam>
            <typeparam name="S">The state type</typeparam>
        </member>
        <member name="T:Z0.Fsm`2">
            <summary>
            Defines a state machine with minimal feature-set
            </summary>
            <typeparam name="E">The incoming event type</typeparam>
            <typeparam name="S">The state type</typeparam>
        </member>
        <member name="F:Z0.Fsm`2.Limit">
            <summary>
            Specifies the maximum number of events that will be accepted prior to forceful termination
            </summary>
        </member>
        <member name="P:Z0.Fsm`2.Runtime">
            <summary>
            Records the time spent actively running
            </summary>
        </member>
        <member name="P:Z0.Fsm`2.Transition">
            <summary>
            The machine transition function
            </summary>
        </member>
        <member name="P:Z0.Fsm`2.ReceiptCount">
            <summary>
            The number of events that have been received
            </summary>
        </member>
        <member name="P:Z0.Fsm`2.TransitionCount">
            <summary>
            The number of state transitions that have occurred
            </summary>
        </member>
        <member name="P:Z0.Fsm`2.EndState">
            <summary>
            The endstate which implicitly signals processing completion
            </summary>
        </member>
        <member name="F:Z0.Fsm`2.CurrentState">
            <summary>
            The current state
            </summary>
        </member>
        <member name="F:Z0.Fsm`2.Error">
            <summary>
            An error that occurred, if any, prior to normal completion
            </summary>
        </member>
        <member name="P:Z0.Fsm`2.Id">
            <summary>
            Identifies the machine within the process
            </summary>
        </member>
        <member name="E:Z0.Fsm`2.InputReceipt">
            <summary>
            Fires when input is received
            </summary>
        </member>
        <member name="E:Z0.Fsm`2.Transitioned">
            <summary>
            Fires when a transition occurs from one state to a different state
            </summary>
        </member>
        <member name="E:Z0.Fsm`2.Completed">
            <summary>
            Fires when the machine has reached endstate
            </summary>
        </member>
        <member name="E:Z0.Fsm`2.Oops">
            <summary>
            Fires when an error is trapped
            </summary>
        </member>
        <member name="P:Z0.Fsm`2.Triggers">
            <summary>
            Specifies the events that the machine can accept
            </summary>
        </member>
        <member name="P:Z0.Fsm`2.Finished">
            <summary>
            Indicates whether the machine has finished
            </summary>
        </member>
        <member name="P:Z0.Fsm`2.StartTime">
            <summary>
            Records the time at which the machine was started
            </summary>
        </member>
        <member name="P:Z0.Fsm`2.EndTime">
            <summary>
            Records the time at which the machine stopped
            </summary>
        </member>
        <member name="P:Z0.Fsm`2.Started">
            <summary>
            Specifies whether the machine has started
            </summary>
        </member>
        <member name="M:Z0.Fsm`2.Start">
            <summary>
            Begins machine execution
            </summary>
        </member>
        <member name="M:Z0.Fsm`2.Submit(`0)">
            <summary>
            Submits input to the machine
            </summary>
            <param name="input">The input data</param>
        </member>
        <member name="M:Z0.Fsm`2.OnEntry(`1)">
            <summary>
            Called upon state entry
            </summary>
            <param name="entry">The entry state</param>
        </member>
        <member name="M:Z0.Fsm`2.OnExit(`1)">
            <summary>
            Called upon state exit
            </summary>
            <param name="exit">The exit state</param>
        </member>
        <member name="T:Z0.Fsm`3">
            <summary>
            Defines a state machine that supports state entry actions
            </summary>
            <typeparam name="E">The incoming event type</typeparam>
            <typeparam name="S">The state type</typeparam>
            <typeparam name="A">The action type</typeparam>
        </member>
        <member name="F:Z0.Fsm`3.EntryFunc">
            <summary>
            The function to evaluate upon state entry to determine the associated action, if any
            </summary>
        </member>
        <member name="F:Z0.Fsm`3.ExitFunc">
            <summary>
            The function to evaluate upon state exit to determine the associated action, if any
            </summary>
        </member>
        <member name="F:Z0.Fsm`3.EntryAction">
            <summary>
            The entry action
            </summary>
        </member>
        <member name="F:Z0.Fsm`3.ExitAction">
            <summary>
            The exit action
            </summary>
        </member>
        <member name="T:Z0.FsmObserver`2">
            <summary>
            Receives notifications from an active machine
            </summary>
            <typeparam name="E">The input event type</typeparam>
            <typeparam name="S">The state type</typeparam>
        </member>
        <member name="M:Z0.FsmObserver`2.OnComplete(Z0.FsmStats,System.Boolean)">
            <summary>
            Receives notification that a state machine has attained its endstate
            </summary>
        </member>
        <member name="M:Z0.FsmObserver`2.OnTransition(`1,`1)">
            <summary>
            Receives notification that a transition has occurred
            </summary>
            <param name="s0">The source state</param>
            <param name="s1">The target state</param>
        </member>
        <member name="M:Z0.FsmObserver`2.OnReceipt(`0)">
            <summary>
            Receives notification that an event has ben submitted
            </summary>
            <param name="input">The input event</param>
        </member>
        <member name="M:Z0.FsmObserver`2.OnError(System.Exception)">
            <summary>
            Receives notification that an error has occurred
            </summary>
            <param name="e">The trapped exception</param>
        </member>
        <member name="T:Z0.FsmStats">
            <summary>
            Captures state machine execution metrics
            </summary>
        </member>
        <member name="P:Z0.FsmStats.MachineId">
            <summary>
            Identifies the machine within the executing process
            </summary>
        </member>
        <member name="P:Z0.FsmStats.StartTime">
            <summary>
            The time the machine received the start signal
            </summary>
        </member>
        <member name="P:Z0.FsmStats.EndTime">
            <summary>
            The time the machine workflow completed
            </summary>
        </member>
        <member name="P:Z0.FsmStats.ReceiptCount">
            <summary>
            The number of received events
            </summary>
        </member>
        <member name="P:Z0.FsmStats.TransitionCount">
            <summary>
            The number of state transitions that have occurred
            </summary>
        </member>
        <member name="P:Z0.FsmStats.Runtime">
            <summary>
            The time spent during active execution
            </summary>
        </member>
        <member name="T:Z0.PrimalFsmSpec`1">
            <summary>
            Specifies a state machine via scalar values
            </summary>
            <typeparam name="T">A scalar type of sufficient size to accommodate specified characteristics</typeparam>
        </member>
        <member name="F:Z0.PrimalFsmSpec`1.Classifier">
            <summary>
            An identifier that defines a membership class that is propagaged to all machines predicated on the specification
            </summary>
        </member>
        <member name="F:Z0.PrimalFsmSpec`1.StateCount">
            <summary>
            The number of states the machine will support
            </summary>
        </member>
        <member name="F:Z0.PrimalFsmSpec`1.EventCount">
            <summary>
            The number of events the machine will recognize
            </summary>
        </member>
        <member name="F:Z0.PrimalFsmSpec`1.MinEventSamples">
            <summary>
            The minimum number of events that will be sampled for each state
            </summary>
        </member>
        <member name="F:Z0.PrimalFsmSpec`1.MaxEventSamples">
            <summary>
            The maximum number of events that will be sampled for each state
            </summary>
        </member>
        <member name="F:Z0.PrimalFsmSpec`1.ReceiptLimit">
            <summary>
            The maximum number of events that the machine will accept
            </summary>
        </member>
        <member name="F:Z0.PrimalFsmSpec`1.StartState">
            <summary>
            The initial state as determined by the default value of the primal type, i.e. StartState = default
            </summary>
        </member>
        <member name="F:Z0.PrimalFsmSpec`1.EndState">
            <summary>
            The final state as determined by the state count, i.e. EndState := StateCount - 1
            </summary>
        </member>
        <member name="T:Z0.ActionRule`2">
            <summary>
            Characterizes an action that that executes per machine rules
            </summary>
        </member>
        <member name="P:Z0.ActionRule`2.Source">
            <summary>
            The state upon which the rule is predicated
            </summary>
        </member>
        <member name="P:Z0.ActionRule`2.Action">
            <summary>
            The action invoked
            </summary>
        </member>
        <member name="P:Z0.ActionRule`2.Key">
            <summary>
            The rule key
            </summary>
        </member>
        <member name="P:Z0.ActionRule`2.RuleId">
            <summary>
            The rule identifier
            </summary>
        </member>
        <member name="M:Z0.ActionRule`2.op_Implicit(System.ValueTuple{`0,`1})~Z0.ActionRule{`0,`1}">
            <summary>
            Constructs a rule from a source/action pair
            </summary>
            <param name="src">The source state</param>
            <param name="action">The action</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="A">The action type</typeparam>
        </member>
        <member name="T:Z0.ActionRuleKey`1">
            <summary>
            Identifies an action rule for lookup purposes
            </summary>
            <typeparam name="S">The state type</typeparam>
        </member>
        <member name="T:Z0.EntryFunction`2">
            <summary>
            Defines a set of rules that define actions associated with state entry
            </summary>
        </member>
        <member name="T:Z0.ExitFunction`2">
            <summary>
            Defines a set of rules that define actions associated with state Exit
            </summary>
        </member>
        <member name="T:Z0.MachineOutput`3">
            <summary>
            Defines a partial state machine output function of the form 
            (source : S, target : S) -> output : Option[O]
            for source/target pairs in the domain. If an input value (s1:S, s2:S) 
            is not in the function domain, en empty option is returned
            </summary>
        </member>
        <member name="M:Z0.MachineOutput`3.Output(`0,`1)">
            <summary>
            Computes the output value, if any, for a specified source state and event
            </summary>
            <param name="trigger">The incoming event</param>
            <param name="source">The source state</param>
        </member>
        <member name="M:Z0.MachineOutput`3.Rule(Z0.IRuleKey)">
            <summary>
            Searches for the output rule given a key
            </summary>
            <param name="key">The rule key</param>
        </member>
        <member name="T:Z0.MachineTransition`2">
            <summary>
            Encapsulates the set of all rules (input : E, source : S) -> target : S that define state machine transitions
            </summary>
        </member>
        <member name="P:Z0.MachineTransition`2.Triggers">
            <summary>
            Specifies the set of events that can effect a transition
            </summary>
        </member>
        <member name="T:Z0.OutputRule`3">
            <summary>
            Specifies a state machine rule of the form (input:E, source:S) -> output:O
            </summary>
            <typeparam name="E">The event type</typeparam>
            <typeparam name="S">The state type</typeparam>
            <typeparam name="O">The output type</typeparam>
        </member>
        <member name="P:Z0.OutputRule`3.Trigger">
            <summary>
            The source state
            </summary>
        </member>
        <member name="P:Z0.OutputRule`3.Source">
            <summary>
            The target state
            </summary>
        </member>
        <member name="P:Z0.OutputRule`3.Output">
            <summary>
            The output value associated with the specified state
            </summary>
        </member>
        <member name="P:Z0.OutputRule`3.Key">
            <summary>
            The key that identifies the rule
            </summary>
        </member>
        <member name="P:Z0.OutputRule`3.RuleId">
            <summary>
            The rule id as determined by the key
            </summary>
        </member>
        <member name="M:Z0.OutputRule`3.op_Implicit(System.ValueTuple{`0,`1,`2})~Z0.OutputRule{`0,`1,`2}">
            <summary>
            Constructs an output rule from a (source,target,output) triple
            </summary>
            <param name="source">The source state</param>
            <param name="target">The target state</param>
            <param name="output">The output to emit upon a source -> target transition</param>
            <typeparam name="S">The state type</typeparam>
            <typeparam name="O">The output type</typeparam>
        </member>
        <member name="T:Z0.OutputRuleKey`2">
            <summary>
            Defines a key for output rule indexing/lookup
            </summary>
            <typeparam name="S">The state type</typeparam>
        </member>
        <member name="P:Z0.OutputRuleKey`2.Hash">
            <summary>
            The invariant hash
            </summary>
        </member>
        <member name="T:Z0.TransitionRule`2">
            <summary>
            Defines state transition rule of the form (input : E, source : S) -> target : S 
            </summary>
            <typeparam name="E">The input event type</typeparam>
            <typeparam name="S">The state type</typeparam>
        </member>
        <member name="M:Z0.TransitionRule`2.op_Implicit(System.ValueTuple{`0,`1,`1})~Z0.TransitionRule{`0,`1}">
            <summary>
            Constructs a state transition rule from an (input,source,target) triple
            </summary>
            <param name="input">The input event</param>
            <param name="source">The source state</param>
            <param name="target">The target state</param>
        </member>
        <member name="P:Z0.TransitionRule`2.Trigger">
            <summary>
            The transition event trigger
            </summary>
        </member>
        <member name="P:Z0.TransitionRule`2.Source">
            <summary>
            The state upon which the rule is predicated
            </summary>
        </member>
        <member name="P:Z0.TransitionRule`2.Target">
            <summary>
            The target state
            </summary>
        </member>
        <member name="P:Z0.TransitionRule`2.Key">
            <summary>
            The key that identifies the rule
            </summary>
        </member>
        <member name="P:Z0.TransitionRule`2.RuleId">
            <summary>
            The rule id as determined by the key
            </summary>
        </member>
        <member name="T:Z0.TransitionRuleKey`2">
            <summary>
            Defines a key, predicated on input event and current state, identifies a transition rule
            </summary>
        </member>
        <member name="P:Z0.TransitionRuleKey`2.Trigger">
            <summary>
            The triggering event
            </summary>
        </member>
        <member name="P:Z0.TransitionRuleKey`2.Source">
            <summary>
            The source state
            </summary>
        </member>
        <member name="M:Z0.FsmX.ToFunction``2(System.Collections.Generic.IEnumerable{Z0.TransitionRule{``0,``1}})">
            <summary>
            Forms a transition function from a sequence of transition rules
            </summary>
            <param name="rules">The individual rules that will comprise the function</param>
            <typeparam name="E">The input event type</typeparam>
            <typeparam name="S">The state type</typeparam>
        </member>
        <member name="M:Z0.FsmX.TraceTransitions(Z0.ObserverTrace)">
            <summary>
            Specifies whether an observer should be notified when a machine transitions from
            one state to a different state
            </summary>
            <param name="trace">The trace specification</param>
        </member>
        <member name="M:Z0.FsmX.TraceEvents(Z0.ObserverTrace)">
            <summary>
            Specifies whether an observer should be notified when a machine receives an event
            </summary>
            <param name="trace">The trace specification</param>
        </member>
        <member name="M:Z0.FsmX.TraceCompletions(Z0.ObserverTrace)">
            <summary>
            Specifies whether an observer should be notified when a machine attains the completion state
            </summary>
            <param name="trace">The trace specification</param>
        </member>
        <member name="M:Z0.FsmX.TraceErrors(Z0.ObserverTrace)">
            <summary>
            Specifies whether an observer should be notified when an error condition is detected
            </summary>
            <param name="trace">The trace specification</param>
        </member>
        <member name="P:Z0.FsmContext.ReceiptLimit">
            <summary>
            If specified, the maximum number of event submissions the machine
            will accept prior to forced termination
            </summary>
        </member>
        <member name="T:Z0.FsmMessages">
            <summary>
            Defines common messages that are issued during setup/execution
            </summary>
        </member>
        <member name="M:Z0.CpuWorkers.thread(System.UInt32)">
            <summary>
            Searches for a thread given an OS-assigned id
            </summary>
            <param name="id">The OS thread Id</param>
        </member>
        <member name="M:Z0.CpuWorkers.create``1(Z0.IWfShell,System.UInt32,System.UInt32,System.Func{``0,``0},``0,System.TimeSpan,System.String,System.UInt64,System.UInt64)">
            <summary>
            Creates and starts a worker
            </summary>
            <param name="context">The context conferred to the worker</param>
            <param name="cpucore">The CPU core number</param>
            <param name="fx">The worker function</param>
            <param name="state">The subject input</param>
            <param name="frequency">The worker frequency</param>
            <param name="cycles">The maximum number of cycles the worker will be allowed to execute before forceful termination</param>
            <typeparam name="T">The subject type</typeparam>
        </member>
        <member name="T:Z0.CpuWorker`1">
            <summary>
            Embodies an asynchronous thread of execution that is assigned to a specific CPU core
            </summary>
        </member>
    </members>
</doc>
