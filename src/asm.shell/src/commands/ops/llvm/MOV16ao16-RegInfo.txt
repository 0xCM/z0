# RegisterInfo
def MOV16ao16 {	// InstructionEncoding Instruction X86Inst Ii16 OpSize16 AdSize16
    int Size = 0;
    string DecoderNamespace = "";
    list<Predicate> Predicates = [];
    string DecoderMethod = "";
    bit hasCompleteDecoder = 1;
    string Namespace = "X86";
    dag OutOperandList = (outs);
    dag InOperandList = (ins offset16_16:$src);
    string AsmString = "mov{w}	{$src, %ax|ax, $src}";
    EncodingByHwMode EncodingInfos = ?;
    list<dag> Pattern = [];
    list<Register> Uses = [];
    list<Register> Defs = [AX];
    int CodeSize = 3;
    int AddedComplexity = 0;
    bit isPreISelOpcode = 0;
    bit isReturn = 0;
    bit isBranch = 0;
    bit isEHScopeReturn = 0;
    bit isIndirectBranch = 0;
    bit isCompare = 0;
    bit isMoveImm = 0;
    bit isMoveReg = 0;
    bit isBitcast = 0;
    bit isSelect = 0;
    bit isBarrier = 0;
    bit isCall = 0;
    bit isAdd = 0;
    bit isTrap = 0;
    bit canFoldAsLoad = 0;
    bit mayLoad = 1;
    bit mayStore = ?;
    bit mayRaiseFPException = 0;
    bit isConvertibleToThreeAddress = 0;
    bit isCommutable = 0;
    bit isTerminator = 0;
    bit isReMaterializable = 0;
    bit isPredicable = 0;
    bit isUnpredicable = 0;
    bit hasDelaySlot = 0;
    bit usesCustomInserter = 0;
    bit hasPostISelHook = 0;
    bit hasCtrlDep = 0;
    bit isNotDuplicable = 0;
    bit isConvergent = 0;
    bit isAuthenticated = 0;
    bit isAsCheapAsAMove = 0;
    bit hasExtraSrcRegAllocReq = 0;
    bit hasExtraDefRegAllocReq = 0;
    bit isRegSequence = 0;
    bit isPseudo = 0;
    bit isExtractSubreg = 0;
    bit isInsertSubreg = 0;
    bit variadicOpsAreDefs = 0;
    bit hasSideEffects = 0;
    bit isCodeGenOnly = 0;
    bit isAsmParserOnly = 0;
    bit hasNoSchedulingInfo = 0;
    InstrItinClass Itinerary = NoItinerary;
    list<SchedReadWrite> SchedRW = [WriteALU];
    string Constraints = "";
    string DisableEncoding = "";
    string PostEncoderMethod = "";
    bits<64> TSFlags = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1 };
    string AsmMatchConverter = "";
    string TwoOperandAliasConstraint = "";
    string AsmVariantName = "";
    bit UseNamedOperandTable = 0;
    bit UseLogicalOperandMappings = 0;
    bit FastISelShouldIgnore = 0;
    bits<8> Opcode = { 1, 0, 1, 0, 0, 0, 0, 1 };
    Format Form = RawFrmMemOffs;
    bits<7> FormBits = { 0, 0, 0, 0, 0, 1, 1 };
    ImmType ImmT = Imm16;
    bit ForceDisassemble = 0;
    OperandSize OpSize = OpSize16;
    bits<2> OpSizeBits = { 0, 1 };
    AddressSize AdSize = AdSize16;
    bits<2> AdSizeBits = { 0, 1 };
    Prefix OpPrefix = NoPrfx;
    bits<3> OpPrefixBits = { 0, 0, 0 };
    Map OpMap = OB;
    bits<3> OpMapBits = { 0, 0, 0 };
    bit hasREX_WPrefix = 0;
    FPFormat FPForm = NotFP;
    bit hasLockPrefix = 0;
    Domain ExeDomain = GenericDomain;
    bit hasREPPrefix = 0;
    Encoding OpEnc = EncNormal;
    bits<2> OpEncBits = { 0, 0 };
    bit HasVEX_W = 0;
    bit IgnoresVEX_W = 0;
    bit EVEX_W1_VEX_W0 = 0;
    bit hasVEX_4V = 0;
    bit hasVEX_L = 0;
    bit ignoresVEX_L = 0;
    bit hasEVEX_K = 0;
    bit hasEVEX_Z = 0;
    bit hasEVEX_L2 = 0;
    bit hasEVEX_B = 0;
    bits<3> CD8_Form = { 0, 0, 0 };
    int CD8_EltSize = 0;
    bit hasEVEX_RC = 0;
    bit hasNoTrackPrefix = 0;
    bits<7> VectSize = { 0, 0, 1, 0, 0, 0, 0 };
    bits<7> CD8_Scale = { 0, 0, 0, 0, 0, 0, 0 };
    string FoldGenRegForm = ?;
    string EVEX2VEXOverride = ?;
    bit isMemoryFoldable = 1;
    bit notEVEX2VEXConvertible = 0;
    bit ExplicitVEXPrefix = 0;
    bit checkVEXPredicate = 0;
  }