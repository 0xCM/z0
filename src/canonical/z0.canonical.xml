<?xml version="1.0"?>
<doc>
    <assembly>
        <name>z0.canonical</name>
    </assembly>
    <members>
        <member name="T:Z0.IAdditiveOps`1">
            <summary>
            Characterizes a type for which commutative additivity can be defined
            </summary>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.IAdditiveOps`1.Add(`0,`0)">
            <summary>
            Alias for commutative semigroup composition operator
            </summary>
            <param name="lhs">The first element</param>
            <param name="rhs">The second element</param>
        </member>
        <member name="T:Z0.IAdditive`2">
            <summary>
            Characterizes a structure that supports semigroup additivity
            </summary>
            <typeparam name="S">The structure type</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Z0.ISuccessive`2" -->
        <member name="M:Z0.ISuccessive`2.Next">
            <summary>
            Given an A-value, computes the next B-value
            </summary>
            <param name="a">The source vlue</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Z0.IAntecedant`2" -->
        <member name="M:Z0.IAntecedant`2.Prior">
            <summary>
            Given an A-value, computes the prior B-value
            </summary>
            <param name="a">The source vlue</param>
        </member>
        <member name="T:Z0.IAdjacency`2">
            <summary>
            Characterizes a bidirectional association between types for which
            the exists notions successors and antecedants
            </summary>
            <typeparam name="A">The type that succeeds B</typeparam>
            <typeparam name="B">The type that precedes A</typeparam>
        </member>
        <member name="T:Z0.IBitwiseOps`1">
            <summary>
            Characterizes bitwise operations over an operand
            </summary>
        </member>
        <member name="M:Z0.IBitwiseOps`1.And(`0,`0)">
            <summary>
            Computes the bitwise AND
            </summary>
            <param name="a">The left value</param>
            <param name="b">The right value</param>
        </member>
        <member name="M:Z0.IBitwiseOps`1.Or(`0,`0)">
            <summary>
            Computes the bitwise OR
            </summary>
            <param name="a">The left value</param>
            <param name="b">The right value</param>
        </member>
        <member name="M:Z0.IBitwiseOps`1.XOr(`0,`0)">
            <summary>
            Computes the bitwise XOR
            </summary>
            <param name="a">The left value</param>
            <param name="b">The right value</param>
        </member>
        <member name="M:Z0.IBitwiseOps`1.Not(`0)">
            <summary>
            Computes the bitwise complement
            </summary>
            <param name="a">The operand</param>
        </member>
        <member name="T:Z0.ICommutativeOps`1">
            <summary>
            Characterizes commutative operations
            </summary>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="T:Z0.ICommutative`1">
            <summary>
            Characterizes structural commutativity
            </summary>
            <typeparam name="S">The structure type</typeparam>
        </member>
        <member name="T:Z0.IComplex`3">
            <summary>
            Characterizes a structure that represents a complex number
            </summary>
            <typeparam name="S">The structure type</typeparam>
            <typeparam name="T">The underlying numeric component type</typeparam>
            <typeparam name="C">The complex number type</typeparam>
        </member>
        <member name="P:Z0.IComplex`3.Re">
            <summary>
            The real part
            </summary>
        </member>
        <member name="P:Z0.IComplex`3.Im">
            <summary>
            The imaginary part
            </summary>
        </member>
        <member name="T:Z0.ICurrencyOps`1">
            <summary>
            Characterizes a bounded fractional operation provider
            </summary>
            <typeparam name="T">The primitive type</typeparam>
        </member>
        <member name="T:Z0.ICurrency`1">
            <summary>
            Characterizes structural reifications of Currency 
            </summary>
            <typeparam name="S">The structural reification type</typeparam>
        </member>
        <member name="M:Z0.ILeftDistributiveOps`1.Distribute(`0,System.ValueTuple{`0,`0})">
            <summary>
            Characterizes a type that defines an operator that left-distributes
            multiplication over addition
            </summary>
            <typeparam name="X">The operand type</typeparam>
        </member>
        <member name="T:Z0.IRightDistributiveOps`1">
            <summary>
            Characterizes a type that defines an operator that right-distributes
            multiplication over addition
            </summary>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="T:Z0.IDistributiveOps`1">
            <summary>
            Characterizes a type that defines both left and right distribution
            over addition
            </summary>
        </member>
        <member name="M:Z0.ILeftDistributive`1.LeftDistribute(System.ValueTuple{`0,`0})">
            <summary>
            Characterizes a type that defines an operator that left-distributes
            multiplication over addition
            </summary>
            <typeparam name="X">The operand type</typeparam>
        </member>
        <member name="M:Z0.IRightDistributive`1.RightDistribute(System.ValueTuple{`0,`0})">
            <summary>
            Characterizes a type that defines an operator that left-distributes
            multiplication over addition
            </summary>
            <typeparam name="X">The operand type</typeparam>
        </member>
        <member name="T:Z0.IIntegralDomainOps`1">
            <summary>
            Characterizes an integral domain, which is a nonzero commutative ring
            such that for every pair of nonzero elements a and b, the product
            ab is nonzero, i.e., ab = 0 iff a = 0 or b = 0
            </summary>
            <typeparam name="T">The individual type</typeparam>
            <remarks>See https://en.wikipedia.org/wiki/Integral_domain</remarks>
        </member>
        <member name="T:Z0.IGcdDomainOps`1">
            <summary>
            Characterizes a GCD domain
            </summary>
            <typeparam name="T">The individual type</typeparam>
            <remarks>See https://en.wikipedia.org/wiki/GCD_domain</remarks>
        </member>
        <member name="T:Z0.IUniqueFactorDomainOps`1">
            <summary>
            Characterizes a **unique** factorization domain
            </summary>
            <typeparam name="T">The individual type</typeparam>
        </member>
        <member name="T:Z0.IPrincipalIdealDomainOps`1">
            <summary>
            Characterizes a principal ideal domain
            </summary>
            <typeparam name="T">The individual type</typeparam>
        </member>
        <member name="T:Z0.IEuclideanDomainOps`1">
            <summary>
            Characterizes a Euclidean domain
            </summary>
            <typeparam name="T">The individual type</typeparam>
        </member>
        <member name="T:Z0.IDiscreteGroup`2">
            <summary>
            Characterizes a discrete group structure
            </summary>
            <typeparam name="T">The operational type</typeparam>
            <typeparam name="S">The structure type</typeparam>
        </member>
        <member name="T:Z0.IFloatingOps`1">
            <summary>
            Characterizes an operation provider for floating point values
            </summary>
            <typeparam name="T">The underlying numeric type</typeparam>
        </member>
        <member name="P:Z0.IFloatingOps`1.Epsilon">
            <summary>
            The minimal resolution of the data type
            </summary>
        </member>
        <member name="M:Z0.IFloatingOps`1.Sqrt(`0)">
            <summary>
            Calculates the square root of the input
            </summary>
            <param name="x">The input value</param>
        </member>
        <member name="T:Z0.IFiniteFloatOps`1">
            <summary>
            Characterizes an operation provider for bounded floating point values
            </summary>
            <typeparam name="T">The underlying numeric type</typeparam>
        </member>
        <member name="T:Z0.IFiniteFloatOps`2">
            <summary>
            Characterizes operational reifications of RealFiniteUInt 
            </summary>
            <typeparam name="R">The reification type</typeparam>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="T:Z0.IFloating`2">
            <summary>
            Characterizes a structure for a floating point number
            </summary>
            <typeparam name="T">The underlying numeric type</typeparam>
        </member>
        <member name="T:Z0.IGroupOps`1">
            <summary>
            Characterizes group operations over a type
            </summary>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="T:Z0.IGroupAOps`1">
            <summary>
            Characterizes additive/abelian group operations
            </summary>
        </member>
        <member name="M:Z0.IGroupA`1.Invert">
            <summary>
            Unary structural negation
            </summary>
        </member>
        <member name="T:Z0.IGroupLike`2">
            <summary>
            Characterizes a group structure
            </summary>
            <typeparam name="T">The type over which the structure is defind</typeparam>
            <typeparam name="S">The structure type</typeparam>
        </member>
        <member name="T:Z0.IGroupA`2">
            <summary>
            Characterizes an additive group structure
            </summary>
            <typeparam name="T">The type over which the structure is defind</typeparam>
            <typeparam name="S">The structure type</typeparam>
        </member>
        <member name="T:Z0.ISetAspect">
            <summary>
            Defines attributes common to set representations
            </summary>
        </member>
        <member name="P:Z0.ISetAspect.IsEmpty">
            <summary>
            Specifies whether the set is void of elements
            </summary>
        </member>
        <member name="P:Z0.ISetAspect.IsFinite">
            <summary>
            Specifies whether the set is finite
            </summary>
        </member>
        <member name="P:Z0.ISetAspect.IsDiscrete">
            <summary>
            Specifies whether the set is discrete
            </summary>
        </member>
        <member name="T:Z0.IInfiniteSet`1">
            <summary>
            Characterizes a type that represents an infinite number of values
            </summary>
            <typeparam name="T">The member type</typeparam>
        </member>
        <member name="T:Z0.IInfiniteSet`2">
            <summary>
            Characterizes a type that represents an infinite number of values
            </summary>
            <typeparam name="T">The member type</typeparam>
        </member>
        <member name="T:Z0.IInfiniteOps`1">
            <summary>
            Characterizes operations over operands for which a given reification may be infinite
            </summary>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="T:Z0.IIntegerOps`1">
            <summary>
            Characterizes operations over an integer type
            </summary>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="T:Z0.IInfiniteIntOps`1">
            <summary>
            Characterizes operations over unbound integers
            </summary>
        </member>
        <member name="T:Z0.ISignableOps`1">
            <summary>
            Characterizes a sign adjudication operation
            </summary>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.ISignableOps`1.Sign(`0)">
            <summary>
            Determines the sign of the supplied value
            </summary>
        </member>
        <member name="T:Z0.ISignedIntOps`1">
            <summary>
            Characterizes operations over a signed interal type
            </summary>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="T:Z0.IFiniteSignedIntOps`1">
            <summary>
            Characterizes operations over a signed, finite interal type
            </summary>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="T:Z0.IInfiniteSignedIntOps`1">
            <summary>
            Characterizes operations over an unbound signed integral type
            </summary>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="T:Z0.IInteger`2">
            <summary>
            Characterizes a reification structure over an integer type
            </summary>
            <typeparam name="S">The reification type</typeparam>
            <typeparam name="T">The underlying type</typeparam>
        </member>
        <member name="T:Z0.IInversionOps`1">
            <summary>
            Characterizes operational inversion
            </summary>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="T:Z0.InversionMOps`1">
            <summary>
            Characterizes operational multiplicative inversion
            </summary>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.InversionMOps`1.InvertM(`0)">
            <summary>
            Multiplicative inversion
            </summary>
            <param name="x">The value to invert</param>
        </member>
        <member name="T:Z0.InvertiveA`1">
            <summary>
            Characterizes operational additive inversion
            </summary>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.InvertiveA`1.InvertA(`0)">
            <summary>
            Additive inversion
            </summary>
            <param name="x">The value to invert</param>
        </member>
        <member name="T:Z0.IInvertive`1">
            <summary>
            Characterizes structural inversion
            </summary>
            <typeparam name="T">The type over which the structure is defined</typeparam>
        </member>
        <member name="T:Z0.IInvertiveM`1">
            <summary>
            Characterizes structural multiplicative inversion
            </summary>
            <typeparam name="S">The reification type</typeparam>
        </member>
        <member name="M:Z0.IInvertiveM`1.InvertM">
            <summary>
            Effects multiplicative inversion
            </summary>
        </member>
        <member name="T:Z0.IInvertiveA`1">
            <summary>
            Characterizes structural additive inversion
            </summary>
            <typeparam name="S">The reification type</typeparam>
        </member>
        <member name="M:Z0.IInvertiveA`1.InvertA">
            <summary>
            Effects additive inversion
            </summary>
        </member>
        <member name="T:Z0.ILogarithmicOps`1">
            <summary>
            Characterizes a type that supports primitive logarithmic operations
            </summary>
            <typeparam name="T">The type of the underlying primitive</typeparam>
        </member>
        <member name="M:Z0.ILogarithmicOps`1.Ln(`0)">
            <summary>
            Computes the natural logarithm 
            </summary>
            <param name="x">The input value</param>
        </member>
        <member name="M:Z0.ILogarithmicOps`1.Log(`0)">
            <summary>
            Computes the base-10 logarithm
            </summary>
            <param name="x">The input value</param>
        </member>
        <member name="M:Z0.ILogarithmicOps`1.LogB(`0,`0)">
            <summary>
            Computes a logarithm at a specified base
            </summary>
            <param name="x">The input value</param>
            <param name="@base">The logarithm base</param> 
        </member>
        <member name="M:Z0.ILogarithmic`1.Ln">
            <summary>
            Computes the natural logarithm 
            </summary>
            <param name="x">The input value</param>
        </member>
        <member name="M:Z0.ILogarithmic`1.Log">
            <summary>
            Computes the base-10 logarithm
            </summary>
            <param name="x">The input value</param>
        </member>
        <member name="M:Z0.ILogarithmic`1.LogB(`0)">
            <summary>
            Computes a logarithm at a specified base
            </summary>
            <param name="x">The input value</param>
            <param name="@base">The logarithm base</param> 
        </member>
        <member name="M:Z0.ILeftModule`2.LeftScale(`0)">
            <summary>
            Effects scalar multiplication from the left
            </summary>
            <param name="r">The ring individual type, i.e., the scalar type</param>
            <param name="m">The group individual type</param>
        </member>
        <member name="M:Z0.IRightModule`2.RightScale(`1)">
            <summary>
            Effects scalar multiplication from the right
            </summary>
            <param name="r">The ring individual type, i.e., the scalar type</param>
            <param name="m">The group individual type</param>
        </member>
        <member name="T:Z0.IGroupAction`2">
            <summary>
            Characterizes a group action on a set
            </summary>
            <typeparam name="G">The type of the acting group</typeparam>
            <typeparam name="R">The type of the target set</typeparam>
            <remarks>
            For an instance to be law-abiding, the act function must satisfy g(act(h,t)) = act(hg,t) and
            act(1,t) = t for all g,h in G and t in T
            Also, see https://en.wikipedia.org/wiki/Group_with_operators
            </remarks>
        </member>
        <member name="M:Z0.IGroupAction`2.Act(`0,`1)">
            <summary>
            Applies a G-element to a T-element
            </summary>
            <param name="g">The group element</param>
            <param name="t">The target element</param>
        </member>
        <member name="T:Z0.ILeftModuleOps`2">
            <summary>
            Characterizes a left module over a commtative unital ring
            </summary>
            <typeparam name="G">The group individual type</typeparam>
            <typeparam name="R">The ring individual type</typeparam>
        </member>
        <member name="M:Z0.ILeftModuleOps`2.LeftScale(`0,`1)">
            <summary>
            Effects left scalar multiplication
            </summary>
            <param name="r">The ring individual type, i.e., the scalar type</param>
            <param name="m">The group individual type</param>
        </member>
        <member name="T:Z0.IRightModuleOps`2">
            <summary>
            Characterizes a right module over a commtative unital ring
            </summary>
            <typeparam name="G">The group individual type</typeparam>
            <typeparam name="R">The ring individual type</typeparam>
        </member>
        <member name="M:Z0.IRightModuleOps`2.RightScale(`0,`1)">
            <summary>
            Effects right scalar multiplication
            </summary>
            <param name="m">The group individual type</param>
            <param name="r">The ring individual type, i.e., the scalar type</param>
        </member>
        <member name="T:Z0.IMonoidMOps`1">
            <summary>
            Characterizes multiplicative monoidal operations
            </summary>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="T:Z0.IMonoidAOps`1">
            <summary>
            Characterizes additive monoidal operations
            </summary>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="T:Z0.IMonoidM`2">
            <summary>
            Characterizes multiplicative monoidal structure
            </summary>
            <typeparam name="S">The classified structure</typeparam>
            <typeparam name="T">The underlying type</typeparam>
        </member>
        <member name="T:Z0.IMonoidA`2">
            <summary>
            Characterizes additive monoidal structure
            </summary>
            <typeparam name="S">The classified structure</typeparam>
            <typeparam name="T">The underlying type</typeparam>
        </member>
        <member name="M:Z0.MonoidialX.foldA``1(System.ReadOnlySpan{``0})">
            <summary>
            Reduces a stream to a single value via an additive monoid
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The stream element type</typeparam>
        </member>
        <member name="M:Z0.MonoidialX.foldM``1(``0[])">
            <summary>
            Reduces a stream to a single value via a multiplicative monoid
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The stream element type</typeparam>
        </member>
        <member name="T:Z0.IMultiplicativeOps`1">
            <summary>
            Characterizes operational multiplication
            </summary>
            <typeparam name="T">The type subject to multiplication</typeparam>
        </member>
        <member name="T:Z0.IFiniteNaturalOps`1">
            <summary>
            Characterizes an operation provider for bounded natural types
            </summary>
            <typeparam name="T">The type over which operations are defined</typeparam>
        </member>
        <member name="T:Z0.IFiniteNaturalOps`2">
            <summary>
            Characterizes operational reifications of RealFiniteUInt 
            </summary>        
            <typeparam name="R">The reification type</typeparam>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="T:Z0.INatural`1">
            <summary>
            Characterizes a reification structure over natural types S where
            s:S => s ∈ {1, … n} where n is some natural number subject to the
            bounds implied by the underlying data structure
            </summary>
            <typeparam name="S">The type of the realizing structure</typeparam>
        </member>
        <member name="M:Z0.INegatableOps`1.Negate(`0)">
            <summary>
            Unary negation of input
            </summary>
            <param name="x">The input value</param>
        </member>
        <member name="T:Z0.INonNegativeOps`1">
            <summary>
            Characterizes operations over nonnegative operands
            </summary>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="T:Z0.INonNegative`1">
            <summary>
            Characterizes a structure whose values are nonnegative
            </summary>
            <typeparam name="S">The reifying structure</typeparam>
        </member>
        <member name="T:Z0.INumberOps`1">
            <summary>
            Defines the minimal aspects for a value to be considered a "real number"
            The dual contract, that subsumes every possible aspect of number, is 
            defined via the Real trait. Note that every Number can be parameterized 
            by any underlying primitive numeric type
            </summary>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="T:Z0.INumber`1">
            <summary>
            Characterizes a structral number
            </summary>
            <typeparam name="S">The structure type</typeparam>
            <typeparam name="T">The underlying operand type</typeparam>
        </member>
        <member name="T:Z0.ICNumber`1">
            <summary>
            Characterizes a structural number in the C adaptation context
            </summary>
            <typeparam name="S">The reifying type</typeparam>
        </member>
        <member name="P:Z0.ICNumber`1.BitSize">
            <summary>
            Specifies the (fixed) number of bits required to represent the numeric value
            </summary>
        </member>
        <member name="T:Z0.ICNumber`2">
            <summary>
            Characterizes a structural number reification in the C adaptation context
            </summary>
            <typeparam name="S">The reifying type</typeparam>
        </member>
        <member name="M:Z0.ICNumber`2.Wrap(System.Collections.Generic.IEnumerable{`1})">
            <summary>
            Elevates a primitive to a structure
            </summary>
            <param name="src">The primitive source</param>
        </member>
        <member name="M:Z0.ICNumber`2.Unwrap(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Unwraps a lifted primitivie
            </summary>
            <param name="src">The lifted source</param>
        </member>
        <member name="T:Z0.IOrderedNumberOps`1">
            <summary>
            Characterizes numeric operations in the presence of order
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Z0.IOrderedNumber`2">
            <summary>
            Characterizes a structural number with order
            </summary>
            <typeparam name="S">The reification type</typeparam>
            <typeparam name="T">The underlying type</typeparam>
        </member>
        <member name="T:Z0.IPartialOrderOps`1">
            <summary>
            Characterizes a partial order, i.e. a reflexive, transitive and 
            antisymmetric binary operator
            </summary>
            <typeparam name="T">The relation domain</typeparam>
            <remarks>See https://en.wikipedia.org/wiki/Partially_ordered_set</remarks>
        </member>
        <member name="T:Z0.IPosetOps`1">
            <summary>
            Characterizes a set equipped with a partial order
            </summary>
            <typeparam name="T"></typeparam>
            <remarks>See https://en.wikipedia.org/wiki/Partially_ordered_set </remarks>
        </member>
        <member name="M:Z0.IPosetOps`1.Comparable(`0,`0)">
            <summary>
            Determines whether order may be adjudicated between two particluar elements
            </summary>
            <param name="x">The left element</param>
            <param name="y">The right element</param>
            <returns>Returns true if either a ~ b or b ~ a and false oterwise</returns>
        </member>
        <member name="T:Z0.IPoweredOps`2">
            <summary>
            Characterizes an exponentiation operation
            </summary>
            <typeparam name="B">The base type</typeparam>
            <typeparam name="E">The exponent type</typeparam>
        </member>
        <member name="T:Z0.IPreorderOps`1">
            <summary>
            Characterizes a preorder, i.e. a reflexive and transitive
            binary relation over its domain
            </summary>
            <typeparam name="T">The preorder domain</typeparam>
            <remarks>See https://en.wikipedia.org/wiki/Preorder </remarks>
        </member>
        <member name="T:Z0.IProsetOps`1">
            <summary>
            Characterizes a set equipped with a preorder
            </summary>
            <typeparam name="T">The element type</typeparam>
            <remarks>See https://en.wikipedia.org/wiki/Preorder </remarks>
        </member>
        <member name="T:Z0.IFractionalOps`1">
            <summary>
            Characterizes fractional operations
            </summary>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="T:Z0.IFractional`2">
            <summary>
            Characterizes a fractional structure
            </summary>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="T:Z0.IBoundRealOps`1">
            <summary>
            Characterizes operations over (ordered) values that 
            exist between upper and lower bounds
            </summary>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="T:Z0.IRealNumber`1">
            <summary>
            Characterizes a structured real
            </summary>
            <typeparam name="S">The reification type</typeparam>
        </member>
        <member name="T:Z0.IRealNumber`2">
            <summary>
            Characterizes a reification structure over real numbers
            </summary>
            <typeparam name="S">The reification type</typeparam>
            <typeparam name="T">The underlying type</typeparam>
        </member>
        <member name="M:Z0.IReciprocativeOps`1.Recip(`0)">
            <summary>
            Calculates the multiplicative inverse of a given element
            </summary>
            <param name="x">The individual for which an inverse will be calculated</param>
        </member>
        <member name="T:Z0.IReciprocative`1">
            <summary>
            Characterizes a multiplicative and unitial structure S such that
            s:S => s * recip(s) = 1
            </summary>
            <typeparam name="S"></typeparam>
        </member>
        <member name="M:Z0.IReciprocative`1.Recip">
            <summary>
            Calculates the structure's multiplicative inverse
            </summary>
        </member>
        <member name="T:Z0.IBinaryRelationOps`1">
            <summary>
            Characterizes a relation over a set
            </summary>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="T:Z0.IReflexiveOps`1">
            <summary>
            Specifies that a ~ a for every a:T
            </summary>
            <typeparam name="T">The element type</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Z0.IAntisymmetricOps`1" -->
        <member name="T:Z0.ISymmetricOps`1">
            <summary>
            Specifies that a ~ b iff b ~ a for every a,b:T
            </summary>
            <typeparam name="T">The element type</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Z0.ITransitiveOps`1" -->
        <member name="T:Z0.IEquivalenceOps`1">
            <summary>
             Characterizes a reflexive, symmetric and transitive binary relation over a set
            \that, consequently, effects a partition over the set
            </summary>
            <typeparam name="T">The element type</typeparam>
            <remarks>See https://en.wikipedia.org/wiki/Equivalence_relation</remarks>
        </member>
        <member name="T:Z0.IResignableOps`1">
            <summary>
            Characterizes a sign-reversal operation
            </summary>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.IResignableOps`1.Resign(`0,Z0.SignKind)">
            <summary>
            Aligns the value with a specified sign
            </summary>
        </member>
        <member name="T:Z0.IReversibleOps`1">
            <summary>
            Characterizes operational reversiblity
            </summary>
            <typeparam name="T">The type for which a reverse operator is defined</typeparam>
        </member>
        <member name="T:Z0.IRingOps`1">
            <summary>
            Characterizes a (unital) ring
            </summary>
        </member>
        <member name="T:Z0.ICommutativeRingOps`1">
            <summary>
            Characterizes a commutative, unital ring
            </summary>
        </member>
        <member name="M:Z0.IImplicitSemigroup`2.Comparer(System.Func{`1,System.Int32})">
            <summary>
            Gets an equality comparer that can determine whether to semigroup elements are equal
            </summary>
            <param name="hasher">The hash function to use, if specified</param>
        </member>
        <member name="T:Z0.ISemiringOps`1">
            <summary>
            Characterizes semiring operations
            </summary>
            <typeparam name="T">The individual type</typeparam>
        </member>
        <member name="T:Z0.ISemiring`1">
            <summary>
            Characterizes a semiring structure
            </summary>
            <typeparam name="S">The structure type</typeparam>
        </member>
        <member name="T:Z0.IStepwiseOps`1">
            <summary>
            Characterizes a type that realizes both incrementing and decrementing operations
            </summary>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="T:Z0.ISubtractiveOps`1">
            <summary>
            Characterizes operational negation and subtraction
            </summary>
            <typeparam name="T">The individual type</typeparam>
        </member>
        <member name="M:Z0.ISubtractiveOps`1.Sub(`0,`0)">
            <summary>
            Combines the first operand with the negation of the second
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
            <returns></returns>
        </member>
        <member name="M:Z0.ISubtractive`1.Sub(`0)">
            <summary>
            Structural subtraction
            </summary>
            <param name="rhs">The right operand</param>
        </member>
        <member name="T:Z0.ITrigonmetricOps`1">
            <summary>
            Characterizes trigonometric operations over a type
            </summary>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="T:Z0.Unit">
            <summary>
            Defines a slot in the type system for an "empty" type
            In this way, void functions can be considered
            to yield a value and participate in functional/monadic expressions
            </summary>
        </member>
        <member name="M:Z0.Unit.op_Explicit(System.Action)~Z0.Unit">
            <summary>
            Executes the action and returns the unit value
            </summary>
            <param name="a">The action to execute</param>
        </member>
        <member name="T:Z0.IUnitalOps`1">
            <summary>
            Characterizes operations over a unital type
            </summary>
            <typeparam name="T">The characterized type</typeparam>
        </member>
        <member name="P:Z0.IUnitalOps`1.One">
            <summary>
            The unital value
            </summary>
        </member>
    </members>
</doc>
