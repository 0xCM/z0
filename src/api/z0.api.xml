<?xml version="1.0"?>
<doc>
    <assembly>
        <name>z0.api</name>
    </assembly>
    <members>
        <member name="M:Z0.ApiSpecs.call(ApiClass)">
            <summary>
            Defines a call to a classified operation that accepts no arguments
            </summary>
            <typeparam name="A0">The first argument type</typeparam>
        </member>
        <member name="M:Z0.ApiSpecs.call``1(ApiClass,``0)">
            <summary>
            Defines a call to a classified operation that accepts 1 argument
            </summary>
            <typeparam name="A0">The first argument type</typeparam>
        </member>
        <member name="M:Z0.ApiSpecs.call``2(ApiClass,``0,``1)">
            <summary>
            Defines a call to a classified operation that accepts 2 arguments
            </summary>
            <typeparam name="A0">The first argument type</typeparam>
            <typeparam name="A1">The second argument type</typeparam>
        </member>
        <member name="M:Z0.ApiSpecs.call``3(ApiClass,``0,``1,``2)">
            <summary>
            Defines a call to a classified operation that accepts 3 arguments
            </summary>
            <typeparam name="A0">The first argument type</typeparam>
            <typeparam name="A1">The second argument type</typeparam>
            <typeparam name="A2">The third argument type</typeparam>
        </member>
        <member name="M:Z0.ApiSpecs.call``4(ApiClass,``0,``1,``2,``3)">
            <summary>
            Defines a call to a classified operation that accepts 4 arguments
            </summary>
            <typeparam name="A0">The first argument type</typeparam>
            <typeparam name="A1">The second argument type</typeparam>
            <typeparam name="A2">The third argument type</typeparam>
            <typeparam name="A3">The fourth argument type</typeparam>
        </member>
        <member name="F:Z0.ApiAction.Class">
            <summary>
            The operator class
            </summary>
        </member>
        <member name="F:Z0.ApiAction`1.Class">
            <summary>
            The operator class
            </summary>
        </member>
        <member name="F:Z0.ApiAction`1.Arg0">
            <summary>
            The first operand
            </summary>
        </member>
        <member name="F:Z0.ApiAction`2.Class">
            <summary>
            The operator class
            </summary>
        </member>
        <member name="F:Z0.ApiAction`2.Arg0">
            <summary>
            The first operand
            </summary>
        </member>
        <member name="F:Z0.ApiAction`2.Arg1">
            <summary>
            The second operand
            </summary>
        </member>
        <member name="T:Z0.ApiCall">
            <summary>
            Represents a call to a classified operation that accepts no arguments
            </summary>
        </member>
        <member name="F:Z0.ApiCall.Class">
            <summary>
            The operator class
            </summary>
        </member>
        <member name="T:Z0.ApiCall`1">
            <summary>
            Represents a call to a classified operation that accepts 1 argument
            </summary>
            <typeparam name="A0">The argument type</typeparam>
        </member>
        <member name="F:Z0.ApiCall`1.Class">
            <summary>
            The operator class
            </summary>
        </member>
        <member name="F:Z0.ApiCall`1.Arg0">
            <summary>
            The first operand
            </summary>
        </member>
        <member name="T:Z0.ApiCall`2">
            <summary>
            Represents a call to a classified operation that accepts 2 arguments
            </summary>
            <typeparam name="A0">The first argument type</typeparam>
            <typeparam name="A1">The second argument type</typeparam>
        </member>
        <member name="F:Z0.ApiCall`2.Class">
            <summary>
            The operator class
            </summary>
        </member>
        <member name="F:Z0.ApiCall`2.Arg0">
            <summary>
            The first operand
            </summary>
        </member>
        <member name="F:Z0.ApiCall`2.Arg1">
            <summary>
            The second operand
            </summary>
        </member>
        <member name="T:Z0.ApiCall`3">
            <summary>
            Represents a call to a classified operation that accepts 3 arguments
            </summary>
            <typeparam name="A0">The first argument type</typeparam>
            <typeparam name="A1">The second argument type</typeparam>
            <typeparam name="A2">The third argument type</typeparam>
        </member>
        <member name="F:Z0.ApiCall`3.Class">
            <summary>
            The operator class
            </summary>
        </member>
        <member name="F:Z0.ApiCall`3.Arg0">
            <summary>
            The first operand
            </summary>
        </member>
        <member name="F:Z0.ApiCall`3.Arg1">
            <summary>
            The second operand
            </summary>
        </member>
        <member name="F:Z0.ApiCall`3.Arg2">
            <summary>
            The third operand
            </summary>
        </member>
        <member name="T:Z0.ApiCall`4">
            <summary>
            Represents a call to a classified operation that accepts 4 arguments
            </summary>
            <typeparam name="A0">The first argument type</typeparam>
            <typeparam name="A1">The second argument type</typeparam>
            <typeparam name="A2">The third argument type</typeparam>
            <typeparam name="A3">The fourth argument type</typeparam>
        </member>
        <member name="F:Z0.ApiCall`4.Class">
            <summary>
            The operator class
            </summary>
        </member>
        <member name="F:Z0.ApiCall`4.Arg0">
            <summary>
            The first operand
            </summary>
        </member>
        <member name="F:Z0.ApiCall`4.Arg1">
            <summary>
            The second operand
            </summary>
        </member>
        <member name="F:Z0.ApiCall`4.Arg2">
            <summary>
            The third operand
            </summary>
        </member>
        <member name="F:Z0.ApiCall`4.Arg3">
            <summary>
            The fourth operand
            </summary>
        </member>
        <member name="T:Z0.IExpr">
            <summary>
            Characterizes an expression
            </summary>
        </member>
        <member name="T:Z0.IExpr`1">
            <summary>
            Characterizes an parametric expression
            </summary>
            <typeparam name="T">The type over which the expression is defined</typeparam>
        </member>
        <member name="T:Z0.IFormulaExpr">
            <summary>
            Characterizes a formula which, by definition, is a named expression
            </summary>
        </member>
        <member name="P:Z0.IFormulaExpr.Name">
            <summary>
            The formula name, unique with respect to some context
            </summary>
        </member>
        <member name="P:Z0.IFormulaExpr.Encoding">
            <summary>
            The defining expression
            </summary>
        </member>
        <member name="T:Z0.IFormulaExpr`1">
            <summary>
            Characterizes a typed formula, a named typed expression
            </summary>
        </member>
        <member name="P:Z0.IFormulaExpr`1.Encoding">
            <summary>
            The defining expression
            </summary>
        </member>
        <member name="P:Z0.ILiteralExpr`1.Value">
            <summary>
            The value of the literal
            </summary>
        </member>
        <member name="T:Z0.ILogicExpr">
            <summary>
            Characterizes a logical expression over a bit
            </summary>
        </member>
        <member name="T:Z0.ILogicExpr`1">
            <summary>
            Characterizes a typed expression that admits logical evaluation
            </summary>
            <typeparam name="T">The type over which the expression is defined</typeparam>
        </member>
        <member name="T:Z0.ILogicOpExpr">
            <summary>
            Characterizes an operator reified as a boolean function
            </summary>
        </member>
        <member name="T:Z0.ILogicOpExpr`2">
            <summary>
            Characterizes a logic operator that varies by operator kind and is evaluated in the context of a parametric type
            </summary>
            <typeparam name="T">The context type</typeparam>
            <typeparam name="K">The operator classifier</typeparam>
        </member>
        <member name="T:Z0.ILogicVarExpr">
            <summary>
            Characterizes a logical variable
            </summary>
        </member>
        <member name="M:Z0.ILogicVarExpr.Set(Z0.ILogicExpr)">
            <summary>
            Updates the variable
            </summary>
            <param name="expr">The value to assigned to the variable</param>
        </member>
        <member name="M:Z0.ILogicVarExpr.Set(Z0.Bit32)">
            <summary>
            Updates the expression value
            </summary>
            <param name="literal">The literal value to assign to the variable</param>
        </member>
        <member name="P:Z0.ILogicVarExpr.Value">
            <summary>
            The current value of the variable
            </summary>
        </member>
        <member name="T:Z0.ILogicVarExpr`1">
            <summary>
            Characterizes a logical variable that also carries type information
            </summary>
        </member>
        <member name="M:Z0.ILogicVarExpr`1.Set(Z0.ILogicExpr{`0})">
            <summary>
            Updates the variable
            </summary>
            <param name="expr">The value to assigned to the variable</param>
        </member>
        <member name="P:Z0.ILogicVarExpr`1.Value">
            <summary>
            The current value of the variable
            </summary>
        </member>
        <member name="T:Z0.IOperatorExpr">
            <summary>
            Characterizes an expression defined via an operator
            </summary>
        </member>
        <member name="T:Z0.IOperatorExpr`1">
            <summary>
            Characterizes a parametric operator that varies over operand type
            </summary>
            <typeparam name="T">The type over which the expression is defined</typeparam>
        </member>
        <member name="T:Z0.IOperatorExpr`2">
            <summary>
            Characterizes a parametric operator that varies over operator kind and operand type
            </summary>
            <typeparam name="T">The type over which the expression is defined</typeparam>
            <typeparam name="K">The operator classifier</typeparam>
        </member>
        <member name="P:Z0.IOperatorExpr`2.ApiClass">
            <summary>
            Specifies the class to which the operator belongs
            </summary>
        </member>
        <member name="P:Z0.ILazySeqExpr`1.Terms">
            <summary>
            The terms in the sequence that are evaluated on-demand
            </summary>
        </member>
        <member name="T:Z0.ISeqExpr`1">
            <summary>
            Characterizes a finite sequence of terms
            </summary>
            <typeparam name="T">The term type</typeparam>
        </member>
        <member name="P:Z0.ISeqExpr`1.Terms">
            <summary>
            The terms in the sequence
            </summary>
        </member>
        <member name="P:Z0.ISeqExpr`1.Item(System.Int32)">
            <summary>
            Sequence value accessor/manipulator
            </summary>
        </member>
        <member name="P:Z0.ISeqExpr`1.Length">
            <summary>
            The number of terms in the sequence
            </summary>
        </member>
        <member name="P:Z0.IShiftOpExpr`1.Subject">
            <summary>
            The thing to shift
            </summary>
        </member>
        <member name="T:Z0.IVarExpr">
            <summary>
            Characterizes a variable
            </summary>
        </member>
        <member name="P:Z0.IVarExpr.Name">
            <summary>
            The name of the variable
            </summary>
        </member>
        <member name="T:Z0.IVarExpr`1">
            <summary>
            Characterizes a typed variable
            </summary>
        </member>
        <member name="M:Z0.IVarExpr`1.Set(Z0.IExpr{`0})">
            <summary>
            Updates the variable
            </summary>
            <param name="expr">The value to assigned to the variable</param>
        </member>
        <member name="M:Z0.IVarExpr`1.Set(`0)">
            <summary>
            Updates the expression value
            </summary>
            <param name="literal">The literal value to assign to the variable</param>
        </member>
        <member name="P:Z0.IVarExpr`1.Value">
            <summary>
            The current value of the variable
            </summary>
        </member>
        <member name="T:Z0.IVariedExpr">
            <summary>
            Distinguishes varied expressions from other sorts of expressions
            </summary>
        </member>
        <member name="T:Z0.IVariedExpr`1">
            <summary>
            Characterizes an expression that varies over a typed expression
            </summary>
            <typeparam name="T">The type over which the expression is defined</typeparam>
        </member>
        <member name="T:Z0.IVariedLogicExpr">
            <summary>
            Characterizes an expression that depends on a boolean variable
            </summary>
        </member>
        <member name="T:Z0.IVariedLogicExpr`1">
            <summary>
            Characterizes an expression that depends on a boolean variable but which
            also carries type information
            </summary>
        </member>
        <member name="T:Z0.IBinaryOpExpr`1">
            <summary>
            Characterizes a binary operator parametrized by expression type
            </summary>
        </member>
        <member name="T:Z0.IComparisonExpr">
            <summary>
            Characterizes a claim that two variable-dependent comparison expressions are equivalent
            </summary>
        </member>
        <member name="P:Z0.IComparisonExpr.Lhs">
            <summary>
            The left expression
            </summary>
        </member>
        <member name="P:Z0.IComparisonExpr.Rhs">
            <summary>
            The right expression
            </summary>
        </member>
        <member name="P:Z0.IComparisonExpr.Vars">
            <summary>
            Variables upon which the expression depends
            </summary>
        </member>
        <member name="T:Z0.IComparisonExpr`1">
            <summary>
            Characterizes a claim that two variable-dependent typed comparison expressions are equivalent
            </summary>
        </member>
        <member name="P:Z0.IComparisonExpr`1.LeftArg">
            <summary>
            The left expression
            </summary>
        </member>
        <member name="P:Z0.IComparisonExpr`1.RightArg">
            <summary>
            The right expression
            </summary>
        </member>
        <member name="P:Z0.IComparisonExpr`1.Vars">
            <summary>
            Variables upon which the expression depends
            </summary>
        </member>
        <member name="P:Z0.IComparisonExpr`1.ComparisonKind">
            <summary>
            The sort of comparison to be applied
            </summary>
        </member>
        <member name="T:Z0.IComparisonPredExpr`1">
            <summary>
            Characterizes a comparison expression that evaluates as a predicate where a single bit, or bitvector,
            characterizes the evaluation result. This is in contradistinction to the more general typed comparison expression
            where the result is predicated on the type and may be scalar/vector/etc in nature
            </summary>
            <typeparam name="T">The type over which the comparison is defined</typeparam>
        </member>
        <member name="T:Z0.ITernaryBitwiseOpExpr`1">
            <summary>
            Characterizes a typed ternary bitwise operator
            </summary>
            <typeparam name="T">The type over which the operator is defined</typeparam>
        </member>
        <member name="T:Z0.ITernaryOpExpr`1">
            <summary>
            Characterizes a ternary operator parametrized by expression type
            </summary>
        </member>
        <member name="T:Z0.IUnaryOpExpr`1">
            <summary>
            Characterizes a unary operator parametrized by an expression type
            </summary>
        </member>
        <member name="P:Z0.IUnaryOpExpr`1.Arg">
            <summary>
            The operand
            </summary>
        </member>
        <member name="M:Z0.ArithmeticSpec.unary``1(Z0.UnaryArithmeticApiClass,Z0.IExpr{``0})">
            <summary>
            Defines an arithmetic unary expression
            </summary>
            <param name="op">The operator classifier</param>
            <param name="a">The operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.ArithmeticSpec.unary``1(Z0.UnaryArithmeticApiClass,``0)">
            <summary>
            Defines an arithmetic unary expression over a literal operand
            </summary>
            <param name="op">The operator classifier</param>
            <param name="operand">The literal value</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.ArithmeticSpec.binary``1(Z0.BinaryArithmeticApiClass,Z0.IExpr{``0},Z0.IExpr{``0})">
            <summary>
            Defines a binary arithmetic expression
            </summary>
            <param name="a">The left expression</param>
            <param name="b">The right expression</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.ArithmeticSpec.binary``1(Z0.BinaryArithmeticApiClass,``0,``0)">
            <summary>
            Defines a binary arithmetic expression over literal operands
            </summary>
            <param name="a">The left expression</param>
            <param name="b">The right expression</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.ArithmeticSpec.inc``1(Z0.IExpr{``0})">
            <summary>
            Defines a unary increment expression
            </summary>
            <param name="a">The expression operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.ArithmeticSpec.inc``1(``0)">
            <summary>
            Defines a unary increment expression with a literal operand
            </summary>
            <param name="a">The literal value</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.ArithmeticSpec.dec``1(Z0.IExpr{``0})">
            <summary>
            Defines a unary decrement expression
            </summary>
            <param name="a">The expression operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.ArithmeticSpec.dec``1(``0)">
            <summary>
            Defines a decrement increment expression with a literal operand
            </summary>
            <param name="a">The literal value</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.ArithmeticSpec.negate``1(Z0.IExpr{``0})">
            <summary>
            Defines a unary decrement expression
            </summary>
            <param name="a">The expression operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.ArithmeticSpec.negate``1(``0)">
            <summary>
            Defines a decrement increment expression with a literal operand
            </summary>
            <param name="a">The literal value</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.ArithmeticSpec.add``1(Z0.IExpr{``0},Z0.IExpr{``0})">
            <summary>
            Defines a binary addition expression
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.ArithmeticSpec.add``1(``0,``0)">
            <summary>
            Defines a binary addition expression over literal operands
            </summary>
            <param name="a">The left literal value</param>
            <param name="b">The right literal value</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.ArithmeticSpec.sub``1(Z0.IExpr{``0},Z0.IExpr{``0})">
            <summary>
            Defines a binary subtraction expression
            </summary>
            <param name="a">The left expression</param>
            <param name="b">The right expression</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.ArithmeticSpec.sub``1(``0,``0)">
            <summary>
            Defines a binary subtraction expression over literal operands
            </summary>
            <param name="a">The left literal value</param>
            <param name="b">The right literal value</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="T:Z0.BitLogicSpec">
            <summary>
            Defines factories that create structures for logic over a single bit
            </summary>
        </member>
        <member name="M:Z0.BitLogicSpec.not(Z0.ILogicExpr)">
            <summary>
            Defines a logical not operator over a logic expression
            </summary>
            <param name="a">The operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.not(Z0.Bit32)">
            <summary>
            Defines a logical not operator over a bit literal
            </summary>
            <param name="a">The operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.not``1(Z0.ILogicExpr{``0})">
            <summary>
            Defines a logical not operator over a typed logic expression
            </summary>
            <param name="a">The operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.not``1(Z0.Bit32)">
            <summary>
            Defines a logical not operator over a typed literal
            </summary>
            <param name="a">The operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.and(Z0.ILogicExpr,Z0.ILogicExpr)">
            <summary>
            Defines a logical And operator over expression operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.and(Z0.Bit32,Z0.Bit32)">
            <summary>
            Defines a logical And operator over bit literal operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.and``1(Z0.ILogicExpr{``0},Z0.ILogicExpr{``0})">
            <summary>
            Defines a logical And operator over typed expression operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.and``1(Z0.Bit32,Z0.Bit32)">
            <summary>
            Defines a logical And operator over typed literal operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.nand(Z0.ILogicExpr,Z0.ILogicExpr)">
            <summary>
            Defines a logical Nand operator over expression operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.nand(Z0.Bit32,Z0.Bit32)">
            <summary>
            Defines a logical Nand operator over bit literal operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.nand``1(Z0.ILogicExpr{``0},Z0.ILogicExpr{``0})">
            <summary>
            Defines a logical Nand operator over typed expression operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.nand``1(Z0.Bit32,Z0.Bit32)">
            <summary>
            Defines a logical Nand operator over typed literal operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.or(Z0.ILogicExpr,Z0.ILogicExpr)">
            <summary>
            Defines a logical Or operator over expression operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.or(Z0.Bit32,Z0.Bit32)">
            <summary>
            Defines a logical Or operator over literal operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.or``1(Z0.ILogicExpr{``0},Z0.ILogicExpr{``0})">
            <summary>
            Defines a logical Or operator over typed expression operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.or``1(Z0.Bit32,Z0.Bit32)">
            <summary>
            Defines a logical Or operator over typed expression operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.nor(Z0.ILogicExpr,Z0.ILogicExpr)">
            <summary>
            Defines a nor operator over expression operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.nor``1(Z0.ILogicExpr{``0},Z0.ILogicExpr{``0})">
            <summary>
            Defines a logical Nor operator over typed expression operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.nor(Z0.Bit32,Z0.Bit32)">
            <summary>
            Defines a nor operator over literal operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.nor``1(Z0.Bit32,Z0.Bit32)">
            <summary>
            Defines a logical Nor operator over typed literal operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.xor(Z0.ILogicExpr,Z0.ILogicExpr)">
            <summary>
            Defines a logical Xor operator over expression operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.xor(Z0.Bit32,Z0.Bit32)">
            <summary>
            Defines a logical Xor operator over literal operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.xor``1(Z0.ILogicExpr{``0},Z0.ILogicExpr{``0})">
            <summary>
            Defines a logical Xor operator over typed expression operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.xor``1(Z0.Bit32,Z0.Bit32)">
            <summary>
            Defines a logical Xor operator over typed expression operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.xnor(Z0.ILogicExpr,Z0.ILogicExpr)">
            <summary>
            Defines an xnor operator over expression operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.xnor(Z0.Bit32,Z0.Bit32)">
            <summary>
            Defines an xnor operator over literal operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.xnor``1(Z0.ILogicExpr{``0},Z0.ILogicExpr{``0})">
            <summary>
            Defines a logical Xnor operator over typed expression operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.xnor``1(Z0.Bit32,Z0.Bit32)">
            <summary>
            Defines a logical Xnor operator over typed expression operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.left(Z0.ILogicExpr,Z0.ILogicExpr)">
            <summary>
            Defines a left projection operator over expression operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.left``1(Z0.ILogicExpr{``0},Z0.ILogicExpr{``0})">
            <summary>
            Defines a logical Xor operator over typed expression operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.left(Z0.Bit32,Z0.Bit32)">
            <summary>
            Defines a left projection over literal operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.left``1(Z0.Bit32,Z0.Bit32)">
            <summary>
            Defines a left projection operator over typed literal operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.right(Z0.ILogicExpr,Z0.ILogicExpr)">
            <summary>
            Defines a right projection operator over expression operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.right(Z0.Bit32,Z0.Bit32)">
            <summary>
            Defines a right projection over literal operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.right``1(Z0.ILogicExpr{``0},Z0.ILogicExpr{``0})">
            <summary>
            Defines a right projection operator over typed expression operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.right``1(Z0.Bit32,Z0.Bit32)">
            <summary>
            Defines a right projection operator over typed literal operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.lnot(Z0.ILogicExpr,Z0.ILogicExpr)">
            <summary>
            Defines a left negation operator over expression operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.lnot(Z0.Bit32,Z0.Bit32)">
            <summary>
            Defines a left negation operator over literal operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.lnot``1(Z0.ILogicExpr{``0},Z0.ILogicExpr{``0})">
            <summary>
            Defines a left negation operator over typed expression operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.lnot``1(Z0.Bit32,Z0.Bit32)">
            <summary>
            Defines a left negation operator over typed literal operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.rnot(Z0.ILogicExpr,Z0.ILogicExpr)">
            <summary>
            Defines a right negation operator over expression operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.rnot(Z0.Bit32,Z0.Bit32)">
            <summary>
            Defines a right negation operator over literal operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.rnot``1(Z0.ILogicExpr{``0},Z0.ILogicExpr{``0})">
            <summary>
            Defines a right negation operator over typed expression operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.rnot``1(Z0.Bit32,Z0.Bit32)">
            <summary>
            Defines a right negation operator over typed literal operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.imply(Z0.ILogicExpr,Z0.ILogicExpr)">
            <summary>
            Defines a material implication operator over expression operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.imply(Z0.Bit32,Z0.Bit32)">
            <summary>
            Defines a material implication operator over literal operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.imply``1(Z0.ILogicExpr{``0},Z0.ILogicExpr{``0})">
            <summary>
            Defines a material implication operator over typed expression operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.imply``1(Z0.Bit32,Z0.Bit32)">
            <summary>
            Defines a material implication operator over typed literal operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.notimply(Z0.ILogicExpr,Z0.ILogicExpr)">
            <summary>
            Defines a material nonimplication operator over expression operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.notimply(Z0.Bit32,Z0.Bit32)">
            <summary>
            Defines a material nonimplication operator over literal operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.notimply``1(Z0.ILogicExpr{``0},Z0.ILogicExpr{``0})">
            <summary>
            Defines a material nonimplication operator over typed expression operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.notimply``1(Z0.Bit32,Z0.Bit32)">
            <summary>
            Defines a material nonimplication operator over typed literal operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.cimply(Z0.ILogicExpr,Z0.ILogicExpr)">
            <summary>
            Defines a converse implication operator over expression operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.cimply(Z0.Bit32,Z0.Bit32)">
            <summary>
            Defines a converse implication operator over literal operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.cimply``1(Z0.ILogicExpr{``0},Z0.ILogicExpr{``0})">
            <summary>
            Defines a converse implication operator over typed expression operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.cimply``1(Z0.Bit32,Z0.Bit32)">
            <summary>
            Defines a converse implication operator over typed literal operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.cnotimply(Z0.ILogicExpr,Z0.ILogicExpr)">
            <summary>
            Defines a converse nonimplication operator over expression operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.cnotimply(Z0.Bit32,Z0.Bit32)">
            <summary>
            Defines a converse nonimplication operator over literal operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.cnotimply``1(Z0.ILogicExpr{``0},Z0.ILogicExpr{``0})">
            <summary>
            Defines a converse nonimplication operator over typed expression operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.cnotimply``1(Z0.Bit32,Z0.Bit32)">
            <summary>
            Defines a converse nonimplication operator over typed literal operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.select(Z0.ILogicExpr,Z0.ILogicExpr,Z0.ILogicExpr)">
            <summary>
            Defines a ternary select operator over expression operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.select(Z0.Bit32,Z0.Bit32,Z0.Bit32)">
            <summary>
            Defines a ternary select operator over bit literal operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.select``1(Z0.ILogicExpr{``0},Z0.ILogicExpr{``0},Z0.ILogicExpr{``0})">
            <summary>
            Defines a ternary select operator over typed expression operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.bitseq(Z0.Bit32[])">
            <summary>
            Defines a bit sequence expression with an arbitrary number of terms
            </summary>
            <param name="terms">The sequence terms</param>
        </member>
        <member name="M:Z0.BitLogicSpec.bitseq``1(``0,Z0.Bit32[])">
            <summary>
            Defines a bit sequence expression of natural length
            </summary>
            <param name="length">The natural length of the sequence</param>
            <param name="terms">The sequence terms</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogicSpec.bitcombo(System.Int32)" -->
        <member name="M:Z0.BitLogicSpec.bitcombo(Z0.N1)">
            <summary>
            Computes all bit sequence expressions of length 1
            </summary>
            <param name="n">The natural selector</param>
        </member>
        <member name="M:Z0.BitLogicSpec.bitcombo(Z0.N2)">
            <summary>
            Computes all bit sequence expressions of length 2
            </summary>
            <param name="n">The natural selector</param>
        </member>
        <member name="M:Z0.BitLogicSpec.bitcombo(Z0.N3)">
            <summary>
            Computes all bit sequence expressions of length 3
            </summary>
            <param name="n">The natural selector</param>
        </member>
        <member name="M:Z0.BitLogicSpec.bitcombo(Z0.N4)">
            <summary>
            Computes all bit sequence expressions of length 4
            </summary>
            <param name="n">The natural selector</param>
        </member>
        <member name="M:Z0.BitLogicSpec.bitcombo(Z0.N5)">
            <summary>
            Computes all bit sequence expressions of length 5
            </summary>
            <param name="n">The natural selector</param>
        </member>
        <member name="M:Z0.BitLogicSpec.bitcombo(Z0.N6)">
            <summary>
            Computes all bit sequence expressions of length 6
            </summary>
            <param name="n">The natural selector</param>
        </member>
        <member name="M:Z0.BitLogicSpec.bitcombo(Z0.N7)">
            <summary>
            Computes all bit sequence expressions of length 7
            </summary>
            <param name="n">The natural selector</param>
        </member>
        <member name="M:Z0.BitLogicSpec.bitcombo(Z0.N8)">
            <summary>
            Computes all bit sequence expressions of length 8
            </summary>
            <param name="n">The natural selector</param>
        </member>
        <member name="M:Z0.BitLogicSpec.compare(Z0.BinaryComparisonApiClass,Z0.ILogicExpr,Z0.ILogicExpr,Z0.ILogicVarExpr[])">
            <summary>
            Defines comparison expression
            </summary>
            <param name="kind">The comparisonkind</param>
            <param name="lhs">The left expression</param>
            <param name="rhs">The right expression</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogicSpec.compare``1(Z0.BinaryComparisonApiClass,Z0.ILogicExpr{``0},Z0.ILogicExpr{``0},Z0.IVarExpr{``0}[])">
            <summary>
            Defines comparison expression
            </summary>
            <param name="kind">The comparisonkind</param>
            <param name="lhs">The left expression</param>
            <param name="rhs">The right expression</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogicSpec.equals(Z0.ILogicExpr,Z0.ILogicExpr,Z0.ILogicVarExpr[])">
            <summary>
            Defines an equality comparison expression
            </summary>
            <param name="lhs">The left expression</param>
            <param name="rhs">The right expression</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogicSpec.equals``1(Z0.ILogicExpr{``0},Z0.ILogicExpr{``0},Z0.IVarExpr{``0}[])">
            <summary>
            Defines an equality comparison expression
            </summary>
            <param name="lhs">The left expression</param>
            <param name="rhs">The right expression</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogicSpec.true">
            <summary>
            Creates a logical TRUE expression, i.e. an expression that is always true
            </summary>
        </member>
        <member name="M:Z0.BitLogicSpec.true``1">
            <summary>
            Creates a logical TRUE expression, i.e. an expression that is always true
            </summary>
        </member>
        <member name="M:Z0.BitLogicSpec.false">
            <summary>
            Creates a logical FALSE expression, i.e. an expression that is always false
            </summary>
        </member>
        <member name="M:Z0.BitLogicSpec.false``1">
            <summary>
            Creates a logical FALSE expression, i.e. an expression that is always false
            </summary>
        </member>
        <member name="M:Z0.BitLogicSpec.literal(Z0.Bit32)">
            <summary>
            Creates a bit literal expression
            </summary>
            <param name="a">The literal value</param>
        </member>
        <member name="M:Z0.BitLogicSpec.literal``1(Z0.Bit32)">
            <summary>
            Creates a typed logic literal
            </summary>
            <param name="a">The literal value</param>
        </member>
        <member name="M:Z0.BitLogicSpec.identity(Z0.ILogicExpr)">
            <summary>
            Defines a logical identity expression
            </summary>
            <param name="a">The operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.identity``1(Z0.ILogicExpr{``0})">
            <summary>
            Defines a typed logical identity expression
            </summary>
            <param name="a">The operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.unary(Z0.UnaryBitLogicKind,Z0.ILogicExpr)">
            <summary>
            Defines a unary logic operator over an expression
            </summary>
            <param name="op">The operator classifier</param>
            <param name="a">The operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogicSpec.unary``1(Z0.UnaryBitLogicKind,Z0.ILogicExpr{``0})">
            <summary>
            Defines a unary logic operator over an expression
            </summary>
            <param name="op">The operator classifier</param>
            <param name="a">The operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogicSpec.unary``1(Z0.UnaryBitLogicKind,Z0.Bit32)">
            <summary>
            Defines a unary logic operator over a typed literal operand
            </summary>
            <param name="op">The operator classifier</param>
            <param name="a">The operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogicSpec.unary(Z0.UnaryBitLogicKind,Z0.Bit32)">
            <summary>
            Defines a unary logic operator over a literal
            </summary>
            <param name="kind">The operator classifier</param>
            <param name="a">The operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogicSpec.binary(Z0.BinaryBitLogicKind,Z0.ILogicExpr,Z0.ILogicExpr)">
            <summary>
            Defines a binary logic operator over expression operands
            </summary>
            <param name="kind">The operator classifier</param>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.binary``1(Z0.BinaryBitLogicKind,Z0.ILogicExpr{``0},Z0.ILogicExpr{``0})">
            <summary>
            Defines a binary logic operator over typed expression operands
            </summary>
            <param name="kind">The operator classifier</param>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.binary(Z0.BinaryBitLogicKind,Z0.Bit32,Z0.Bit32)">
            <summary>
            Defines a binary logic operator over bit literal operands
            </summary>
            <param name="kind">The operator classifier</param>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.binary``1(Z0.BinaryBitLogicKind,Z0.Bit32,Z0.Bit32)">
            <summary>
            Defines a binary logic operator over typed literal operands
            </summary>
            <param name="kind">The operator classifier</param>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.ternary(Z0.TernaryBitLogicKind,Z0.ILogicExpr,Z0.ILogicExpr,Z0.ILogicExpr)">
            <summary>
            Defines a ternary logic operator over expression operands
            </summary>
            <param name="kind">The operator classifier</param>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <param name="c">The third operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.ternary``1(Z0.TernaryBitLogicKind,Z0.ILogicExpr{``0},Z0.ILogicExpr{``0},Z0.ILogicExpr{``0})">
            <summary>
            Defines a ternary logic operator over expression operands
            </summary>
            <param name="kind">The operator classifier</param>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <param name="c">The third operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.ternary(Z0.TernaryBitLogicKind,Z0.Bit32,Z0.Bit32,Z0.Bit32)">
            <summary>
            Defines a ternary logic operator over bit literal operands
            </summary>
            <param name="kind">The operator classifier</param>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <param name="c">The third operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.ternary``1(Z0.TernaryBitLogicKind,Z0.Bit32,Z0.Bit32,Z0.Bit32)">
            <summary>
            Defines a ternary logic operator over typed literal operands
            </summary>
            <param name="kind">The operator classifier</param>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <param name="c">The third operand</param>
        </member>
        <member name="M:Z0.BitLogicSpec.lvar(System.Char,Z0.Bit32)">
            <summary>
            Defines a bit variable expression initialized to a literal value
            </summary>
            <param name="name">The variable's single-character name</param>
            <param name="init">The variable's initial value</param>
        </member>
        <member name="M:Z0.BitLogicSpec.lvar(System.UInt32,Z0.Bit32)">
            <summary>
            Defines a bit variable expression initialized to a literal value
            and the variable name is defined by an integer
            </summary>
            <param name="symbol">The variable's name</param>
            <param name="init">The variable's initial value</param>
        </member>
        <member name="M:Z0.BitLogicSpec.lvar``1(System.UInt32,Z0.ILogicExpr{``0})">
            <summary>
            Defines a typed logic variable expression initialized to a literal value
            </summary>
            <param name="symbol">The variable's symbolic identifier</param>
            <param name="init">The variable's initial value</param>
        </member>
        <member name="M:Z0.BitLogicSpec.lvar``1(System.Char,Z0.Bit32)">
            <summary>
            Defines a typed logic variable expression initialized to a literal value
            </summary>
            <param name="symbol">The variable's name</param>
            <param name="init">The variable's initial value</param>
        </member>
        <member name="M:Z0.BitLogicSpec.lvar``1(System.UInt32,Z0.Bit32)">
            <summary>
            Defines a typed logic variable expression initialized to a literal value
            </summary>
            <param name="symbol">The variable's name</param>
            <param name="init">The variable's initial value</param>
        </member>
        <member name="M:Z0.BitLogicSpec.lvars(System.UInt32)">
            <summary>
            Defines a specified number n of logic variable expressions where each variable is respectively named 0,..., n - 1
            </summary>
            <param name="n">The number of variables to define</param>
        </member>
        <member name="M:Z0.BitLogicSpec.lvars``1(System.UInt32)">
            <summary>
            Defines a specified number n of typed logic variable expressions where each variable is respectively named 0,..., n - 1
            </summary>
            <param name="n">The number of variables to define</param>
        </member>
        <member name="M:Z0.BitLogicSpec.varied(Z0.ILogicExpr,Z0.LogicVariable[])">
            <summary>
            Creates a varied expression predicated on a specified variable sequence
            </summary>
            <param name="expr">The variable-dependent expression</param>
            <param name="vars">The variable sequence</param>
        </member>
        <member name="M:Z0.BitLogicSpec.varied``1(Z0.ILogicExpr{``0},Z0.LogicVariable{``0}[])">
            <summary>
            Creates a varied expression predicated on a specified variable sequence
            </summary>
            <param name="expr">The variable-dependent expression</param>
            <param name="vars">The variable sequence</param>
        </member>
        <member name="P:Z0.LogicIdentities.AndOverOr">
            <summary>
            Specifies the identity and(a,or(b,c)) == or(and(a,b), and(a,c))
            </summary>
        </member>
        <member name="P:Z0.LogicIdentities.AndOverXOr">
            <summary>
            Specifies the identity and(a,xor(b,c)) == xor(and(a,b), and(a,c))
            </summary>
        </member>
        <member name="P:Z0.LogicIdentities.OrOverAnd">
            <summary>
            Specifies the identity or(a,and(b,c)) == and(or(a,b), or(a,c))
            </summary>
        </member>
        <member name="P:Z0.LogicIdentities.NotOverAnd">
            <summary>
            Specifies the identity not(and(a,b)) == or(not(x),not(y))
            </summary>
        </member>
        <member name="P:Z0.LogicIdentities.NotOverXOr">
            <summary>
            Specifies the identity not(xor(a,b)) == xor(not(x),y)
            </summary>
        </member>
        <member name="M:Z0.PredicateSpec.compare``1(Z0.BinaryComparisonApiClass,Z0.IExpr{``0},Z0.IExpr{``0})">
            <summary>
            Defines a typed comparison predicate over operand expressions
            </summary>
            <param name="kind">The comparison kind</param>
            <param name="a">The left expression</param>
            <param name="b">The right expression</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.PredicateSpec.compare``1(Z0.BinaryComparisonApiClass,``0,``0)">
            <summary>
            Defines a typed comparison predicate over literal operands
            </summary>
            <param name="kind">The comparison kind</param>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.PredicateSpec.equals``1(Z0.IExpr{``0},Z0.IExpr{``0})">
            <summary>
            Defines an equality comparison expression
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.PredicateSpec.equals``1(``0,``0)">
            <summary>
            Defines an equality comparison expression over literal operands
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.PredicateSpec.lt``1(Z0.IExpr{``0},Z0.IExpr{``0})">
            <summary>
            Defines a less-than comparison expression
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.PredicateSpec.lt``1(``0,``0)">
            <summary>
            Defines a less-than comparison expression over literal operands
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.PredicateSpec.lteq``1(Z0.IExpr{``0},Z0.IExpr{``0})">
            <summary>
            Defines a less-than or equal comparison expression
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.PredicateSpec.lteq``1(``0,``0)">
            <summary>
            Defines a less-than or equal comparison expression over literal operands
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.PredicateSpec.gt``1(Z0.IExpr{``0},Z0.IExpr{``0})">
            <summary>
            Defines a greater-than comparison expression
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.PredicateSpec.gt``1(``0,``0)">
            <summary>
            Defines a greater-than comparison expression over literal operands
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.PredicateSpec.gteq``1(Z0.IExpr{``0},Z0.IExpr{``0})">
            <summary>
            Defines a greater-than or equal comparison expression
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.PredicateSpec.gteq``1(``0,``0)">
            <summary>
            Defines a greater-than or equal comparison expression over literal operands
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="T:Z0.TypedComparisonSpec">
            <summary>
            Constructs type operator comparison expressions
            </summary>
        </member>
        <member name="M:Z0.TypedComparisonSpec.compare``1(Z0.BinaryComparisonApiClass,Z0.IExpr{``0},Z0.IExpr{``0})">
            <summary>
            Defines a comparison expression of specified kind over typed expressions
            </summary>
            <param name="kind">The comparison kind</param>
            <param name="lhs">The left expression</param>
            <param name="rhs">The right expression</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedComparisonSpec.compare``1(Z0.BinaryComparisonApiClass,``0,``0)">
            <summary>
            Defines a comparison expression of specified kind over literals
            </summary>
            <param name="kind">The comparison kind</param>
            <param name="lhs">The left operand</param>
            <param name="rhs">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedComparisonSpec.equals``1(Z0.IExpr{``0},Z0.IExpr{``0})">
            <summary>
            Defines an equals operator expression
            </summary>
            <param name="lhs">The left operand</param>
            <param name="rhs">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedComparisonSpec.equals``1(``0,``0)">
            <summary>
            Defines an equals operator expression over literal values
            </summary>
            <param name="lhs">The left operand</param>
            <param name="rhs">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedComparisonSpec.neq``1(Z0.IExpr{``0},Z0.IExpr{``0})">
            <summary>
            Defines a not equal operator expression
            </summary>
            <param name="lhs">The left operand</param>
            <param name="rhs">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedComparisonSpec.neq``1(``0,``0)">
            <summary>
            Defines a not equal operator expression over literal values
            </summary>
            <param name="lhs">The left operand</param>
            <param name="rhs">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedComparisonSpec.lt``1(Z0.IExpr{``0},Z0.IExpr{``0})">
            <summary>
            Defines a less than operator expression
            </summary>
            <param name="lhs">The left operand</param>
            <param name="rhs">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedComparisonSpec.lt``1(``0,``0)">
            <summary>
            Defines an less than operator expression over literal values
            </summary>
            <param name="lhs">The left operand</param>
            <param name="rhs">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedComparisonSpec.lteq``1(Z0.IExpr{``0},Z0.IExpr{``0})">
            <summary>
            Defines a less than or equal operator expression
            </summary>
            <param name="lhs">The left operand</param>
            <param name="rhs">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedComparisonSpec.lteq``1(``0,``0)">
            <summary>
            Defines an less than or equal operator expression over literal values
            </summary>
            <param name="lhs">The left operand</param>
            <param name="rhs">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedComparisonSpec.gt``1(Z0.IExpr{``0},Z0.IExpr{``0})">
            <summary>
            Defines a greater than operator expression
            </summary>
            <param name="lhs">The left operand</param>
            <param name="rhs">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedComparisonSpec.gt``1(``0,``0)">
            <summary>
            Defines greater than operator expression over literal values
            </summary>
            <param name="lhs">The left operand</param>
            <param name="rhs">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedComparisonSpec.gteq``1(Z0.IExpr{``0},Z0.IExpr{``0})">
            <summary>
            Defines a greater than or equal operator expression
            </summary>
            <param name="lhs">The left operand</param>
            <param name="rhs">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedComparisonSpec.gteq``1(``0,``0)">
            <summary>
            Defines a greater than or equal operator expression over literal values
            </summary>
            <param name="lhs">The left operand</param>
            <param name="rhs">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedIdentities.AndOverOr``1">
            <summary>
            Specifies the identity and(a,or(b,c)) == or(and(a,b), and(a,c))
            </summary>
        </member>
        <member name="M:Z0.TypedIdentities.AndOverXOr``1">
            <summary>
            Specifies the identity and(a,xor(b,c)) == xor(and(a,b), and(a,c))
            </summary>
        </member>
        <member name="M:Z0.TypedIdentities.OrOverAnd``1">
            <summary>
            Specifies the identity or(a,and(b,c)) == and(or(a,b), or(a,c))
            </summary>
        </member>
        <member name="M:Z0.TypedIdentities.NotOverAnd``1">
            <summary>
            Specifies the identity not(and(a,b)) == or(not(x),not(y))
            </summary>
        </member>
        <member name="M:Z0.TypedIdentities.NotOverXOr``1">
            <summary>
            Specifies the identity not(xor(a,b)) == xor(not(x),y)
            </summary>
        </member>
        <member name="M:Z0.TypedLogicSpec.true``1">
            <summary>
            Defines a typed literal where all bits are on
            </summary>
            <typeparam name="T">The literal type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.true``1(Z0.N128)">
            <summary>
            Defines a 128-bit cpu vector where all bits are on
            </summary>
            <typeparam name="T">The literal type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.true``1(Z0.N256)">
            <summary>
            Defines a 128-bit cpu vector where all bits are on
            </summary>
            <typeparam name="T">The literal type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.false``1">
            <summary>
            Defines a typed literal where all bits are off
            </summary>
            <typeparam name="T">The literal type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.and``1(Z0.IExpr{``0},Z0.IExpr{``0})">
            <summary>
            Defines a bitwise and expression
            </summary>
            <param name="lhs">The left operand</param>
            <param name="rhs">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.and``1(``0,``0)">
            <summary>
            Defines a bitwise and expression with literal operands
            </summary>
            <param name="lhs">The left operand</param>
            <param name="rhs">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.or``1(Z0.IExpr{``0},Z0.IExpr{``0})">
            <summary>
            Defines a bitwise or expression
            </summary>
            <param name="lhs">The left operand</param>
            <param name="rhs">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.or``1(``0,``0)">
            <summary>
            Defines a bitwise or expression with literal operands
            </summary>
            <param name="lhs">The left operand</param>
            <param name="rhs">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.xor``1(Z0.IExpr{``0},Z0.IExpr{``0})">
            <summary>
            Defines a bitwise xor expression
            </summary>
            <param name="lhs">The left operand</param>
            <param name="rhs">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.xor``1(``0,``0)">
            <summary>
            Defines a bitwise xor expression with literal operands
            </summary>
            <param name="lhs">The left operand</param>
            <param name="rhs">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.not``1(Z0.IExpr{``0})">
            <summary>
            Defines a a bitwise complement expression
            </summary>
            <param name="operand">The expression operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.not``1(``0)">
            <summary>
            Defines a a bitwise complement expression with a literal operand
            </summary>
            <param name="operand">The expression operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.nand``1(Z0.IExpr{``0},Z0.IExpr{``0})">
            <summary>
            Defines a bitwise NAND expression
            </summary>
            <param name="lhs">The left operand</param>
            <param name="rhs">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.nand``1(``0,``0)">
            <summary>
            Defines a bitwise NAND expression with literal operands
            </summary>
            <param name="lhs">The left operand</param>
            <param name="rhs">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.nor``1(Z0.IExpr{``0},Z0.IExpr{``0})">
            <summary>
            Defines a bitwise NOR expression
            </summary>
            <param name="lhs">The left operand</param>
            <param name="rhs">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.nor``1(``0,``0)">
            <summary>
            Defines a bitwise NOR expression with literal operands
            </summary>
            <param name="lhs">The left operand</param>
            <param name="rhs">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.xnor``1(Z0.IExpr{``0},Z0.IExpr{``0})">
            <summary>
            Defines a bitwise XNOR expression
            </summary>
            <param name="lhs">The left operand</param>
            <param name="rhs">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.xnor``1(``0,``0)">
            <summary>
            Defines a bitwise XNOR expression with literal operands
            </summary>
            <param name="lhs">The left operand</param>
            <param name="rhs">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.literal``1(``0)">
            <summary>
            Creates a literal expression
            </summary>
            <param name="value">The literal value</param>
            <typeparam name="T">The literal type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.unary``1(Z0.UnaryBitLogicKind,Z0.IExpr{``0})">
            <summary>
            Creates a bitwise unary expression
            </summary>
            <param name="op">The operator classifier</param>
            <param name="operand">The operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.binary``1(Z0.BinaryBitLogicKind,Z0.IExpr{``0},Z0.IExpr{``0})">
            <summary>
            Creates a bitwise binary expression
            </summary>
            <param name="op">The operator classifier</param>
            <param name="left">The left operand</param>
            <param name="right">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.binary``1(Z0.BinaryComparisonApiClass,Z0.IExpr{``0},Z0.IExpr{``0})">
            <summary>
            Creates a binary comparison expression
            </summary>
            <param name="op">The operator classifier</param>
            <param name="left">The left operand</param>
            <param name="right">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.ternary``1(Z0.TernaryBitLogicKind,Z0.IExpr{``0},Z0.IExpr{``0},Z0.IExpr{``0})">
            <summary>
            Creates a bitwise ternary expression
            </summary>
            <param name="op">The operator classifier</param>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.rangexpr``1(``0,``0,System.Nullable{``0})">
            <summary>
            Defines a scalar range expression
            </summary>
            <param name="min">The minimum scalar in the range</param>
            <param name="max">The maximum scalar in the range</param>
            <typeparam name="T">The scalar type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.shift``1(Z0.BitShiftApiClass,Z0.IExpr{``0},System.Byte)">
            <summary>
            Creates a shift expression
            </summary>
            <param name="op">The operator classifier</param>
            <param name="src">The left operand</param>
            <param name="count">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.shiftx``1(Z0.BitShiftApiClass,Z0.IExpr{``0},Z0.IExpr{System.Byte})">
            <summary>
            Creates a shift expression
            </summary>
            <param name="op">The operator classifier</param>
            <param name="src">The left operand</param>
            <param name="count">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.sll``1(Z0.IExpr{``0},System.Byte)">
            <summary>
            Defines a bitwise sll expression
            </summary>
            <param name="src">The left operand</param>
            <param name="count">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.sll``1(``0,System.Byte)">
            <summary>
            Defines a bitwise sll expression with literal operands
            </summary>
            <param name="src">The left operand</param>
            <param name="count">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.srl``1(Z0.IExpr{``0},System.Byte)">
            <summary>
            Defines a bitwise srl expression
            </summary>
            <param name="src">The left operand</param>
            <param name="count">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.srl``1(``0,System.Byte)">
            <summary>
            Defines a bitwise srl expression with literal operands
            </summary>
            <param name="src">The left operand</param>
            <param name="count">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.rotr``1(Z0.IExpr{``0},System.Byte)">
            <summary>
            Defines a bitwise rotr expression
            </summary>
            <param name="src">The left operand</param>
            <param name="count">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.rotr``1(``0,System.Byte)">
            <summary>
            Defines a bitwise rotr expression with literal operands
            </summary>
            <param name="src">The left operand</param>
            <param name="count">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.rotl``1(Z0.IExpr{``0},System.Byte)">
            <summary>
            Defines a bitwise rotl expression
            </summary>
            <param name="src">The left operand</param>
            <param name="count">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.rotl``1(``0,System.Byte)">
            <summary>
            Defines a bitwise rotl expression with literal operands
            </summary>
            <param name="src">The left operand</param>
            <param name="count">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.sll``1(Z0.IExpr{``0},Z0.IExpr{System.Byte})">
            <summary>
            Defines a bitwise sll expression
            </summary>
            <param name="src">The left operand</param>
            <param name="count">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.sllx``1(``0,Z0.IExpr{System.Byte})">
            <summary>
            Defines a bitwise sll expression with literal operands
            </summary>
            <param name="src">The left operand</param>
            <param name="count">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.srl``1(Z0.IExpr{``0},Z0.IExpr{System.Byte})">
            <summary>
            Defines a bitwise srl expression
            </summary>
            <param name="src">The left operand</param>
            <param name="count">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.srl``1(``0,Z0.IExpr{System.Byte})">
            <summary>
            Defines a bitwise srl expression with literal operands
            </summary>
            <param name="src">The left operand</param>
            <param name="count">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.rotr``1(Z0.IExpr{``0},Z0.IExpr{System.Byte})">
            <summary>
            Defines a bitwise rotr expression
            </summary>
            <param name="src">The left operand</param>
            <param name="count">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.rotr``1(``0,Z0.IExpr{System.Byte})">
            <summary>
            Defines a bitwise rotr expression with literal operands
            </summary>
            <param name="src">The left operand</param>
            <param name="count">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.rotl``1(Z0.IExpr{``0},Z0.IExpr{System.Byte})">
            <summary>
            Defines a bitwise rotl expression
            </summary>
            <param name="src">The left operand</param>
            <param name="count">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.rotl``1(``0,Z0.IExpr{System.Byte})">
            <summary>
            Defines a bitwise rotl expression with literal operands
            </summary>
            <param name="src">The left operand</param>
            <param name="count">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.variable``1(System.String,Z0.IExpr{``0})">
            <summary>
            Defines a variable expression
            </summary>
            <param name="value">The initial value of the variable</param>
            <typeparam name="T">The variable type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.variable``1(System.Char,Z0.IExpr{``0})">
            <summary>
            Defines a variable expression
            </summary>
            <param name="value">The initial value of the variable</param>
            <typeparam name="T">The variable type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.variable``1(Z0.AsciLetterLo,Z0.IExpr{``0})">
            <summary>
            Defines a variable expression
            </summary>
            <param name="value">The initial value of the variable</param>
            <typeparam name="T">The variable type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.variable``1(System.UInt32,Z0.IExpr{``0})">
            <summary>
            Defines a bit variable expression where the variable name is defined by an integer
            </summary>
            <param name="name">The variable's name</param>
            <param name="init">The variable's initial value</param>
        </member>
        <member name="M:Z0.TypedLogicSpec.variable``1(System.String,``0)">
            <summary>
            Defines a variable expression with an initial value specified by a literal
            </summary>
            <param name="value">The initial value of the variable</param>
            <typeparam name="T">The variable type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.variable``1(System.Char,``0)">
            <summary>
            Defines a variable expression with an initial value specified by a literal
            </summary>
            <param name="value">The initial value of the variable</param>
            <typeparam name="T">The variable type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.variable``1(Z0.AsciLetterLo,``0)">
            <summary>
            Defines a variable expression with an initial value specified by a literal
            </summary>
            <param name="value">The initial value of the variable</param>
            <typeparam name="T">The variable type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.variable``1(System.UInt32,``0)">
            <summary>
            Defines a variable expression where the variable name is defined by an integer and
            an initial value is specified by a literal
            </summary>
            <param name="value">The initial value of the variable</param>
            <typeparam name="T">The variable type</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.varied``1(Z0.IExpr{``0},Z0.VariableExpr{``0}[])">
            <summary>
            Creates a varied expression predicated on a typed variable sequence
            </summary>
            <param name="subject">The variable-dependent expression</param>
            <param name="variables">The variable sequence</param>
        </member>
        <member name="M:Z0.TypedLogicSpec.varied``2(``0,Z0.IExpr{``1},Z0.IVarExpr{``1}[])">
            <summary>
            Creates a varied expression predicated on a typed variable sequence of natural length
            </summary>
            <param name="subject">The variable-dependent expression</param>
            <param name="variables">The variable sequence</param>
        </member>
        <member name="M:Z0.TypedLogicSpec.varied``1(Z0.N1,Z0.IExpr{``0},Z0.IVarExpr{``0})">
            <summary>
            Defines a varied expression of 1 variable
            </summary>
            <param name="n">The number of variables in the expression</param>
            <param name="baseExpr">The variable-dependent expression </param>
            <param name="v0">The variable</param>
            <typeparam name="T">The type over which the expression is defined</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.varied``1(Z0.N2,Z0.IExpr{``0},Z0.IVarExpr{``0},Z0.IVarExpr{``0})">
            <summary>
            Defines a varied expression of 2 variables
            </summary>
            <param name="n">The number of variables in the expression</param>
            <param name="baseExpr">The variable-dependent expression </param>
            <param name="v0">The first variable</param>
            <param name="v1">The second variable</param>
            <typeparam name="T">The type over which the expression is defined</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.varied``1(Z0.N3,Z0.IExpr{``0},Z0.IVarExpr{``0},Z0.IVarExpr{``0},Z0.IVarExpr{``0})">
            <summary>
            Defines a varied expression of 3 variables
            </summary>
            <param name="n">The number of variables in the expression</param>
            <param name="baseExpr">The variable-dependent expression </param>
            <param name="v0">The first variable</param>
            <param name="v1">The second variable</param>
            <param name="v2">The third variable</param>
            <typeparam name="T">The type over which the expression is defined</typeparam>
        </member>
        <member name="M:Z0.TypedLogicSpec.equals``1(Z0.IExpr{``0},Z0.IExpr{``0},Z0.IVarExpr{``0}[])">
            <summary>
            Defines a typed test expression
            </summary>
            <param name="test">The logical operator to use for the test</param>
            <param name="lhs">The control expression</param>
            <param name="rhs">The test subject</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.XExpr.Set``1(Z0.IVarExpr{``0},Z0.IPolyrand)">
            <summary>
            Assigns a random value to a variable and returns that value to the caller
            </summary>
            <param name="v">The variable to set</param>
            <param name="random">The random source</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.XExpr.Set``1(Z0.IVarExpr{``0},Z0.IPolyrand,``0,``0)">
            <summary>
            Assigns a random value to a variable and returns that value to the caller
            </summary>
            <param name="v">The variable to set</param>
            <param name="random">The random source</param>
            <param name="min">The inclusive min value to assign</param>
            <param name="max">The exclusive max value to assign</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.XExpr.Var0``1(Z0.VariedExpr{Z0.N1,``0})">
            <summary>
            Returns the source expression variable at index 0
            </summary>
            <param name="src">The source expression</param>
            <param name="value">The value, if any, to assign the variable</param>
            <typeparam name="T">The type over which the expression is defined</typeparam>
        </member>
        <member name="M:Z0.XExpr.Var0``1(Z0.VariedExpr{Z0.N1,``0},Z0.IExpr{``0})">
            <summary>
            Returns the source expression variable at index 0, optionally assigned to supplied value
            </summary>
            <param name="src">The source expression</param>
            <param name="value">The value, if any, to assign the variable</param>
            <typeparam name="T">The type over which the expression is defined</typeparam>
        </member>
        <member name="M:Z0.XExpr.Var0``1(Z0.VariedExpr{Z0.N1,``0},``0)">
            <summary>
            Returns the source expression variable at index 0, optionally assigned to supplied value
            </summary>
            <param name="src">The source expression</param>
            <param name="value">The value, if any, to assign the variable</param>
            <typeparam name="T">The type over which the expression is defined</typeparam>
        </member>
        <member name="M:Z0.XExpr.Var0``1(Z0.VariedExpr{Z0.N2,``0})">
            <summary>
            Returns the source expression variable at index 0
            </summary>
            <param name="src">The source expression</param>
            <param name="value">The value, if any, to assign the variable</param>
            <typeparam name="T">The type over which the expression is defined</typeparam>
        </member>
        <member name="M:Z0.XExpr.Var0``1(Z0.VariedExpr{Z0.N2,``0},Z0.IExpr{``0})">
            <summary>
            Returns the source expression variable at index 0, optionally assigned to supplied value
            </summary>
            <param name="src">The source expression</param>
            <param name="value">The value, if any, to assign the variable</param>
            <typeparam name="T">The type over which the expression is defined</typeparam>
        </member>
        <member name="M:Z0.XExpr.Var0``1(Z0.VariedExpr{Z0.N2,``0},``0)">
            <summary>
            Returns the source expression variable at index 0, optionally assigned to supplied value
            </summary>
            <param name="src">The source expression</param>
            <param name="value">The value, if any, to assign the variable</param>
            <typeparam name="T">The type over which the expression is defined</typeparam>
        </member>
        <member name="M:Z0.XExpr.Var1``1(Z0.VariedExpr{Z0.N2,``0})">
            <summary>
            Returns the source expression variable at index 1
            </summary>
            <param name="src">The source expression</param>
            <param name="value">The value, if any, to assign the variable</param>
            <typeparam name="T">The type over which the expression is defined</typeparam>
        </member>
        <member name="M:Z0.XExpr.Var1``1(Z0.VariedExpr{Z0.N2,``0},Z0.IExpr{``0})">
            <summary>
            Returns the source expression variable at index 1, optionally assigned to supplied value
            </summary>
            <param name="src">The source expression</param>
            <param name="value">The value, if any, to assign the variable</param>
            <typeparam name="T">The type over which the expression is defined</typeparam>
        </member>
        <member name="M:Z0.XExpr.Var1``1(Z0.VariedExpr{Z0.N2,``0},``0)">
            <summary>
            Returns the source expression variable at index 1, optionally assigned to supplied value
            </summary>
            <param name="src">The source expression</param>
            <param name="value">The value, if any, to assign the variable</param>
            <typeparam name="T">The type over which the expression is defined</typeparam>
        </member>
        <member name="M:Z0.XExpr.Var0``1(Z0.VariedExpr{Z0.N3,``0})">
            <summary>
            Returns the source expression variable at index 0
            </summary>
            <param name="src">The source expression</param>
            <param name="value">The value, if any, to assign the variable</param>
            <typeparam name="T">The type over which the expression is defined</typeparam>
        </member>
        <member name="M:Z0.XExpr.Var0``1(Z0.VariedExpr{Z0.N3,``0},Z0.IExpr{``0})">
            <summary>
            Returns the source expression variable at index 0, optionally assigned to supplied value
            </summary>
            <param name="src">The source expression</param>
            <param name="value">The value, if any, to assign the variable</param>
            <typeparam name="T">The type over which the expression is defined</typeparam>
        </member>
        <member name="M:Z0.XExpr.Var0``1(Z0.VariedExpr{Z0.N3,``0},``0)">
            <summary>
            Returns the source expression variable at index 0, optionally assigned to supplied value
            </summary>
            <param name="src">The source expression</param>
            <param name="value">The value, if any, to assign the variable</param>
            <typeparam name="T">The type over which the expression is defined</typeparam>
        </member>
        <member name="M:Z0.XExpr.Var1``1(Z0.VariedExpr{Z0.N3,``0})">
            <summary>
            Returns the source expression variable at index 1
            </summary>
            <param name="src">The source expression</param>
            <param name="value">The value, if any, to assign the variable</param>
            <typeparam name="T">The type over which the expression is defined</typeparam>
        </member>
        <member name="M:Z0.XExpr.Var1``1(Z0.VariedExpr{Z0.N3,``0},Z0.IExpr{``0})">
            <summary>
            Returns the source expression variable at index 1, optionally assigned to supplied value
            </summary>
            <param name="src">The source expression</param>
            <param name="value">The value, if any, to assign the variable</param>
            <typeparam name="T">The type over which the expression is defined</typeparam>
        </member>
        <member name="M:Z0.XExpr.Var1``1(Z0.VariedExpr{Z0.N3,``0},``0)">
            <summary>
            Returns the source expression variable at index 1, optionally assigned to supplied value
            </summary>
            <param name="src">The source expression</param>
            <param name="value">The value, if any, to assign the variable</param>
            <typeparam name="T">The type over which the expression is defined</typeparam>
        </member>
        <member name="M:Z0.XExpr.Var2``1(Z0.VariedExpr{Z0.N3,``0})">
            <summary>
            Returns the source expression variable at index 2
            </summary>
            <param name="src">The source expression</param>
            <param name="value">The value, if any, to assign the variable</param>
            <typeparam name="T">The type over which the expression is defined</typeparam>
        </member>
        <member name="M:Z0.XExpr.Var2``1(Z0.VariedExpr{Z0.N3,``0},Z0.IExpr{``0})">
            <summary>
            Returns the source expression variable at index 2, optionally assigned to supplied value
            </summary>
            <param name="src">The source expression</param>
            <param name="value">The value, if any, to assign the variable</param>
            <typeparam name="T">The type over which the expression is defined</typeparam>
        </member>
        <member name="M:Z0.XExpr.Var2``1(Z0.VariedExpr{Z0.N3,``0},``0)">
            <summary>
            Returns the source expression variable at index 2, optionally assigned to supplied value
            </summary>
            <param name="src">The source expression</param>
            <param name="value">The value, if any, to assign the variable</param>
            <typeparam name="T">The type over which the expression is defined</typeparam>
        </member>
        <member name="T:Z0.LogicExprKind">
            <summary>
            Classifier for logical expressions
            </summary>
        </member>
        <member name="F:Z0.LogicExprKind.Variable">
            <summary>
            Classifies boolean bariables
            </summary>
        </member>
        <member name="F:Z0.LogicExprKind.Varied">
            <summary>
            Classifies a boolean expression that depends on one or more variables
            </summary>
        </member>
        <member name="F:Z0.LogicExprKind.Literal">
            <summary>
            Classifies a boolean literal expression
            </summary>
        </member>
        <member name="F:Z0.LogicExprKind.Comparison">
            <summary>
            Classifies a boolean comparison expression
            </summary>
        </member>
        <member name="F:Z0.LogicExprKind.UnaryOperator">
            <summary>
            Classifies a boolean unary operator
            </summary>
        </member>
        <member name="F:Z0.LogicExprKind.BinaryOperator">
            <summary>
            Classifies a boolean binary operator
            </summary>
        </member>
        <member name="F:Z0.LogicExprKind.TernaryOperator">
            <summary>
            Classifies a boolean ternary operator
            </summary>
        </member>
        <member name="T:Z0.BinaryArithmeticOpExpr`1">
            <summary>
            Defines a typed binary arithmetic operator expression
            </summary>
        </member>
        <member name="P:Z0.BinaryArithmeticOpExpr`1.ApiClass">
            <summary>
            The operator kind
            </summary>
        </member>
        <member name="P:Z0.BinaryArithmeticOpExpr`1.LeftArg">
            <summary>
            The left operand
            </summary>
        </member>
        <member name="P:Z0.BinaryArithmeticOpExpr`1.RightArg">
            <summary>
            The right operand
            </summary>
        </member>
        <member name="M:Z0.BinaryArithmeticOpExpr`1.Format">
            <summary>
            Renders the expression in canonical form
            </summary>
        </member>
        <member name="T:Z0.UnaryArithmeticOpExpr`1">
            <summary>
            Defines a typed unary arithmetic operator expression
            </summary>
        </member>
        <member name="P:Z0.UnaryArithmeticOpExpr`1.ApiClass">
            <summary>
            The operator kind
            </summary>
        </member>
        <member name="P:Z0.UnaryArithmeticOpExpr`1.Arg">
            <summary>
            The operand
            </summary>
        </member>
        <member name="T:Z0.BinaryBitwiseOpExpr`1">
            <summary>
            Captures a binary bitwise operator along with with its operands
            </summary>
        </member>
        <member name="P:Z0.BinaryBitwiseOpExpr`1.ApiClass">
            <summary>
            The operator kind
            </summary>
        </member>
        <member name="P:Z0.BinaryBitwiseOpExpr`1.LeftArg">
            <summary>
            The left operand
            </summary>
        </member>
        <member name="P:Z0.BinaryBitwiseOpExpr`1.RightArg">
            <summary>
            The right operand
            </summary>
        </member>
        <member name="M:Z0.BinaryBitwiseOpExpr`1.Format">
            <summary>
            Renders the expression in canonical form
            </summary>
        </member>
        <member name="T:Z0.ShiftOpExpr`1">
            <summary>
            Defines a bitwise shift operator expression
            </summary>
        </member>
        <member name="P:Z0.ShiftOpExpr`1.ApiClass">
            <summary>
            The operator kind
            </summary>
        </member>
        <member name="P:Z0.ShiftOpExpr`1.Subject">
            <summary>
            The operand
            </summary>
        </member>
        <member name="P:Z0.ShiftOpExpr`1.Offset">
            <summary>
            The magnitude of the shift
            </summary>
        </member>
        <member name="T:Z0.TernaryBitwiseOpExpr`1">
            <summary>
            Defines a typed ternary bitwise operator expression
            </summary>
        </member>
        <member name="P:Z0.TernaryBitwiseOpExpr`1.ApiClass">
            <summary>
            The operator kind
            </summary>
        </member>
        <member name="P:Z0.TernaryBitwiseOpExpr`1.FirstArg">
            <summary>
            The first operand
            </summary>
        </member>
        <member name="P:Z0.TernaryBitwiseOpExpr`1.SecondArg">
            <summary>
            The second operand
            </summary>
        </member>
        <member name="P:Z0.TernaryBitwiseOpExpr`1.ThirdArg">
            <summary>
            The third operand
            </summary>
        </member>
        <member name="T:Z0.UnaryBitwiseOpExpr`1">
            <summary>
            Defines a unary bitwise operator expression
            </summary>
        </member>
        <member name="P:Z0.UnaryBitwiseOpExpr`1.ApiClass">
            <summary>
            The operator kind
            </summary>
        </member>
        <member name="P:Z0.UnaryBitwiseOpExpr`1.Arg">
            <summary>
            The operand
            </summary>
        </member>
        <member name="T:Z0.ComparisonExpr">
            <summary>
            Defines an untyped comparison expression
            </summary>
        </member>
        <member name="P:Z0.ComparisonExpr.ComparisonKind">
            <summary>
            The operator kind
            </summary>
        </member>
        <member name="P:Z0.ComparisonExpr.Lhs">
            <summary>
            The left operand
            </summary>
        </member>
        <member name="P:Z0.ComparisonExpr.Rhs">
            <summary>
            The right operand
            </summary>
        </member>
        <member name="P:Z0.ComparisonExpr.Vars">
            <summary>
            The variables upon which the operands depend
            </summary>
        </member>
        <member name="T:Z0.ComparisonExpr`1">
            <summary>
            Defines a typed comparison expression
            </summary>
        </member>
        <member name="P:Z0.ComparisonExpr`1.ComparisonKind">
            <summary>
            The operator kind
            </summary>
        </member>
        <member name="P:Z0.ComparisonExpr`1.LeftArg">
            <summary>
            The left expression
            </summary>
        </member>
        <member name="P:Z0.ComparisonExpr`1.RightArg">
            <summary>
            The right expression
            </summary>
        </member>
        <member name="P:Z0.ComparisonExpr`1.Vars">
            <summary>
            The variables upon which the operands depend
            </summary>
        </member>
        <member name="T:Z0.ComparisonPredExpr`1">
            <summary>
            Defines a typed comparison predicate
            </summary>
        </member>
        <member name="P:Z0.ComparisonPredExpr`1.ComparisonKind">
            <summary>
            The operator kind
            </summary>
        </member>
        <member name="P:Z0.ComparisonPredExpr`1.LeftArg">
            <summary>
            The left operand
            </summary>
        </member>
        <member name="P:Z0.ComparisonPredExpr`1.RightArg">
            <summary>
            The right operand
            </summary>
        </member>
        <member name="P:Z0.ComparisonPredExpr`1.Vars">
            <summary>
            The variables upon which the operands depend
            </summary>
        </member>
        <member name="P:Z0.Expr`1.Encoding">
            <summary>
            The identified expression
            </summary>
        </member>
        <member name="T:Z0.FormulaExpr">
            <summary>
            Defines an untyped identified expression, identifier := expression
            </summary>
        </member>
        <member name="P:Z0.FormulaExpr.Name">
            <summary>
            The identifier
            </summary>
        </member>
        <member name="P:Z0.FormulaExpr.Encoding">
            <summary>
            The identified expression
            </summary>
        </member>
        <member name="T:Z0.FormulaExpr`1">
            <summary>
            Defines a typed identified expression, identifier := expression
            </summary>
        </member>
        <member name="P:Z0.FormulaExpr`1.Name">
            <summary>
            The identifier
            </summary>
        </member>
        <member name="P:Z0.FormulaExpr`1.Encoding">
            <summary>
            The identified expression
            </summary>
        </member>
        <member name="T:Z0.BinaryLogicOpExpr">
            <summary>
            Definesan untyped binary logical operator expression
            </summary>
        </member>
        <member name="P:Z0.BinaryLogicOpExpr.ApiClass">
            <summary>
            The operator kind
            </summary>
        </member>
        <member name="P:Z0.BinaryLogicOpExpr.LeftArg">
            <summary>
            The left operand
            </summary>
        </member>
        <member name="P:Z0.BinaryLogicOpExpr.RightArg">
            <summary>
            The right operand
            </summary>
        </member>
        <member name="T:Z0.BinaryLogicOpExpr`1">
            <summary>
            Defines a typed binary logical operator expression
            </summary>
        </member>
        <member name="P:Z0.BinaryLogicOpExpr`1.LeftArg">
            <summary>
            The left operand
            </summary>
        </member>
        <member name="P:Z0.BinaryLogicOpExpr`1.RightArg">
            <summary>
            The right operand
            </summary>
        </member>
        <member name="P:Z0.BinaryLogicOpExpr`1.ApiClass">
            <summary>
            The operator kind
            </summary>
        </member>
        <member name="T:Z0.LiteralLogicSeqExpr`1">
            <summary>
            Defines a natural-length sequence of literal bit values
            </summary>
        </member>
        <member name="T:Z0.LiteralLogicExpr">
            <summary>
            Defines an untyped literal logic expression
            </summary>
        </member>
        <member name="P:Z0.LiteralLogicExpr.Value">
            <summary>
            The literal value
            </summary>
        </member>
        <member name="M:Z0.LiteralLogicExpr.op_Implicit(Z0.LiteralLogicExpr)~System.Boolean">
            <summary>
            Implicitly converts a literal expression to the underlying value
            </summary>
            <param name="src">The source expression</param>
        </member>
        <member name="M:Z0.LiteralLogicExpr.op_Implicit(System.Boolean)~Z0.LiteralLogicExpr">
            <summary>
            Implicitly converts a value to a literal expression
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="T:Z0.LiteralLogicExpr`1">
            <summary>
            Defines a typed literal logic expression
            </summary>
        </member>
        <member name="P:Z0.LiteralLogicExpr`1.Value">
            <summary>
            The literal value
            </summary>
        </member>
        <member name="T:Z0.LiteralLogicSeqExpr">
            <summary>
            Defines a sequence of literal bit values
            </summary>
        </member>
        <member name="P:Z0.LiteralLogicSeqExpr.ExprKind">
            <summary>
            The expression classifier
            </summary>
        </member>
        <member name="T:Z0.LogicVariable">
            <summary>
            Defines an untyped logic variable
            </summary>
        </member>
        <member name="P:Z0.LogicVariable.Symbol">
            <summary>
            The variable's symbolic identifier
            </summary>
        </member>
        <member name="P:Z0.LogicVariable.Value">
            <summary>
            The variable value
            </summary>
        </member>
        <member name="P:Z0.LogicVariable.Name">
            <summary>
            The variable name
            </summary>
        </member>
        <member name="T:Z0.LogicVariable`1">
            <summary>
            Defines a typed logic variable expression
            </summary>
        </member>
        <member name="P:Z0.LogicVariable`1.Name">
            <summary>
            The variable name
            </summary>
        </member>
        <member name="P:Z0.LogicVariable`1.Value">
            <summary>
            The variable value
            </summary>
        </member>
        <member name="T:Z0.TernaryLogicOpExpr">
            <summary>
            Defines the application of an untyped ternary logic operator
            </summary>
        </member>
        <member name="P:Z0.TernaryLogicOpExpr.ApiClass">
            <summary>
            The operator kind
            </summary>
        </member>
        <member name="P:Z0.TernaryLogicOpExpr.FirstArg">
            <summary>
            The first operand
            </summary>
        </member>
        <member name="P:Z0.TernaryLogicOpExpr.SecondArg">
            <summary>
            The second operand
            </summary>
        </member>
        <member name="P:Z0.TernaryLogicOpExpr.ThirdArg">
            <summary>
            The third operand
            </summary>
        </member>
        <member name="T:Z0.TernaryLogicOpExpr`1">
            <summary>
            Defines a typed ternary logic operator expression
            </summary>
        </member>
        <member name="P:Z0.TernaryLogicOpExpr`1.ApiClass">
            <summary>
            The operator kind
            </summary>
        </member>
        <member name="P:Z0.TernaryLogicOpExpr`1.FirstArg">
            <summary>
            The first operand
            </summary>
        </member>
        <member name="P:Z0.TernaryLogicOpExpr`1.SecondArg">
            <summary>
            The second operand
            </summary>
        </member>
        <member name="P:Z0.TernaryLogicOpExpr`1.ThirdArg">
            <summary>
            The third operand
            </summary>
        </member>
        <member name="T:Z0.UnaryLogicOpExpr">
            <summary>
            Defines an untyped unary logic operator expression
            </summary>
        </member>
        <member name="P:Z0.UnaryLogicOpExpr.ApiClass">
            <summary>
            The operator kind
            </summary>
        </member>
        <member name="P:Z0.UnaryLogicOpExpr.Arg">
            <summary>
            The operand
            </summary>
        </member>
        <member name="T:Z0.VariedLogicExpr">
            <summary>
            Defines an untyped logic expression over one or more variables
            </summary>
        </member>
        <member name="P:Z0.VariedLogicExpr.BaseExpr">
            <summary>
            The variable-dependent expression
            </summary>
        </member>
        <member name="P:Z0.VariedLogicExpr.Vars">
            <summary>
            The variables that parametrize the base expression
            </summary>
        </member>
        <member name="T:Z0.VariedLogicExpr`1">
            <summary>
            Defines a typed logic expression over one or more variables
            </summary>
        </member>
        <member name="P:Z0.VariedLogicExpr`1.BaseExpr">
            <summary>
            The variable-dependent expression
            </summary>
        </member>
        <member name="P:Z0.VariedLogicExpr`1.Vars">
            <summary>
            The variables that parametrize the base expression
            </summary>
        </member>
        <member name="M:Z0.VarRandom.SetNext``1(Z0.IPolySourced,Z0.VariableExpr{``0})">
            <summary>
            Obtains the next primal value from the random source, assigns the
            variable to this value and returns the value to the caller
            </summary>
            <param name="random"></param>
            <param name="current"></param>
            <typeparam name="T">The primal value over which the variable is defined</typeparam>
        </member>
        <member name="T:Z0.RangeExpr`1">
            <summary>
            Defines a stewise-contiguous sequence of scalar values, available on-demand,
            that satisfy upper/lower bound constraints
            </summary>
            <typeparam name="T">The scalar type</typeparam>
        </member>
        <member name="F:Z0.RangeExpr`1.Min">
            <summary>
            The min value in the range
            </summary>
        </member>
        <member name="F:Z0.RangeExpr`1.Max">
            <summary>
            The max value in the range
            </summary>
        </member>
        <member name="F:Z0.RangeExpr`1.Step">
            <summary>
            The distance between successive range points
            </summary>
        </member>
        <member name="T:Z0.LiteralExpr`1">
            <summary>
            Lifts a literal value to an expression
            </summary>
        </member>
        <member name="P:Z0.LiteralExpr`1.Value">
            <summary>
            The literal value
            </summary>
        </member>
        <member name="M:Z0.LiteralExpr`1.op_Implicit(Z0.LiteralExpr{`0})~`0">
            <summary>
            Implicitly converts a literal expression to the underlying value
            </summary>
            <param name="src">The source expression</param>
        </member>
        <member name="M:Z0.LiteralExpr`1.op_Implicit(`0)~Z0.LiteralExpr{`0}">
            <summary>
            Implicitly converts a value to a literal expression
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="P:Z0.VariableExpr`1.Name">
            <summary>
            The name of the variable
            </summary>
        </member>
        <member name="P:Z0.VariableExpr`1.Value">
            <summary>
            The value of the variable
            </summary>
        </member>
        <member name="M:Z0.VariableExpr`1.Set(Z0.IExpr{`0})">
            <summary>
            Updates the variable's value
            </summary>
            <param name="value">The new value</param>
        </member>
        <member name="T:Z0.VariedExpr`2">
            <summary>
             Defines a typed expression over a variable sequence of natural length
            </summary>
            <typeparam name="N">The sequence length type</typeparam>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="T:Z0.VariedExpr`1">
            <summary>
            Defines a variable-dependent typed expression
            </summary>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="P:Z0.VariedExpr`1.BaseExpr">
            <summary>
            A variable-dependent expression
            </summary>
        </member>
        <member name="P:Z0.VariedExpr`1.Vars">
            <summary>
            The variables upon which the expression depends
            </summary>
        </member>
        <member name="T:Z0.TypedExprKind">
            <summary>
            Classifies typed expressions
            </summary>
        </member>
        <member name="F:Z0.TypedExprKind.Variable">
            <summary>
            Classifies a variable
            </summary>
        </member>
        <member name="F:Z0.TypedExprKind.Varied">
            <summary>
            Classifies an expression that depends on one or more variables
            </summary>
        </member>
        <member name="F:Z0.TypedExprKind.Literal">
            <summary>
            Classifies a literal expression
            </summary>
        </member>
        <member name="F:Z0.TypedExprKind.Comparison">
            <summary>
            Classifies a comparison expression
            </summary>
        </member>
        <member name="F:Z0.TypedExprKind.UnaryOperator">
            <summary>
            Classifies a unary operator
            </summary>
        </member>
        <member name="F:Z0.TypedExprKind.BinaryOperator">
            <summary>
            Classifies a binary operator
            </summary>
        </member>
        <member name="F:Z0.TypedExprKind.TernaryOperator">
            <summary>
            Classifies a ternary operator
            </summary>
        </member>
        <member name="F:Z0.TypedExprKind.ShiftExpr">
            <summary>
            Classifies a shift expression
            </summary>
        </member>
        <member name="T:Z0.Choice16">
            <summary>
            Represents a subset of 16 distinct choices, including the empty set
            </summary>
        </member>
        <member name="T:Z0.Choice32">
            <summary>
            Represents a subset of 32 distinct choices, including the empty set
            </summary>
        </member>
        <member name="T:Z0.Choice8">
            <summary>
            Represents a subset of 8 distinct choices, including the empty set
            </summary>
        </member>
        <member name="T:Z0.QuestionChoice`1">
            <summary>
            Defines a choice in the context of a survey question
            </summary>
            <typeparam name="T">The primal survey representation type</typeparam>
        </member>
        <member name="P:Z0.QuestionChoice`1.ChoiceId">
            <summary>
            Uniquely identifies a choice relative to a question
            </summary>
        </member>
        <member name="P:Z0.QuestionChoice`1.Label">
            <summary>
            The meaning of the choice
            </summary>
        </member>
        <member name="T:Z0.QuestionResponse`1">
            <summary>
            Defines a response to a survey question
            </summary>
            <typeparam name="T">The primal survey representation type</typeparam>
        </member>
        <member name="T:Z0.Question`1">
            <summary>
            Defines a question in the context of a survey
            </summary>
            <typeparam name="T">The primal survey representation type</typeparam>
        </member>
        <member name="P:Z0.Question`1.QuestionId">
            <summary>
            Uniquely identifies a question relative to a survey
            </summary>
        </member>
        <member name="P:Z0.Question`1.Label">
            <summary>
            The question statement
            </summary>
        </member>
        <member name="P:Z0.Question`1.MaxSelect">
            <summary>
            The maximum number of choices allowed for a response, between 0 and the number of available choices
            </summary>
        </member>
        <member name="P:Z0.Question`1.Choices">
            <summary>
            The potential choices/answers
            </summary>
        </member>
        <member name="T:Z0.Survey`1">
            <summary>
            Defines a survey predicated on primal type evaluation
            </summary>
            <typeparam name="T">The primal survey representation type</typeparam>
        </member>
        <member name="P:Z0.SurveyFormatter.ChoiceCodes">
            <summary>
            The numeric codes for the asci characters 'A' .. 'Z'
            </summary>
        </member>
        <member name="T:Z0.SurveyResponse`1">
            <summary>
            Defines a response to a survey
            </summary>
            <typeparam name="T">The primal survey representation type</typeparam>
        </member>
        <member name="P:Z0.SurveyResponse`1.SurveyId">
            <summary>
            The survey identifier
            </summary>
        </member>
        <member name="P:Z0.SurveyResponse`1.Answered">
            <summary>
            The answered survey questions
            </summary>
        </member>
    </members>
</doc>
