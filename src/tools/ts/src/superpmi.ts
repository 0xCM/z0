import * as z0 from "./Tools"
declare let superpmi: "./superpmi"
export default superpmi
export type Tool = 'superpmi'
let tool:Tool = 'superpmi'

export type ExitCode = -1 | -2 | 0 | 1 | 2

export let ExitCodes:z0.ExitCodes<Tool,ExitCode> = [
    tool,
    [
        [-2, `JIT failed to initialize`],
        [-1, `general fatal error (e.g., failed to initialize, failed to read files)`],
        [0,  `Success`],
        [1,  `there were compilation failures`],
        [2,  `there were assembly diffs`],
    ]]

export type VerbosityFlag =
    | 'a'
    | 'd'
    | 'e'
    | 'i'
    | 'm'
    | 'n'
    | 'q'
    | 'v'
    | 'w'

export let VerbosityFlags:z0.ToolFlags<Tool,VerbosityFlag> = [
    tool,
    [
        ['a', 'all: enable all message types; overrides other enable message types'],
        ['e', `errors: internal fatal errors that are non-recoverable`],
        ['i', `issues: issues found with the JIT, e.g., asm diffs, asserts`],
        ['m', `missing: failures due to missing JIT-EE interface details`],
        ['n', `information: notifications/summaries, e.g., 'Loaded 5  Jitted 4  FailedCompile 1'`],
        ['q', `quiet: disable all output; overrides all others`],
        ['v', `verbose: status messages, e.g., 'Jit startup took '151.12ms'`],
        ['w', `warnings: internal conditions that are unusual, but not serious`],
    ]]

export type StatsFlag =
    | 'i'
    | 'a'
    | 'h'
    | 'n'
    | 't'
    | '*'

export type StatsChoice =
    | 'i'   | 'a'    | 'h'   | 'n'  | 't'  | '*'
    | 'ia'  | 'ih'   | 'in'  | 'it'
    | 'ah'  | 'an'   | 'at'
    | 'hn'  | 'ht'
    | 'iah' | 'iahn' | 'iahnt'
    | 'ahn' | 'ahnt'
    | 'hnt'

export let StatsFlags:z0.ToolFlags<Tool,StatsFlag> = [
    tool,
    [
        ['a', "method compiled ASM code size"],
        ['i', "method IL code size"],
        ['h', "method hash to uniquely identify a method across MCH files"],
        ['n', "method number inside the source MCH"],
        ['t', "method throughput time"],
        ['*', "all available method stats"]
    ]]

export type Flag =
    | '-a'
    | '-applyDiff'
    | '-boe'
    | '-boa'
    | '-c'
    | '-compile'
    | '-diffMCList'
    | '-e'
    | '-emitMethodStats'
    | '-f'
    | '-failingMCList'
    | '-m'
    | '-matchHash'
    | '-r'
    | '-reproName'
    | '-p'
    | '-parallel'
    | '-skipCleanup'
    | '-target'
    | '-jitoption'
    | '-jit2option'
    | '-v'
    | '-verbosity'
    | '-w'
    | '-writeLogFile'

export let Synonyms : z0.FlagSynonyms<Tool,Flag> = [
    tool,
    [
        ['-a', '-applyDiff'],
        ['-c', '-compile'],
        ['-e', '-emitMethodStats'],
        ['-f', '-failingMCList'],
        ['-m', '-matchHash'],
        ['-p', '-parallel'],
        ['-v', '-verbosity'],
        ['-w', '-writeLogFile'],
    ]]

export let Flags:z0.ToolFlags<Tool,Flag> = [
    tool,
    [
        ['-applyDiff',
            `Compare the compile result generated from the provided JIT with the
            compile result stored with the MC. If two JITs are provided, this
            compares the compile results generated by the two JITs.`],
        ['-boa',`Break on assert from the JIT`],
        ['-boe', `Break on error return from compileMethod`],
        ['-compile',
            `Compile only those method contexts whose indices are specified. Indices can be
            either a single index, comma separated values, a range, or the name of a .MCL file
            with newline delimited indices.`],
        ['-diffMCList',`Write out methods that differ between compilations to diffMCLfilename. This only works with -applyDiff`],
        ['-emitMethodStats', `Emit method statistics in CSV format to filename.mc.stats`],
        ['-failingMCList',
            ` Write out failing methods to mclfilename. If using -applyDiff and no -diffMCList is specified,
            comparison failures also get written to mclfilename.`],
        ['-jit2option',
            `Set the JIT option named "key" to "value" for JIT 2 if the option was not set. With optional
            force flag overwrites the existing value if it was already set. NOTE: do not use a "COMPlus_"
            prefix, "key" and "value" are case sensitive! Inputs are case sensitive. SuperPMI method contexts
            are stored in files with extension .MC, implying a single method context, or .MCH, implying a set
            of method contexts. Either extension works equivalently.`],
        ['-jitoption',
            `Set the JIT option named "key" to "value" for JIT 1
            if the option was not set. With optional force flag overwrites the existing value if it was
            already set. NOTE: do not use a "COMPlus_" prefix, "key" and "value" are case sensitive!`],
        ['-matchHash',`Compile only method context with specific MD5 hash`],
        ['-parallel',
            `Run in parallel mode by spawning 'workerCount' processes to
            do processing. If 'workerCount' is not specified, the number of workers used is
            the number of processors on the machine.`],
        ['-reproName',`Write out failing methods to prefix-n.mc`],
        ['-skipCleanup',`Skip deletion of temporary files created by child SuperPMI processes with -parallel`],
        ['-target',
            `Used by the assembly differences calculator. This specifies the target
            architecture for cross-compilation. Currently allowed <target> values: arm, arm64`],
        ['-verbosity',
            `Controls which types of messages SuperPMI logs. Specify a string of characters representing message categories to enable`],
        ['-writeLogFile', `Write log messages to the specified file.`]
    ]]

export let Examples: z0.UsageExamples<Tool> = [
    tool,
    [
        "{ToolId} clrjit.dll test.mch:: compile all functions in test.mch using clrjit.dll",
        "{ToolId} -p clrjit.dll test.mch:: same as above, but use all available processors to compile in parallel",
        "{ToolId} -f fail.mcl clrjit.dll test.mch:: if there are any failures, record their MC numbers in the file fail.mcl"
    ]
]

export let Doc: z0.UsageDoc<Tool> = [
    tool,
    `
    SuperPMI is a JIT compiler testing tool.

    Usage: superpmi [options] jitname [jitname2] filename.mc
     jitname.dll - path of jit to be tested
     jitname2.dll - optional path of second jit to be tested
     filename.mc - load method contexts from filename.mc
     -j[it] Name - optionally -jit can be used to specify jits
     -l[oad] filename - optionally -load can be used to specify method contexts

    Options:

     -boe
         Break on error return from compileMethod

     -boa
         Break on assert from the JIT

     -v[erbosity] messagetypes
         Controls which types of messages SuperPMI logs. Specify a string of
         characters representing message categories to enable, where:
             e - errors (internal fatal errors that are non-recoverable)
             w - warnings (internal conditions that are unusual, but not serious)
             m - missing (failures due to missing JIT-EE interface details)
             i - issues (issues found with the JIT, e.g. asm diffs, asserts)
             n - information (notifications/summaries, e.g. 'Loaded 5  Jitted 4  FailedCompile 1')
             v - verbose (status messages, e.g. 'Jit startup took '151.12ms')
             d - debug (lots of detailed output)
             a - all (enable all message types; overrides other enable message types)
             q - quiet (disable all output; overrides all others)
         e.g. '-v ew' only writes error and warning messages to the console.
         'q' takes precedence over any other message type specified.
         Default set of messages enabled is 'ewminv'.

     -w[riteLogFile] logfile
         Write log messages to the specified file.

     -c[ompile] <indices>
         Compile only those method contexts whose indices are specified.
         Indices can be either a single index, comma separated values,
         a range, or the name of a .MCL file with newline delimited indices.
         e.g. -compile 20
         e.g. -compile 20,25,30,32
         e.g. -compile 10-99
         e.g. -compile 5,10-99,101,201-300
         e.g. -compile failed.mcl

     -m[atchHash] <MD5 Hash>
         Compile only method context with specific MD5 hash

     -e[mitMethodStats] <stats-types>
         Emit method statistics in CSV format to filename.mc.stats.
         Specify a string of characters representing statistics to emit, where:
             i - method IL code size
             a - method compiled ASM code size
             h - method hash to uniquely identify a method across MCH files
             n - method number inside the source MCH
             t - method throughput time
             * - all available method stats

     -a[pplyDiff]
         Compare the compile result generated from the provided JIT with the
         compile result stored with the MC. If two JITs are provided, this
         compares the compile results generated by the two JITs.

     -r[eproName] prefix
         Write out failing methods to prefix-n.mc

     -f[ailingMCList] mclfilename
         Write out failing methods to mclfilename.
         If using -applyDiff and no -diffMCList is specified,
         comparison failures also get written to mclfilename.

     -diffMCList diffMCLfilename
         Write out methods that differ between compilations to diffMCLfilename.
         This only works with -applyDiff.

     -p[arallel] [workerCount]
         Run in parallel mode by spawning 'workerCount' processes to do processing.
         If 'workerCount' is not specified, the number of workers used is
         the number of processors on the machine.

     -skipCleanup
         Skip deletion of temporary files created by child SuperPMI processes with -parallel.

     -target <target>
         Used by the assembly differences calculator. This specifies the target
         architecture for cross-compilation. Currently allowed <target> values: arm, arm64

     -coredistools
         Use disassembly tools from the CoreDisTools library
         Ignored: MSVCDIS is not available, so CoreDisTools will be used.

     -jitoption [force] key=value
         Set the JIT option named "key" to "value" for JIT 1 if the option was not set.
         With optional force flag overwrites the existing value if it was already set.
         NOTE: do not use a "COMPlus_" prefix, "key" and "value" are case sensitive!

     -jit2option [force] key=value
         Set the JIT option named "key" to "value" for JIT 2 if the option was not set.
         With optional force flag overwrites the existing value if it was already set.
         NOTE: do not use a "COMPlus_" prefix, "key" and "value" are case sensitive!

    Inputs are case sensitive.

    SuperPMI method contexts are stored in files with extension .MC, implying
    a single method context, or .MCH, implying a set of method contexts. Either
    extension works equivalently.

    Exit codes:
    0  : success
    -1 : general fatal error (e.g., failed to initialize, failed to read files)
    -2 : JIT failed to initialize
    1  : there were compilation failures
    2  : there were assembly diffs

    Examples:
     superpmi clrjit.dll test.mch
         ; compile all functions in test.mch using clrjit.dll
     superpmi -p clrjit.dll test.mch
         ; same as above, but use all available processors to compile in parallel
     superpmi -f fail.mcl clrjit.dll test.mch
         ; if there are any failures, record their MC numbers in the file fail.mcl
     `
]