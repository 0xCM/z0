<?xml version="1.0"?>
<doc>
    <assembly>
        <name>z0.derivatives</name>
    </assembly>
    <members>
        <member name="T:Z0.X.Events.DiagnosticConsoleEventListener">
            <summary>
              An event listener that will print all telemetry messages to the console with timestamps.
              The format of the message is designed for completeness and parsability, but not for beauty.
            </summary>
        </member>
        <member name="T:Z0.X.Events.PrettyConsoleEventListener">
            <summary>
              An event listener that will print any message that it can nicely format for the console
              that matches the verbosity level it is given.  At the moment, this means only messages
              with an "ErrorMessage" attribute will get displayed.
            </summary>
        </member>
        <member name="T:Z0.X.Pipes.NamedPipeMessages">
            <summary>
            Define messages used to communicate via the named-pipe in Scalar.
            </summary>
        </member>
        <member name="T:Z0.X.Pipes.NamedPipeServer">
             <summary>
             The server side of a Named Pipe used for interprocess communication.
            
             Named Pipe protocol:
                The client / server process sends a "message" (or line) of data as a
                sequence of bytes terminated by a 0x3 byte (ASCII control code for
                End of text). Text is encoded as UTF-8 to be sent as bytes across the wire.
            
             This format was chosen so that:
               1) A reasonable range of values can be transmitted across the pipe,
                  including null and bytes that represent newline characters.
               2) It would be easy to implement in multiple places, as we
                  have managed and native implementations.
             </summary>
        </member>
        <member name="T:Z0.X.Pipes.NamedPipeServerStreamEx">
             <remarks>
             The overload of NamedPipeServerStream.ctor with the PipeSecurity parameter was removed
             in .NET Standard and .NET Core.
            
             Unfortunately, the default constructor does not provide WRITE_DAC, so attempting
             to use SetAccessControl after construction will always fail.
             (https://github.com/dotnet/corefx/issues/31190)
            
             Since the PipeAccessRights parameter was also removed, we cannot pass the
             PipeAccessRights.ChangePermissions option either to provide WRITE_DAC to the pipe.
             (https://github.com/dotnet/corefx/issues/24040)
            
             Instead we must manually create the underlying pipe handle with the correct security
             attributes up-front, and then pass this native handle to the NamedPipeServerStream
             managed object. Depressingly, the .NET Core codebase already contains all the methods
             we need to call to do this, but they are all internal/private. We include a copy of
             the minimum required code here to reinstate the removed constructor and functionality.
            
             All the code below was taken from the .NET Core codebase with comments pointing to
             the source file and version.
             </remarks>
        </member>
        <member name="M:Z0.X.Pipes.NamedPipeServerStreamEx.Create(System.String,System.IO.Pipes.PipeDirection,System.Int32,System.IO.Pipes.PipeTransmissionMode,System.IO.Pipes.PipeOptions,System.Int32,System.Int32,System.IO.Pipes.PipeSecurity,System.IO.HandleInheritability)">
            <summary>
            Create a named pipe server stream with pipe security options.
            </summary>
        </member>
        <member name="T:Z0.X.Pipes.NamedPipeStreamReader">
            <summary>
            Implements the NamedPipe protocol as described in NamedPipeServer.
            </summary>
        </member>
        <member name="M:Z0.X.Pipes.NamedPipeStreamReader.ReadMessage">
            <summary>
            Read a message from the stream.
            </summary>
            <returns>The message read from the stream, or null if the end of the input stream has been reached. </returns>
        </member>
        <member name="M:Z0.X.Pipes.NamedPipeStreamReader.TryReadByte(System.Byte@)">
            <summary>
            Read a byte from the stream.
            </summary>
            <param name="readByte">The byte read from the stream</param>
            <returns>True if byte read, false if end of stream has been reached</returns>
        </member>
        <member name="M:Z0.X.FnvHash.GetFNVHashCode(System.ReadOnlySpan{System.Byte})">
            <summary>
            Compute the FNV-1a hash of a sequence of bytes
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="data">The sequence of bytes</param>
            <returns>The FNV-1a hash of <paramref name="data"/></returns>
        </member>
        <member name="M:Z0.X.FnvHash.Combine(System.Int32,System.Int32)">
            <summary>
            This is how VB Anonymous Types combine hash values for fields.
            </summary>
        </member>
        <member name="M:Z0.X.FnvHash.Combine``1(``0,System.Int32)">
            <summary>
            This is how VB Anonymous Types combine hash values for fields.
            PERF: Do not use with enum types because that involves multiple
            unnecessary boxing operations.  Unfortunately, we can't constrain
            T to "non-enum", so we'll use a more restrictive constraint.
            </summary>
        </member>
        <member name="F:Z0.X.FnvHash.FnvOffsetBias">
            <summary>
            The offset bias value used in the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
        </member>
        <member name="F:Z0.X.FnvHash.FnvPrime">
            <summary>
            The generative factor used in the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
        </member>
        <member name="M:Z0.X.FnvHash.GetFNVHashCode(System.Byte[])">
            <summary>
            Compute the FNV-1a hash of a sequence of bytes
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="data">The sequence of bytes</param>
            <returns>The FNV-1a hash of <paramref name="data"/></returns>
        </member>
        <member name="M:Z0.X.FnvHash.GetFNVHashCode(System.Byte*,System.Int32,System.Boolean@)">
            <summary>
            Compute the FNV-1a hash of a sequence of bytes and determines if the byte
            sequence is valid ASCII and hence the hash code matches a char sequence
            encoding the same text.
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="data">The sequence of bytes that are likely to be ASCII text.</param>
            <param name="length">The length of the sequence.</param>
            <param name="isAscii">True if the sequence contains only characters in the ASCII range.</param>
            <returns>The FNV-1a hash of <paramref name="data"/></returns>
        </member>
        <member name="M:Z0.X.FnvHash.GetFNVHashCode(System.String,System.Int32,System.Int32)">
            <summary>
            Compute the hashcode of a sub-string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            Note: FNV-1a was developed and tuned for 8-bit sequences. We're using it here
            for 16-bit Unicode chars on the understanding that the majority of chars will
            fit into 8-bits and, therefore, the algorithm will retain its desirable traits
            for generating hash codes.
            </summary>
            <param name="text">The input string</param>
            <param name="start">The start index of the first character to hash</param>
            <param name="length">The number of characters, beginning with <paramref name="start"/> to hash</param>
            <returns>The FNV-1a hash code of the substring beginning at <paramref name="start"/> and ending after <paramref name="length"/> characters.</returns>
        </member>
        <member name="M:Z0.X.FnvHash.GetFNVHashCode(System.String,System.Int32)">
            <summary>
            Compute the hashcode of a sub-string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string</param>
            <param name="start">The start index of the first character to hash</param>
            <returns>The FNV-1a hash code of the substring beginning at <paramref name="start"/> and ending at the end of the string.</returns>
        </member>
        <member name="M:Z0.X.FnvHash.GetFNVHashCode(System.String)">
            <summary>
            Compute the hashcode of a string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string</param>
            <returns>The FNV-1a hash code of <paramref name="text"/></returns>
        </member>
        <member name="M:Z0.X.FnvHash.GetFNVHashCode(System.Text.StringBuilder)">
            <summary>
            Compute the hashcode of a string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string</param>
            <returns>The FNV-1a hash code of <paramref name="text"/></returns>
        </member>
        <member name="M:Z0.X.FnvHash.GetFNVHashCode(System.Char[],System.Int32,System.Int32)">
            <summary>
            Compute the hashcode of a sub string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="text">The input string as a char array</param>
            <param name="start">The start index of the first character to hash</param>
            <param name="length">The number of characters, beginning with <paramref name="start"/> to hash</param>
            <returns>The FNV-1a hash code of the substring beginning at <paramref name="start"/> and ending after <paramref name="length"/> characters.</returns>
        </member>
        <member name="M:Z0.X.FnvHash.GetFNVHashCode(System.Char)">
            <summary>
            Compute the hashcode of a single character using the FNV-1a algorithm
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            Note: In general, this isn't any more useful than "char.GetHashCode". However,
            it may be needed if you need to generate the same hash code as a string or
            substring with just a single character.
            </summary>
            <param name="ch">The character to hash</param>
            <returns>The FNV-1a hash code of the character.</returns>
        </member>
        <member name="M:Z0.X.FnvHash.CombineFNVHash(System.Int32,System.String)">
            <summary>
            Combine a string with an existing FNV-1a hash code
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="hashCode">The accumulated hash code</param>
            <param name="text">The string to combine</param>
            <returns>The result of combining <paramref name="hashCode"/> with <paramref name="text"/> using the FNV-1a algorithm</returns>
        </member>
        <member name="M:Z0.X.FnvHash.CombineFNVHash(System.Int32,System.Char)">
            <summary>
            Combine a char with an existing FNV-1a hash code
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="hashCode">The accumulated hash code</param>
            <param name="ch">The new character to combine</param>
            <returns>The result of combining <paramref name="hashCode"/> with <paramref name="ch"/> using the FNV-1a algorithm</returns>
        </member>
        <member name="M:Z0.CommandLines.split(System.String,System.Boolean)">
             <summary>
             Split a command line by the same rules as Main would get the commands except the original
             state of backslashes and quotes are preserved.  For example in normal Windows command line
             parsing the following command lines would produce equivalent Main arguments:
            
                 - /r:a,b
                 - /r:"a,b"
            
             This method will differ as the latter will have the quotes preserved.  The only case where
             quotes are removed is when the entire argument is surrounded by quotes without any inner
             quotes.
             </summary>
             <remarks>
             Rules for command line parsing, according to MSDN:
            
             Arguments are delimited by white space, which is either a space or a tab.
            
             A string surrounded by double quotation marks ("string") is interpreted
             as a single argument, regardless of white space contained within.
             A quoted string can be embedded in an argument.
            
             A double quotation mark preceded by a backslash (\") is interpreted as a
             literal double quotation mark character (").
            
             Backslashes are interpreted literally, unless they immediately precede a
             double quotation mark.
            
             If an even number of backslashes is followed by a double quotation mark,
             one backslash is placed in the argv array for every pair of backslashes,
             and the double quotation mark is interpreted as a string delimiter.
            
             If an odd number of backslashes is followed by a double quotation mark,
             one backslash is placed in the argv array for every pair of backslashes,
             and the double quotation mark is "escaped" by the remaining backslash,
             causing a literal double quotation mark (") to be placed in argv.
             </remarks>
        </member>
        <member name="M:System.IO.TempDir.CreateFile(System.String)">
            <summary>
            Creates a file in this directory.
            </summary>
            <param name="name">File name.</param>
        </member>
        <member name="M:System.IO.TempDir.CopyFile(System.String)">
            <summary>
            Creates a file in this directory that is a copy of the specified file.
            </summary>
        </member>
        <member name="M:System.IO.TempDir.CreateDirectory(System.String)">
            <summary>
            Creates a subdirectory in this directory.
            </summary>
            <param name="name">Directory name or unrooted directory path.</param>
        </member>
        <member name="M:System.IO.TempFiles.DisposableFile.DeleteFileOnClose(System.String)">
            <summary>
            Marks given file for automatic deletion when all its handles are closed.
            Note that after doing this the file can't be opened again, not even by the same process.
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:System.Reflection.Emit.DispatchProxyGenerator" -->
        <member name="M:System.Reflection.Emit.IgnoreAccessChecksToAttributeBuilder.AddToModule(System.Reflection.Emit.ModuleBuilder)">
            <summary>
            Generate the declaration for the IgnoresAccessChecksToAttribute type.
            This attribute will be both defined and used in the dynamic assembly.
            Each usage identifies the name of the assembly containing non-public
            types the dynamic assembly needs to access.  Normally those types
            would be inaccessible, but this attribute allows them to be visible.
            It works like a reverse InternalsVisibleToAttribute.
            This method returns the ConstructorInfo of the generated attribute.
            </summary>
        </member>
    </members>
</doc>
