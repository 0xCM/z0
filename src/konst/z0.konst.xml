<?xml version="1.0"?>
<doc>
    <assembly>
        <name>z0.konst</name>
    </assembly>
    <members>
        <member name="M:Z0.XTend.Close(Z0.GenericApiMethod)">
            <summary>
            Closes generic operations over the set of primal types that each operation supports
            </summary>
            <param name="generics">Metadata for generic operations</param>
        </member>
        <member name="M:Z0.XTend.Identify(System.Reflection.MethodInfo)">
            <summary>
            Identifies a method
            </summary>
            <param name="m">The method to identify</param>
        </member>
        <member name="M:Z0.XTend.Identify(System.Delegate)">
            <summary>
            Identifies a delegate
            </summary>
            <param name="m">The method to identify</param>
        </member>
        <member name="M:Z0.XTend.IsFloat(Z0.SegBlockKind)">
            <summary>
            Determines whether the floating facet of a block classification is enabled
            </summary>
            <param name="k">The vector classifier</param>
        </member>
        <member name="M:Z0.XTend.IsIntegral(Z0.SegBlockKind)">
            <summary>
            Determines whether the signed or unsigned facet of a block classification is enabled
            </summary>
            <param name="k">The vector classifier</param>
        </member>
        <member name="M:Z0.XTend.IsSigned(Z0.SegBlockKind)">
            <summary>
            Determines whether the signed facet of a block classification is enabled
            </summary>
            <param name="k">The vector classifier</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.XTend.IsUnsigned(Z0.SegBlockKind)" -->
        <member name="M:Z0.XTend.BoxedZero(Z0.NumericKind)">
            <summary>
            Returns 0 in a box
            </summary>
            <param name="kind">The numeric kind of 0 to be put into the box</param>
        </member>
        <member name="M:Z0.XTend.Box``1(Z0.NumericKind,``0)">
            <summary>
            Puts a value of any numeric kind into a box of any numeric kind
            </summary>
            <param name="dst">The target box kind</param>
            <param name="src">The source value</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.XTend.Box``1(``0)">
            <summary>
            Puts an enum value into a (numeric) box
            </summary>
            <param name="e">The enumeration value</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.XTend.Clear``1(``0[])">
            <summary>
            Fills an array with the element type's default value
            </summary>
            <param name="src">The source array</param>
            <typeparam name="T">The array element type</typeparam>
        </member>
        <member name="M:Z0.XTend.Append``1(``0[],``0[])">
            <summary>
            Concatenates two arrays
            </summary>
        </member>
        <member name="M:Z0.XTend.CopyTo``1(System.Collections.Generic.IReadOnlyList{``0},``0[])">
            <summary>
            Copies a source list to a target array
            </summary>
            <param name="src">The list containing the elements to copy</param>
            <param name="dst">The array that will receive the copied elements</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XTend.Fill``1(``0[],``0)">
            <summary>
            Fills an array, in-place, with a specified value
            </summary>
            <param name="dst">The target array</param>
            <param name="src">The source value</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XTend.FirstIndexOf``1(``0[],``0)">
            <summary>
            Returns the index of the first value that matches a specified value, if any. Otherwise, returns -1
            </summary>
            <param name="src">The source array</param>
            <param name="value">The value to match in the source</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XTend.Replicate``1(``0[])">
            <summary>
            Allocates an populates a new array that is identical to the source array
            </summary>
            <param name="src">The source array</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XTend.Slice``1(``0[],System.Int32,System.Int32)">
            <summary>
            Creates a new array from a (contiguous) subset of an existing array
            </summary>
            <typeparam name="T">The array element type</typeparam>
            <param name="src">The source array</param>
            <param name="offset">The position of the first element of the source array </param>
            <param name="count">The number of elements to take from the source array following the offset</param>
        </member>
        <member name="M:Z0.XTend.ToPointer``1(System.RuntimeFieldHandle)">
            <summary>
            Gets the void* for the identified field
            </summary>
            <param name="src">The runtime field handle</param>
        </member>
        <member name="M:Z0.XTend.ToVoid(System.IntPtr)">
            <summary>
            Uses the (void*) explicit operator defined by the source type to
            present said source as a void*
            </summary>
            <param name="src">The source pointer representative</param>
        </member>
        <member name="M:Z0.XTend.AddRange``1(System.Collections.Concurrent.ConcurrentBag{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Adds a collection of items to a bag
            </summary>
            <typeparam name="T">The item type</typeparam>
            <param name="bag">The destination bag</param>
            <param name="items">The items to add</param>
        </member>
        <member name="M:Z0.XTend.ToKVPairs``2(System.Collections.Generic.Dictionary{``0,``1})">
            <summary>
            Creates a hashtable from a dictionary
            </summary>
            <param name="src">The data source</param>
            <typeparam name="K">The key type</typeparam>
            <typeparam name="V">The value type</typeparam>
        </member>
        <member name="M:Z0.XTend.HasAnyKey``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines whether the dictionary has any the keys that are specified in a set
            </summary>
            <typeparam name="K">The key type</typeparam>
            <typeparam name="V">The value type</typeparam>
            <param name="subject">The dictionary to evaluate</param>
            <param name="keys">The keys to check</param>
        </member>
        <member name="M:Z0.XTend.HasAllKeys``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Determines whether the dictionary has all of the keys that are specified in a set
            </summary>
            <typeparam name="K">The key type</typeparam>
            <typeparam name="V">The value type</typeparam>
            <param name="subject">The dictionary to evaluate</param>
            <param name="keys">The keys to check</param>
        </member>
        <member name="M:Z0.XTend.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Returns the first element if it exists; otherwise returns the supplied default
            </summary>
            <typeparam name="T">The item type</typeparam>
            <param name="src">The items to search</param>
            <param name="default">The replacement value if the sequence is empty</param>
        </member>
        <member name="M:Z0.XTend.FirstOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0})">
            <summary>
            Returns the first element if it exists; otherwise returns the value supplied
            by invoking the default function
            </summary>
            <typeparam name="T">The item type</typeparam>
            <param name="src">The items to search</param>
            <param name="default">The function invoked to produce a default value</param>
        </member>
        <member name="M:Z0.XTend.OnFirstOrDefault``2(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0},System.Func{``0,``1})">
            <summary>
            Applies a function to the first item in the list that satisfies the predicate if such an item exists.
            If no such item exists, the function is applied to the default value of the item
            </summary>
            <typeparam name="T">The item type</typeparam>
            <typeparam name="R">The function result type</typeparam>
            <param name="items">The items to search</param>
            <param name="predicate">The predicate applied during the search</param>
            <param name="f">The function to apply to the identified item</param>
        </member>
        <member name="M:Z0.XTend.Force``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Forces enumerable evaluation
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XTend.Intersperse``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Interleaves a specified value between each element of the source
            </summary>
            <param name="src">The source stream</param>
            <param name="x">The value to interleave</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XTend.Intersperse``1(``0[],``0)">
            <summary>
            Interleaves a specified value between each element of the source
            </summary>
            <param name="src">The source stream</param>
            <param name="x">The value to interleave</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XTend.Intersperse``1(System.ReadOnlySpan{``0},``0,System.Span{``0})">
            <summary>
            Interleaves a specified value between each element of the source
            </summary>
            <param name="src">The source stream</param>
            <param name="x">The value to interleave</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XTend.Iter``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0},System.Boolean)">
            <summary>
            Applies an action to each member of the collection
            </summary>
            <typeparam name="T">The item type</typeparam>
            <param name="items">The items to enumerate</param>
            <param name="action">The action to apply</param>
            <param name="pll">Indicates whether the action should be applied concurrently</param>
        </member>
        <member name="M:Z0.XTend.Iter``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Action{``0,``0})">
            <summary>
            Enumerates stream elements in pairs, until one of the streams is exhausted,
            invoking a traversal action for each enumerated pair
            </summary>
            <param name="lhs">The left stream</param>
            <param name="rhs">The right stream</param>
            <param name="f">The side-effect</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XTend.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>
            Returns the last element if it exists; otherwise returns the supplied default
            </summary>
            <param name="src">The source sequence</param>
            <param name="default">The replacement value if the sequence is empty</param>
            <typeparam name="T">The item type</typeparam>
        </member>
        <member name="M:Z0.XTend.LastOrDefault``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0})">
            <summary>
            Returns the last element if it exists; otherwise returns the value supplied
            by invoking the default function
            </summary>
            <param name="src">The source sequence</param>
            <param name="default">The function invoked to produce a default value</param>
            <typeparam name="T">The item type</typeparam>
        </member>
        <member name="M:Z0.XTend.Map``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Applies a function to an input sequence to yield a transformed output sequence
            </summary>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
            <param name="src">The source sequence</param>
            <param name="f">The mapping function</param>
        </member>
        <member name="M:Z0.XTend.Partition``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Partitions a source stream into sub-arrays of a maximum length
            </summary>
            <param name="src">The source stream</param>
            <param name="max">The maximum sub-array length</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XTend.Partition``1(``0[],System.Int32)">
            <summary>
            Partitions the source array into a sequence of array segments
            </summary>
            <param name="src">The source array</param>
            <param name="width">The maximal segment width</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XTend.Batch``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Runs through an enumerable in batches
            </summary>
            <typeparam name="T">The item type</typeparam>
            <param name="source">The item source</param>
            <param name="max">The maximum number of elements per batch</param>
            <remarks>
            Implementation inspired from https://github.com/morelinq/MoreLINQ
            </remarks>
        </member>
        <member name="M:Z0.XTend.Prepend``1(System.Collections.Generic.IEnumerable{``0},``0[])">
            <summary>
            Prepends one or more items to the head of the sequence
            </summary>
            <typeparam name="T">The item type</typeparam>
            <param name="src">The sequence that will be prependend</param>
            <param name="preceding">The items that will be prepended</param>
        </member>
        <member name="M:Z0.XTend.SecondOrDefault``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns the second term of the sequence if it exists; otherwise returns the default value
            </summary>
            <param name="src">The source sequence</param>
            <typeparam name="T">The item type</typeparam>
        </member>
        <member name="M:Z0.XTend.Singletons``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Constructs a sequence of singleton sequences from a sequence of elements
            </summary>
            <param name="src">The source sequence</param>
            <typeparam name="T">The item type</typeparam>
        </member>
        <member name="M:Z0.XTend.Collapse``1(System.Collections.Generic.IEnumerable{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Reduces a stream of element streams to an element stream
            </summary>
            <param name="src">The element streams</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XTend.StreamTo``1(System.Collections.Generic.IEnumerable{``0},System.Span{``0})">
            <summary>
            Fills an allocated span from a sequence
            </summary>
            <param name="src">The source sequence</param>
            <param name="dst">The target spn</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XTend.Take``1(System.Collections.Generic.IEnumerable{``0},System.UInt32)">
            <summary>
            Defines missing Take(stream,n:uint) method
            </summary>
            <param name="src">The source stream</param>
            <param name="count">The number of elements to remove from the from of the stream</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XTend.ToArray``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Creates a transformed array
            </summary>
            <typeparam name="S">The source item type</typeparam>
            <typeparam name="T">The target item type</typeparam>
            <param name="src">The source sequence</param>
            <param name="transform">The transformation function</param>
        </member>
        <member name="M:Z0.XTend.ToConcurrentDictionary``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Creates a concurrent dictionary from an ordinary dictionary
            </summary>
            <typeparam name="K">The key type</typeparam>
            <typeparam name="V">The value type</typeparam>
            <param name="d">The source dictionary</param>
        </member>
        <member name="M:Z0.XTend.ToConcurrentDictionary``2(System.Collections.Generic.IEnumerable{``1},System.Func{``1,``0})">
            <summary>
            Creates a concurrent dictionary from the input sequence
            </summary>
            <typeparam name="K">The key type</typeparam>
            <typeparam name="V">The value type</typeparam>
            <param name="values">The input sequence</param>
            <param name="keySelector"></param>
        </member>
        <member name="M:Z0.XTend.ToConcurrentDictionary``3(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1},System.Func{``0,``2})">
            <summary>
            Creates a concurrent dictionary from the input sequence
            </summary>
            <typeparam name="S">The input sequence type</typeparam>
            <typeparam name="K">The dictionary key type</typeparam>
            <typeparam name="V">The type of the indexed valuie</typeparam>
            <param name="sources">The input sequence</param>
            <param name="keySelector">Function that selects the key</param>
            <param name="valueSelector">Function that selects the value</param>
        </member>
        <member name="M:Z0.XTend.ToDictionary``2(System.Collections.Generic.IEnumerable{System.ValueTuple{``0,``1}})">
            <summary>
            Constructs a mutable dictionary from a sequence of key-value pairs
            </summary>
            <param name="key">The key</param>
            <param name="value">The indexed value</param>
            <typeparam name="K">The key type</typeparam>
            <typeparam name="V">The value type</typeparam>
        </member>
        <member name="M:Z0.XTend.ReadOnly``2(System.Collections.Generic.IDictionary{``0,``1})">
            <summary>
            Creates a read-only dictionary from an existing mutable dictionary
            </summary>
            <typeparam name="K">The dictionary key type</typeparam>
            <typeparam name="V">The dictionary value type</typeparam>
            <param name="src">The extended type</param>
        </member>
        <member name="M:Z0.XTend.ToReadOnlySpan``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Constructs a span of specified length from a sequence
            </summary>
            <param name="src">The source sequence</param>
            <param name="length">The length of the result span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XTend.ToReadOnlySpan``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
            <summary>
            Constructs a span of specified length from the sequence obtained by skipping a specified number of leading elements
            </summary>
            <param name="src">The source sequence</param>
            <param name="skip">The number of elements to skip</param>
            <param name="length">The length of the result span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XTend.ToReadOnlySpan``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Constructs a span from a (presumeably finite) sequence selection
            </summary>
            <param name="src">The source sequence</param>
            <param name="offset">The number of elements to skip from the head of the sequence</param>
            <param name="length">The number of elements to take from the sequence</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XTend.ToReadOnlySpan``1(``0[])">
            <summary>
            Constructs a span from an array
            </summary>
            <param name="src">The source array</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XTend.ToSet``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a set from an item stream
            </summary>
            <typeparam name="T">The item type</typeparam>
            <param name="items">The item sequence</param>
        </member>
        <member name="M:Z0.XTend.ToSet``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Creates a set from a sequence projection
            </summary>
            <typeparam name="T">The source element type</typeparam>
            <typeparam name="U">The targert element type</typeparam>
            <param name="items">The item sequence</param>
        </member>
        <member name="M:Z0.XTend.ReadOnly``1(System.Span{``0})">
            <summary>
            Presents a mutable span as a readonly span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XTend.ToSpan``1(``0[])">
            <summary>
            Constructs a span from an array
            </summary>
            <param name="src">The source sequence</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XTend.ToSpan``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Constructs a span from a (presumeably finite) sequence selection
            </summary>
            <param name="src">The source sequence</param>
            <param name="offset">The number of elements to skip from the head of the sequence</param>
            <param name="length">The number of elements to take from the sequence</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XTend.ToSpan``1(System.ReadOnlySpan{``0})">
            <summary>
            Constructs a span from a readonly span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XTend.ToSpan``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Constructs a span of specified length from a sequence
            </summary>
            <param name="src">The source sequence</param>
            <param name="length">The length of the result span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XTend.ToSpan``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
            <summary>
            Constructs a span of specified length from the sequence obtained by skipping a specified number of leading elements
            </summary>
            <param name="src">The source sequence</param>
            <param name="offset">The number of elements to skip</param>
            <param name="length">The length of the result span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XTend.TakeArray``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Constructs an array of specified length from a stream
            </summary>
            <param name="src">The source stream</param>
            <param name="length">The length of the index</param>
            <typeparam name="T">The item type</typeparam>
        </member>
        <member name="M:Z0.XTend.TakeArray``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
            <summary>
            Constructs an array from a specified number of elements from a source stream after a skip
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.XTend.TakeMemory``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Constructs a memory segment of specified length from a stream (allocating)
            </summary>
            <param name="src">The source stream</param>
            <param name="length">The length of the index</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.XTend.TakeReadOnlyMemory``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>
            Constructs a memory segment of specified length from a stream (allocating)
            </summary>
            <param name="src">The source stream</param>
            <param name="length">The length of the index</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.XTend.TakeMemory``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
            <summary>
            Constructs an array from a specified number of elements from a source stream after a skip (allocating)
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.XTend.Dequeue``1(System.Collections.Generic.Queue{``0},System.Int32)">
            <summary>
            Removes a specified number of items from a queue
            </summary>
            <typeparam name="T">The item type</typeparam>
            <param name="queue">The queue from which items will be removed</param>
            <param name="count">The (maximum) number of items to remove</param>
        </member>
        <member name="M:Z0.XTend.Dequeue``1(System.Collections.Concurrent.ConcurrentQueue{``0})">
            <summary>
            Pops all items off the queue
            </summary>
            <typeparam name="T">The type of value contained int he queue</typeparam>
            <param name="q">The queue to manipulate</param>
        </member>
        <member name="M:Z0.XTend.Dequeue``1(System.Collections.Concurrent.ConcurrentQueue{``0},System.Int32)">
            <summary>
            Pops a sequence of items off a queue
            </summary>
            <typeparam name="T">The item type</typeparam>
            <param name="q">The queue to manipulate</param>
            <param name="max">The maximum number of items to remove</param>
        </member>
        <member name="M:Z0.XTend.Enqueue``1(System.Collections.Generic.Queue{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Enqueues a stream
            </summary>
            <typeparam name="T">The item type</typeparam>
            <param name="queue">The destination queue</param>
            <param name="items">The items to enqueue</param>
        </member>
        <member name="M:Z0.XTend.Enqueue``1(System.Collections.Concurrent.ConcurrentQueue{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Pushes a sequence of items into queue and returns the number of items enqueued
            </summary>
            <typeparam name="T">The item type</typeparam>
            <param name="q">The queue to manipulate</param>
            <param name="items">The items to place on the qeeue</param>
        </member>
        <member name="M:Z0.XTend.Include``1(System.Collections.Generic.ISet{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Adds items from a stream to a target set
            </summary>
            <param name="dst">The target set</param>
            <param name="src">The source stream</param>
            <typeparam name="T">The item type</typeparam>
        </member>
        <member name="M:Z0.XTend.Include``1(System.Collections.Generic.ISet{``0},``0[])">
            <summary>
            Adds items from a parameter array to a target set
            </summary>
            <param name="dst">The target set</param>
            <param name="src">The source stream</param>
            <typeparam name="T">The item type</typeparam>
        </member>
        <member name="M:Z0.XTend.Intersect``1(System.Collections.Generic.ISet{``0},System.Collections.Generic.ISet{``0}[])">
            <summary>
            Computes the intersection of a target set with source sets specified in a parameter array
            </summary>
            <param name="dst">The target set</param>
            <param name="src">The source sets</param>
            <typeparam name="T">The item type</typeparam>
        </member>
        <member name="M:Z0.XTend.IsEmpty``1(System.Collections.Generic.ISet{``0})">
            <summary>
            Determines whether a set is empty
            </summary>
            <typeparam name="T">The type of element that may be contained in the set</typeparam>
            <param name="set">The set under examination</param>
        </member>
        <member name="M:Z0.XTend.IsNonEmpty``1(System.Collections.Generic.ISet{``0})">
            <summary>
            Determines whether a set is nonempty
            </summary>
            <typeparam name="T">The type of element that may be contained in the set</typeparam>
            <param name="set">The set under examination</param>
        </member>
        <member name="M:Z0.XTend.IsEmpty``1(System.Collections.Generic.IReadOnlyCollection{``0})">
            <summary>
            Determines whether a collection contains any elements
            </summary>
            <typeparam name="T">The type of item contained by the collection</typeparam>
            <param name="src">The collection to examine</param>
        </member>
        <member name="M:Z0.XTend.ToReadOnlyList``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a read-only list from a source sequence
            </summary>
            <param name="src">The source sequence</param>
        </member>
        <member name="M:Z0.XTend.Unions``1(System.Collections.Generic.ISet{``0},System.Collections.Generic.ISet{``0}[])">
            <summary>
            Adds all items from sets specified in a parameter array to a target set
            </summary>
            <param name="dst">The target set</param>
            <param name="src">The source sets</param>
            <typeparam name="T">The item type</typeparam>
        </member>
        <member name="M:Z0.XTend.WithItems``1(System.Collections.Generic.ISet{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Adds a stream of items to a target set
            </summary>
            <typeparam name="T">The item type</typeparam>
            <param name="dst">The target set</param>
            <param name="src">The source stream</param>
        </member>
        <member name="M:Z0.XTend.WithItems``1(System.Collections.Generic.HashSet{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Adds a stream of items to a target set
            </summary>
            <typeparam name="T">The item type</typeparam>
            <param name="dst">The target set</param>
            <param name="src">The source stream</param>
        </member>
        <member name="M:Z0.XTend.WithItems``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IReadOnlyDictionary{``0,``1})">
            <summary>
            Addes the entries of the source dictionary to the destination dictionary
            </summary>
            <typeparam name="TKey">The common dictionary key type</typeparam>
            <typeparam name="TValue">The common dictionary value type</typeparam>
            <param name="dst">The target dictionary</param>
            <param name="src">The source dictionary</param>
        </member>
        <member name="M:Z0.XTend.WithItems``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{``0,``1}})">
            <summary>
            Addes the key-value pairs to the extended dictionary
            </summary>
            <param name="dst">The extended dictionary</param>
            <param name="src">The items to add</param>
            <typeparam name="K">The dictionary key type</typeparam>
            <typeparam name="V">The dictionary value type</typeparam>
        </member>
        <member name="M:Z0.XTend.WithItems``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Adds items to a list
            </summary>
            <param name="dst">The list to modify</param>
            <param name="src">The items to add</param>
            <typeparam name="T">The item type</typeparam>
        </member>
        <member name="M:Z0.XTend.WhereSome``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Filters zero-valued elements from the source stream
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="E">The enumeration type</typeparam>
        </member>
        <member name="M:Z0.XTend.WhereSome``1(``0[])">
            <summary>
            Filters zero-valued elements from the source array
            </summary>
            <param name="src">The source array</param>
            <typeparam name="E">The enumeration type</typeparam>
        </member>
        <member name="M:Z0.XTend.ReadText(Z0.FilePath)">
            <summary>
            Reads the full content of a text file
            </summary>
            <param name="src">The file path</param>
        </member>
        <member name="M:Z0.XTend.ReadLines(Z0.FilePath)">
            <summary>
            Reads the line-partitioned content of a text file
            </summary>
            <param name="src">The file path</param>
        </member>
        <member name="M:Z0.XTend.ReadBytes(Z0.FilePath)">
            <summary>
            Reads the full content of a file into a byte array
            </summary>
            <param name="src">The file path</param>
        </member>
        <member name="M:Z0.XTend.Delete(Z0.FilePath)">
            <summary>
            Deletes the file if it exists
            </summary>
            <param name="src">The path to the file</param>
        </member>
        <member name="M:Z0.XTend.Reader(Z0.FilePath)">
            <summary>
            Creates a reader initialized with the source file; caller-disposal required
            </summary>
            <param name="src">The file path</param>
        </member>
        <member name="M:Z0.XTend.Writer(Z0.FilePath)">
            <summary>
            Creates an overwriting and caller-disposed stream writer that targets a specified path
            </summary>
            <param name="dst">The file path</param>
        </member>
        <member name="M:Z0.XTend.NextPair``1(Z0.IValueSource,``0)">
            <summary>
            Yields the next source-provided pair
            </summary>
            <param name="source">The value source</param>
            <param name="a">The first element in the pair</param>
            <param name="t">A primal type representative</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.XTend.NextPair``1(Z0.IDomainValues,``0,``0)">
            <summary>
            Yields the next source-provided pair over a specified domain
            </summary>
            <param name="source">The value source</param>
            <param name="min">The inclusive minimum value</param>
            <param name="max">The exclusive maximum value</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.XTend.NextQuad``1(Z0.IValueSource,``0)">
            <summary>
            Produces the next triple of random primal values
            </summary>
            <param name="random">The random source</param>
            <param name="a">The first element in the pair</param>
            <param name="t">A primal type representative</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.XTend.NextQuad``1(Z0.IDomainValues,``0,``0)">
            <summary>
            Produces the next triple of random primal values within a specified range
            </summary>
            <param name="random">The random source</param>
            <param name="min">The inclusive minimum value</param>
            <param name="max">The exclusive maximum value</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.XTend.NextTriple``1(Z0.IValueSource,``0)">
            <summary>
            Produces the next source-provided triple
            </summary>
            <param name="source">The value source</param>
            <param name="a">The first element in the pair</param>
            <param name="t">A primal type representative</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.XTend.NextTriple``1(Z0.IDomainValues,``0,``0)">
            <summary>
            Produces the next source-provided triple over a specified domain
            </summary>
            <param name="source">The value source</param>
            <param name="min">The inclusive minimum value</param>
            <param name="max">The exclusive maximum value</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.XTend.Paired``2(Z0.IValueSource)">
            <summary>
            Yields a source-provided heterogenous pairs
            </summary>
            <param name="source">The value source</param>
            <typeparam name="S">The left value type</typeparam>
            <typeparam name="T">The right value type</typeparam>
        </member>
        <member name="M:Z0.XTend.Pairings``2(Z0.IValueSource)">
            <summary>
            Yields a stream of source-provided heterogenous pairs
            </summary>
            <param name="source">The value source</param>
            <typeparam name="S">The left value type</typeparam>
            <typeparam name="T">The right value type</typeparam>
        </member>
        <member name="M:Z0.XTend.Pairings``2(Z0.IValueSource,System.UInt32)">
            <summary>
            Fills the target with parings taken from the source
            </summary>
            <param name="source">The value source</param>
            <param name="dst">The receiver</param>
            <typeparam name="S">The left value type</typeparam>
            <typeparam name="T">The right value type</typeparam>
        </member>
        <member name="M:Z0.XTend.Pairings``2(Z0.IValueSource,Z0.Pairings{``0,``1})">
            <summary>
            Fills the target with parings taken from the source
            </summary>
            <param name="source">The value source</param>
            <param name="dst">The receiver</param>
            <typeparam name="S">The left value type</typeparam>
            <typeparam name="T">The right value type</typeparam>
        </member>
        <member name="M:Z0.XTend.StreamTo``3(System.Collections.Generic.IEnumerable{``2},Z0.TableSpan{``0,``1,``2}@)">
            <summary>
            Fills a tabular span of natural dimensions with streamed elements
            </summary>
            <param name="src">The source stream</param>
            <param name="dst">The target span</param>
            <typeparam name="M">The row dimension type</typeparam>
            <typeparam name="N">The column dimension type</typeparam>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XTend.FormatList``2(Z0.NatSpan{``0,``1},System.Char,System.Int32,System.Int32)">
            <summary>
            Formats a span of natural length as a delimited list
            </summary>
            <param name="src">The source span</param>
            <param name="delimiter">The delimiter</param>
            <param name="offset">The position at which formatting should begin</param>
            <typeparam name="T">The element type</typeparam>
            <typeparam name="N">The length type</typeparam>
        </member>
        <member name="M:Z0.XTend.FormatList(System.Collections.Generic.IEnumerable{System.Object},System.Char)">
            <summary>
            Formats a sequence of objects as a delimited list
            </summary>
            <param name="src">The source span</param>
            <param name="delimiter">The delimiter, if specified; otherwise, a system default is chosen</param>
            <param name="offset">The index of the source element at which formatting will begin</param>
            <typeparam name="T">A formattable type</typeparam>
        </member>
        <member name="M:Z0.XTend.FormatAsVector``1(System.ReadOnlySpan{``0},System.Char)">
            <summary>
            Formats a readonly span as a vector
            </summary>
            <param name="src">The source stream</param>
            <param name="sep">The item separator</param>
            <typeparam name="T">The item type</typeparam>
        </member>
        <member name="M:Z0.XTend.FormatAsVector``1(System.Span{``0},System.Char)">
            <summary>
            Formats a span as a vector
            </summary>
            <param name="src">The source stream</param>
            <param name="sep">The item separator</param>
            <typeparam name="T">The item type</typeparam>
        </member>
        <member name="M:Z0.XTend.FormatCellBlocks``1(System.ReadOnlySpan{``0},System.Nullable{System.Int32},System.Nullable{System.Char},System.Boolean)">
            <summary>
            Formats a span as [c0   c1 ...  cm]  where m = length - 1
            </summary>
            <param name="src">The source span</param>
            <param name="cellpad">The width of a padded cell, if applicable</param>
            <param name="padchar">The character to use for cell padding, if applicable</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XTend.FormatCellBlocks``1(System.Span{``0},System.Nullable{System.Int32},System.Nullable{System.Char},System.Boolean)">
            <summary>
            Formats a span as [c0   c1 ...  cm]  where m = length - 1
            </summary>
            <param name="src">The source span</param>
            <param name="cellpad">The width of a padded cell, if applicable</param>
            <param name="padchar">The character to use for cell padding, if applicable</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XTend.FormatLines``1(System.ReadOnlySpan{``0})">
            <summary>
            Formats each source element on a new line
            </summary>
            <param name="src">The source span</param>
        </member>
        <member name="M:Z0.XTend.FormatLines``1(System.Span{``0})">
            <summary>
            Formats each source element on a new line
            </summary>
            <param name="src">The source span</param>
        </member>
        <member name="M:Z0.XTend.FormatHex(System.SByte,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Renders a number as a hexadecimal string
            </summary>
            <param name="src">The source number</param>
            <param name="zpad">Specifies whether the numeric content should be left-padded with zeros</param>
            <param name="specifier">Specifies whether the hex numeric specifier shold prefix the output</param>
            <param name="uppercase">Specifies whether hex characters should be upper-cased</param>
            <param name="prespec">Indicates where the specifier, if applied, is a prefix specifier (true) or a postfix specifier (false)</param>
        </member>
        <member name="M:Z0.XTend.FormatHex(System.Int16,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Renders a number as a hexadecimal string
            </summary>
            <param name="src">The source number</param>
            <param name="zpad">Specifies whether the numeric content should be left-padded with zeros</param>
            <param name="specifier">Specifies whether the hex numeric specifier shold prefix the output</param>
            <param name="uppercase">Specifies whether hex characters should be upper-cased</param>
            <param name="prespec">Indicates where the specifier, if applied, is a prefix specifier (true) or a postfix specifier (false)</param>
        </member>
        <member name="M:Z0.XTend.FormatHex(System.UInt16,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Renders a number as a hexadecimal string
            </summary>
            <param name="src">The source number</param>
            <param name="zpad">Specifies whether the numeric content should be left-padded with zeros</param>
            <param name="specifier">Specifies whether the hex numeric specifier shold prefix the output</param>
            <param name="uppercase">Specifies whether hex characters should be upper-cased</param>
            <param name="prespec">Indicates where the specifier, if applied, is a prefix specifier (true) or a postfix specifier (false)</param>
        </member>
        <member name="M:Z0.XTend.FormatHex(System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Renders a number as a hexadecimal string
            </summary>
            <param name="src">The source number</param>
            <param name="zpad">Specifies whether the numeric content should be left-padded with zeros</param>
            <param name="specifier">Specifies whether the hex numeric specifier shold prefix the output</param>
            <param name="uppercase">Specifies whether hex characters should be upper-cased</param>
            <param name="prespec">Indicates where the specifier, if applied, is a prefix specifier (true) or a postfix specifier (false)</param>
        </member>
        <member name="M:Z0.XTend.FormatHex(System.UInt32,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Renders a number as a hexadecimal string
            </summary>
            <param name="src">The source number</param>
            <param name="zpad">Specifies whether the numeric content should be left-padded with zeros</param>
            <param name="specifier">Specifies whether the hex numeric specifier shold prefix the output</param>
            <param name="uppercase">Specifies whether hex characters should be upper-cased</param>
            <param name="prespec">Indicates where the specifier, if applied, is a prefix specifier (true) or a postfix specifier (false)</param>
        </member>
        <member name="M:Z0.XTend.FormatHex(System.Int64,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Renders a number as a hexadecimal string
            </summary>
            <param name="src">The source number</param>
            <param name="zpad">Specifies whether the numeric content should be left-padded with zeros</param>
            <param name="specifier">Specifies whether the hex numeric specifier shold prefix the output</param>
            <param name="uppercase">Specifies whether hex characters should be upper-cased</param>
            <param name="prespec">Indicates where the specifier, if applied, is a prefix specifier (true) or a postfix specifier (false)</param>
        </member>
        <member name="M:Z0.XTend.FormatHex(System.UInt64,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Renders a number as a hexadecimal string
            </summary>
            <param name="src">The source number</param>
            <param name="zpad">Specifies whether the numeric content should be left-padded with zeros</param>
            <param name="specifier">Specifies whether the hex numeric specifier shold prefix the output</param>
            <param name="uppercase">Specifies whether hex characters should be upper-cased</param>
            <param name="prespec">Indicates where the specifier, if applied, is a prefix specifier (true) or a postfix specifier (false)</param>
        </member>
        <member name="M:Z0.XTend.FormatHex(System.Single,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Formats a scalar value as a sequence of hex digits
            </summary>
            <param name="src">The source value</param>
            <param name="uppercase">Whether to use uppercase characters for digits A - F</param>
        </member>
        <member name="M:Z0.XTend.FormatHex(System.Double,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Formats a scalar value as a sequence of hex digits
            </summary>
            <param name="src">The source value</param>
            <param name="uppercase">Whether to use uppercase characters for digits A - F</param>
        </member>
        <member name="M:Z0.XTend.FormatHex``1(System.ReadOnlySpan{``0},System.Char,System.Boolean)">
            <summary>
            Formats a span pf presumed integral values as a sequence of hex values
            </summary>
            <param name="src">The source span</param>
            <param name="bracket">Whether to format the result as a vector</param>
            <param name="sep">The character to use when separating digits</param>
            <param name="specifier">Whether to prefix each number with the canonical hex specifier, "0x"</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.XTend.FormatHex``1(System.Span{``0},System.Char,System.Boolean)">
            <summary>
            Formats a span of numeric cell type as a sequence of hex values
            </summary>
            <param name="src">The source span</param>
            <param name="bracket">Whether to enclose the formatted hex within brackets</param>
            <param name="sep">The character to use when separating digits</param>
            <param name="specifier">Whether to prefix each number with the canonical hex specifier, "0x"</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.XTend.FormatHex``1(System.Span{``0})">
            <summary>
            Formats a span of numeric cell type as a sequence of hex values
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.XTend.FormatHex``1(System.ReadOnlySpan{``0})">
            <summary>
            Formats a span of numeric cell type as a sequence of hex values
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.XTend.FormatHex``1(System.Collections.Generic.IEnumerable{``0},System.Char,System.Boolean)">
            <summary>
            Formats a (hopefully finite) stream of values (hopefully numeric) as a sequence of hex values
            </summary>
            <param name="src">The source span</param>
            <param name="bracket">Whether to enclose the formatted hex within brackets</param>
            <param name="sep">The character to use when separating digits</param>
            <param name="specifier">Whether to prefix each number with the canonical hex specifier, "0x"</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.XTend.FormatHex``2(Z0.NatSpan{``0,``1},System.Char,System.Boolean)">
            <summary>
            Formats a span of natural length and integral type as a sequence of hex values
            </summary>
            <param name="src">The source span</param>
            <param name="bracket">Whether to enclose the formatted hex within brackets</param>
            <param name="sep">The character to use when separating digits</param>
            <param name="specifier">Whether to prefix each number with the canonical hex specifier, "0x"</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.XTend.BlockPartition(System.String,System.Int32,System.String)">
            <summary>
            Block-formats a string using specified block length and separator
            </summary>
            <param name="src">The source string</param>
            <param name="blocklen">The number of characters in each block, save the last</param>
            <param name="sep">The block separator</param>
        </member>
        <member name="M:Z0.XTend.BlockPartition(System.String,System.Int32,System.Char)">
            <summary>
            Block-formats a string using specified block length and separator
            </summary>
            <param name="src">The source string</param>
            <param name="blocklen">The number of characters in each block, save the last</param>
            <param name="sep">The block separator</param>
        </member>
        <member name="M:Z0.XTend.BlockPartition(System.String,System.Int32,System.Char,System.String)">
            <summary>
            Block-formats a string using specified block length, separator and block prefix
            </summary>
            <param name="src">The source string</param>
            <param name="blocklen">The number of characters in each block, save the last</param>
            <param name="sep">The block separator</param>
            <param name="prefix">Content that immediately precedes each block</param>
        </member>
        <member name="M:Z0.XTend.Label(System.Text.StringBuilder,System.String,System.Char)">
            <summary>
            Appends a label suffixed by a separator to produce '{label}{sep}'
            </summary>
            <param name="sb">The target builder</param>
            <param name="label">The label text</param>
            <param name="sep">A character that denotes the end of a label and indicate that what follows is content</param>
        </member>
        <member name="M:Z0.XTend.Label(System.Text.StringBuilder,System.String,System.Char,System.Object)">
            <summary>
            Appends labeled content to produce: '{label}{sep} {content}'
            </summary>
            <param name="sb">The target builder</param>
            <param name="label">The label text</param>
            <param name="sep">A character that denotes the end of a label and indicate that what follows is content</param>
            <param name="content">The content to append</param>
        </member>
        <member name="M:Z0.XTend.Label``1(System.Text.StringBuilder,System.String,``0,System.Char)">
            <summary>
            Appends labeled formattable content to produce: '{label}{sep} {content}'
            </summary>
            <param name="sb">The target builder</param>
            <param name="label">The label text</param>
            <param name="sep">A character that denotes the end of a label and indicate that what follows is content</param>
            <param name="content">The content to append</param>
        </member>
        <member name="M:Z0.XTend.Label``1(System.Text.StringBuilder,System.String,System.Char,``0,Z0.Padding,System.Char)">
            <summary>
            Delimits labeled formattable content to produce '{delimiter} {label}{sep} {content}'
            </summary>
            <param name="sb">The target builder</param>
            <param name="label">The label text</param>
            <param name="sep">A character that denotes the end of a label and indicate that what follows is content</param>
            <param name="content">The content to delimit</param>
            <param name="pad">The right-padded content width</param>
            <param name="delimiter">The content delimiter</param>
        </member>
        <member name="M:Z0.XTend.Concat(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Joins the strings provided by the enumerable with an optional separator
            </summary>
            <param name="src">The source strings</param>
            <param name="sep">The separator, if any</param>
        </member>
        <member name="M:Z0.XTend.Concat(System.Collections.Generic.IEnumerable{System.Char},System.Char)">
            <summary>
            Joins a sequence of source characters interspersed with a supplied separator
            </summary>
            <param name="chars">The characters to join</param>
            <param name="sep">The character to intersperse</param>
        </member>
        <member name="M:Z0.XTend.Concat(System.Collections.Generic.IEnumerable{System.Char})">
            <summary>
            Forms a string by source character juxtaposition
            </summary>
            <param name="src">The characters to concatenate</param>
        </member>
        <member name="M:Z0.XTend.Concat(System.Char[])">
            <summary>
            Forms a string from a character array
            </summary>
            <param name="src">The source array</param>
        </member>
        <member name="M:Z0.XTend.Concat(System.ReadOnlySpan{System.Char})">
            <summary>
            Forms a string by source character juxtaposition
            </summary>
            <param name="src">The source span</param>
        </member>
        <member name="M:Z0.XTend.Concat(System.Span{System.Char})">
            <summary>
            Forms a string by source character juxtaposition
            </summary>
            <param name="src">The source span</param>
        </member>
        <member name="M:Z0.XTend.Concat(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
            <summary>
            Forms a string by source character juxtaposition
            </summary>
            <param name="src">The source span</param>
        </member>
        <member name="M:Z0.XTend.Concat(System.Span{System.String})">
            <summary>
            Sequentially concatenates each indexed cell to the next without deimiters/interspersal
            </summary>
            <param name="src">The source text</param>
        </member>
        <member name="M:Z0.XTend.Concat(System.Span{System.String},System.Char)">
            <summary>
            Sequentially concatenates each indexed cell to the next, separated by a specified character
            </summary>
            <param name="src">The source text</param>
        </member>
        <member name="M:Z0.XTend.ContentEqual(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
            <summary>
            Returns true if the character spans are equal as strings, false otherwise
            </summary>
            <param name="lhs">The left operand</param>
            <param name="rhs">The right operand</param>
        </member>
        <member name="M:Z0.XTend.ContentEqual(System.Span{System.Char},System.ReadOnlySpan{System.Char})">
            <summary>
            Returns true if the character spans are equal as strings, false otherwise
            </summary>
            <param name="lhs">The left operand</param>
            <param name="rhs">The right operand</param>
        </member>
        <member name="M:Z0.XTend.ContentEqual(System.Span{System.Char},System.Span{System.Char})">
            <summary>
            Returns true if the character spans are equal as strings, false otherwise
            </summary>
            <param name="lhs">The left operand</param>
            <param name="rhs">The right operand</param>
        </member>
        <member name="M:Z0.XTend.DelimitLabel(System.Text.StringBuilder,System.String,System.Char,System.Object,Z0.Padding,System.Char)">
            <summary>
            Delimits labeled content to produce '{delimiter} {label}{sep} {content}'
            </summary>
            <param name="sb">The target builder</param>
            <param name="label">The label text</param>
            <param name="sep">A character that denotes the end of a label and indicate that what follows is content</param>
            <param name="content">The content to delimit</param>
            <param name="pad">The right-padded content width</param>
            <param name="delimiter">The content delimiter</param>
        </member>
        <member name="M:Z0.XTend.EnclosedBy(System.String,System.String,System.String,System.StringComparison)">
            <summary>
            Determines whether the subject is contained betwee specified left and right markers
            </summary>
            <param name="s">The subject to test</param>
            <param name="left">The left marker</param>
            <param name="right">The right marker</param>
            <param name="compare">Th comparison type</param>
        </member>
        <member name="M:Z0.XTend.EnclosedBy(System.String,System.Char,System.Char)">
            <summary>
            Determines whether the subject is contained betwee specified left and right markers
            </summary>
            <param name="s">The string to search</param>
            <param name="left">The left marker</param>
            <param name="right">The right marker</param>
        </member>
        <member name="M:Z0.XTend.EndsWith(System.String,System.Char)">
            <summary>
            Determines whether a string ends with a specific character
            </summary>
            <param name="s">The string to search</param>
            <param name="c">The character to match</param>
        </member>
        <member name="M:Z0.XTend.EndsWithAny(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Determines whether a string terminates with a value from a supplied set
            </summary>
            <param name="src">The string to examine</param>
            <param name="values">The characters for which to search</param>
        </member>
        <member name="M:Z0.XTend.EndsWithDigit(System.String)">
            <summary>
            Determines whether a string ends with a digit
            </summary>
            <param name="s">The string to search</param>
        </member>
        <member name="M:Z0.XTend.Enquote(System.String)">
            <summary>
            Encloses supplied text in quotation marks
            </summary>
            <param name="content">The content to be quoted</param>
        </member>
        <member name="M:Z0.XTend.LastIndexOf(System.String,System.Char)">
            <summary>
            Searches for the last index of a specified character in a string
            </summary>
            <param name="s">The string to search</param>
            <param name="match">The character to match</param>
        </member>
        <member name="M:Z0.XTend.LastIndexOf(System.String,System.String)">
            <summary>
            Searches for the last index of a specified character in a string
            </summary>
            <param name="s">The string to search</param>
            <param name="match">The substring to match</param>
        </member>
        <member name="M:Z0.XTend.FirstIndexOf(System.String,System.Char)">
            <summary>
            Searches a string for the first occurrence of a specified character
            </summary>
            <param name="s">The string to search</param>
            <param name="match">The character to match</param>
        </member>
        <member name="M:Z0.XTend.FirstIndexOf(System.String,System.String)">
            <summary>
            Searches a string for the first occurrence of a specified substring
            </summary>
            <param name="s">The string to search</param>
            <param name="match">The substring to match</param>
        </member>
        <member name="M:Z0.XTend.IfBlank(System.String,System.String)">
            <summary>
            Returns the source string if it is not blank; otherwise, returns an alternate string
            </summary>
            <param name="src">The source string</param>
            <param name="alt">The alternate string</param>
        </member>
        <member name="M:Z0.XTend.Intersperse(System.String,System.Char)">
            <summary>
            Creates a new string by weaving a specified character between each character in the source
            </summary>
            <param name="src">The source string</param>
            <param name="c">The character to intersperse</param>
        </member>
        <member name="M:Z0.XTend.Intersperse(System.String,System.String)">
            <summary>
            Creates a new string by weaving a substring between each character in the source
            </summary>
            <param name="src">The source string</param>
            <param name="sep">The value to intersperse</param>
        </member>
        <member name="M:Z0.XTend.IsBlank(System.String)">
            <summary>
            Returns true if a string is null or whitespace; otherwise, returns false
            </summary>
            <param name="s">The string to evaluate</param>
        </member>
        <member name="M:Z0.XTend.IsNotBlank(System.String)">
            <summary>
            Returns true if a string has at least one character that is not considered whitespace
            </summary>
            <param name="s">The string to evaluate</param>
        </member>
        <member name="M:Z0.XTend.apply``2(``0,System.Func{``0,``1})">
            <summary>
            Applies a function to a value
            </summary>
            <param name="x">The source value</param>
            <param name="f">The function to apply</param>
            <typeparam name="X">The source value type</typeparam>
            <typeparam name="Y">The output value type</typeparam>
        </member>
        <member name="M:Z0.XTend.LeftOfIndex(System.String,System.Int32)">
            <summary>
            Gets the string to the left of, but not including, a specified index
            </summary>
            <param name="s">The string to search</param>
            <param name="idx">The index</param>
        </member>
        <member name="M:Z0.XTend.RightOfIndex(System.String,System.Int32)">
            <summary>
            Gets the string to the right of, but not including, a specified index
            </summary>
            <param name="src">The string to search</param>
            <param name="idx">The index</param>
        </member>
        <member name="M:Z0.XTend.LeftOfFirst(System.String,System.Char)">
            <summary>
            Gets the string to the left of, but not including, the first instance of a specified character
            </summary>
            <param name="s">The string to search</param>
            <param name="c">The character</param>
        </member>
        <member name="M:Z0.XTend.LeftOfFirst(System.String,System.String)">
            <summary>
            Gets the string to the left of, but not including, a specified substring
            </summary>
            <param name="s">The string to search</param>
            <param name="substring">The substring to match</param>
        </member>
        <member name="M:Z0.XTend.RightOfFirst(System.String,System.Char)">
            <summary>
            Gets the string to the right of, but not including, the first instance of a specified character
            </summary>
            <param name="s">The string to search</param>
            <param name="c">The character</param>
        </member>
        <member name="M:Z0.XTend.Unfence(System.String,System.Char,System.Char)">
            <summary>
            Extracts content demarcated by left/right character boundaries
            </summary>
            <param name="src">The source text</param>
            <param name="left">The left marker</param>
            <param name="right">THe right marker</param>
        </member>
        <member name="M:Z0.XTend.RightOf(System.String,System.String)">
            <summary>
            Gets the string to the right of, but not including, a specified substring
            </summary>
            <param name="s">The string to search</param>
            <param name="substring">The substring to match</param>
        </member>
        <member name="M:Z0.XTend.RightOfLast(System.String,System.String)">
            <summary>
            Retrieves the substring that follows the last occurrence of a marker
            </summary>
            <param name="s">The string to search</param>
            <param name="match">The substring to match</param>
        </member>
        <member name="M:Z0.XTend.RightOfLast(System.String,System.Char)">
            <summary>
            Retrieves the substring that follows the last occurrence of a marker
            </summary>
            <param name="s">The string to search</param>
            <param name="match">The substring to match</param>
        </member>
        <member name="M:Z0.XTend.LeftOfLast(System.String,System.Char)">
            <summary>
            Retrieves the substring that precedes the last occurrence of a marker
            </summary>
            <param name="s">The string to search</param>
            <param name="match">The substring to match</param>
        </member>
        <member name="M:Z0.XTend.OnSome(System.String,System.Action{System.String})">
            <summary>
            Invokes an action if the source string is nonempty
            </summary>
            <param name="s">The string to evaluate</param>
            <param name="f">The action to conditionally invoke</param>
        </member>
        <member name="M:Z0.XTend.RemoveAny(System.String,System.Collections.Generic.IEnumerable{System.Char})">
            <summary>
            Erases a specified set of character occurrences in a string
            </summary>
            <param name="s">The string to manipulate</param>
            <param name="removals">The characters to remove</param>
        </member>
        <member name="M:Z0.XTend.RemoveAny(System.String,System.Char[])">
            <summary>
            Erases a specified set of character occurrences in a string
            </summary>
            <param name="s">The string to manipulate</param>
            <param name="removals">The characters to remove</param>
        </member>
        <member name="M:Z0.XTend.RemoveBlanks(System.String)">
            <summary>
            Removes whitespace characters from a string
            </summary>
            <param name="src">The source string</param>
        </member>
        <member name="M:Z0.XTend.SplitClean(System.String,System.String)">
            <summary>
            Splits the source string predicated on a string delimiter, removing any empy entries
            </summary>
            <param name="s">The string to split</param>
            <param name="delimiter">The delimiter</param>
        </member>
        <member name="M:Z0.XTend.SplitClean(System.String,System.Char)">
            <summary>
            Splits the source string predicated on a character delimiter, removing any empy entries
            </summary>
            <param name="s">The string to split</param>
            <param name="delimiter">The delimiter</param>
        </member>
        <member name="M:Z0.XTend.StartsWith(System.String,System.Char)">
            <summary>
            Determines whether a string begins with a specific character
            </summary>
            <param name="s">The string to search</param>
            <param name="c">The character to match</param>
        </member>
        <member name="M:Z0.XTend.StartsWithAny(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Determines whether a string starts with a value from a supplied set
            </summary>
            <param name="src">The string to examine</param>
            <param name="values">The characters for which to search</param>
        </member>
        <member name="M:Z0.XTend.StartsWithAny(System.String,System.Collections.Generic.IEnumerable{System.Char})">
            <summary>
            Determines whether a string leads with any of a specified set of characters
            </summary>
            <param name="src">The string to examine</param>
            <param name="chars">The characters for which to search</param>
        </member>
        <member name="M:Z0.XTend.StartsWithDigit(System.String)">
            <summary>
            Determines whether a string starts with a digit
            </summary>
            <param name="s">The string to search</param>
        </member>
        <member name="M:Z0.XTend.ContainsAny(System.String,System.Collections.Generic.IEnumerable{System.Char})">
            <summary>
            Determines whether a string contains any of the characters in a supplied sequence
            </summary>
            <param name="src">The string to test</param>
            <param name="chars">The characters for which to search</param>
        </member>
        <member name="M:Z0.XTend.ContainsAny(System.String,System.ReadOnlySpan{System.Char})">
            <summary>
            Determines whether a string contains any of the characters in a supplied sequence
            </summary>
            <param name="src">The string to test</param>
            <param name="chars">The characters for which to search</param>
        </member>
        <member name="M:Z0.XTend.ContainsAny(System.String,System.String[])">
            <summary>
            Determines whether a string contains any of the supplied substrings
            </summary>
            <param name="src">The string to test</param>
            <param name="substrings">The characters for which to search</param>
        </member>
        <member name="M:Z0.XTend.ContainsAny(System.String,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Determines whether a string contains any of the supplied substrings
            </summary>
            <param name="src">The string to test</param>
            <param name="substrings">The characters for which to search</param>
        </member>
        <member name="M:Z0.XTend.TakeBefore(System.String,System.Char)">
            <summary>
            Selects the substring prior to the first occurrence of a specified character if it is found in the string; otherwise, 
            returns the original string
            </summary>
            <param name="s">The string to search</param>
            <param name="c">The marking character</param>
        </member>
        <member name="M:Z0.XTend.TakeAfter(System.String,System.Char)">
            <summary>
            Selects the substring after the first ocurrence of a specified character it is found in the string; otherwise, 
            returns the original string
            </summary>
            <param name="s">The string to search</param>
            <param name="c">The marking character</param>
        </member>
        <member name="M:Z0.XTend.ToLexicalString(System.DateTime,Z0.TimeResolution)">
            <summary>
            Renders a string in a more rational manner than the default behavior
            </summary>
            <param name="t">The instant to render</param>
            <param name="accuracy">The accuracy with which to render the instant</param>
        </member>
        <member name="M:Z0.XTend.ToDateKey(System.DateTime)">
            <summary>
            Creates an integer of the form YYYYMMDD corresponding to a supplied date
            </summary>
            <param name="d">The date whose integer representation will be determined</param>
        </member>
        <member name="M:Z0.XTend.ToDateKey(System.Nullable{System.DateTime})">
            <summary>
            Creates an integer of the form YYYYMMDD corresponding to a supplied date if the date
            is not null and returns 0 otherwise
            </summary>
            <param name="d">The date whose integer representation will be determined</param>
        </member>
        <member name="M:Z0.XTend.GetItemArray(System.Date)">
            <summary>
            Represents a date value as an array of integers
            </summary>
            <param name="x">The date to convert to an array</param>
        </member>
        <member name="M:Z0.XTend.Yesterday(System.DateTime)">
            <summary>
            Returns the instant that is one day less than the specified instant
            </summary>
            <param name="x">The reference data</param>
        </member>
        <member name="M:Z0.XTend.LastMonth(System.DateTime)">
            <summary>
            Returns the instant that is one day less than the specified instant
            </summary>
            <param name="x">The reference data</param>
        </member>
        <member name="M:Z0.XTend.NextMonth(System.DateTime)">
            <summary>
            Returns the instant that is one day less than the specified instant
            </summary>
            <param name="x">The reference data</param>
        </member>
        <member name="M:Z0.XTend.EndOfYear(System.Date)">
            <summary>
            The last day of the current year
            </summary>
            <param name="x">The reference data</param>
        </member>
        <member name="M:Z0.XTend.Yesterday(System.Date)">
            <summary>
            Returns the instant that is one day less than the specified instant
            </summary>
            <param name="x">The reference data</param>
        </member>
        <member name="M:Z0.XTend.Tomorrow(System.DateTime)">
            <summary>
            Returns the instant that is one day more than the specified instant
            </summary>
            <param name="x">The reference data</param>
        </member>
        <member name="M:Z0.XTend.Tomorrow(System.Date)">
            <summary>
            Returns the instant that is one day more than the specified instant
            </summary>
            <param name="x">The reference data</param>
        </member>
        <member name="M:Z0.XTend.EndOfDay(System.DateTime)">
            <summary>
            Gets the time at which the day ends
            </summary>
            <param name="d">The instant in time</param>
        </member>
        <member name="M:Z0.XTend.StartOfDay(System.DateTime)">
            <summary>
            Gets the time at which the day begins
            </summary>
            <param name="d">The instant in time</param>
        </member>
        <member name="M:Z0.XTend.ContiguousDatesTo(System.DateTime,System.DateTime)">
            <summary>
            Creates a contiguous range of dates within a supplied range
            </summary>
            <param name="min">The first date in the range</param>
            <param name="max">The last date in the range</param>
        </member>
        <member name="M:Z0.XTend.ContiguousDatesTo(System.Date,System.Date)">
            <summary>
            Creates a contiguous range of dates within a supplied range
            </summary>
            <param name="min">The first date in the range</param>
            <param name="max">The last date in the range</param>
        </member>
        <member name="M:Z0.XTend.IsSameDay(System.DateTime,System.DateTime)">
            <summary>
            Determines whether the <see cref="T:System.DateTime"/> values occur on the same day
            </summary>
            <param name="d">One subject</param>
            <param name="other">The other subject</param>
        </member>
        <member name="M:Z0.XTend.ToTimeKey(System.DateTime)">
            <summary>
            Returns the number of seconds elapsed since midnight
            </summary>
            <param name="d">The subject</param>
        </member>
        <member name="M:Z0.XTend.ToTimeKey(System.Nullable{System.DateTime})">
            <summary>
            Returns the number of seconds elapsed since midnight if date is not null, 0 otherwise
            </summary>
            <param name="d">The subject</param>
        </member>
        <member name="M:Z0.XTend.ToDate(System.DateTime)">
            <summary>
            Returns the <see cref="T:System.Date"/> part of the supplied <see cref="T:System.DateTime"/>
            </summary>
            <param name="src">The subject</param>
        </member>
        <member name="M:Z0.XTend.ToLexicalDateString(System.DateTime)">
            <summary>
            Renders a <see cref="T:System.DateTime"/> to the form YYYY-MM-DD
            </summary>
            <param name="t"></param>
        </member>
        <member name="M:Z0.XTend.Replicate``2(Z0.NatSpan{``0,``1}@)">
            <summary>
            Clones a natural span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XTend.IsTypeNat(System.Type)">
            <summary>
            Determines whether a type encodes a natural number
            </summary>
            <param name="t">The type to test</param>
        </member>
        <member name="M:Z0.XTend.NatValue(System.Type)">
            <summary>
            For a type that encodes a natural number, returns the corresponding value; otherwise, returns none
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.XTend.TypeNatural(System.Type)">
            <summary>
            Returns the type's natural reification if it exists; otherwise, returns the 0 reification
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.XTend.StoreTo``1(System.Runtime.Intrinsics.Vector128{``0},Z0.SpanBlock128{``0}@)">
            <summary>
            Stores vector content to a caller-supplied block
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.XTend.StoreTo``1(System.Runtime.Intrinsics.Vector128{``0},Z0.SpanBlock128{``0}@,System.Int32)">
            <summary>
            Stores vector content to a specified block in a blocked container
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
            <param name="block">The 0-based block index at which storage should begin</param>
        </member>
        <member name="M:Z0.XTend.StoreTo``1(System.Runtime.Intrinsics.Vector256{``0},Z0.SpanBlock256{``0}@)">
            <summary>
            Stores vector content to a caller-supplied block
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.XTend.StoreTo``1(Z0.Vector512{``0},Z0.SpanBlock512{``0}@)">
            <summary>
            Stores vector content to a caller-supplied block
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.XTend.StoreTo``1(System.Runtime.Intrinsics.Vector256{``0},Z0.SpanBlock256{``0}@,System.Int32)">
            <summary>
            Stores vector content to a specified block in a blocked container
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
            <param name="block">The 0-based block index at which storage should begin</param>
        </member>
        <member name="M:Z0.XTend.StoreTo``1(Z0.Vector512{``0},Z0.SpanBlock512{``0}@,System.Int32)">
            <summary>
            Stores vector content to a specified block in a blocked container
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
            <param name="block">The 0-based block index at which storage should begin</param>
        </member>
        <member name="M:Z0.XTend.ToBlock``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>
            Allocates and deposits vector content to a data block
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The component type</typeparam>
        </member>
        <member name="M:Z0.XTend.ToBlock``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>
            Allocates and deposits vector content to a data block
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The primitive type</typeparam>
        </member>
        <member name="M:Z0.XTend.ToBlock``1(Z0.Vector512{``0})">
            <summary>
            Allocates and deposits vector content to a data block
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The primitive type</typeparam>
        </member>
        <member name="M:Z0.XTend.To(Z0.NumericKind,System.Object)">
            <summary>
            Convers a source value, which is hopefully a supported kind, to a target kind
            </summary>
            <param name="k">The primal kind</param>
        </member>
        <member name="M:Z0.ApiCatalogs.system(Z0.FS.Files)">
            <summary>
            Creates a system-level api catalog over a set of path-identified components
            </summary>
            <param name="paths">The source paths</param>
        </member>
        <member name="M:Z0.ApiCatalogs.system(System.Reflection.Assembly[])">
            <summary>
            Creates a system-level api catalog over a specified component set
            </summary>
            <param name="src">The source components</param>
        </member>
        <member name="M:Z0.ApiCatalogs.part(System.Reflection.Assembly)">
            <summary>
            Defines a <see cref='T:Z0.ApiPartCatalog'/> over a specified assembly
            </summary>
            <param name="src">The source assembly</param>
        </member>
        <member name="M:Z0.ApiCatalogs.part(Z0.IPart)">
            <summary>
            Defines a <see cref='T:Z0.ApiPartCatalog'/> over a specified part
            </summary>
            <param name="src">The source assembly</param>
        </member>
        <member name="M:Z0.ApiCatalogs.TryGetPart(System.Reflection.Assembly)">
            <summary>
            Attempts to resolve a part resolution type
            </summary>
        </member>
        <member name="M:Z0.ApiCatalogs.part(Z0.FS.FilePath)">
            <summary>
            Attempts to resolve a part from an assembly file path
            </summary>
        </member>
        <member name="M:Z0.ApiCatalogs.resolve(System.Reflection.Assembly)">
            <summary>
            Attempts to resolve a part resolution type
            </summary>
        </member>
        <member name="M:Z0.ApiCatalogs.resolve(System.Type)">
            <summary>
            Attempts to resolve a part resolution property
            </summary>
        </member>
        <member name="M:Z0.ApiCatalogs.resolve(System.Reflection.PropertyInfo)">
            <summary>
            Attempts to resolve a part from a resolution property
            </summary>
        </member>
        <member name="M:Z0.ApiCatalogs.apiHostTypes(System.Reflection.Assembly)">
            <summary>
            Searches an assembly for types tagged with the <see cref="T:Z0.ApiHostAttribute"/>
            </summary>
            <param name="src">The assembly to search</param>
        </member>
        <member name="M:Z0.ApiCatalogs.svcHostTypes(System.Reflection.Assembly)">
            <summary>
            Searches an assembly for types tagged with the <see cref="T:Z0.FunctionalServiceAttribute"/>
            </summary>
            <param name="src">The assembly to search</param>
        </member>
        <member name="M:Z0.ApiCatalogs.datatypes(System.Reflection.Assembly)">
            <summary>
            Searches an assembly for types tagged with the <see cref="T:Z0.ApiDataTypeAttribute"/>
            </summary>
            <param name="src">The assembly to search</param>
        </member>
        <member name="M:Z0.ApiCodeArchive.Read(Z0.ApiHostUri)">
            <summary>
            Reads the archived files owned by a specified host
            </summary>
        </member>
        <member name="M:Z0.ApiCodeArchive.Files">
            <summary>
            Enumerates the archived files
            </summary>
        </member>
        <member name="M:Z0.ApiCodeArchive.Files(PartId)">
            <summary>
            Enumerates the archived files owned by a specified part
            </summary>
        </member>
        <member name="M:Z0.ApiCodeArchive.Read">
            <summary>
            Enumerates the content of all archived files
            </summary>
        </member>
        <member name="M:Z0.ApiCodeArchive.Read(PartId)">
            <summary>
            Enumerates the content of archived files owned by a specified part
            </summary>
        </member>
        <member name="M:Z0.ApiCodeArchive.Read(System.Func{Z0.FS.FileName,System.Boolean})">
            <summary>
            Reads the archived files with names that satisfy a specified predicate
            </summary>
        </member>
        <member name="M:Z0.ApiCodeArchive.Read(Z0.FilePath)">
            <summary>
            Reads the code defined by a specified file
            </summary>
            <param name="src">The source path</param>
        </member>
        <member name="M:Z0.ApiCodeArchive.Read(Z0.OpIdentity)">
            <summary>
            Reads the bits of an identified operation
            </summary>
            <param name="id">The source path</param>
        </member>
        <member name="M:Z0.ApiQuery.host(PartId,System.Type)">
            <summary>
            Describes an api host
            </summary>
            <param name="part">The defining part</param>
            <param name="tHost">The reifying type</param>
        </member>
        <member name="M:Z0.ApiQuery.host(Z0.FS.FileName)">
            <summary>
            Determines the api host that owns the file, if any
            </summary>
            <param name="src">The source file</param>
        </member>
        <member name="M:Z0.ApiQuery.component(Z0.FS.FilePath)">
            <summary>
            Loads an assembly from a potential part path
            </summary>
        </member>
        <member name="M:Z0.ApiQuery.NumericClosureKinds(System.Reflection.MethodInfo)">
            <summary>
            Computes a method's numeric closures, predicated on available metadata
            </summary>
            <param name="m">The source method</param>
        </member>
        <member name="M:Z0.ApiQuery.CodeBlockIndex(Z0.ApiCodeBlock[])">
            <summary>
            Creates an operation index from a uri bitstream
            </summary>
            <param name="src">The source bits</param>
        </member>
        <member name="M:Z0.ApiQuery.index``1(System.ReadOnlySpan{``0})">
            <summary>
            Creates an operation index from an api member span, readonly that is
            </summary>
            <param name="src">The members to index</param>
            <typeparam name="M">The member type</typeparam>
        </member>
        <member name="M:Z0.ApiQuery.NumericClosureKinds(System.Type)">
            <summary>
            Computes a types's numeric closures, predicated on available metadata
            </summary>
            <param name="t">The source type</param>
        </member>
        <member name="M:Z0.ApiQuery.NaturalClosureTypes(System.Reflection.MethodInfo)">
            <summary>
            Computes a method's natural closures, predicated on available metadata
            </summary>
            <param name="m">The source method</param>
        </member>
        <member name="M:Z0.ApiServices.UriParser">
            <summary>
            Factory for <see cref='T:Z0.ApiUriParser'/> services
            </summary>
        </member>
        <member name="M:Z0.ApiServices.PartIdParser">
            <summary>
            Factory for <see cref='T:Z0.ApiPartIdParser'/> services
            </summary>
        </member>
        <member name="M:Z0.ApiServices.CodeIdentity">
            <summary>
            Factory for code identifier <see cref='T:Z0.LegalIdentityBuilder'/> services
            </summary>
        </member>
        <member name="M:Z0.ApiServices.FileIdentity">
            <summary>
            Factory for file identifier <see cref='T:Z0.LegalIdentityBuilder'/> services
            </summary>
        </member>
        <member name="T:Z0.IApiHexWriter">
            <summary>
            Defines service contract for persting text-formatted x86 encoded assembly
            </summary>
        </member>
        <member name="M:Z0.IApiHexWriter.Write(Z0.ApiCodeBlock,System.Int32)">
            <summary>
            Write host bits with a specified uri identifier padding
            </summary>
            <param name="src">The source bits</param>
            <param name="idpad">The padding amount</param>
        </member>
        <member name="T:Z0.IApiKey`1">
            <summary>
            Characterizes a subkey group
            </summary>
            <typeparam name="G">The group key kind</typeparam>
        </member>
        <member name="T:Z0.IApiKey`2">
            <summary>
            Characterizes a reified subkey group
            </summary>
            <typeparam name="G">The group key kind</typeparam>
        </member>
        <member name="P:Z0.IApiMethod.Host">
            <summary>
            The globally-unique host uri
            </summary>
        </member>
        <member name="P:Z0.IApiMethod.Method">
            <summary>
            The hosted method
            </summary>
        </member>
        <member name="P:Z0.IApiMethod.MetaUri">
            <summary>
            The metadata uri
            </summary>
        </member>
        <member name="P:Z0.IApiMethod.ApiKind">
            <summary>
            The method's kind identifier if it exists
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Z0.IApiMethod.OpUri" -->
        <member name="T:Z0.IApiOpIndex`1">
            <summary>
            Characterizes anything that can be uniquely identified by an operation identity and
            </summary>
            <typeparam name="T">The type of identified thing</typeparam>
        </member>
        <member name="P:Z0.IApiOpIndex`1.EntryCount">
            <summary>
            The number of indexed items
            </summary>
        </member>
        <member name="P:Z0.IApiOpIndex`1.Keys">
            <summary>
            The item keys
            </summary>
        </member>
        <member name="P:Z0.IApiOpIndex`1.DuplicateKeys">
            <summary>
            Duplicate keys found the source that were rejected from the index
            </summary>
        </member>
        <member name="P:Z0.IApiOpIndex`1.Item(Z0.OpIdentity)">
            <summary>
            Looks up the index item and blows up if item does not exist
            </summary>
        </member>
        <member name="M:Z0.IApiOpIndex`1.Lookup(Z0.OpIdentity)">
            <summary>
            A server version of the lookup indexer that returns an optional value, thus allowing
            for the possibility that the id doesn't identify anything in the index
            </summary>
            <param name="id"></param>
        </member>
        <member name="P:Z0.IApiOpIndex`1.Enumerated">
            <summary>
            Enumerates the key/value index pairs
            </summary>
        </member>
        <member name="T:Z0.IApiPartCatalog">
            <summary>
            Characterizes the api set exposed by a part
            </summary>
        </member>
        <member name="P:Z0.IApiPartCatalog.Owner">
            <summary>
            The defining assembly
            </summary>
        </member>
        <member name="P:Z0.IApiPartCatalog.OperationHosts">
            <summary>
            The operation hosts
            </summary>
        </member>
        <member name="P:Z0.IApiPartCatalog.ApiDataTypes">
            <summary>
            The data type hosts
            </summary>
        </member>
        <member name="P:Z0.IApiPartCatalog.ServiceHosts">
            <summary>
            The known types that reify contracted operation services, potentially generic
            </summary>
        </member>
        <member name="P:Z0.IApiPartCatalog.PartId">
            <summary>
            The identity of the assembly that defines and owns the catalog
            </summary>
        </member>
        <member name="P:Z0.IApiPartCatalog.ApiHosts">
            <summary>
            The api hosts known to the catalog, including both operation and data type hosts
            </summary>
        </member>
        <member name="P:Z0.IApiPartCatalog.Operations">
            <summary>
            The operations defined by <see cref='P:Z0.IApiPartCatalog.ApiHosts'/>
            </summary>
        </member>
        <member name="P:Z0.IApiPartCatalog.ManifestModule">
            <summary>
            The component's manifest module
            </summary>
        </member>
        <member name="P:Z0.IApiPartCatalog.IsIdentified">
            <summary>
            Specifies whether the catalog contains content from an identified assembly
            </summary>
        </member>
        <member name="P:Z0.IApiPartCatalog.IsNonEmpty">
            <summary>
            Specifies whether the catalog describes any api hosts
            </summary>
        </member>
        <member name="P:Z0.IApiPartCatalog.IsEmpty">
            <summary>
            Specifies whether the catalog describes any api hosts
            </summary>
        </member>
        <member name="P:Z0.IApiOpSig.Host">
            <summary>
            The declaring api host
            </summary>
        </member>
        <member name="T:Z0.IIdentification`1">
            <summary>
            Specifies what it means to be a reified identifier
            </summary>
        </member>
        <member name="T:Z0.IIdentityDiviner`2">
            <summary>
            Characterizes a service that attempts to assign a non-cryptic identity to a
            subject that is both useful and unique within the intended scope
            </summary>
            <typeparam name="S">The type of the thing to identify</typeparam>
            <typeparam name="T">The target identity type</typeparam>
        </member>
        <member name="M:Z0.IIdentityDiviner`2.DivineIdentity(`0)">
            <summary>
            Reifies an identity divination algorithm
            </summary>
            <param name="src">The divinity source</param>
        </member>
        <member name="T:Z0.ITypeIdentityDiviner">
            <summary>
            Characterizes a services that attempts to assign a reasonable identity to a type
            </summary>
        </member>
        <member name="T:Z0.IMethodIdentityDiviner">
            <summary>
            Characterizes a service that attempts to assign a reasonable identity to a method
            </summary>
        </member>
        <member name="T:Z0.IIdentityProvider`1">
            <summary>
            Characterizes a services capable of assigning identity to T-values
            </summary>
            <typeparam name="S">The subject of identification</typeparam>
        </member>
        <member name="T:Z0.IResolvedApi">
            <summary>
            Characterizes, in dependency injection vernacular, composition roots
            </summary>
        </member>
        <member name="P:Z0.IResolvedApi.Resolved">
            <summary>
            The resolved assemblies that comprise the composition
            </summary>
        </member>
        <member name="T:Z0.IRuntimeOp">
            <summary>
            Characterizes a runtime function of some sort
            </summary>
        </member>
        <member name="T:Z0.ITargetPart`2">
            <summary>
            Characterizes a directed dependency d:S -> T from a client s:S to a suppler t:T
            </summary>
            <typeparam name="S">The source client type</typeparam>
            <typeparam name="T">The target supplier type</typeparam>
        </member>
        <member name="T:Z0.ITypeIdentityProvider`1">
            <summary>
            Characterizes a type identity provider than can define an identity predicated solely on a parametric type
            </summary>
            <typeparam name="S">The type for which identity will be defined</typeparam>
        </member>
        <member name="M:Z0.ApiFiles.capture(Z0.FS.FolderPath)">
            <summary>
            Creates an archive over a set of capture artifacts
            </summary>
            <param name="root">The archive root</param>
        </member>
        <member name="M:Z0.ApiFiles.capture(Z0.ArchiveConfig)">
            <summary>
            Creates an archive over a set of capture artifacts
            </summary>
            <param name="root">The archive configuration</param>
        </member>
        <member name="M:Z0.ApiFiles.read(Z0.ApiCodeArchive)">
            <summary>
            Enumerates the content of all archived files
            </summary>
        </member>
        <member name="M:Z0.ApiFiles.read(Z0.ApiCodeArchive,PartId)">
            <summary>
            Enumerates the content of archived files owned by a specified part
            </summary>
        </member>
        <member name="M:Z0.ApiHexParser.Z0#ITextParser{Z0#ApiCodeBlock}#Parse(System.String)">
            <summary>
            Parses a row of identified hex text
            </summary>
            <param name="src">The formatted text</param>
        </member>
        <member name="P:Z0.ApiHexWriter.TargetPath">
            <summary>
            The writer's target path
            </summary>
        </member>
        <member name="M:Z0.ApiIdentify.build(System.String,Z0.TypeWidth,Z0.NumericKind,System.Boolean)">
            <summary>
            Defines an identifier of the form {opname}_WxN{u | i | f} where N := bitsize[T]
            </summary>
            <param name="opname">The base operator name</param>
            <param name="w">The covering bit width representative</param>
            <param name="t">A primal cell type representative</param>
            <typeparam name="W">The bit width type</typeparam>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.ApiIdentify.build(System.String,Z0.NumericKind,System.Boolean)">
            <summary>
            Produces an identifier of the form {opname}_{g}{bitsize(kind)}{u | i | f}
            </summary>
            <param name="opname">The base operator name</param>
            <param name="k">The primal kind over which the identifier is deined</param>
        </member>
        <member name="M:Z0.ApiIdentify.build``2(System.String,``0,``1)">
            <summary>
            Defines an identifier of the form {opname}_WxN{u | i | f} where N := bitsize[T]
            </summary>
            <param name="opname">The base operator name</param>
            <param name="w">The covering bit width representative</param>
            <param name="t">A primal cell type representative</param>
            <typeparam name="W">The bit width type</typeparam>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.ApiIdentify.keyword(System.Type)">
            <summary>
            For a system-defined type, returns the C#-specific keyword for the type if it has one;
            otherwise, returns an empty string
            </summary>
            <param name="src">The type to test</param>
        </member>
        <member name="M:Z0.ApiIdentify.enum(System.Type)">
            <summary>
            Defines an <see cref='T:System.Enum'/> identifier
            </summary>
        </member>
        <member name="M:Z0.ApiIdentify.generic(System.Reflection.MethodInfo)">
            <summary>
            Identifies a generic method
            </summary>
            <param name="src">The method to identify</param>
        </member>
        <member name="M:Z0.ApiIdentify.generic(System.String)">
            <summary>
            Creates a moniker directly from source text
            </summary>
            <param name="src">The source text</param>
        </member>
        <member name="M:Z0.ApiIdentify.identify(System.Type)">
            <summary>
            Identifies a type
            </summary>
            <param name="src">The type to identify</param>
        </member>
        <member name="M:Z0.ApiIdentify.identify(System.Reflection.MethodInfo)">
            <summary>
            Identifies a method
            </summary>
            <param name="src">The method to identify</param>
        </member>
        <member name="M:Z0.ApiIdentify.identify(System.Delegate)">
            <summary>
            Identifies a delegate
            </summary>
            <param name="src">The method to identify</param>
        </member>
        <member name="M:Z0.ApiIdentify.imm8(Z0.OpIdentity)">
            <summary>
            Extracts an 8-bit immediate value from an identity if it contains an immediate suffix; otherwise, returns none
            </summary>
            <param name="src">The source identity</param>
        </member>
        <member name="M:Z0.ApiIdentify.IsNatSpan(System.Type)">
            <summary>
            Determines whether a type is a natural span
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.ApiIdentify.name(ApiClass)">
            <summary>
            Produces the canonical name of a kinded operation
            </summary>
            <param name="k">The operation kind id</param>
        </member>
        <member name="M:Z0.ApiIdentify.vname(ApiClass)">
            <summary>
            Produces the canonical name of a kinded vectorized operation
            </summary>
            <param name="k">The operation kind id</param>
        </member>
        <member name="M:Z0.ApiIdentify.numeric(System.String,Z0.NumericKind,System.Boolean)">
            <summary>
            Produces an identifier of the form {opname}_{bitsize(kind)}{u | i | f}
            </summary>
            <param name="opname">The base operator name</param>
            <param name="k">The primal kind over which the identifier is deined</param>
        </member>
        <member name="M:Z0.ApiIdentify.numeric``1(``0)">
            <summary>
            Produces an identifier of the form {bitsize[T]}{u | i | f} for a numeric type
            </summary>
            <param name="t">A primal type representative</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.ApiIdentify.numeric(System.String)">
            <summary>
            Attempts to parse a numeric kind from a string in the form {width}{indicator}
            </summary>
            <param name="src">The source text</param>
        </member>
        <member name="M:Z0.ApiIdentify.numeric(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Attempts to parse a sequence of numeric kinds from a sequence of strings in the form {width}{indicator}
            </summary>
            <param name="src">The source text</param>
        </member>
        <member name="M:Z0.ApiIdentify.NumericOp(System.String,Z0.NumericKind,System.Boolean)">
            <summary>
            Produces an identifier of the form {opname}_{bitsize(kind)}{u | i | f}
            </summary>
            <param name="opname">The base operator name</param>
            <param name="k">The primal kind over which the identifier is deined</param>
        </member>
        <member name="M:Z0.ApiIdentify.NumericOp``1(System.String,System.Boolean)">
            <summary>
            Produces an identifier of the form {opname}_g{kind}{u | i | f}
            </summary>
            <param name="opname">The base operator name</param>
            <param name="t">A primal type representative</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.ApiIdentify.NumericOp(ApiClass,System.Boolean,Z0.NumericKind[])">
            <summary>
            Defines kinded identifiers for numeric functions
            </summary>
            <param name="id">The operation kind id</param>
            <param name="generic">Whether the operation should include a generic marker</param>
            <param name="kinds">The numeric argument kinds</param>
        </member>
        <member name="M:Z0.ApiIdentify.NumericOp(ApiClass,Z0.NumericKind[])">
            <summary>
            Defines kinded identifiers for nongeneric numeric functions
            </summary>
            <param name="id">The operation kind id</param>
            <param name="kinds">The numeric argument kinds</param>
        </member>
        <member name="M:Z0.ApiIdentify.primal(System.Type)">
            <summary>
            Defines a primal identity if the source type represents a recognized primitive; otherwise,
            returns <see cref='P:Z0.PrimalIdentity.Empty'/>
            </summary>
            <param name="src">The source type</param>
        </member>
        <member name="M:Z0.ApiIdentify.provider(System.Type,System.Func{System.Type,Z0.ITypeIdentityProvider})">
            <summary>
            Retrieves a type's specialized identity provider, if it has one; otherwise, returns a caller-supplied fallback
            </summary>
            <param name="src">The source type</param>
            <param name="fallback">The identity provider to yield if the type does not have a specialized provider</param>
        </member>
        <member name="M:Z0.ApiIdentify.sequential(System.Char,System.Char,System.Char,System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Assigns aggregate identity to an identity sequence
            </summary>
            <param name="open">The left fence</param>
            <param name="close">The right fence</param>
            <param name="sep">The sequence element delimiter</param>
            <param name="src">The source sequence</param>
        </member>
        <member name="M:Z0.ApiIdentify.sfunc``2(System.String,``0,``1,System.Boolean)">
            <summary>
            Defines an identifier of the form {opname}_WxN{u | i | f} where N := bitsize[T]
            </summary>
            <param name="opname">The base operator name</param>
            <param name="w">The covering bit width representative</param>
            <param name="t">A primal cell type representative</param>
            <typeparam name="W">The bit width type</typeparam>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.ApiIdentify.sfunc``1(System.String)">
            <summary>
            Defines an operand identifier of the form {opname}_N{u | i | f} that identifies an operation over a primal type of bit width N := bitsize[T]
            </summary>
            <param name="opname">The base operator name</param>
            <param name="t">A primal type representative</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.ApiIdentify.type(System.String)">
            <summary>
            Defines a type ideentity, bypassing validity checks
            </summary>
            <param name="src">The identity content</param>
        </member>
        <member name="M:Z0.ApiIdentify.sfunc``1(System.String,Z0.Vec128Kind{``0})">
            <summary>
            Defines an operand identifier of the form {opname}_N{u | i | f} that identifies an operation over a primal type of bit width N := bitsize[T]
            </summary>
            <param name="opname">The base operator name</param>
            <param name="t">A primal type representative</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.ApiIdentify.sfunc``1(System.String,Z0.Vec256Kind{``0})">
            <summary>
            Defines an operand identifier of the form {opname}_N{u | i | f} that identifies an operation over a primal type of bit width N := bitsize[T]
            </summary>
            <param name="opname">The base operator name</param>
            <param name="t">A primal type representative</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.ApiIdentify.width(System.Type)">
            <summary>
            Divines the bit-width of a specified type, if possible
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="F:Z0.ApiIdentityPartKind.Name">
            <summary>
            The unadorned subject name and the first part of the moniker
            </summary>
        </member>
        <member name="F:Z0.ApiIdentityPartKind.Suffix">
            <summary>
            A trailing component of the form {suffix sep}{suffix name}
            </summary>
        </member>
        <member name="F:Z0.ApiIdentityPartKind.Numeric">
            <summary>
            A numeric specifier of the form {width}{numeric_indicator}
            </summary>
            <example>
            In the identifier 'gteq_(8u,8u)' both arguments are 8-bit unsigned scalar values
            </example>
        </member>
        <member name="F:Z0.ApiIdentityPartKind.Segment">
            <summary>
            A segmentation specifier of the form {total width}x{segment width}{numeric indicator}
            </summary>
            <example>
            in the identifier 'vnand_(v128x16u,v128x16u)', the term '128x16u' in both value arguments is a segment specifier
            </example>
        </member>
        <member name="F:Z0.ApiUriDelimiters.UriEndOfScheme">
            <summary>
            The text used to terminate a uri scheme and trailing '//'
            </summary>
        </member>
        <member name="F:Z0.ApiUriDelimiters.UriPathSep">
            <summary>
            Forward slash
            </summary>
        </member>
        <member name="F:Z0.ApiUriDelimiters.UriQuery">
            <summary>
            Query marker
            </summary>
        </member>
        <member name="F:Z0.ApiUriDelimiters.UriFragment">
            <summary>
            Hash marker
            </summary>
        </member>
        <member name="F:Z0.ApiUriScheme.Asm">
            <summary>
            Marker for operations emitted to a decoded asm file
            </summary>
        </member>
        <member name="F:Z0.ApiUriScheme.Hex">
            <summary>
            Marker for operations emitted to a hex-formatted file
            </summary>
        </member>
        <member name="F:Z0.ApiUriScheme.Type">
            <summary>
            Marker for stateless hosted operations
            </summary>
        </member>
        <member name="F:Z0.ApiUriScheme.Svc">
            <summary>
            Marker for serviced hosted operations
            </summary>
        </member>
        <member name="F:Z0.ApiUriScheme.Located">
            <summary>
            Marker for memory-located operations
            </summary>
        </member>
        <member name="F:Z0.ApiUriScheme.Meta">
            <summary>
            Marker for metadata-located operations
            </summary>
        </member>
        <member name="T:Z0.IDI">
            <summary>
            Identity indicators
            </summary>
        </member>
        <member name="F:Z0.IDI.PartSep">
            <summary>
            An identity part delimiter
            </summary>
        </member>
        <member name="F:Z0.IDI.SuffixSep">
            <summary>
            A suffix part delimiter
            </summary>
        </member>
        <member name="F:Z0.IDI.SegSep">
            <summary>
            A separator between the bit width of a segmented type and the width of each segment
            </summary>
        </member>
        <member name="F:Z0.IDI.ModSep">
            <summary>
            A separator between an identifier body and an applied modifier
            </summary>
        </member>
        <member name="F:Z0.IDI.Refines">
            <summary>
            A seperator that between a type and a generalization
            </summary>
        </member>
        <member name="F:Z0.IDI.Signed">
            <summary>
            Indicates a signed integral type
            </summary>
        </member>
        <member name="F:Z0.IDI.Unsigned">
            <summary>
            Indicates an unsigned integral type
            </summary>
        </member>
        <member name="F:Z0.IDI.Float">
            <summary>
            Indicates a floating-point type
            </summary>
        </member>
        <member name="F:Z0.IDI.Vector">
            <summary>
            Indicates an intrinsic vector
            </summary>
        </member>
        <member name="F:Z0.IDI.Block">
            <summary>
            Indicates a blocked type
            </summary>
        </member>
        <member name="F:Z0.IDI.Nat">
            <summary>
            Indicates a natural number type
            </summary>
        </member>
        <member name="F:Z0.IDI.Generic">
            <summary>
            Indicates a generic type or method
            </summary>
        </member>
        <member name="F:Z0.IDI.ArgSep">
            <summary>
            A type or value argument delimiter
            </summary>
        </member>
        <member name="F:Z0.IDI.ArgsOpen">
            <summary>
            Opens a value parameter list
            </summary>
        </member>
        <member name="F:Z0.IDI.ArgsClose">
            <summary>
            Closes a value parameter list
            </summary>
        </member>
        <member name="F:Z0.IDI.TypeArgsOpen">
            <summary>
            Opens a type argument list
            </summary>
        </member>
        <member name="F:Z0.IDI.TypeArgsClose">
            <summary>
            Closes a type argument list
            </summary>
        </member>
        <member name="F:Z0.IDI.EndOfScheme">
            <summary>
            The text used to terminate a uri scheme and trailing '//'
            </summary>
        </member>
        <member name="F:Z0.IDI.UriPathSep">
            <summary>
            The symbol used to separate uri path components
            </summary>
        </member>
        <member name="F:Z0.IDI.UriQueryMarker">
            <summary>
            The symbol used to delimit a uri query segment from the path
            </summary>
        </member>
        <member name="F:Z0.IDI.UriFragment">
            <summary>
            The symbol used to announce a fragment
            </summary>
        </member>
        <member name="F:Z0.IDI.Pointer">
            <summary>
            Indicates a pointer
            </summary>
        </member>
        <member name="F:Z0.IDI.Array">
            <summary>
            Indicates an array
            </summary>
        </member>
        <member name="F:Z0.IDI.Span">
            <summary>
            Indicates a span
            </summary>
        </member>
        <member name="F:Z0.IDI.ReadOnlySpan">
            <summary>
            Indicates an unmodifiable (readonly, immutable, etc) span
            </summary>
        </member>
        <member name="F:Z0.IDI.NatSpan">
            <summary>
            Indicates a natural span
            </summary>
        </member>
        <member name="F:Z0.IDI.Imm">
            <summary>
            An identifier suffix indicating that an immediate value is required
            </summary>
        </member>
        <member name="T:Z0.ApiCaptureBlock">
            <summary>
             Defines the dataset accumulated for an operation-targeted capture workflow
            </summary>
        </member>
        <member name="T:Z0.ApiCodeBlock">
            <summary>
            The hex bits found at the end of a uri
            </summary>
        </member>
        <member name="F:Z0.ApiCodeBlock.Uri">
            <summary>
            The operation uri
            </summary>
        </member>
        <member name="F:Z0.ApiCodeBlock.Code">
            <summary>
            The encoded operation data
            </summary>
        </member>
        <member name="P:Z0.ApiCodeBlock.Base">
            <summary>
            The code's base address
            </summary>
        </member>
        <member name="P:Z0.ApiCodeBlock.Identifier">
            <summary>
            An identifier populated with parsed operation uri text, when possible; otherwise populated with unparsed uri text
            </summary>
        </member>
        <member name="P:Z0.ApiCodeBlock.OpUri">
            <summary>
            The operation uri
            </summary>
        </member>
        <member name="P:Z0.ApiCodeBlock.Encoded">
            <summary>
            The encoded operation data
            </summary>
        </member>
        <member name="P:Z0.ApiCodeBlock.Id">
            <summary>
            The identifier of the defined operation
            </summary>
        </member>
        <member name="P:Z0.ApiCodeBlock.Empty">
            <summary>
            No code, no identity, no life
            </summary>
        </member>
        <member name="T:Z0.ApiDependency`1">
            <summary>
            Defines an homogenous api dependency
            </summary>
        </member>
        <member name="M:Z0.ApiExtractReport.Load(Z0.FilePath)">
            <summary>
            Loads a saved extract report
            </summary>
            <param name="src">The report path</param>
        </member>
        <member name="T:Z0.ApiGenericOpIdentity">
            <summary>
            Defines identity for a generic operation
            </summary>
        </member>
        <member name="P:Z0.ApiGenericOpIdentity.Identifier">
            <summary>
            The operation identifier
            </summary>
        </member>
        <member name="T:Z0.ApiHost">
            <summary>
            Identifies/describes a type that declares a formalized api set
            </summary>
        </member>
        <member name="T:Z0.ApiHostCatalog">
            <summary>
            Defines a catalog over <see cref='T:Z0.ApiMember'/> values for a specified <see cref='T:Z0.IApiHost'/>
            </summary>
        </member>
        <member name="P:Z0.ApiHostCatalog.Part">
            <summary>
            The defining part
            </summary>
        </member>
        <member name="P:Z0.ApiHostCatalog.HostType">
            <summary>
            The defining part
            </summary>
        </member>
        <member name="T:Z0.ApiHostCodeBlocks">
            <summary>
            Collects code derived from members declared by a specific operation host
            </summary>
        </member>
        <member name="F:Z0.ApiHostCodeBlocks.Host">
            <summary>
            The defining host
            </summary>
        </member>
        <member name="F:Z0.ApiHostCodeBlocks.Data">
            <summary>
            The host-owned code
            </summary>
        </member>
        <member name="P:Z0.ApiHostCodeBlocks.Length">
            <summary>
            The number of collected functions
            </summary>
        </member>
        <member name="T:Z0.ApiHostInfo">
            <summary>
            Describes an api host
            </summary>
        </member>
        <member name="T:Z0.ApiHostMemberCode">
            <summary>
            Joins host-defined members with executable code
            </summary>
        </member>
        <member name="P:Z0.ApiHostMemberCode.Host">
            <summary>
            The defining host
            </summary>
        </member>
        <member name="P:Z0.ApiHostMemberCode.Members">
            <summary>
            The code-correlated members
            </summary>
        </member>
        <member name="T:Z0.ApiHostMethods">
            <summary>
            Defines a catalog over <see cref='T:Z0.ApiMember'/> values for a specified <see cref='T:Z0.IApiHost'/>
            </summary>
        </member>
        <member name="T:Z0.ApiIdentityPart">
            <summary>
            Defines an identity component
            </summary>
        </member>
        <member name="M:Z0.ApiIdentityPart.Define(System.Byte,Z0.ApiIdentityPartKind,System.String)">
            <summary>
            Defines an identity part
            </summary>
            <param name="width">The scalar bit-width</param>
        </member>
        <member name="T:Z0.ApiMember">
            <summary>
            Describes a reified api member which may be of hosted or located state
            </summary>
        </member>
        <member name="T:Z0.ApiMemberCode">
            <summary>
            Pairs an api member with the executable code derived from that member
            </summary>
        </member>
        <member name="F:Z0.ApiMemberCode.Sequence">
            <summary>
            The extraction index
            </summary>
        </member>
        <member name="F:Z0.ApiMemberCode.Member">
            <summary>
            The member to which executable code is attached
            </summary>
        </member>
        <member name="F:Z0.ApiMemberCode.TermCode">
            <summary>
            The extraction termination code
            </summary>
        </member>
        <member name="F:Z0.ApiMemberCode.Encoded">
            <summary>
            The encoded data
            </summary>
        </member>
        <member name="T:Z0.ApiMemberCodeBlocks">
            <summary>
            Defines a sequence of <see cref='T:Z0.ApiMemberCode'/> records
            </summary>
        </member>
        <member name="T:Z0.ApiMembers">
            <summary>
            Defines and index over <see cref='T:Z0.ApiMember'/> values
            </summary>
        </member>
        <member name="P:Z0.ApiNaturalOp.Host">
            <summary>
            The operation host to which generic definition and any concrete closures belong
            </summary>
        </member>
        <member name="P:Z0.ApiNaturalOp.GenericId">
            <summary>
            The generic operation identity
            </summary>
        </member>
        <member name="P:Z0.ApiNaturalOp.Closures">
            <summary>
            The supported closures
            </summary>
        </member>
        <member name="P:Z0.ApiNaturalOp.Method">
            <summary>
            The generic method definition
            </summary>
        </member>
        <member name="P:Z0.ApiNaturalOp.Id">
            <summary>
            The generalized identity
            </summary>
        </member>
        <member name="T:Z0.ApiOpAddress">
            <summary>
            Pairs a located operation with, well, its location
            </summary>
        </member>
        <member name="T:Z0.ApiPartCatalog">
            <summary>
            Defines a catalog over a <see cref='T:Z0.IPart'/>
            </summary>
        </member>
        <member name="P:Z0.ApiPartCatalog.PartId">
            <summary>
            The identity of the assembly that defines and owns the catalog
            </summary>
        </member>
        <member name="P:Z0.ApiPartCatalog.Owner">
            <summary>
            The assembly that defines and owns the catalog
            </summary>
        </member>
        <member name="P:Z0.ApiPartCatalog.ApiDataTypes">
            <summary>
            The data types defined by the assembly
            </summary>
        </member>
        <member name="P:Z0.ApiPartCatalog.OperationHosts">
            <summary>
            The data types defined by the assembly
            </summary>
        </member>
        <member name="P:Z0.ApiPartCatalog.ServiceHosts">
            <summary>
            The api service types types defined by the assembly
            </summary>
        </member>
        <member name="P:Z0.ApiPartCatalog.ApiHosts">
            <summary>
            The api hosts known to the catalog, including both operation and data type hosts
            </summary>
        </member>
        <member name="P:Z0.ApiPartCatalog.Operations">
            <summary>
            The host-defined operations
            </summary>
        </member>
        <member name="P:Z0.ApiPartCatalog.IsIdentified">
            <summary>
            Specifies whether the catalog contains content from an identified assembly
            </summary>
        </member>
        <member name="P:Z0.ApiPartCatalog.IsNonEmpty">
            <summary>
            Specifies whether the catalog describes any api hosts
            </summary>
        </member>
        <member name="P:Z0.ApiPartCatalog.IsEmpty">
            <summary>
            Specifies whether the catalog describes any api hosts
            </summary>
        </member>
        <member name="F:Z0.ApiPartCodeBlocks.Part">
            <summary>
            The owning part
            </summary>
        </member>
        <member name="F:Z0.ApiPartCodeBlocks.Data">
            <summary>
            The code in the set
            </summary>
        </member>
        <member name="T:Z0.ApiPartSet">
            <summary>
            Associates a collection of components along with a<see cref = 'T:Z0.ISystemApiCatalog'/>
            </summary>
        </member>
        <member name="P:Z0.ApiPartSet.Source">
            <summary>
            The root of the archive one which the api module set is predicated
            </summary>
        </member>
        <member name="T:Z0.ApiPartTypes">
            <summary>
            Represents the types defined by a part
            </summary>
        </member>
        <member name="T:Z0.ArityValue">
            <summary>
            Defines numeric arity values and is independent of the arity classifier/classification scheme
            </summary>
        </member>
        <member name="F:Z0.ArityValue.Nullary">
            <summary>
            None
            </summary>
        </member>
        <member name="F:Z0.ArityValue.Unary">
            <summary>
            One
            </summary>
        </member>
        <member name="F:Z0.ArityValue.Binary">
            <summary>
            Two
            </summary>
        </member>
        <member name="F:Z0.ArityValue.Ternary">
            <summary>
            Three
            </summary>
        </member>
        <member name="T:Z0.CliSig">
            <summary>
            Defines a cli signature
            </summary>
        </member>
        <member name="T:Z0.ClosedApiMethod">
            <summary>
            Captures identifying/descriptive information about a generic closure
            </summary>
        </member>
        <member name="P:Z0.ClosedApiMethod.Host">
            <summary>
            The delcaring host
            </summary>
        </member>
        <member name="P:Z0.ClosedApiMethod.Id">
            <summary>
            The closure identity
            </summary>
        </member>
        <member name="P:Z0.ClosedApiMethod.Kind">
            <summary>
            The primal kind over which the subject operation was closed
            </summary>
        </member>
        <member name="P:Z0.ClosedApiMethod.Method">
            <summary>
            The closed method
            </summary>
        </member>
        <member name="M:Z0.ClosedApiMethod.#ctor(Z0.IApiHost,Z0.OpIdentity,Z0.NumericKind,System.Reflection.MethodInfo)">
            <summary>
            Initializes a closure specification
            </summary>
            <param name="id">The assigned identity</param>
            <param name="kind">The primal kind over which the subject was closed</param>
            <param name="closed">The closed method</param>
        </member>
        <member name="P:Z0.DelegateIdentity.Parameters">
            <summary>
            The type parameters that define the full delegate signature that includes the return type
            as the last identity in the array
            </summary>
        </member>
        <member name="P:Z0.DelegateIdentity.DelegateName">
            <summary>
            The unadorned name of the delegate tyepe
            </summary>
        </member>
        <member name="P:Z0.DelegateIdentity.Identifier">
            <summary>
            The identifier computed from the name and parameter identities
            </summary>
        </member>
        <member name="P:Z0.DelegateIdentity.Generic">
            <summary>
            Indicates whether identifier should be rendered with a generic marker
            </summary>
        </member>
        <member name="T:Z0.DirectApiGroup">
            <summary>
            Defines a grouping construct for relating non-generic operations
            </summary>
        </member>
        <member name="P:Z0.DirectApiGroup.GroupId">
            <summary>
            The group identity
            </summary>
        </member>
        <member name="P:Z0.DirectApiGroup.Host">
            <summary>
            The delcaring host
            </summary>
        </member>
        <member name="P:Z0.DirectApiGroup.Members">
            <summary>
            The grouped operations
            </summary>
        </member>
        <member name="P:Z0.DirectApiMethod.Host">
            <summary>
            The delcaring host
            </summary>
        </member>
        <member name="P:Z0.DirectApiMethod.Id">
            <summary>
            The operation identity
            </summary>
        </member>
        <member name="P:Z0.DirectApiMethod.Method">
            <summary>
            The concrete method that defines the operation
            </summary>
        </member>
        <member name="T:Z0.EnumIdentity">
            <summary>
            Identifies an <see cref='T:System.Enum'/>
            </summary>
        </member>
        <member name="T:Z0.GenericApiMethod">
            <summary>
            Glues a generic method definition to a set of kinds that represent types over which the
            generic method can close
            </summary>
        </member>
        <member name="P:Z0.GenericApiMethod.Host">
            <summary>
            The operation host to which generic definition and any concrete closures belong
            </summary>
        </member>
        <member name="P:Z0.GenericApiMethod.GenericId">
            <summary>
            The generic operation identity
            </summary>
        </member>
        <member name="P:Z0.GenericApiMethod.Kinds">
            <summary>
            The supported closures
            </summary>
        </member>
        <member name="P:Z0.GenericApiMethod.Id">
            <summary>
            The generalized identity
            </summary>
        </member>
        <member name="P:Z0.GenericApiMethod.Method">
            <summary>
            The generic method definition
            </summary>
        </member>
        <member name="T:Z0.HostCaptureArchive">
            <summary>
            A host-specific capture archive
            </summary>
        </member>
        <member name="T:Z0.LocatedPart">
            <summary>
            Represents an in-memory part with a specified base address
            </summary>
        </member>
        <member name="T:Z0.NumericIndicator">
            <summary>
            Defines character representations of the partitions identified by the NumericClass kind
            </summary>
        </member>
        <member name="F:Z0.NumericIndicator.Signed">
            <summary>
            105: Indicates a signed integral type
            </summary>
        </member>
        <member name="F:Z0.NumericIndicator.Float">
            <summary>
            102: Indicates a floating-point type
            </summary>
        </member>
        <member name="F:Z0.NumericIndicator.Unsigned">
            <summary>
            117: Indicates an unsigned integral type
            </summary>
        </member>
        <member name="T:Z0.OpIdentity">
            <summary>
            Specifies host-independent api member identity
            </summary>
        </member>
        <member name="M:Z0.OpIdentity.define(System.String)">
            <summary>
            Creates a moniker directly from source text
            </summary>
            <param name="src">The source text</param>
        </member>
        <member name="P:Z0.OpIdentity.Identifier">
            <summary>
            The operation identifier
            </summary>
        </member>
        <member name="P:Z0.OpIdentity.Name">
            <summary>
            The unqualified operation name
            </summary>
        </member>
        <member name="P:Z0.OpIdentity.Suffix">
            <summary>
            The identifier suffix, if any
            </summary>
        </member>
        <member name="P:Z0.OpIdentity.IsGeneric">
            <summary>
            Specifies whether the operation was reified from a generic definition
            </summary>
        </member>
        <member name="P:Z0.OpIdentity.HasImm">
            <summary>
            Specifies whether the operation is specialized for an immediate value
            </summary>
        </member>
        <member name="P:Z0.OpIdentity.TextComponents">
            <summary>
            The moniker parts, as determined by part delimiters
            </summary>
        </member>
        <member name="P:Z0.OpUri.UriText">
            <summary>
            The full uri in the form {scheme}://{hostpath}/{opid}
            </summary>
        </member>
        <member name="F:Z0.OpUri.Scheme">
            <summary>
            The uri scheme, constrained to the defining enumeration
            </summary>
        </member>
        <member name="F:Z0.OpUri.Host">
            <summary>
            The host fragment, of the form {assembly_short_name}/{hostname}
            </summary>
        </member>
        <member name="F:Z0.OpUri.GroupName">
            <summary>
            The name assigned to a group of methods; usually agrees with what is called a "method group" in clr-land
            The purpose of the group name is to classify/identify a related set of methods and, again, this typically
            corresponds to the "name" property on a method
            </summary>
        </member>
        <member name="F:Z0.OpUri.OpId">
            <summary>
            Defines host-relative identity in the form, for example, {opname}_{typewidth}X{segwidth}{u | i | f}
            </summary>
        </member>
        <member name="P:Z0.OpUri.Part">
            <summary>
            The defining part
            </summary>
        </member>
        <member name="P:Z0.OpUri.Empty">
            <summary>
            Emptiness of nothing
            </summary>
        </member>
        <member name="T:Z0.PartFile">
            <summary>
            Specifies a part-owned file path
            </summary>
        </member>
        <member name="T:Z0.PartUri">
            <summary>
            Uri for .net clr assembly
            </summary>
        </member>
        <member name="F:Z0.PartUri.Id">
            <summary>
            The assembly identifier, constrained to the defining enumeration
            </summary>
        </member>
        <member name="P:Z0.PartUri.UriText">
            <summary>
            The uri content
            </summary>
        </member>
        <member name="T:Z0.SystemApiCatalog">
            <summary>
            Defines a catalog over one or more parts
            </summary>
        </member>
        <member name="P:Z0.SystemApiCatalog.Parts">
            <summary>
            The members of the compostion
            </summary>
        </member>
        <member name="P:Z0.SystemApiCatalog.Operations">
            <summary>
            The host-defined operations
            </summary>
        </member>
        <member name="M:Z0.TypeIdentity.numeric(Z0.NumericKind)">
            <summary>
            Defines a scalar type identity
            </summary>
            <param name="width">The scalar bit-width</param>
        </member>
        <member name="M:Z0.TypeIdentity.numeric``1(``0)">
            <summary>
            Produces an identifier of the form {bitsize[T]}{u | i | f} for a numeric type
            </summary>
            <param name="t">A primal type representative</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="T:Z0.TypeIndicator">
            <summary>
            Partitions types into manageable pieces in various ways, hopefully sensible, with 16 bits
            </summary>
        </member>
        <member name="P:Z0.TypeIndicator.Empty">
            <summary>
            The nonindicating indicator
            </summary>
        </member>
        <member name="P:Z0.TypeIndicator.Signed">
            <summary>
            Identifies the signed numeric partition
            </summary>
        </member>
        <member name="P:Z0.TypeIndicator.Unsigned">
            <summary>
            Identifies the unsigned numeric partition
            </summary>
        </member>
        <member name="P:Z0.TypeIndicator.Float">
            <summary>
            Identifies the floating-point numeric partition
            </summary>
        </member>
        <member name="P:Z0.TypeIndicator.Vector">
            <summary>
            Identifies the vectorized type partition
            </summary>
        </member>
        <member name="P:Z0.TypeIndicator.Block">
            <summary>
            Identifies the block type partition
            </summary>
        </member>
        <member name="P:Z0.TypeIndicator.Generic">
            <summary>
            Identifies the generic type partition
            </summary>
        </member>
        <member name="P:Z0.TypeIndicator.IsEmpty">
            <summary>
            Specifies whether the indicator is non-indicating
            </summary>
        </member>
        <member name="M:Z0.XApiCatalogs.Vectorized(System.Reflection.MethodInfo[],Z0.W128,System.Boolean)">
            <summary>
            selects vectorized methods from a source stream
            </summary>
            <param name="src">The source stream</param>
            <param name="w">The vector width</param>
            <param name="g">The generic partition from which methods should be selected</param>
        </member>
        <member name="M:Z0.XApiCatalogs.Vectorized(System.Reflection.MethodInfo[],Z0.W256,System.Boolean)">
            <summary>
            selects vectorized methods from a source stream
            </summary>
            <param name="src">The source stream</param>
            <param name="w">The vector width</param>
            <param name="g">The generic partition from which methods should be selected</param>
        </member>
        <member name="M:Z0.XApiCatalogs.Vectorized(System.Reflection.MethodInfo[],Z0.W512,System.Boolean)">
            <summary>
            selects vectorized methods from a source stream
            </summary>
            <param name="src">The source stream</param>
            <param name="w">The vector width</param>
            <param name="g">The generic partition from which methods should be selected</param>
        </member>
        <member name="M:Z0.XApiCatalogs.Vectorized(System.Reflection.MethodInfo[],Z0.W128,System.String,System.Boolean)">
            <summary>
            Selects vectorized methods from a stream predicated on width, name and generic partition membership
            </summary>
            <param name="src">The source stream</param>
            <param name="w">The vector width</param>
            <param name="name">The name to match</param>
            <param name="g">The generic partition to which the considered members belong</param>
        </member>
        <member name="M:Z0.XApiCatalogs.Vectorized(System.Reflection.MethodInfo[],Z0.W256,System.String,System.Boolean)">
            <summary>
            Selects vectorized methods from a stream predicated on width, name and generic partition membership
            </summary>
            <param name="src">The source stream</param>
            <param name="w">The vector width</param>
            <param name="name">The name to match</param>
            <param name="g">The generic partition to which the considered members belong</param>
        </member>
        <member name="M:Z0.XApiCatalogs.Vectorized(System.Reflection.MethodInfo[],Z0.W512,System.String,System.Boolean)">
            <summary>
            Selects vectorized methods from a stream predicated on width, name and generic partition membership
            </summary>
            <param name="src">The source stream</param>
            <param name="w">The vector width</param>
            <param name="name">The name to match</param>
            <param name="generic">The generic partition to which the considered members belong</param>
        </member>
        <member name="M:Z0.XApiCatalogs.VectorizedDirect(System.Reflection.MethodInfo[],Z0.W128)">
            <summary>
            Selects nongeneric source methods that have at least one 128-bit vector parameter
            </summary>
            <param name="src">The source methods</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.XApiCatalogs.VectorizedDirect(System.Reflection.MethodInfo[],Z0.W256)">
            <summary>
            Selects nongeneric source methods that have at least one 256-bit vector parameter
            </summary>
            <param name="src">The source methods</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.XApiCatalogs.VectorizedDirect(System.Reflection.MethodInfo[],Z0.W512)">
            <summary>
            Selects nongeneric source methods that have at least one 512-bit vector parameter
            </summary>
            <param name="src">The source methods</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.XApiCatalogs.VectorizedDirect(System.Reflection.MethodInfo[],Z0.W128,System.String)">
            <summary>
            Selects nongeneric source methods with a specified name that have at least one 128-bit vector parameter
            </summary>
            <param name="src">The source methods</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.XApiCatalogs.VectorizedDirect(System.Reflection.MethodInfo[],Z0.W256,System.String)">
            <summary>
            Selects nongeneric source methods with a specified name that have at least one 256-bit vector parameter
            </summary>
            <param name="src">The source methods</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.XApiCatalogs.VectorizedDirect(System.Reflection.MethodInfo[],Z0.W512,System.String)">
            <summary>
            Selects nongeneric source methods with a specified name that have at least one 512-bit vector parameter
            </summary>
            <param name="src">The source methods</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.XApiCatalogs.VectorizedDirect(System.Reflection.MethodInfo[],Z0.W128,System.Type)">
            <summary>
            Selects nongeneric source methods that have at least one 128-bit vector parameter closed over a specified type
            </summary>
            <param name="src">The source methods</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.XApiCatalogs.VectorizedDirect(System.Reflection.MethodInfo[],Z0.W256,System.Type)">
            <summary>
            Selects nongeneric source methods that have at least one 256-bit vector parameter closed over a specified type
            </summary>
            <param name="src">The source methods</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.XApiCatalogs.VectorizedDirect(System.Reflection.MethodInfo[],Z0.W512,System.Type)">
            <summary>
            Selects nongeneric source methods that have at least one 512-bit vector parameter closed over a specified type
            </summary>
            <param name="src">The source methods</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.XApiCatalogs.VectorizedDirect``1(System.Reflection.MethodInfo[],Z0.W128)">
            <summary>
            Selects nongeneric source methods that have at least one 128-bit vector parameter closed over a specified parametric type
            </summary>
            <param name="src">The source methods</param>
            <param name="w">The vector width</param>
            <typeparam name="T">The type to match</typeparam>
        </member>
        <member name="M:Z0.XApiCatalogs.VectorizedDirect``1(System.Reflection.MethodInfo[],Z0.W256)">
            <summary>
            Selects nongeneric source methods that have at least one 256-bit vector parameter closed over a specified parametric type
            </summary>
            <param name="src">The source methods</param>
            <param name="w">The vector width</param>
            <typeparam name="T">The type to match</typeparam>
        </member>
        <member name="M:Z0.XApiCatalogs.VectorizedDirect``1(System.Reflection.MethodInfo[],Z0.W512)">
            <summary>
            Selects nongeneric source methods that have at least one 512-bit vector parameter closed over a specified parametric type
            </summary>
            <param name="src">The source methods</param>
            <param name="w">The vector width</param>
            <typeparam name="T">The type to match</typeparam>
        </member>
        <member name="M:Z0.XApiCatalogs.VectorizedGeneric(System.Reflection.MethodInfo[],Z0.W128)">
            <summary>
            Selects open generic source methods that have at least one 128-bit vector parameter
            </summary>
            <param name="src">The source methods</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.XApiCatalogs.VectorizedGeneric(System.Reflection.MethodInfo[],Z0.W256)">
            <summary>
            Selects open generic source methods that have at least one 256-bit vector parameter
            </summary>
            <param name="src">The source methods</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.XApiCatalogs.VectorizedGeneric(System.Reflection.MethodInfo[],Z0.W512)">
            <summary>
            Selects open generic source methods that have at least one 512-bit vector parameter
            </summary>
            <param name="src">The source methods</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.XApiCatalogs.VectorizedGeneric(System.Reflection.MethodInfo[],Z0.W128,System.String)">
            <summary>
            Selects open generic source methods with a specified name that have at least one 128-bit vector parameter
            </summary>
            <param name="src">The source methods</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.XApiCatalogs.VectorizedGeneric(System.Reflection.MethodInfo[],Z0.W256,System.String)">
            <summary>
            Selects open generic source methods with a specified name that have at least one 256-bit vector parameter
            </summary>
            <param name="src">The source methods</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.XApiCatalogs.VectorizedGeneric(System.Reflection.MethodInfo[],Z0.W512,System.String)">
            <summary>
            Selects open generic source methods with a specified name that have at least one 512-bit vector parameter
            </summary>
            <param name="src">The source methods</param>
            <param name="w">The vector width</param>
        </member>
        <member name="T:Z0.ApiHostQuery">
            <summary>
            Defines api queries over a specific host
            </summary>
        </member>
        <member name="P:Z0.ApiHostQuery.Source">
            <summary>
            The host to interrogate
            </summary>
        </member>
        <member name="P:Z0.ApiHostQuery.Hosted">
            <summary>
            All hosted methods
            </summary>
        </member>
        <member name="P:Z0.ApiHostQuery.Generic">
            <summary>
            All hosted generic methods
            </summary>
        </member>
        <member name="P:Z0.ApiHostQuery.Direct">
            <summary>
            All hosted non-generic methods
            </summary>
        </member>
        <member name="M:Z0.ApiHostQuery.OfKind``1(``0)">
            <summary>
            Queries the host for operations of specified kind
            </summary>
            <param name="k">The kind classifier</param>
            <typeparam name="K">The kind type</typeparam>
        </member>
        <member name="M:Z0.ApiHostQuery.OfKind``1(``0,Z0.GenericState)">
            <summary>
            Queries the host for generic operations of specified kind
            </summary>
            <param name="k">The kind classifier</param>
            <typeparam name="K">The kind type</typeparam>
        </member>
        <member name="M:Z0.ApiHostQuery.UnaryOps(Z0.GenericState)">
            <summary>
            Queries the host for binary operators belonging to a specified generic partition
            </summary>
            <param name="g">The generic partition</param>
        </member>
        <member name="M:Z0.ApiHostQuery.BinaryOps(Z0.GenericState)">
            <summary>
            Queries the host for binary operators belonging to a specified generic partition
            </summary>
            <param name="g">The generic partition</param>
        </member>
        <member name="M:Z0.ApiHostQuery.TernaryOps(Z0.GenericState)">
            <summary>
            Queries the host for binary operators belonging to a specified generic partition
            </summary>
            <param name="g">The generic partition</param>
        </member>
        <member name="M:Z0.ApiHostQuery.Vectorized(Z0.W128,Z0.GenericState)">
            <summary>
            Queries the host for operations vectorized over 128-bit vectors
            </summary>
            <param name="w">The vector width</param>
            <param name="generic">Whether generic or non-generic methods should be selected</param>
        </member>
        <member name="M:Z0.ApiHostQuery.Vectorized(Z0.W256,Z0.GenericState)">
            <summary>
            Queries the host for operations vectorized over 128-bit vectors
            </summary>
            <param name="w">The vector width</param>
            <param name="generic">Whether generic or non-generic methods should be selected</param>
        </member>
        <member name="M:Z0.ApiHostQuery.Vectorized(Z0.W128,System.String,Z0.GenericState)">
            <summary>
            Queries the host for vectorized methods of specified vector width, name and generic partition
            </summary>
            <param name="w">The width to match</param>
            <param name="name">The name to match</param>
            <param name="g">The generic partition to consider</param>
        </member>
        <member name="M:Z0.ApiHostQuery.Vectorized(Z0.W256,System.String,Z0.GenericState)">
            <summary>
            Queries the host for vectorized methods of specified vector width, name and generic partition
            </summary>
            <param name="w">The width to match</param>
            <param name="name">The name to match</param>
            <param name="g">The generic partition to consider</param>
        </member>
        <member name="M:Z0.ApiHostQuery.Vectorized(Z0.W512,System.String,Z0.GenericState)">
            <summary>
            Queries the host for vectorized methods of specified vector width, name and generic partition
            </summary>
            <param name="w">The width to match</param>
            <param name="name">The name to match</param>
            <param name="g">The generic partition to consider</param>
        </member>
        <member name="M:Z0.ApiHostQuery.Vectorized``1(Z0.W128)">
            <summary>
            Queries the host for vectorized methods closed over cells of specified parametric type
            </summary>
            <param name="w">The width to match</param>
            <typeparam name="T">The cell type to match</typeparam>
        </member>
        <member name="M:Z0.ApiHostQuery.Vectorized``1(Z0.W256)">
            <summary>
            Queries the host for vectorized methods closed over cells of specified parametric type
            </summary>
            <param name="w">The width to match</param>
            <typeparam name="T">The cell type to match</typeparam>
        </member>
        <member name="M:Z0.ApiHostQuery.Vectorized``1(Z0.W512)">
            <summary>
            Queries the host for vectorized methods closed over cells of specified parametric type
            </summary>
            <param name="w">The width to match</param>
            <typeparam name="T">The cell type to match</typeparam>
        </member>
        <member name="M:Z0.ApiHostQuery.Vectorized``1(Z0.W128,System.String)">
            <summary>
            Queries the host for vectorized methods closed over cells of specified parametric type and that have a specified name
            </summary>
            <param name="w">The width to match</param>
            <param name="name">The name to match</param>
            <typeparam name="T">The cell type to match</typeparam>
        </member>
        <member name="M:Z0.ApiHostQuery.Vectorized``1(Z0.W256,System.String)">
            <summary>
            Queries the host for vectorized methods closed over cells of specified parametric type and that have a specified name
            </summary>
            <param name="w">The width to match</param>
            <param name="name">The name to match</param>
            <typeparam name="T">The cell type to match</typeparam>
        </member>
        <member name="M:Z0.ApiHostQuery.Vectorized``1(Z0.W512,System.String)">
            <summary>
            Queries the host for vectorized methods closed over cells of specified parametric type and that have a specified name
            </summary>
            <param name="w">The width to match</param>
            <param name="name">The name to match</param>
            <typeparam name="T">The cell type to match</typeparam>
        </member>
        <member name="M:Z0.ApiIdentity.name(System.Reflection.MethodInfo)">
            <summary>
            Defines the name of an api member predicated on a tag, if present, or the metadata-defined name if not
            </summary>
            <param name="m">The source method</param>
        </member>
        <member name="M:Z0.ApiIdentity.identify(System.Reflection.MethodInfo)">
            <summary>
            Creates a <see cref='T:Z0.ApiMetadataUri'/> that identifies a specified method
            </summary>
            <param name="src">The source method</param>
        </member>
        <member name="M:Z0.ApiIdentityKinds.typeset(Z0.NumericKind)">
            <summary>
            Computes the primal types identified by a specified kind
            </summary>
            <param name="k">The primal kind</param>
        </member>
        <member name="M:Z0.ApiIdentityKinds.kindset(Z0.NumericKind)">
            <summary>
            Specifies the primal types identified by a <see cref='T:Z0.NumericKind' />
            </summary>
            <param name="k">The primal kind</param>
        </member>
        <member name="M:Z0.ApiIdentityKinds.OwningPartText(System.Type)">
            <summary>
            Produces the formatted identifier of the declaring assembly
            </summary>
            <param name="host">The source type</param>
        </member>
        <member name="T:Z0.ApiMemberCodeIndex">
            <summary>
            Correlates operation identifiers and coded members
            </summary>
        </member>
        <member name="T:Z0.ApiPartCatalogQuery">
            <summary>
            Defines a view over a <see cref='T:Z0.IApiPartCatalog'/>
            </summary>
        </member>
        <member name="P:Z0.ApiPartCatalogQuery.Source">
            <summary>
            The catalog to interrogate
            </summary>
        </member>
        <member name="M:Z0.ApiPartIdParser.parse(System.String[])">
            <summary>
            Parses each supplied identifier; if an identifier does not parse, the return slot
            is None-populated
            </summary>
            <param name="parts">The part identifiers</param>
        </member>
        <member name="M:Z0.ApiPartIdParser.WhereSome``1(``0[])">
            <summary>
            Filters zero-valued elements from the source array
            </summary>
            <param name="src">The source array</param>
            <typeparam name="E">The enumeration type</typeparam>
        </member>
        <member name="M:Z0.ApiPartIdParser.parse``1(System.String)">
            <summary>
            Attempts to parse an enum literal, ignoring case, and returns a null value if parsing failed
            </summary>
            <param name="name">The literal name</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="T:Z0.ApiQueries">
            <summary>
            Defines a view over a <see cref='T:Z0.ApiMember'/> collection
            </summary>
        </member>
        <member name="M:Z0.ApiTestIdentity.owner(System.Type)">
            <summary>
            Produces the formatted identifier of the declaring assembly
            </summary>
            <param name="host">The source type</param>
        </member>
        <member name="M:Z0.ApiTestIdentity.name(System.Type,Z0.OpIdentity)">
            <summary>
            Produces a test case name predicated on an operation identity
            </summary>
            <param name="id">Identifies the operation under test</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.ApiTestIdentity.id``1(System.String)" -->
        <member name="M:Z0.ApiTestIdentity.name``1(System.Type,System.String)">
            <summary>
            Produces a test case name predicated on a parametrically-specialized label
            </summary>
            <param name="label">The case label</param>
            <typeparam name="T">The label specialization type</typeparam>
        </member>
        <member name="M:Z0.ApiTestIdentity.name_alt``1(System.Type,System.String)">
            <summary>
            Produces the name of the test case predicated on a root name and parametric type
            </summary>
            <param name="label">The root name</param>
        </member>
        <member name="M:Z0.ApiTestIdentity.match(System.Type,Z0.OpIdentity,Z0.OpIdentity)">
            <summary>
            Produces a case name for an identified operation match test
            </summary>
            <param name="f">The left operation</param>
            <param name="g">The right operation</param>
        </member>
        <member name="M:Z0.ApiUri.Imm8Suffix(System.Byte)">
            <summary>
            Defines an 8-bit immediate suffix predicated on an immediate value
            </summary>
            <param name="imm8">The source immediate</param>
        </member>
        <member name="M:Z0.ApiUri.TestCase(System.Type,Z0.IFunc)">
            <summary>
            Produces the name of the test case for the specified function
            </summary>
            <param name="f">The function</param>
        </member>
        <member name="M:Z0.ApiUri.HostUri(System.Type)">
            <summary>
            Produces an identifier of the form {owner}/{host} where owner is the formatted identifier of the declaring assembly and host is the name of the type
            </summary>
            <param name="host">The source type</param>
        </member>
        <member name="M:Z0.ApiUri.TestCase(System.Reflection.MethodInfo)">
            <summary>
            Produces the name of the test case determined by a source method
            </summary>
            <param name="method">The method that implements the test</param>
        </member>
        <member name="M:Z0.ApiUri.TestCase(System.Type,System.String)">
            <summary>
            Produces the name of the test case predicated on fully-specified name, excluding the host name
            </summary>
            <param name="fullname">The full name of the test</param>
        </member>
        <member name="M:Z0.ApiUri.TestCase(System.Type,Z0.OpIdentity)">
            <summary>
            Produces the name of the test case predicated on fully-specified name, excluding the host name
            </summary>
            <param name="id">Identity of the operation under test</param>
        </member>
        <member name="M:Z0.Identity.GenericIdentity(System.Reflection.MethodInfo)">
            <summary>
            Assigns host-independent api member identity to a generic method; if the
            source method is nongeneric, returns <see cref='P:Z0.ApiGenericOpIdentity.Empty' />
            </summary>
            <param name="src">The source method</param>
        </member>
        <member name="M:Z0.Identity.identify(System.Reflection.MethodInfo)">
            <summary>
            Assigns host-independent identity to an api member
            </summary>
            <param name="src">The source method</param>
        </member>
        <member name="M:Z0.Identity.identify(System.Delegate)">
            <summary>
            Assigns identity to a delegate
            </summary>
            <param name="src">The source delegate</param>
        </member>
        <member name="M:Z0.Identity.identify(System.Type)">
            <summary>
            Assigns identity to a type
            </summary>
            <param name="src">The source type</param>
        </member>
        <member name="M:Z0.Identity.BitWidth(System.Type)">
            <summary>
            Divines the bit-width of a specified type, if possible
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.Identity.Closures(Z0.GenericApiMethod)">
            <summary>
            Closes generic operations over the set of primal types that each operation supports
            </summary>
            <param name="generics">Metadata for generic operations</param>
        </member>
        <member name="M:Z0.Identity.ConstructedIdentity(System.Reflection.MethodInfo)">
            <summary>
            Assigns host-independent api identity to a constructed generic method
            </summary>
            <param name="src">The constructed method</param>
        </member>
        <member name="M:Z0.Identity.NonGenericIdentity(System.Reflection.MethodInfo)">
            <summary>
            Assigns host-independent api member identity to a nongeneric method
            </summary>
            <param name="src">The source method</param>
        </member>
        <member name="M:Z0.Identity.ParameterTypeIdentity(System.Reflection.ParameterInfo)">
            <summary>
            Assigns identity a nongeneric value parameter
            </summary>
            <param name="src">The source parameter</param>
        </member>
        <member name="M:Z0.Identity.ValueParamIdentities(System.Reflection.MethodInfo)">
            <summary>
            Assigns identity to each value parameter (not to be confused with type parametricity) declared by a method
            </summary>
            <param name="src">The source method</param>
        </member>
        <member name="M:Z0.Identity.TypeArgIdentities(System.Reflection.MethodInfo)">
            <summary>
            Assigns identity to each type argument supplied to close a generic method
            </summary>
            <param name="src">The constructed generic method</param>
        </member>
        <member name="M:Z0.Identity.TypeArgIdentity(System.Reflection.MethodInfo)">
            <summary>
            Assigns aggregate identity to the type argument sequence that closes a generic method
            </summary>
            <param name="src">The constructed generic method</param>
        </member>
        <member name="M:Z0.Identity.ValueParamIdentity(System.Reflection.MethodInfo)">
            <summary>
            Assigns aggregate identity to a method's value parameter sequence
            </summary>
            <param name="src">The source method</param>
        </member>
        <member name="M:Z0.IdentityReflector.IsSource(System.Reflection.MethodInfo)">
            <summary>
            Determines whether a method is an emitter, i.e. a method that returns a value but accepts no input
            </summary>
            <param name="m">The method to classify</param>
        </member>
        <member name="M:Z0.IdentityReflector.IsSink(System.Reflection.MethodInfo)">
            <summary>
            Determines whether a method has void return and has arity = 1
            </summary>
            <param name="m">The method to classify</param>
        </member>
        <member name="M:Z0.IdentityReflector.WithArityClass(System.Reflection.MethodInfo[])">
            <summary>
            Queries the stream for methods with a nonempty arity classification
            </summary>
            <param name="src">The source stream</param>
        </member>
        <member name="M:Z0.IdentityReflector.WithArityClass(System.Reflection.MethodInfo[],Z0.ArityKind)">
            <summary>
            Queries the stream for methods with a specified arity classification
            </summary>
            <param name="src">The source stream</param>
        </member>
        <member name="M:Z0.IdentityReflector.IsNumericFunction(System.Reflection.MethodInfo)">
            <summary>
            Determines whether a method is a function with numeric operands (if any) and return type
            </summary>
            <param name="m">The method to examine</param>
        </member>
        <member name="M:Z0.IdentityReflector.Functions(System.Reflection.MethodInfo[])">
            <summary>
            Queries the stream for methods that are functions
            </summary>
            <param name="src">The source stream</param>
        </member>
        <member name="M:Z0.IdentityReflector.Actions(System.Reflection.MethodInfo[])">
            <summary>
            Queries the stream for methods that are actions
            </summary>
            <param name="src">The source stream</param>
        </member>
        <member name="M:Z0.IdentityReflector.WithPredicateClass(System.Reflection.MethodInfo[],Z0.ApiPredicateClass)">
            <summary>
            Queries the stream for methods with a specified predicate classification
            </summary>
            <param name="src">The source stream</param>
        </member>
        <member name="M:Z0.IdentityReflector.WithPredicateClass(System.Reflection.MethodInfo[])">
            <summary>
            Queries the stream for methods with a nonempty predicate classification
            </summary>
            <param name="src">The source stream</param>
        </member>
        <member name="M:Z0.IdentityReflector.WithOperatorClass(System.Reflection.MethodInfo[])">
            <summary>
            Queries the stream for methods with a nonempty operator classification
            </summary>
            <param name="src">The source stream</param>
        </member>
        <member name="M:Z0.IdentityReflector.WithOperatorClass(System.Reflection.MethodInfo[],Z0.ApiOperatorClass)">
            <summary>
            Queries the stream for methods with a specified operator classification
            </summary>
            <param name="src">The source stream</param>
        </member>
        <member name="M:Z0.IdentityReflector.IsPredicate(System.Reflection.MethodInfo)">
            <summary>
            Determines whether a method defines a predicate that returns a bit or bool value
            </summary>
            <param name="m">The method to examine</param>
        </member>
        <member name="M:Z0.IdentityReflector.ClassifyPredicate(System.Reflection.MethodInfo)">
            <summary>
            Classifies a methods that is an operator and has arity between 1 and 3; otherwise, returns None
            </summary>
            <param name="m">The method to examine</param>
        </member>
        <member name="M:Z0.IdentityReflector.ArityClass(System.Reflection.MethodInfo)">
            <summary>
            Assigns an arity classification, if any, to a method
            </summary>
            <param name="m">The method to examine</param>
        </member>
        <member name="M:Z0.IdentityReflector.ClassifyOperator(System.Reflection.MethodInfo)">
            <summary>
            Classifies a methods that is an operator and has arity between 1 and 3; otherwise, returns None
            </summary>
            <param name="src">The method to examine</param>
        </member>
        <member name="M:Z0.TypeIdentities.provider(System.Type,System.Func{System.Type,Z0.ITypeIdentityProvider})">
            <summary>
            Retrieves a type's specialized identity provider, if it has one; otherwise, returns a caller-supplied fallback
            </summary>
            <param name="src">The source type</param>
            <param name="fallback">The identity provider to yield if the type does not have a specialized provider</param>
        </member>
        <member name="M:Z0.TypeIdentityDiviner.HostedProvider(System.Type)">
            <summary>
            Creates a type identity provider from a host type that realizes the required interface, if possible;
            otherwise, returns none
            </summary>
            <param name="host">A type that realizes an identity provider</param>
        </member>
        <member name="M:Z0.TypeIdentityDiviner.IdentityProvider(System.Type)">
            <summary>
            Retrieves a cached identity provider, if found; otherwise, creates and caches the identity provider for the source type
            </summary>
            <param name="t">The source type</param>
        </member>
        <member name="M:Z0.TypeIdentityDiviner.NatSpanId(System.Type)">
            <summary>
            Defines an identity for a type-natural span type
            </summary>
            <param name="src">The type to examine</param>
        </member>
        <member name="M:Z0.XApiIdentity.Format(Z0.CellWidth)">
            <summary>
            Produces a canonical text representation of the source kind
            </summary>
            <param name="src">The source kind</param>
        </member>
        <member name="M:Z0.XApiIdentity.KindId(System.Reflection.MethodInfo)">
            <summary>
            Returns the source method's kind identifier if it exists
            </summary>
            <param name="src">The method to examine</param>
        </member>
        <member name="M:Z0.XApiIdentity.ExtractImm8(Z0.OpIdentity)">
            <summary>
            Extracts an 8-bit immediate value from an identity if it contains an immediate suffix; otherwise, returns none
            </summary>
            <param name="src">The source identity</param>
        </member>
        <member name="M:Z0.XApiIdentity.WithAsm(Z0.OpIdentity)">
            <summary>
            Enables the assembly indicator
            </summary>
        </member>
        <member name="M:Z0.XApiIdentity.WithGeneric(Z0.OpIdentity)">
            <summary>
            Enables the generic indicator
            </summary>
        </member>
        <member name="M:Z0.XApiIdentity.WithImm8(Z0.OpIdentity,System.Byte)">
            <summary>
            Attaches an immediate suffix to an identity, removing an existing immediate suffix if necessary
            </summary>
            <param name="src">The source identity</param>
            <param name="immval">The immediate value to attach</param>
        </member>
        <member name="M:Z0.XApiIdentity.WithoutImm8(Z0.OpIdentity)">
            <summary>
            Clears an attached immediate suffix, if any
            </summary>
        </member>
        <member name="M:Z0.XApiIdentity.IsBlocked(System.Type)">
            <summary>
            Determines whether a type is classified as a blocked type via attribution
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.XApiIdentity.IsSegmented(System.Type)">
            <summary>
            Returns true if the source type is intrinsic or blocked
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="F:Z0.ApiInvariantKind.NonNull">
            <summary>
            Requires an argument to be non-null
            </summary>
        </member>
        <member name="F:Z0.ApiInvariantKind.NonNeg">
            <summary>
            Requires an argument to be non-negative
            </summary>
        </member>
        <member name="F:Z0.ApiInvariantKind.Z">
            <summary>
            Requires an argument or consraint to have a zero evaluation
            </summary>
        </member>
        <member name="F:Z0.ApiInvariantKind.Nz">
            <summary>
            Requires an argument or consraint to have a nonzero evaluation
            </summary>
        </member>
        <member name="F:Z0.ApiInvariantKind.Eq">
            <summary>
            Specifies that an equality constraint was unsatisfied
            </summary>
        </member>
        <member name="F:Z0.ApiInvariantKind.NEq">
            <summary>
            Specifies that a non-equality constraint was unsatisfied
            </summary>
        </member>
        <member name="F:Z0.ApiInvariantKind.Lt">
            <summary>
            Requires satisfaction of a less-than constraint
            </summary>
        </member>
        <member name="F:Z0.ApiInvariantKind.NLt">
            <summary>
            Requires satisfaction of a not less-than constraint
            </summary>
        </member>
        <member name="F:Z0.ApiInvariantKind.Gt">
            <summary>
            Requires satisfaction of a greater than constraint
            </summary>
        </member>
        <member name="F:Z0.ApiInvariantKind.NGt">
            <summary>
            Requires satisfaction of a not greater than constraint
            </summary>
        </member>
        <member name="F:Z0.ApiInvariantKind.LtEq">
            <summary>
            Requires satisfaction of a less than or equal to constraint
            </summary>
        </member>
        <member name="F:Z0.ApiInvariantKind.NLtEq">
            <summary>
            Requires satisfaction of a not than or equal to constraint
            </summary>
        </member>
        <member name="F:Z0.ApiInvariantKind.GtEq">
            <summary>
            Requires satisfaction of a greater than or equal to constraint
            </summary>
        </member>
        <member name="F:Z0.ApiInvariantKind.NGtEq">
            <summary>
            Requires satisfaction of a not greater than or equal to constraint
            </summary>
        </member>
        <member name="T:Z0.A0`1">
            <summary>
            Classifies generic operations of arity 0
            </summary>
        </member>
        <member name="T:Z0.A1`1">
            <summary>
            Classifies parametric operations of arity 1
            </summary>
        </member>
        <member name="T:Z0.A2`1">
            <summary>
            Classifies parametric operations of arity 2
            </summary>
        </member>
        <member name="T:Z0.A3`1">
            <summary>
            Classifies parametric operations of arity 3
            </summary>
        </member>
        <member name="T:Z0.A0">
            <summary>
            Classifies operations of arity 0
            </summary>
        </member>
        <member name="T:Z0.A1">
            <summary>
            Classifies operations of arity 0
            </summary>
        </member>
        <member name="T:Z0.A2">
            <summary>
            Classifies operations of arity 0
            </summary>
        </member>
        <member name="T:Z0.A3">
            <summary>
            Classifies operations of arity 3
            </summary>
        </member>
        <member name="T:Z0.BinaryOpClass">
            <summary>
            Defines a type-level lift for the <see cref='F:Z0.ApiOperatorClass.BinaryOp'/> classifier
            </summary>
        </member>
        <member name="T:Z0.BinaryOpClass`1">
            <summary>
            Defines an operand-parametric type-level lift for the <see cref='F:Z0.ApiOperatorClass.BinaryOp'/> classifier
            </summary>
        </member>
        <member name="T:Z0.ICanonicalKind`3">
            <summary>
            Characterizes a kind, numeric, and width-parametric canonical operation classifier
            </summary>
            <typeparam name="K">The kind classifier type</typeparam>
            <typeparam name="W">The width type</typeparam>
            <typeparam name="T">The numeric type</typeparam>
        </member>
        <member name="P:Z0.ICanonicalKind`3.OperandWidth">
            <summary>
            The parametrically-identified operand width
            </summary>
        </member>
        <member name="T:Z0.IComparisonApiKey">
            <summary>
            Characterizes a bitshift operation classifier
            </summary>
        </member>
        <member name="T:Z0.IComparisonKind`1">
            <summary>
            Characterizes a reified comparison operation classifier
            </summary>
            <typeparam name="F">The reification type</typeparam>
        </member>
        <member name="T:Z0.IComparisonKind`2">
            <summary>
            Characterizes a kind-parametric and numeric-parametric comparison operation classifier
            </summary>
            <typeparam name="F">The kind classifier type</typeparam>
            <typeparam name="T">The numeric type</typeparam>
        </member>
        <member name="P:Z0.IComparisonKind`2.NumericKind">
            <summary>
            The parametrically-identified numeric kind
            </summary>
        </member>
        <member name="T:Z0.IComparisonKind`3">
            <summary>
            Characterizes a kind, numeric, and width-parametric comparison operation classifier
            </summary>
            <typeparam name="K">The kind classifier type</typeparam>
            <typeparam name="W">The width type</typeparam>
            <typeparam name="T">The numeric type</typeparam>
        </member>
        <member name="P:Z0.IComparisonKind`3.OperandWidth">
            <summary>
            The parametrically-identified operand width
            </summary>
        </member>
        <member name="T:Z0.IMemoryApiKey">
            <summary>
            Characterizes a system operation classifier
            </summary>
        </member>
        <member name="T:Z0.IMemoryOpKind`1">
            <summary>
            Characterizes a reified system operation classifier
            </summary>
            <typeparam name="F">The reification type</typeparam>
        </member>
        <member name="T:Z0.IMemoryOpKind`2">
            <summary>
            Characterizes a kind-parametric and numeric-parametric system operation classifier
            </summary>
            <typeparam name="F">The kind classifier type</typeparam>
            <typeparam name="T">The numeric type</typeparam>
        </member>
        <member name="P:Z0.IMemoryOpKind`2.NumericKind">
            <summary>
            The parametrically-identified numeric kind
            </summary>
        </member>
        <member name="T:Z0.ISigned">
            <summary>
            Characterizes a type-level sign classifier
            </summary>
        </member>
        <member name="P:Z0.ISigned.Kind">
            <summary>
            Specifies the literal classifier the type-level classifier represents
            </summary>
        </member>
        <member name="T:Z0.ISigned`1">
            <summary>
            Characterizes an F-bound polymorphic type-level sign classifier reification
            </summary>
            <typeparam name="F">The reifying type</typeparam>
        </member>
        <member name="T:Z0.ISigned`2">
            <summary>
            Characterizes an F-bound polymorphic and S-parametric sign classifier reification
            </summary>
            <typeparam name="F">The reifying type</typeparam>
            <typeparam name="S">The sign classifier type</typeparam>
        </member>
        <member name="T:Z0.ISigned`3">
            <summary>
            Characterizes an F-bound polymorphic S/T-parametric sign classifier reification
            </summary>
            <typeparam name="F">The reifying type</typeparam>
            <typeparam name="S">The sign classifier type</typeparam>
            <typeparam name="T">The T-carrier, of any sort</typeparam>
        </member>
        <member name="P:Z0.ISigned`3.SignType">
            <summary>
            Reveals the singleton instance of the T-parametric classifier
            </summary>
        </member>
        <member name="P:Z0.ISigned`3.Z0#ISigned#Kind">
            <summary>
            Default implementation of <see cref="P:Z0.ISigned.Kind"/>
            </summary>
        </member>
        <member name="T:Z0.ISizedOp">
            <summary>
            Characterizes an operation class that classifies width-parametric operations
            </summary>
        </member>
        <member name="T:Z0.ISizedOp`1">
            <summary>
            Characterizes a width-parametric operation class
            </summary>
            <typeparam name="W">The width type</typeparam>
        </member>
        <member name="T:Z0.ISizedOp`2">
            <summary>
            Characterizes a width-parametric operation class that is also class-parametric
            </summary>
            <typeparam name="W">The width type</typeparam>
            <typeparam name="E">The class type</typeparam>
        </member>
        <member name="T:Z0.ISizedOp`3">
            <summary>
            Characterizes an operation class, parametric in both width and class, is also operand-parametric
            </summary>
            <typeparam name="W">The width type</typeparam>
            <typeparam name="E">The class type</typeparam>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="T:Z0.IStepwise`1">
            <summary>
            Characterizes a structure over which both incrementing and decrementing 
            operations are defined
            </summary>
            <typeparam name="S">The structure type</typeparam>
        </member>
        <member name="T:Z0.ISystemOpKind">
            <summary>
            Characterizes a system operation classifier
            </summary>
        </member>
        <member name="T:Z0.ISystemOpKind`1">
            <summary>
            Characterizes a reified system operation classifier
            </summary>
            <typeparam name="F">The reification type</typeparam>
        </member>
        <member name="T:Z0.ISystemOpKind`2">
            <summary>
            Characterizes a kind-parametric and numeric-parametric system operation classifier
            </summary>
            <typeparam name="F">The kind classifier type</typeparam>
            <typeparam name="T">The numeric type</typeparam>
        </member>
        <member name="P:Z0.ISystemOpKind`2.NumericKind">
            <summary>
            The parametrically-identified numeric kind
            </summary>
        </member>
        <member name="M:Z0.XKinds.NumericOperators(System.Reflection.MethodInfo[])">
            <summary>
            Queries the stream for methods that are recognized as numeric operators
            </summary>
            <param name="src">The source stream</param>
        </member>
        <member name="M:Z0.XKinds.NumericOperators(System.Reflection.MethodInfo[],System.Int32)">
            <summary>
            Selects numeric operators with a specified arity from the source stream
            </summary>
            <param name="src">The methods to filter</param>
        </member>
        <member name="M:Z0.XKinds.AcceptsImmediate(System.Reflection.MethodInfo,Z0.ScalarRefinementKind)">
            <summary>
            Determines whether a method defines a parameter that requires an 8-bit immediate immediate
            </summary>
            <param name="m">The method to examine</param>
        </member>
        <member name="M:Z0.XKinds.AcceptsImmediate(System.Reflection.MethodInfo)">
            <summary>
            Determines whether a method defines a parameter that requires an 8-bit immediate immediate
            </summary>
            <param name="m">The method to examine</param>
        </member>
        <member name="M:Z0.XKinds.AcceptsImmediate(System.Reflection.MethodInfo,System.Int32,Z0.ScalarRefinementKind)">
            <summary>
            Determines whether a method defines an index-identified parameter that requires an 8-bit immediate immediate
            </summary>
            <param name="m">The method to examine</param>
        </member>
        <member name="M:Z0.XKinds.IsBinaryOperator(System.Reflection.MethodInfo)">
            <summary>
            Determines whether a method is a binary operator
            </summary>
            <param name="m">The method to examine</param>
        </member>
        <member name="M:Z0.XKinds.IsBinaryFunction(System.Reflection.MethodInfo)">
            <summary>
            Determines whether a method defines a binary function
            </summary>
            <param name="m">The method to examine</param>
        </member>
        <member name="M:Z0.XKinds.BinaryOperators(System.Reflection.MethodInfo[])">
            <summary>
            Selects binary operators from a stream
            </summary>
            <param name="src">The methods to examine</param>
        </member>
        <member name="M:Z0.XKinds.ImmFunctionClass(System.Reflection.MethodInfo,Z0.ScalarRefinementKind)">
            <summary>
            Calculates a method's immediate class
            </summary>
            <param name="src">The method to classify</param>
        </member>
        <member name="M:Z0.XKinds.IsNaturalNumeric(System.Reflection.MethodInfo)">
            <summary>
            Returns true if a method is open generic with parametric arity 2 and is attributed
            with both natural an numeric closures
            </summary>
            <param name="m">The method to test</param>
        </member>
        <member name="M:Z0.XKinds.NaturalNumeric(System.Collections.Generic.IEnumerable{System.Reflection.MethodInfo})">
            <summary>
            Selects the natural numeric methods from a stream
            </summary>
            <param name="src">The methods to examine</param>
        </member>
        <member name="M:Z0.XKinds.IsNumeric(System.Reflection.MethodInfo)">
            <summary>
            Determines whether a method has numeric operands (if any) and a numeric return type (if any)
            </summary>
            <param name="src">The method to examine</param>
        </member>
        <member name="M:Z0.XKinds.IsNumericOperator(System.Reflection.MethodInfo,System.Nullable{System.Int32})">
            <summary>
            Determines whether a method is a numeric operator with a specified arity
            </summary>
            <param name="m">The method to examine</param>
        </member>
        <member name="M:Z0.XKinds.IsKinded(System.Reflection.MethodInfo)">
            <summary>
            Determines whether the method has a kind identifier
            </summary>
            <param name="m">The source method</param>
        </member>
        <member name="M:Z0.XKinds.IsKindedOperator(System.Reflection.MethodInfo)">
            <summary>
            Determines whether a method defines an operator with identified kind
            </summary>
            <param name="m">The source method</param>
        </member>
        <member name="M:Z0.XKinds.Kinded(System.Reflection.MethodInfo[])">
            <summary>
            Queries the stream for methods that have a nonempty kind assignment
            </summary>
            <param name="src">The source methods</param>
        </member>
        <member name="M:Z0.XKinds.Kinded(System.Reflection.MethodInfo[],ApiClass)">
            <summary>
            Queries the stream for mathods that are of a specified kind
            </summary>
            <param name="src">The source methods</param>
            <param name="kind">The kind to match</param>
        </member>
        <member name="M:Z0.XKinds.KindedOperators(System.Collections.Generic.IEnumerable{System.Reflection.MethodInfo})">
            <summary>
            Queries the stream for methods that have a nonempty kind assignment
            </summary>
            <param name="src">The souce methods</param>
            <param name="kind">The kind to match</param>
        </member>
        <member name="M:Z0.XKinds.OfKind(System.Reflection.MethodInfo[],Z0.Vec128Type,System.Boolean)">
            <summary>
            Selects methods from a stream that accept and/or return intrinsic vectors
            </summary>
            <param name="src">The methods to examine</param>
        </member>
        <member name="M:Z0.XKinds.OfKind(System.Reflection.MethodInfo[],Z0.Vec256Type,System.Boolean)">
            <summary>
            Selects methods from a stream that accept and/or return intrinsic vectors
            </summary>
            <param name="src">The methods to examine</param>
        </member>
        <member name="M:Z0.XKinds.OfKind``1(System.Reflection.MethodInfo[],Z0.Vec128Kind{``0})">
            <summary>
            Selects methods from a stream that accept and/or return intrinsic vectors
            </summary>
            <param name="src">The methods to examine</param>
        </member>
        <member name="M:Z0.XKinds.OfKind``1(System.Reflection.MethodInfo[],Z0.Vec256Kind{``0})">
            <summary>
            Selects methods from a stream that accept and/or return intrinsic vectors
            </summary>
            <param name="src">The methods to examine</param>
        </member>
        <member name="M:Z0.XKinds.IsOperator(System.Reflection.MethodInfo)">
            <summary>
            Determines whether a method defines an operator over a (common) domain
            </summary>
            <param name="src">The method to examine</param>
        </member>
        <member name="M:Z0.XKinds.IsHomogenous(System.Reflection.MethodInfo)">
            <summary>
            Returns true if all non-void input/output values are of the same type
            </summary>
            <param name="src">The method to examine</param>
        </member>
        <member name="M:Z0.XKinds.ClassifyOperator(System.Reflection.MethodInfo)">
            <summary>
            Classifies a methods that is an operator and has arity between 1 and 3; otherwise, returns None
            </summary>
            <param name="src">The method to examine</param>
        </member>
        <member name="M:Z0.XKinds.ReturnsVector(System.Reflection.MethodInfo)">
            <summary>
            Determines whether a method returns an intrinsic vector
            </summary>
            <param name="src">The method to test</param>
        </member>
        <member name="M:Z0.XKinds.IsTernaryFunction(System.Reflection.MethodInfo)">
            <summary>
            Determines whether a method defines a binary function
            </summary>
            <param name="m">The method to examine</param>
        </member>
        <member name="M:Z0.XKinds.IsTernaryOperator(System.Reflection.MethodInfo)">
            <summary>
            Determines whether a method is a ternary operator
            </summary>
            <param name="m">The method to examine</param>
        </member>
        <member name="M:Z0.XKinds.TernaryOperators(System.Reflection.MethodInfo[])">
            <summary>
            Selects ternary operators from a stream
            </summary>
            <param name="src">The methods to examine</param>
        </member>
        <member name="M:Z0.XKinds.IsUnaryFunction(System.Reflection.MethodInfo)">
            <summary>
            Determines whether a method defines a unary function
            </summary>
            <param name="m">The method to examine</param>
        </member>
        <member name="M:Z0.XKinds.IsUnaryOperator(System.Reflection.MethodInfo)">
            <summary>
            Determines whether a method is a unary operator
            </summary>
            <param name="m">The method to examine</param>
        </member>
        <member name="M:Z0.XKinds.UnaryOperators(System.Reflection.MethodInfo[])">
            <summary>
            Selects unary operators from a stream
            </summary>
            <param name="src">The methods to examine</param>
        </member>
        <member name="M:Z0.XKinds.DistinctKinds(Z0.NumericKind)">
            <summary>
            Enumerates the distinct numeric kinds represented by the (bitfield) source kind
            </summary>
            <param name="k">The kind to evaluate</param>
        </member>
        <member name="M:Z0.XKinds.DistinctTypes(Z0.NumericKind)">
            <summary>
            Specifies the primal types identified by a specified kind
            </summary>
            <param name="k">The primal kind</param>
        </member>
        <member name="M:Z0.XKinds.ArityValue(Z0.ApiOperatorClass)">
            <summary>
            Determines the numeric arity of a classified operator
            </summary>
            <param name="src">The operator class</param>
        </member>
        <member name="M:Z0.XKinds.ImmParameters(System.Reflection.MethodInfo,Z0.ScalarRefinementKind)">
            <summary>
            Selects parameters from a method, if any, that acceptrequire an immediate value
            </summary>
            <param name="m">The method to examine</param>
        </member>
        <member name="M:Z0.XKinds.ImmRefinementType(System.Reflection.ParameterInfo)">
            <summary>
            Determines the imm refinement type, if any
            </summary>
            <param name="src">The source parameter</param>
        </member>
        <member name="M:Z0.XKinds.IsImmediate(System.Reflection.ParameterInfo,Z0.ScalarRefinementKind)">
            <summary>
            Determines whether a parameters is an immediate
            </summary>
            <param name="src">The source parameter</param>
        </member>
        <member name="M:Z0.XKinds.IsUnrefinedImmediate(System.Reflection.ParameterInfo)">
            <summary>
            Determines whether a parameters is an unrefined immediate
            </summary>
            <param name="src">The source parameter</param>
        </member>
        <member name="M:Z0.XKinds.IsRefinedImmediate(System.Reflection.ParameterInfo)">
            <summary>
            Determines whether a parameters is a refined immediate
            </summary>
            <param name="src">The source parameter</param>
        </member>
        <member name="M:Z0.XKinds.ImmParameterTypes(System.Reflection.MethodInfo,Z0.ScalarRefinementKind)">
            <summary>
            Returns a method's immediate parameter types
            </summary>
            <param name="m">The method to examine</param>
        </member>
        <member name="P:Z0.Kinds.Negative">
            <summary>
            Specifies the singleton instance of the <see cref="T:Z0.Negative"/> type-level classifier
            </summary>
        </member>
        <member name="P:Z0.Kinds.Positive">
            <summary>
            Specifies the singleton instance of the <see cref="T:Z0.Positive"/> type-level classifier
            </summary>
        </member>
        <member name="M:Z0.Kinds.sign``1(``0)">
            <summary>
            Closes the S-parametric sign classifier over a particular sign choice
            </summary>
            <param name="s">The sign choice, used only for type inference</param>
            <typeparam name="S">The choice type: Negative, Neutral or Positive</typeparam>
        </member>
        <member name="M:Z0.Kinds.kind``1(``0)">
            <summary>
            Reveals the literal represented by a parametrically-identified classifier
            </summary>
            <param name="s">The sign classifier, used only for type inference</param>
            <typeparam name="S">The choice type: Negative, Neutral or Positive</typeparam>
        </member>
        <member name="M:Z0.Kinds.negative``1(``0)">
            <summary>
            Closes the S/T-parametric sign classifier over the <see cref="T:Z0.Negative"/> with a specified T-choice
            </summary>
            <param name="t">A T-choice representative, used only for type inference</param>
            <typeparam name="T">Any type</typeparam>
        </member>
        <member name="M:Z0.Kinds.unsigned``1(``0)">
            <summary>
            Closes the S/T-parametric sign classifier over the <see cref="T:Z0.Positive"/> with a specified T-choice
            </summary>
            <param name="t">A T-choice representative, used only for type inference</param>
            <typeparam name="T">Any type</typeparam>
        </member>
        <member name="P:Z0.Kinds.v128">
            <summary>
            Specifies the 128-bit vector type classifier
            </summary>
        </member>
        <member name="P:Z0.Kinds.v256">
            <summary>
            Specifies the 256-bit vector type classifier
            </summary>
        </member>
        <member name="P:Z0.Kinds.v512">
            <summary>
            Specifies the 512-bit vector type classifier
            </summary>
        </member>
        <member name="M:Z0.Kinds.vk128``1(``0)">
            <summary>
            Reifies a cell-parametric 128-bit vector kind
            </summary>
        </member>
        <member name="M:Z0.Kinds.vk256``1(``0)">
            <summary>
            Reifies a cell-parametric 256-bit vector kind
            </summary>
        </member>
        <member name="M:Z0.Kinds.vk512``1(``0)">
            <summary>
            Reifies a cell-parametric 512-bit vector kind
            </summary>
        </member>
        <member name="T:Z0.Kinds.Block512x32u">
            <summary>
            Characterizes <see cref='T:Z0.W512'/> types that are semented over the <see cref='T:System.UInt32'/> domain
            </summary>
        </member>
        <member name="T:Z0.Kinds.Block512x32i">
            <summary>
            Characterizes <see cref='T:Z0.W512'/> types that are semented over the <see cref='T:System.Int32'/> domain
            </summary>
        </member>
        <member name="T:Z0.IArithmeticApiKey">
            <summary>
            Characterizes an arithmetic function classifier
            </summary>
        </member>
        <member name="P:Z0.IArithmeticApiKey.Kind">
            <summary>
            The literal identifier that will be lifted to the type-level
            </summary>
        </member>
        <member name="T:Z0.IArithmeticKind`1">
            <summary>
            Characterizes a reified arithmetic function classifier
            </summary>
            <typeparam name="F">The reification type</typeparam>
        </member>
        <member name="T:Z0.IArithmeticKind`2">
            <summary>
            Characterizes a kind-parametric and numeric-parametric arithmetic operation classifier
            </summary>
            <typeparam name="F">The kind classifier type</typeparam>
            <typeparam name="T">The numeric type</typeparam>
        </member>
        <member name="P:Z0.IArithmeticKind`2.Z0#IArithmeticApiKey#OperandKind">
            <summary>
            The parametrically-identified numeric kind
            </summary>
        </member>
        <member name="T:Z0.IArithmeticKind`3">
            <summary>
            Characterizes a kind, numeric, and width-parametric arithmetic operation classifier
            </summary>
            <typeparam name="F">The kind classifier type</typeparam>
            <typeparam name="W">The width type</typeparam>
            <typeparam name="T">The numeric type</typeparam>
        </member>
        <member name="P:Z0.IArithmeticKind`3.OperandWidth">
            <summary>
            The parametrically-identified operand width
            </summary>
        </member>
        <member name="T:Z0.IBitShiftApiKey">
            <summary>
            Characterizes a bitshift operation classifier
            </summary>
        </member>
        <member name="T:Z0.IBitShiftApiKey`1">
            <summary>
            Characterizes a reified bitlogic operation classifier
            </summary>
            <typeparam name="F">The reification type</typeparam>
        </member>
        <member name="T:Z0.IBitShiftApiKey`2">
            <summary>
            Characterizes a kind-parametric and numeric-parametric bitshift operation classifier
            </summary>
            <typeparam name="K">The kind classifier type</typeparam>
            <typeparam name="T">The numeric type</typeparam>
        </member>
        <member name="P:Z0.IBitShiftApiKey`2.NumericKind">
            <summary>
            The parametrically-identified numeric kind
            </summary>
        </member>
        <member name="T:Z0.IBitShiftApiKey`3">
            <summary>
            Characterizes a kind, numeric, and width-parametric bitshift operation classifier
            </summary>
            <typeparam name="K">The kind classifier type</typeparam>
            <typeparam name="W">The width type</typeparam>
            <typeparam name="T">The numeric type</typeparam>
        </member>
        <member name="P:Z0.IBitShiftApiKey`3.OperandWidth">
            <summary>
            The parametrically-identified operand width
            </summary>
        </member>
        <member name="T:Z0.IPredicateApiKey">
            <summary>
            Characterizes a bitfunction classifier
            </summary>
        </member>
        <member name="T:Z0.IBooleanPredicateKind`1">
            <summary>
            Characterizes a reified bitfunction classifier
            </summary>
            <typeparam name="F">The reification type</typeparam>
        </member>
        <member name="T:Z0.IBooleanPredicateKind`2">
            <summary>
            Characterizes a kind-parametric and numeric-parametric boolean predicate operation classifier
            </summary>
            <typeparam name="F">The kind classifier type</typeparam>
            <typeparam name="T">The numeric type</typeparam>
        </member>
        <member name="P:Z0.IBooleanPredicateKind`2.NumericKind">
            <summary>
            The parametrically-identified numeric kind
            </summary>
        </member>
        <member name="F:Z0.OperatorTypeClass.OperandType">
            <summary>
            The operator operand type
            </summary>
        </member>
        <member name="F:Z0.OperatorTypeClass.OperatorClass">
            <summary>
            The operator classification
            </summary>
        </member>
        <member name="M:Z0.SpanTypes.kind(System.Type)">
            <summary>
            Classifies a type according to whether it is a span, a readonly span, or otherwise
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.SpanTypes.test(System.Type)">
            <summary>
            Determines whether a type is a span
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.SpanTypes.IsSystemSpan(System.Type)">
            <summary>
            Tests whether a type defines a system-defined span
            </summary>
            <param name="t">The type to test</param>
        </member>
        <member name="T:Z0.CliDependency">
            <summary>
            Defines a directed association from one artifact to another
            </summary>
        </member>
        <member name="M:Z0.BitFieldSpecs.format(System.ReadOnlySpan{Z0.BitFieldSegment})">
            <summary>
            Computes the canonical format for a contiguous field segment sequence
            </summary>
            <param name="src">The source segment</param>
            <typeparam name="T">The type over which the segment is defined</typeparam>
        </member>
        <member name="M:Z0.BitFieldSpecs.width(Z0.BitFieldSpec@)">
            <summary>
            Computes the aggregate width of the segments that comprise the bitfield
            </summary>
            <param name="spec">The bitfield spec</param>
        </member>
        <member name="M:Z0.BitFieldSpecs.format``2(System.ReadOnlySpan{``0})">
            <summary>
            Computes the canonical format for a contiguous field segment sequence
            </summary>
            <param name="src">The source segment</param>
            <typeparam name="T">The type over which the segment is defined</typeparam>
        </member>
        <member name="T:Z0.BitFieldAttribute">
            <summary>
            Identifies a bitfield specification
            </summary>
        </member>
        <member name="M:Z0.BitFieldAttribute.#ctor(System.Byte)">
            <summary>
            Specifies the bitfield section [0..right]
            </summary>
            <param name="right">The inclusive right bitfield index</param>
        </member>
        <member name="M:Z0.BitFieldAttribute.#ctor(System.Byte,System.Byte)">
            <summary>
            Specifies the bitfield section [left..right]
            </summary>
            <param name="left">The inclusive left bitfield index</param>
            <param name="right">The inclusive right bitfield index</param>
        </member>
        <member name="P:Z0.BitFieldAttribute.LeftIndex">
            <summary>
            The left bitfield index
            </summary>
        </member>
        <member name="P:Z0.BitFieldAttribute.RightIndex">
            <summary>
            The right bitfield index
            </summary>
        </member>
        <member name="T:Z0.FieldWidthAttribute">
            <summary>
            Specifies the effective bit-width of a bitfield segment
            </summary>
        </member>
        <member name="T:Z0.IBitField`1">
            <summary>
            Characterizes a content-parametric bitfield
            </summary>
            <typeparam name="T">The bitfield content type</typeparam>
        </member>
        <member name="P:Z0.IBitField`1.Content">
            <summary>
            The raw bitfield data
            </summary>
        </member>
        <member name="T:Z0.IBitField`2">
            <summary>
            Characterizes a content and index-parametric bitfield
            </summary>
            <typeparam name="I">The bitfield index type that defines 0-based sequential index corresponding to each bitfield segment</typeparam>
            <typeparam name="T">The bitfield content type</typeparam>
        </member>
        <member name="T:Z0.IBitField`3">
            <summary>
            Characterizes a bitfield from which segments can be specified/extracted
            </summary>
            <typeparam name="I">The bitfield index type that defines 0-based sequential index corresponding to each bitfield segment</typeparam>
            <typeparam name="P">The bitfield position type</typeparam>
            <typeparam name="T">The bitfield content type from which segments are extracted/specified</typeparam>
        </member>
        <member name="T:Z0.IBitField`4">
            <summary>
            Characterizes a reified bitfield predicated on 3 type parameters
            </summary>
            <typeparam name="F">The reification type</typeparam>
            <typeparam name="I">The bifield index type that defines 0-based sequential index corresponding to each bitfield segment</typeparam>
            <typeparam name="P">The bitfield position type</typeparam>
            <typeparam name="T">The bitfield content type from which segments are extracted/specified</typeparam>
        </member>
        <member name="T:Z0.IBitField`6">
            <summary>
            Characterizes a reified bitfield predicated on 4 type parameters
            </summary>
            <typeparam name="F">The reification type</typeparam>
            <typeparam name="I">The bifield index type that defines 0-based sequential index corresponding to each bitfield segment</typeparam>
            <typeparam name="P">The bitfield segment type</typeparam>
            <typeparam name="T">The bitfield content type from which segments are extracted/specified</typeparam>
            <typeparam name="W">The bitfield segment width type</typeparam>
        </member>
        <member name="P:Z0.IBitFieldIndexEntry.FieldIndex">
            <summary>
            The zero-based and sequential field index
            </summary>
        </member>
        <member name="P:Z0.IBitFieldIndexEntry.FieldName">
            <summary>
            The field name
            </summary>
        </member>
        <member name="P:Z0.IBitFieldIndexEntry.FieldWidth">
            <summary>
            The number of bits covered by the field
            </summary>
        </member>
        <member name="P:Z0.IBitFieldIndexEntry`2.FieldWidth">
            <summary>
            The number of bits covered by the field
            </summary>
        </member>
        <member name="P:Z0.IBitFieldIndexEntry`3.FieldIndex">
            <summary>
            The zero-based and sequential field index
            </summary>
        </member>
        <member name="T:Z0.IBitFieldSegment">
            <summary>
            Identifies a value partition element
            </summary>
        </member>
        <member name="P:Z0.IBitFieldSegment.Name">
            <summary>
            A unique name that identifies the segment
            </summary>
        </member>
        <member name="T:Z0.IBitFieldSegment`1">
            <summary>
            Characterizes an element within a field partition
            </summary>
            <typeparam name="T">The field type over which a partition is defined</typeparam>
        </member>
        <member name="P:Z0.IBitFieldSegment`1.StartPos">
            <summary>
            The first index of the segment, relative to the source field
            </summary>
        </member>
        <member name="P:Z0.IBitFieldSegment`1.EndPos">
            <summary>
            The last index of the segment, relative to the source field
            </summary>
        </member>
        <member name="P:Z0.IBitFieldSegment`1.Width">
            <summary>
            The number of bits in the segment
            </summary>
        </member>
        <member name="T:Z0.IScalarBitField`1">
            <summary>
            Characterizes a bitfield defined over a numeric value
            </summary>
            <typeparam name="T">The numeric type</typeparam>
        </member>
        <member name="M:Z0.IScalarBitField`1.Update(`0@)">
            <summary>
            Updates the underlying scalar value
            </summary>
            <param name="src">The source data</param>
        </member>
        <member name="P:Z0.BitFieldIndexEntry.FieldIndex">
            <summary>
            The zero-based and sequential field index
            </summary>
        </member>
        <member name="P:Z0.BitFieldIndexEntry.FieldName">
            <summary>
            The field name
            </summary>
        </member>
        <member name="P:Z0.BitFieldIndexEntry.FieldWidth">
            <summary>
            The number of bits covered by the field
            </summary>
        </member>
        <member name="T:Z0.BitFieldSegment">
            <summary>
            Defines a byte-parametric field segment
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Z0.BitFieldSegment.Width" -->
        <member name="P:Z0.BitFieldSegment.Boundary">
            <summary>
            The inclusive left/right segment index boundaries
            </summary>
        </member>
        <member name="T:Z0.BitFieldSegment`1">
            <summary>
            Defines a segment within a bitfield
            </summary>
            <typeparam name="T">The value type relative to which the segment is defined</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Z0.BitFieldSegment`1.Width" -->
        <member name="F:Z0.BitFieldSegment`1.Boundary">
            <summary>
            The inclusive left/right segment index boundaries
            </summary>
        </member>
        <member name="T:Z0.BitFieldSpec">
            <summary>
            Defines a partition over a contiguous sequence of bits
            </summary>
        </member>
        <member name="P:Z0.BitFieldSpec.TotalWidth">
            <summary>
            The sum of the widths of the defining segments
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Z0.BitFieldSpec256`1" -->
        <member name="F:Z0.BitFieldSpec`2.Untyped">
            <summary>
            The bitfield definition upon which the reader is predicated
            </summary>
        </member>
        <member name="T:Z0.IBitFunctionApiKey">
            <summary>
            Characterizes a bitfunction classifier
            </summary>
        </member>
        <member name="T:Z0.IBitFunctionKind`1">
            <summary>
            Characterizes a reified bitfunction classifier
            </summary>
            <typeparam name="F">The reification type</typeparam>
        </member>
        <member name="T:Z0.IBitFunctionKind`2">
            <summary>
            Characterizes a kind-parametric and numeric-parametric bitfunction operation classifier
            </summary>
            <typeparam name="K">The kind classifier type</typeparam>
            <typeparam name="T">The numeric type</typeparam>
        </member>
        <member name="T:Z0.IBitFunctionKind`3">
            <summary>
            Characterizes a kind, numeric, and width-parametric bitfunction operation classifier
            </summary>
            <typeparam name="K">The kind classifier type</typeparam>
            <typeparam name="W">The width type</typeparam>
            <typeparam name="T">The numeric type</typeparam>
        </member>
        <member name="P:Z0.IBitFunctionKind`3.OperandWidth">
            <summary>
            The parametrically-identified operand width
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Bits.and(Z0.bit,Z0.bit)" -->
        <member name="M:Z0.BitLogic.Bits.or(Z0.bit,Z0.bit)">
            <summary>
            Computes c = a | b
            </summary>
            <param name="a">The left bit</param>
            <param name="b">The right bit</param>
        </member>
        <member name="M:Z0.BitLogic.Bits.xor(Z0.bit,Z0.bit)">
            <summary>
            Computes c = a ^ b
            </summary>
            <param name="a">The left bit</param>
            <param name="b">The right bit</param>
        </member>
        <member name="M:Z0.BitLogic.Bits.not(Z0.bit)">
            <summary>
            Computes c := ~a = !a
            </summary>
            <param name="a">The source bit</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Bits.nand(Z0.bit,Z0.bit)" -->
        <member name="M:Z0.BitLogic.Bits.nor(Z0.bit,Z0.bit)">
            <summary>
            Computes c := ~ (a | b)
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <remarks>See https://en.wikipedia.org/wiki/Logical_biconditional</remarks>
        </member>
        <member name="M:Z0.BitLogic.Bits.xnor(Z0.bit,Z0.bit)">
            <summary>
            Computes c := ~ (a ^ b)
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <remarks>See https://en.wikipedia.org/wiki/Logical_biconditional</remarks>
        </member>
        <member name="M:Z0.BitLogic.Bits.impl(Z0.bit,Z0.bit)">
            <summary>
            Computes c := a -> b := a | ~b
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <remarks>See https://en.wikipedia.org/wiki/Material_conditional</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Bits.nonimpl(Z0.bit,Z0.bit)" -->
        <member name="M:Z0.BitLogic.Bits.cimpl(Z0.bit,Z0.bit)">
            <summary>
            Computes the converse implication c := ~a | b
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Bits.cnonimpl(Z0.bit,Z0.bit)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Bits.select(Z0.bit,Z0.bit,Z0.bit)" -->
        <member name="M:Z0.BitLogic.Scalar.left(System.SByte,System.SByte)">
            <summary>
            Returns the left operand value
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The primal operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogic.Scalar.left(System.Byte,System.Byte)">
            <summary>
            Returns the left operand value
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The primal operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogic.Scalar.left(System.Int16,System.Int16)">
            <summary>
            Returns the left operand value
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The primal operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogic.Scalar.left(System.UInt16,System.UInt16)">
            <summary>
            Returns the left operand value
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The primal operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogic.Scalar.left(System.Int32,System.Int32)">
            <summary>
            Returns the left operand value
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The primal operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogic.Scalar.left(System.UInt32,System.UInt32)">
            <summary>
            Returns the left operand value
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The primal operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogic.Scalar.left(System.Int64,System.Int64)">
            <summary>
            Returns the left operand value
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The primal operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogic.Scalar.left(System.UInt64,System.UInt64)">
            <summary>
            Returns the left operand value
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The primal operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogic.Scalar.right(System.SByte,System.SByte)">
            <summary>
            Returns the right operand value
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The primal operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogic.Scalar.right(System.Byte,System.Byte)">
            <summary>
            Returns the right operand value
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The primal operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogic.Scalar.right(System.Int16,System.Int16)">
            <summary>
            Returns the right operand value
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The primal operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogic.Scalar.right(System.UInt16,System.UInt16)">
            <summary>
            Returns the right operand value
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The primal operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogic.Scalar.right(System.Int32,System.Int32)">
            <summary>
            Returns the right operand value
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The primal operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogic.Scalar.right(System.UInt32,System.UInt32)">
            <summary>
            Returns the right operand value
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The primal operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogic.Scalar.right(System.Int64,System.Int64)">
            <summary>
            Returns the right operand value
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The primal operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogic.Scalar.right(System.UInt64,System.UInt64)">
            <summary>
            Returns the right operand value
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The primal operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogic.Scalar.false(System.SByte,System.SByte)">
            <summary>
            Returns 0, irrespective of the operand values
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The primal operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogic.Scalar.false(System.Byte,System.Byte)">
            <summary>
            Returns 0, irrespective of the operand values
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The primal operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogic.Scalar.false(System.Int16,System.Int16)">
            <summary>
            Returns 0, irrespective of the operand values
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The primal operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogic.Scalar.false(System.UInt16,System.UInt16)">
            <summary>
            Returns 0, irrespective of the operand values
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The primal operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogic.Scalar.false(System.Int32,System.Int32)">
            <summary>
            Returns 0, irrespective of the operand values
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The primal operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogic.Scalar.false(System.UInt32,System.UInt32)">
            <summary>
            Returns 0, irrespective of the operand values
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The primal operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogic.Scalar.false(System.Int64,System.Int64)">
            <summary>
            Returns 0, irrespective of the operand values
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The primal operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogic.Scalar.false(System.UInt64,System.UInt64)">
            <summary>
            Returns 0, irrespective of the operand values
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The primal operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogic.Scalar.not(System.SByte)">
            <summary>
            Computes the bitwise not c := ~src of the source operand
            </summary>
            <param name="src">The source operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.not(System.Byte)">
            <summary>
            Computes the bitwise not c := ~src of the source operand
            </summary>
            <param name="src">The source operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.not(System.Int16)">
            <summary>
            Computes the bitwise not c := ~src of the source operand
            </summary>
            <param name="src">The source operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.not(System.UInt16)">
            <summary>
            Computes the bitwise not c := ~src of the source operand
            </summary>
            <param name="src">The source operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.not(System.Int32)">
            <summary>
            Computes the bitwise not c := ~src of the source operand
            </summary>
            <param name="src">The source operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.not(System.UInt32)">
            <summary>
            Computes the bitwise not c := ~src of the source operand
            </summary>
            <param name="src">The source operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.not(System.Int64)">
            <summary>
            Computes the bitwise not c := ~src of the source operand
            </summary>
            <param name="src">The source operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.not(System.UInt64)">
            <summary>
            Computes the bitwise not c := ~src of the source operand
            </summary>
            <param name="src">The source operand</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Scalar.and(System.SByte,System.SByte)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Scalar.and(System.Byte,System.Byte)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Scalar.and(System.Int16,System.Int16)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Scalar.and(System.UInt16,System.UInt16)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Scalar.and(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Scalar.and(System.UInt32,System.UInt32)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Scalar.and(System.Int64,System.Int64)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Scalar.and(System.UInt64,System.UInt64)" -->
        <member name="M:Z0.BitLogic.Scalar.or(System.SByte,System.SByte)">
            <summary>
            Computes the bitwise or c := a | b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.or(System.Byte,System.Byte)">
            <summary>
            Computes the bitwise or c := a | b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.or(System.Int16,System.Int16)">
            <summary>
            Computes the bitwise or c := a | b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.or(System.UInt16,System.UInt16)">
            <summary>
            Computes the bitwise or c := a | b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.or(System.Int32,System.Int32)">
            <summary>
            Computes the bitwise or c := a | b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.or(System.UInt32,System.UInt32)">
            <summary>
            Computes the bitwise or c := a | b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.or(System.Int64,System.Int64)">
            <summary>
            Computes the bitwise or c := a | b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.or(System.UInt64,System.UInt64)">
            <summary>
            Computes the bitwise or c := a | b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.cimpl(System.SByte,System.SByte)">
            <summary>
            Computes the converse implication c := ~a | b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.cimpl(System.Byte,System.Byte)">
            <summary>
            Computes the converse implication c := ~a | b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.cimpl(System.Int16,System.Int16)">
            <summary>
            Computes the converse implication c := ~a | b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.cimpl(System.UInt16,System.UInt16)">
            <summary>
            Computes the converse implication c := ~a | b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.cimpl(System.Int32,System.Int32)">
            <summary>
            Computes the converse implication c := ~a | b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.cimpl(System.UInt32,System.UInt32)">
            <summary>
            Computes the converse implication c := ~a | b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.cimpl(System.Int64,System.Int64)">
            <summary>
            Computes the converse implication c := ~a | b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.cimpl(System.UInt64,System.UInt64)">
            <summary>
            Computes the converse implication c := ~a | b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Scalar.cnonimpl(System.SByte,System.SByte)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Scalar.cnonimpl(System.Byte,System.Byte)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Scalar.cnonimpl(System.Int16,System.Int16)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Scalar.cnonimpl(System.UInt16,System.UInt16)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Scalar.cnonimpl(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Scalar.cnonimpl(System.UInt32,System.UInt32)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Scalar.cnonimpl(System.Int64,System.Int64)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Scalar.cnonimpl(System.UInt64,System.UInt64)" -->
        <member name="M:Z0.BitLogic.Scalar.impl(System.SByte,System.SByte)">
            <summary>
            Computes the material implication c := a | ~b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.impl(System.Byte,System.Byte)">
            <summary>
            Computes the material implication c := a | ~b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.impl(System.Int16,System.Int16)">
            <summary>
            Computes the material implication c := a | ~b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.impl(System.UInt16,System.UInt16)">
            <summary>
            Computes the material implication c := a | ~b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.impl(System.Int32,System.Int32)">
            <summary>
            Computes the material implication c := a | ~b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.impl(System.UInt32,System.UInt32)">
            <summary>
            Computes the material implication c := a | ~b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.impl(System.Int64,System.Int64)">
            <summary>
            Computes the material implication c := a | ~b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.impl(System.UInt64,System.UInt64)">
            <summary>
            Computes the material implication c := a | ~b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Scalar.nand(System.SByte,System.SByte)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Scalar.nand(System.Byte,System.Byte)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Scalar.nand(System.Int16,System.Int16)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Scalar.nand(System.UInt16,System.UInt16)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Scalar.nand(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Scalar.nand(System.UInt32,System.UInt32)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Scalar.nand(System.Int64,System.Int64)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Scalar.nand(System.UInt64,System.UInt64)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Scalar.nonimpl(System.SByte,System.SByte)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Scalar.nonimpl(System.Byte,System.Byte)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Scalar.nonimpl(System.Int16,System.Int16)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Scalar.nonimpl(System.UInt16,System.UInt16)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Scalar.nonimpl(System.Int32,System.Int32)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Scalar.nonimpl(System.UInt32,System.UInt32)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Scalar.nonimpl(System.Int64,System.Int64)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.Scalar.nonimpl(System.UInt64,System.UInt64)" -->
        <member name="M:Z0.BitLogic.Scalar.nor(System.SByte,System.SByte)">
            <summary>
            Computes the bitwise nor c := ~(a | b) for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.nor(System.Byte,System.Byte)">
            <summary>
            Computes the bitwise nor c := ~(a | b) for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.nor(System.Int16,System.Int16)">
            <summary>
            Computes the bitwise nor c := ~(a | b) for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.nor(System.UInt16,System.UInt16)">
            <summary>
            Computes the bitwise nor c := ~(a | b) for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.nor(System.Int32,System.Int32)">
            <summary>
            Computes the bitwise nor c := ~(a | b) for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.nor(System.UInt32,System.UInt32)">
            <summary>
            Computes the bitwise nor c := ~(a | b) for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.nor(System.Int64,System.Int64)">
            <summary>
            Computes the bitwise nor c := ~(a | b) for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.nor(System.UInt64,System.UInt64)">
            <summary>
            Computes the bitwise nor c := ~(a | b) for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.xor(System.SByte,System.SByte)">
            <summary>
            Computes the bitwise xor c := a ^ b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.xor(System.Byte,System.Byte)">
            <summary>
            Computes the bitwise xor c := a ^ b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.xor(System.Int16,System.Int16)">
            <summary>
            Computes the bitwise xor c := a ^ b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.xor(System.UInt16,System.UInt16)">
            <summary>
            Computes the bitwise xor c := a ^ b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.xor(System.Int32,System.Int32)">
            <summary>
            Computes the bitwise xor c := a ^ b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.xor(System.UInt32,System.UInt32)">
            <summary>
            Computes the bitwise xor c := a ^ b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.xor(System.Int64,System.Int64)">
            <summary>
            Computes the bitwise xor c := a ^ b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.xor(System.UInt64,System.UInt64)">
            <summary>
            Computes the bitwise xor c := a ^ b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.xnor(System.SByte,System.SByte)">
            <summary>
            Computes the bitwise xnor c := ~(a ^ b) for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.xnor(System.Byte,System.Byte)">
            <summary>
            Computes the bitwise xnor c := ~(a ^ b) for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.xnor(System.Int16,System.Int16)">
            <summary>
            Computes the bitwise xnor c := ~(a ^ b) for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.xnor(System.UInt16,System.UInt16)">
            <summary>
            Computes the bitwise xnor c := ~(a ^ b) for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.xnor(System.Int32,System.Int32)">
            <summary>
            Computes the bitwise xnor c := ~(a ^ b) for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.xnor(System.UInt32,System.UInt32)">
            <summary>
            Computes the bitwise xnor c := ~(a ^ b) for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.xnor(System.Int64,System.Int64)">
            <summary>
            Computes the bitwise xnor c := ~(a ^ b) for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.xnor(System.UInt64,System.UInt64)">
            <summary>
            Computes the bitwise xnor c := ~(a ^ b) for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.lnot(System.SByte,System.SByte)">
            <summary>
            Computes the bitwise not of the left operand
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.lnot(System.Byte,System.Byte)">
            <summary>
            Computes the bitwise not of the left operand
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.lnot(System.Int16,System.Int16)">
            <summary>
            Computes the bitwise not of the left operand
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.lnot(System.UInt16,System.UInt16)">
            <summary>
            Computes the bitwise not of the left operand
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.lnot(System.Int32,System.Int32)">
            <summary>
            Computes the bitwise not of the left operand
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.lnot(System.UInt32,System.UInt32)">
            <summary>
            Computes the bitwise not of the left operand
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.lnot(System.Int64,System.Int64)">
            <summary>
            Computes the bitwise not of the left operand
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.lnot(System.UInt64,System.UInt64)">
            <summary>
            Computes the bitwise not of the left operand
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.rnot(System.SByte,System.SByte)">
            <summary>
            Computes the bitwise not of the right operand
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.rnot(System.Byte,System.Byte)">
            <summary>
            Computes the bitwise not of the right operand
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.rnot(System.Int16,System.Int16)">
            <summary>
            Computes the bitwise not of the right operand
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.rnot(System.UInt16,System.UInt16)">
            <summary>
            Computes the bitwise not of the right operand
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.rnot(System.Int32,System.Int32)">
            <summary>
            Computes the bitwise not of the right operand
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.rnot(System.UInt32,System.UInt32)">
            <summary>
            Computes the bitwise not of the right operand
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.rnot(System.Int64,System.Int64)">
            <summary>
            Computes the bitwise not of the right operand
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.rnot(System.UInt64,System.UInt64)">
            <summary>
            Computes the bitwise not of the right operand
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.select(System.SByte,System.SByte,System.SByte)">
            <summary>
            Computes the bitwise select of the operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <param name="c">The third operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.select(System.Byte,System.Byte,System.Byte)">
            <summary>
            Computes the bitwise select of the operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <param name="c">The third operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.select(System.Int16,System.Int16,System.Int16)">
            <summary>
            Computes the bitwise select of the operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <param name="c">The third operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.select(System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Computes the bitwise select of the operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <param name="c">The third operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.select(System.Int32,System.Int32,System.Int32)">
            <summary>
            Computes the bitwise select of the operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <param name="c">The third operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.select(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Computes the bitwise select of the operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <param name="c">The third operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.select(System.Int64,System.Int64,System.Int64)">
            <summary>
            Computes the bitwise select of the operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <param name="c">The third operand</param>
        </member>
        <member name="M:Z0.BitLogic.Scalar.select(System.UInt64,System.UInt64,System.UInt64)">
            <summary>
            Computes the bitwise select of the operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <param name="c">The third operand</param>
        </member>
        <member name="M:Z0.BitLogic.U8.left(System.Byte,System.Byte)">
            <summary>
            Returns the left operand value
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The primal operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogic.U8.right(System.Byte,System.Byte)">
            <summary>
            Returns the right operand value
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The primal operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogic.U8.false(System.Byte,System.Byte)">
            <summary>
            Returns 0, irrespective of the operand values
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The primal operand type</typeparam>
        </member>
        <member name="M:Z0.BitLogic.U8.not(System.Byte)">
            <summary>
            Computes the bitwise not c := ~src of the source operand
            </summary>
            <param name="src">The source operand</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.U8.and(System.Byte,System.Byte)" -->
        <member name="M:Z0.BitLogic.U8.or(System.Byte,System.Byte)">
            <summary>
            Computes the bitwise or c := a | b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.U8.cimpl(System.Byte,System.Byte)">
            <summary>
            Computes the converse implication c := ~a | b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.U8.cnonimpl(System.Byte,System.Byte)" -->
        <member name="M:Z0.BitLogic.U8.impl(System.Byte,System.Byte)">
            <summary>
            Computes the material implication c := a | ~b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.U8.nand(System.Byte,System.Byte)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitLogic.U8.nonimpl(System.Byte,System.Byte)" -->
        <member name="M:Z0.BitLogic.U8.nor(System.Byte,System.Byte)">
            <summary>
            Computes the bitwise nor c := ~(a | b) for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.U8.xor(System.Byte,System.Byte)">
            <summary>
            Computes the bitwise xor c := a ^ b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.U8.xnor(System.Byte,System.Byte)">
            <summary>
            Computes the bitwise xnor c := ~(a ^ b) for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.U8.lnot(System.Byte,System.Byte)">
            <summary>
            Computes the bitwise not of the left operand
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.U8.rnot(System.Byte,System.Byte)">
            <summary>
            Computes the bitwise not of the right operand
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.BitLogic.U8.select(System.Byte,System.Byte,System.Byte)">
            <summary>
            Computes the bitwise select of the operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <param name="c">The third operand</param>
        </member>
        <member name="M:Z0.BitStates.test(System.SByte,System.Byte)">
            <summary>
            Tests the state of an index-identified source bit
            </summary>
            <param name="src">The source value</param>
            <param name="pos">The 0-based index of the bit to test</param>
        </member>
        <member name="M:Z0.BitStates.test(System.Byte,System.Byte)">
            <summary>
            Tests the state of an index-identified source bit
            </summary>
            <param name="src">The source value</param>
            <param name="pos">The 0-based index of the bit to test</param>
        </member>
        <member name="M:Z0.BitStates.test(System.Int16,System.Byte)">
            <summary>
            Tests the state of an index-identified source bit
            </summary>
            <param name="src">The source value</param>
            <param name="pos">The 0-based index of the bit to test</param>
        </member>
        <member name="M:Z0.BitStates.test(System.UInt16,System.Byte)">
            <summary>
            Tests the state of an index-identified source bit
            </summary>
            <param name="src">The source value</param>
            <param name="pos">The 0-based index of the bit to test</param>
        </member>
        <member name="M:Z0.BitStates.test(System.Int32,System.Byte)">
            <summary>
            Tests the state of an index-identified source bit
            </summary>
            <param name="src">The source value</param>
            <param name="pos">The 0-based index of the bit to test</param>
        </member>
        <member name="M:Z0.BitStates.test(System.Int64,System.Byte)">
            <summary>
            Tests the state of an index-identified source bit
            </summary>
            <param name="src">The source value</param>
            <param name="pos">The 0-based index of the bit to test</param>
        </member>
        <member name="M:Z0.BitStates.test(System.UInt32,System.Byte)">
            <summary>
            Tests the state of an index-identified source bit
            </summary>
            <param name="src">The source value</param>
            <param name="pos">The 0-based index of the bit to test</param>
        </member>
        <member name="M:Z0.BitStates.test(System.UInt64,System.Byte)">
            <summary>
            Tests the state of an index-identified source bit
            </summary>
            <param name="src">The source value</param>
            <param name="pos">The 0-based index of the bit to test</param>
        </member>
        <member name="M:Z0.BitStates.set(System.SByte,System.Byte,Z0.bit)">
            <summary>
            Aligns an index-identified source bit with with a suplied state
            </summary>
            <param name="src">The source</param>
            <param name="pos">The source bit index</param>
            <param name="state">The state with which to align a source bit</param>
        </member>
        <member name="M:Z0.BitStates.set(System.Byte,System.Byte,Z0.bit)">
            <summary>
            Aligns an index-identified source bit with with a suplied state
            </summary>
            <param name="src">The source</param>
            <param name="pos">The source bit index</param>
            <param name="state">The state with which to align a source bit</param>
        </member>
        <member name="M:Z0.BitStates.set(System.Int16,System.Byte,Z0.bit)">
            <summary>
            Aligns an index-identified source bit with with a suplied state
            </summary>
            <param name="src">The source</param>
            <param name="pos">The source bit index</param>
            <param name="state">The state with which to align a source bit</param>
        </member>
        <member name="M:Z0.BitStates.set(System.UInt16,System.Byte,Z0.bit)">
            <summary>
            Aligns an index-identified source bit with with a suplied state
            </summary>
            <param name="src">The source</param>
            <param name="pos">The source bit index</param>
            <param name="state">The state with which to align a source bit</param>
        </member>
        <member name="M:Z0.BitStates.set(System.Int32,System.Byte,Z0.bit)">
            <summary>
            Aligns an index-identified source bit with with a suplied state
            </summary>
            <param name="src">The source</param>
            <param name="pos">The source bit index</param>
            <param name="state">The state with which to align a source bit</param>
        </member>
        <member name="M:Z0.BitStates.set(System.UInt32,System.Byte,Z0.bit)">
            <summary>
            Aligns an index-identified source bit with with a suplied state
            </summary>
            <param name="src">The source</param>
            <param name="pos">The source bit index</param>
            <param name="state">The state with which to align a source bit</param>
        </member>
        <member name="M:Z0.BitStates.set(System.Int64,System.Byte,Z0.bit)">
            <summary>
            Aligns an index-identified source bit with with a suplied state
            </summary>
            <param name="src">The source</param>
            <param name="pos">The source bit index</param>
            <param name="state">The state with which to align a source bit</param>
        </member>
        <member name="M:Z0.BitStates.set(System.UInt64,System.Byte,Z0.bit)">
            <summary>
            Aligns an index-identified source bit with with a suplied state
            </summary>
            <param name="src">The source</param>
            <param name="index">The source bit index</param>
            <param name="value">The state with which to align a source bit</param>
        </member>
        <member name="T:Z0.IBitLogicKind">
            <summary>
            Characterizes a bitlogic operation classifier
            </summary>
        </member>
        <member name="T:Z0.IBitLogicKind`1">
            <summary>
            Characterizes a reified bitlogic operation classifier
            </summary>
            <typeparam name="F">The reification type</typeparam>
        </member>
        <member name="T:Z0.IBitLogicKind`2">
            <summary>
            Characterizes a kind-parametric and numeric-parametric bitlogic operation classifier
            </summary>
            <typeparam name="F">The kind classifier type</typeparam>
            <typeparam name="T">The numeric type</typeparam>
        </member>
        <member name="T:Z0.IBitLogicKindHost`3">
            <summary>
            Characterizes a kind, numeric, and width-parametric bitlogic operation classifier
            </summary>
            <typeparam name="F">The kind classifier type</typeparam>
            <typeparam name="W">The width type</typeparam>
            <typeparam name="T">The numeric type</typeparam>
        </member>
        <member name="P:Z0.IBitLogicKindHost`3.OperandWidth">
            <summary>
            The parametrically-identified operand width
            </summary>
        </member>
        <member name="T:Z0.BinaryBitLogicKind">
            <summary>
            Classifies binary boolean and bitwise logical operations
            </summary>
        </member>
        <member name="F:Z0.BinaryBitLogicKind.False">
            <summary>
            Classifies a logical  binary operator false(a,b) := bv(0000)
            </summary>
            <remarks>
            bv(0000) = id(True)
            </remarks>
        </member>
        <member name="F:Z0.BinaryBitLogicKind.And">
            <summary>
            Classifies a logical binary operator and(a,b) := bv(1000)
            </summary>
            <remarks>
            bv(1000) = id(Nor)
            0 0 0
            1 0 0
            0 1 0
            1 1 1
            </remarks>
        </member>
        <member name="F:Z0.BinaryBitLogicKind.CNonImpl">
            <summary>
            Classifies a logical binary operator cnotimply(a,b) := and(a, ~b) = bv(0010)
            </summary>
            <remarks>
            bv(0010) = id(ConverseNonimplication)
            Truth table:
            0 0 0
            1 0 1
            0 1 0
            1 1 0
            </remarks>
        </member>
        <member name="F:Z0.BinaryBitLogicKind.LProject">
            <summary>
            Classifies a logical binary operator left(a,b) := a = bv(1010)
            </summary>
            <remarks>
            bv(1010) = id(RightNot)
            Truth Table:
            0 0 0
            1 0 1
            0 1 0
            1 1 1
            </remarks>
        </member>
        <member name="F:Z0.BinaryBitLogicKind.NonImpl">
            <summary>
            Identifies a logical binary operator notimply(a,b) := and(~a, b) = bv(0100)
            </summary>
            <remarks>
            bv(0100) = id(Nonimplication)
            Truth table:
            0 0 0
            1 0 0
            0 1 1
            1 1 0
            </remarks>
        </member>
        <member name="F:Z0.BinaryBitLogicKind.RProject">
            <summary>
            Classifies a logical binary operator right(a,b) := b = bv(1100)
            </summary>
            <remarks>
            bv(1100) = id(LeftNot)
            Truth table:
            0 0 0
            1 0 0
            0 1 1
            1 1 1
            </remarks>
        </member>
        <member name="F:Z0.BinaryBitLogicKind.Xor">
            <summary>
            Classifies a logical binary operator xor(a,b) := bv(0110)
            </summary>
            <remarks>
            bv(0110) = id(XOr)
            Truth Table:
            0 0 0
            1 0 1
            0 1 1
            1 1 0
            </remarks>
        </member>
        <member name="F:Z0.BinaryBitLogicKind.Or">
            <summary>
            Classifies a logical binary operator or(a,b) := bv(1110)
            </summary>
            <remarks>
            bv(1110) = id(Nand)
            Truth Table:
            0 0 0
            1 0 1
            0 1 1
            1 1 1
            </remarks>
        </member>
        <member name="F:Z0.BinaryBitLogicKind.Nor">
            <summary>
            Classifies a logical binary operator that computes nor(a,b) := not(or(a,b)) = bv(0001)
            </summary>
            <remarks>
            bv(0001) = id(And)
            Truth Table:
            0 0 1
            1 0 0
            0 1 0
            1 1 0
            </remarks>
        </member>
        <member name="F:Z0.BinaryBitLogicKind.Xnor">
            <summary>
            Classifies a binary operator xnor(a,b) := not(xor(a,b)) = bv(1001)
            </summary>
            <remarks>
            bv(1001) = id(Xnor)
            Truth Table:
            0 0 1
            1 0 0
            0 1 0
            1 1 1
            </remarks>
        </member>
        <member name="F:Z0.BinaryBitLogicKind.RNot">
            <summary>
            Classifies a logical binary operator rnot(a,b) := not(b) = bv(0011)
            </summary>
            <remarks>
            bv(0011) = id(LeftProject)
            Truth table:
            0 0 1
            1 0 1
            0 1 0
            1 1 0
            </remarks>
        </member>
        <member name="F:Z0.BinaryBitLogicKind.Impl">
            <summary>
            Classifies a logical binary operator imply(a,b) := or(a, not(b)) = bv(1011)
            </summary>
            <remarks>
            bv(1011) = id(Implication)
            Truth table:
            0 0 1
            1 0 1
            0 1 0
            1 1 1
            </remarks>
        </member>
        <member name="F:Z0.BinaryBitLogicKind.LNot">
            <summary>
            Classifies a logical binary operator lnot(a,b) := not(a) = bv(0101)
            </summary>
            <remarks>
            bv(0101) = id(RightProject)
            Truth table:
            0 0 1
            1 0 0
            0 1 1
            1 1 0
            </remarks>
        </member>
        <member name="F:Z0.BinaryBitLogicKind.CImpl">
            <summary>
            Classifies a logical binary operator cimpl(a,b) := or(not(a), b) = bv(1101)
            </summary>
            bv(1101) = id(ConverseImplication)
            <remarks>
            Truth table:
            0 0 1
            1 0 0
            0 1 1
            1 1 1
            </remarks>
        </member>
        <member name="F:Z0.BinaryBitLogicKind.Nand">
            <summary>
            Classifies a logical binary operator nand(a,b) := not(and(a,b)) = bv(0111)
            </summary>
            <remarks>
            bv(0111) = id(Or)
            Truth Table:
            0 0 1
            1 0 1
            0 1 1
            1 1 0
            </remarks>
        </member>
        <member name="F:Z0.BinaryBitLogicKind.True">
            <summary>
            Classifies a logical binary operator true(a,b) = bv(1111)
            </summary>
            <remarks>
            bv(1111) = id(False)
            </remarks>
        </member>
        <member name="T:Z0.TernaryBitLogicKind">
            <summary>
            Classifies ternary logic and bitwise operators
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.None">
            <summary>
            The empty identity
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X01">
            <summary>
            nor(a, or(b,c))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X02">
            <summary>
            and(c, nor(b,a))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X03">
            <summary>
            nor(b,a)
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X04">
            <summary>
            and(b, nor(a,c))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X05">
            <summary>
            nor(c,a)
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X06">
            <summary>
            and(not(a), xor(b,c))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X07">
            <summary>
            nor(a, and(b,c))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X08">
            <summary>
            and(and(not(a),b), c)
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X09">
            <summary>
             nor(a, xor(b,c))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X0A">
            <summary>
            and(c, not(a))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X0B">
            <summary>
            and(not(a), or(not(b),  c))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X0C">
            <summary>
            and(b, not(a))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X0D">
            <summary>
            and(not(a), or(b, not(c)))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X0E">
            <summary>
            and(not(a),or(b,c))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X0F">
            <summary>
            not(a)
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X10">
            <summary>
            and(a, nor(b, c))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X11">
            <summary>
            nor(c,b)
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X12">
            <summary>
            and(not(b), xor(a,c))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X13">
            <summary>
            nor(b, and(a,c))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X14">
            <summary>
            and(not(c), xor(a,b))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X15">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X16">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X17">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X18">
            <summary>
            and(xor(a,b), xor(a,c))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X19">
            <summary>
            xor(xor(b,c), and(a, and(b,c)))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X1A">
            <summary>
            not(and(and(a,b), xor(a, c)))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X1B">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X1C">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X1D">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X1E">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X1F">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X20">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X21">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X22">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X23">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X24">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X25">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X26">
            <summary>
            and(not(and(a,b)), xor(a, not(c)));
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X27">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X28">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X29">
            <summary>
            select(c, xor(b,a), nor(b,a))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X2A">
            <summary>
            and(c, nand(b,a))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X2B">
            <summary>
            select(c, nand(b,a), nor(b,a))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X2C">
            <summary>
            and(or(b,c), xor(a,b))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X2D">
            <summary>
             xor(a,(or(b,not(c))))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X2E">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X2F">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X30">
            <summary>
            cnotimply(a,b)
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X31">
            <summary>
            and(not(b), or(a,not(c)))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X32">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X33">
            <summary>
            not(b)
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X34">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X35">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X36">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X37">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X38">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X39">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X3A">
            <summary>
            select(a, not(b), c)
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X3B">
            <summary>
            or(and(not(a),c),not(b))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X3C">
            <summary>
            xor(b,a)
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X3D">
            <summary>
            or(xor(b,a),nor(a,c))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X3E">
            <summary>
            or(and(not(a),c),xor(a,b))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X3F">
            <summary>
            nand(b,a)
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X40">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X41">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X42">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X43">
            <summary>
            and(not(and(a,c)), xor(a,not(b)))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X44">
            <summary>
            cnotimply(b,c)
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X45">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X46">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X47">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X48">
            <summary>
            and(b,xor(a,c))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X49">
            <summary>
            select(b,xor(a,c),nor(a,c))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X4A">
            <summary>
            and(or(b,c), xor(a,c))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X4B">
            <summary>
            xor(a, or(not(b), c))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X4C">
            <summary>
            and(b, nand(a,c))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X4D">
            <summary>
            select(b, nand(a,c),nor(a,c))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X4E">
            <summary>
            select(c, not(a), b)
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X4F">
            <summary>
            or(not(a), andnot(b,c))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X50">
            <summary>
            cnotimply(a,c)
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X51">
            <summary>
            and(not(c),or(a,not(b)))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X52">
            <summary>
            and(not(and(b,c)),xor(a,c))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X53">
            <summary>
            select(a, not(c), not(b))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X54">
            <summary>
            and(not(c), or(a,b))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X55">
            <summary>
            not(c)
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X56">
            <summary>
            xor(c,or(b,a))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X57">
            <summary>
            nand(c,or(b,a))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X58">
            <summary>
            and(or(a,b),xor(a,c))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X59">
            <summary>
            xor(c, or(a,xor1(b)))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X5A">
            <summary>
            xor(c,a)
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X5B">
            <summary>
            or(xor(a,c), xor(or(a,b),on))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X5C">
            <summary>
            select(a,not(c), b)
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X5D">
            <summary>
            or(not(c), and(not(a), b))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X5E">
            <summary>
            or(and(not(c),b),(xor(a,c)))
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X5F">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X60">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X61">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X62">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X63">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X64">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X65">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X66">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X67">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X68">
             <summary>
            
             </summary>
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X69">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X6A">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X6B">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X6C">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X6D">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X6E">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X6F">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X70">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X71">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X72">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X73">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X74">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X75">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X76">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X77">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X78">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X79">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X7A">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X7B">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X7C">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X7D">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X7E">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X7F">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X80">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X81">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X82">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X83">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X84">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X85">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X86">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X87">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X88">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X89">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X8A">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X8B">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X8C">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X8D">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X8E">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X8F">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X90">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X91">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X92">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X93">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X94">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X95">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X96">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X97">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X98">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X99">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X9A">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X9B">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X9C">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X9D">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X9E">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.X9F">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XA0">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XA1">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XA2">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XA3">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XA4">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XA5">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XA6">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XA7">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XA8">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XA9">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XAA">
            <summary>
            third(a,b,c) := c
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XAB">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XAC">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XAD">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XAE">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XAF">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XB0">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XB1">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XB2">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XB3">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XB4">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XB5">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XB6">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XB7">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XB8">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XB9">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XBA">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XBB">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XBC">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XBD">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XBE">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XBF">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XC0">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XC1">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XC2">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XC3">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XC4">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XC5">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XC6">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XC7">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XC8">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XC9">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XCA">
            <summary>
            select(a,b,c)
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XCB">
            <summary>
            second(a,b,c) := b
            </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XCC">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XCD">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XCE">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XCF">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XD0">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XD1">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XD2">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XD3">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XD4">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XD5">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XD6">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XD7">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XD8">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XD9">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XDA">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XDB">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XDC">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XDD">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XDE">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XDF">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XE0">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XE1">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XE2">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XE3">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XE4">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XE5">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XE6">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XE7">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XE8">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XE9">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XEA">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XEB">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XEC">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XED">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XEE">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XEF">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XF0">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XF1">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XF2">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XF3">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XF4">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XF5">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XF6">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XF7">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XF8">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XF9">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XFA">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XFB">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XFC">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XFD">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XFE">
             <summary>
            
             </summary>
        </member>
        <member name="F:Z0.TernaryBitLogicKind.XFF">
            <summary>
             Pervasive and invariant truth
            </summary>
        </member>
        <member name="T:Z0.UnaryBitLogicKind">
            <summary>
            Classifies unary logic operators
            </summary>
        </member>
        <member name="F:Z0.UnaryBitLogicKind.False">
            <summary>
            The unary operator that always returns false
            </summary>
        </member>
        <member name="F:Z0.UnaryBitLogicKind.Not">
            <summary>
            Logical NOT
            </summary>
        </member>
        <member name="F:Z0.UnaryBitLogicKind.Identity">
            <summary>
            The identity operator
            </summary>
        </member>
        <member name="F:Z0.UnaryBitLogicKind.True">
            <summary>
            The unary operator that always returns true
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Central4x4x2">
            <summary>
            0x6 = [0110]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Central8x4x2">
            <summary>
            0x66 = [01100110]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Central16x4x2">
            <summary>
            0x6666 = [01100110 01100110]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Central32x4x2">
            <summary>
            0x66666666 = [01100110 01100110 01100110 01100110]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Central64x4x2">
            <summary>
            0x6666666666666666 = [01100110 01100110 01100110 01100110 01100110 01100110 01100110 01100110 01100110 01100110]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Central8x8x2">
            <summary>
            0x18 = [00011000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Central16x8x2">
            <summary>
            0x1818 = [00011000 00011000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Central32x8x2">
            <summary>
            0x18181818 = [00011000 00011000 00011000 00011000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Central64x8x2">
            <summary>
            0x1818181818181818 = [00011000 00011000 00011000 00011000 00011000 00011000 00011000 00011000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Central8x8x4">
            <summary>
            0x3C = [00111100]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Central16x8x4">
            <summary>
            0x3C3C = [00111100 00111100]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Central32x8x4">
            <summary>
            0x3C3C3C3C = [00111100 00111100 00111100 00111100]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Central64x8x4">
            <summary>
            0x3C3C3C3C3C3C3C3C = [00111100 00111100 00111100 00111100 00111100 00111100 00111100 00111100]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Central16x16x8">
            <summary>
            0x0FF0 = [00001111 11110000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Central32x16x8">
            <summary>
            0x0FF00FF0 = [00001111 11110000 00001111 11110000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Central64x16x8">
            <summary>
            0x0FF00FF00FF00FF0 = [00001111 11110000 00001111 11110000 00001111 11110000 00001111 11110000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Central8x8x6">
            <summary>
            [01111110]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Central16x8x6">
            <summary>
            [01111110 01111110]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Central32x8x6">
            <summary>
            [01111110 01111110 01111110 01111110]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Central64x8x6">
            <summary>
            [01111110 01111110 01111110 01111110 01111110 01111110 01111110 01111110]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Central16x16x2">
            <summary>
            [00000001 10000000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Central32x16x2">
            <summary>
            [00000001 10000000 00000001 10000000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Central64x16x2">
            <summary>
            [00000001 10000000 00000001 10000000 00000001 10000000 00000001 10000000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Central16x4">
            <summary>
            [00000011 11000000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Central16x6">
            <summary>
            [00000111 11100000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Central16x10">
            <summary>
            [00011111 11111000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Central16x12">
            <summary>
            [00111111 11111100]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Central16x14">
            <summary>
            [01111111 11111110]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Central32x2">
            <summary>
            [00000000 00000001 10000000 00000000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Central32x32x16">
            <summary>
            0x00FFFF00
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Central64x32x16">
            <summary>
            0x00FFFF0000FFFF00
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Central64x64x32">
            <summary>
            0x0000FFFFFFFF0000
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.CJsb8x8x2x1">
            <summary>
            [10011001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.CJsb16x8x2x1">
            <summary>
            [10011001 10011001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.CJsb32x8x2x1">
            <summary>
            [10011001 10011001 10011001 10011001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.CJsb64x8x2x1">
            <summary>
            [10011001 10011001 10011001 10011001 10011001 10011001 10011001 10011001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.CJsb8x8x2x2">
            <summary>
            [0b11011011]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.CJsb16x8x2x2">
            <summary>
            [0b11011011_11011011]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.CJsb32x8x2x2">
            <summary>
            [11011011 11011011 11011011 11011011]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.CJsb64x8x2x2">
            <summary>
            [0b11011011_11011011_11011011_11011011_11011011_11011011_11011011_11011011]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.CJsb8x8x4x1">
            <summary>
            [10111101]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.CJsb16x8x4x1">
            <summary>
            [10111101 10111101]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.CJsb32x8x4x1">
            <summary>
            [10111101 10111101 10111101 10111101]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.CJsb64x8x4x1">
            <summary>
            [10111101 10111101 10111101 10111101]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Index8x8x0">
            <summary>
            [00000001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Index8x8x1">
            <summary>
            [00000010]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Index8x8x2">
            <summary>
            [00000100]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Index8x8x3">
            <summary>
            [00001000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Index8x8x4">
            <summary>
            [00010000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Index8x8x5">
            <summary>
            [00100000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Index8x8x6">
            <summary>
            [01000000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Index8x8x7">
            <summary>
            [10000000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Index16x16x1">
            <summary>
            [00000000 00000001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Index16x8x0">
            <summary>
            [00000001 00000001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Index16x8x1">
            <summary>
            [00000010 00000010]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Index16x8x2">
            <summary>
            [00000100 00000100]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Index16x8x3">
            <summary>
            [00001000 00001000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Index16x8x4">
            <summary>
            [00010000 00010000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Index16x8x5">
            <summary>
            [00100000 00100000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Index16x8x6">
            <summary>
            [01000000 01000000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Index16x8x7">
            <summary>
            [10000000 10000000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Index32x8x0">
            <summary>
            [00000001 00000001 00000001 00000001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Index32x8x1">
            <summary>
            [00000010 00000010 00000010 00000010]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Index32x8x2">
            <summary>
            [00000100 00000100 00000100 00000100]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Index32x8x3">
            <summary>
            [00001000 00001000 00001000 00001000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Index32x8x4">
            <summary>
            [00010000 00010000 00010000 00010000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Index32x8x5">
            <summary>
            [00100000 00100000 00100000 00100000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Index32x8x6">
            <summary>
            [01000000 01000000 01000000 01000000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Index32x8x7">
            <summary>
            [10000000 10000000 10000000 10000000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Index64x8x0">
            <summary>
            [00000001 00000001 00000001 00000001 00000001 00000001 00000001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Index64x8x1">
            <summary>
            [00000010 00000010 00000010 00000010 00000010 00000010 00000010 00000010]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Index64x8x2">
            <summary>
            [00000100 00000100 00000100 00000100 00000100 00000100 00000100 00000100]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Index64x8x3">
            <summary>
            [00001000 00001000 00001000 00001000 00001000 00001000 00001000 00001000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Index64x8x4">
            <summary>
            [00010000 00010000 00010000 00010000 00010000 00010000 00010000 00010000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Index64x8x5">
            <summary>
            [00100000 00100000 00100000 00100000 00100000 00100000 00100000 00100000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Index64x8x6">
            <summary>
            [01000000 01000000 01000000 01000000 01000000 01000000 01000000 01000000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Index64x8x7">
            <summary>
            [10000000 10000000 10000000 10000000 10000000 10000000 10000000 10000000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Increment16">
            <summary>
            [00000010 00000001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Increment24">
            <summary>
            [00000100 00000010 00000001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Increment32">
            <summary>
            [00001000 00000100 00000010 00000001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Increment40">
            <summary>
            [00010000 00001000 00000100 00000010 00000001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Increment48">
            <summary>
            [00100000 00010000 00001000 00000100 00000010 00000001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Increment56">
            <summary>
            [01000000 00100000 00010000 00001000 00000100 00000010 00000001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Increment64">
            <summary>
            [10000000 01000000 00100000 00010000 00001000 00000100 00000010 00000001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Jsb8x8x1">
            <summary>
            [10000001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Jsb16x8x1">
            <summary>
            [10000001 10000001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Jsb32x8x1">
            <summary>
            [10000001 10000001 10000001 10000001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Jsb64x8x1">
            <summary>
            [10000001 10000001 10000001 10000001 10000001 10000001 10000001 10000001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Jsb8x8x2">
            <summary>
            [11000011]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Jsb16x8x2">
            <summary>
            [11000011 11000011]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Jsb32x8x2">
            <summary>
            [11000011 11000011 11000011 11000011]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Jsb64x8x2">
            <summary>
            [11000011 11000011 11000011 11000011 11000011 11000011 11000011 11000011]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Jsb8x8x3">
            <summary>
            [11100111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Jsb16x8x3">
            <summary>
            [11100111 11100111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Jsb32x8x3">
            <summary>
            [11100111 11100111 11100111 11100111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Jsb64x8x3">
            <summary>
            [11100111 11100111 11100111 11100111 11100111 11100111 11100111 11100111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lo8u">
            <summary>
            [11111111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lo16u">
            <summary>
            [11111111 11111111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lo24u">
            <summary>
            [11111111 11111111 11111111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lo32u">
            <summary>
            [11111111 11111111 11111111 11111111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lo64u">
            <summary>
            [11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb4x2x1">
            <summary>
            [0101]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb6x2x1">
            <summary>
            [010101]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb8x2x1">
            <summary>
            [01010101]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb10x2x1">
            <summary>
            [01 01010101]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb12x2x1">
            <summary>
            [0101 01010101]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb14x2x1">
            <summary>
            [010101 01010101]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb16x2x1">
            <summary>
            [01010101 01010101]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb18x2x1">
            <summary>
            [01 01010101 01010101]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb32x2x1">
            <summary>
            [01010101 01010101 01010101 01010101]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb64x2x1">
            <summary>
            [01010101 01010101 01010101 01010101 01010101 01010101 01010101 01010101]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb6x3x1">
            <summary>
            [001 001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb9x3x1">
            <summary>
            [001 001 001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb12x3x1">
            <summary>
            [001 001 001 001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb15x3x1">
            <summary>
            [001 001 001 001 001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb18x3x1">
            <summary>
            [001 001 001 001 001 001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb21x3x1">
            <summary>
            [001 001 001 001 001 001 001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb24x3x1">
            <summary>
            [001 001 001 001 001 001 001 001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb27x3x1">
            <summary>
            [001 001 001 001 001 001 001 001 001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb30x3x1">
            <summary>
            [001 001 001 001 001 001 001 001 001 001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb33x3x1">
            <summary>
            [001 001 001 001 001 001 001 001 001 001 001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb36x3x1">
            <summary>
            [001 001 001 001 001 001 001 001 001 001 001 001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb39x3x1">
            <summary>
            [001 001 001 001 001 001 001 001 001 001 001 001 001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb41x3x1">
            <summary>
            [001 001 001 001 001 001 001 001 001 001 001 001 001 001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb44x3x1">
            <summary>
            [001 001 001 001 001 001 001 001 001 001 001 001 001 001 001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb48x3x1">
            <summary>
            [001 001 001 001 001 001 001 001 001 001 001 001 001 001 001 001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb51x3x1">
            <summary>
            [001 001 001 001 001 001 001 001 001 001 001 001 001 001 001 001 001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb54x3x1">
            <summary>
            [001 001 001 001 001 001 001 001 001 001 001 001 001 001 001 001 001 001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb57x3x1">
            <summary>
            [001 001 001 001 001 001 001 001 001 001 001 001 001 001 001 001 001 001 001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb60x3x1">
            <summary>
            [001 001 001 001 001 001 001 001 001 001 001 001 001 001 001 001 001 001 001 001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb63x3x1">
            <summary>
            [001 001 001 001 001 001 001 001 001 001 001 001 001 001 001 001 001 001 001 001 001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb4x4x1">
            <summary>
            [0001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb8x4x1">
            <summary>
            [0001 0001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb12x4x1">
            <summary>
            [0001 0001 0001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb16x4x1">
            <summary>
            [0001 0001 0001 0001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb32x4x1">
            <summary>
            [0001_0001 0001_0001 0001_0001 0001_0001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb64x4x1">
            <summary>
            [00010001 00010001 00010001 00010001 00010001 00010001 00010001 00010001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb5x5x1">
            <summary>
            [00001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb10x5x1">
            <summary>
            [00001 00001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb6x6x1">
            <summary>
            [000001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb12x6x1">
            <summary>
            [000001 000001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb18x6x1">
            <summary>
            [000001 000001 000001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb7x7x1">
            <summary>
            [0000001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb14x7x1">
            <summary>
            [0000001 0000001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb8x1x1">
            <summary>
            0x01 = [00000001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb16x8x1">
            <summary>
            0x0101 = [00000001 00000001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb24x8x1">
            <summary>
            0x010101 = [00000001 00000001 00000001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb32x8x1">
            <summary>
            0x01010101 = [00000001 00000001 00000001 00000001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb64x8x1">
            <summary>
            0x0101010101010101 = [00000001 00000001 00000001 00000001 00000001 00000001 00000001 00000001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb16x16x1">
            <summary>
            [00000000 00000001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb32x16x1">
            <summary>
            [00000000 00000001 00000000 00000001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb64x16x1">
            <summary>
            [00000000 00000001 00000000 00000001 00000000 00000001 00000000 00000001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb32x32x1">
            <summary>
            [00000000 00000000 00000000 00000001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb64x32x1">
            <summary>
            [00000000 00000000 00000000 00000001 00000000 00000000 00000000 00000001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb64x64x1">
            <summary>
            [00000000 00000000 00000000 0000000 00000000 00000000 00000000 0000001]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb8x8x2">
            <summary>
            [00000011]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb16x8x2">
            <summary>
            [00000011 00000011]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb32x8x2">
            <summary>
            [00000011 00000011 00000011 00000011]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb64x8x2">
            <summary>
            [00000011 00000011 00000011 00000011 00000011 00000011 00000011 00000011]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb8x8x3">
            <summary>
            [00000111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb16x8x3">
            <summary>
            [00000111 00000111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb32x8x3">
            <summary>
            [00000111 00000111 00000111 00000111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb64x8x3">
            <summary>
            [00000111 00000111 00000111 00000111 00000111 00000111 00000111 00000111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb8x8x4">
            <summary>
            0x0f = [00001111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb16x8x4">
            <summary>
            0x0f0f = [00001111 00001111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb32x8x4">
            <summary>
            0x0f0f0f0f = [00001111 ... 00001111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb64x8x4">
            <summary>
            0x0f0f0f0f0f0f0f0f = [00001111 ... 00001111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb8x8x5">
            <summary>
            [00011111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb16x8x5">
            <summary>
            [00011111 00011111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb24x8x5">
            <summary>
            [00011111 00011111 00011111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb32x8x5">
            <summary>
            [00011111 00011111 00011111 00011111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb40x8x5">
            <summary>
            [00011111 00011111 00011111 00011111 00011111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb64x8x5">
            <summary>
            [00011111 00011111 00011111 00011111 00011111 00011111 00011111 00011111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb8x8x6">
            <summary>
            [00111111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb16x8x6">
            <summary>
            [00111111 00111111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb32x8x6">
            <summary>
            [00111111 00111111 00111111 00111111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb64x8x6">
            <summary>
            [00111111 00111111 00111111 00111111 00111111 00111111 00111111 00111111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb8x8x7">
            <summary>
            [01111111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb16x8x7">
            <summary>
            [01111111 01111111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb32x8x7">
            <summary>
            [01111111 01111111 01111111 01111111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb64x8x7">
            <summary>
            [01111111 01111111 01111111 01111111 01111111 01111111 01111111 01111111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb16x16x3">
            <summary>
            [00000000 00000111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb32x16x3">
            <summary>
            [00000000 00000111 00000000 00000111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb16x16x15">
            <summary>
            [01111111 11111111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb64x15">
            <summary>
            [1111111 11111111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Lsb64x16">
            <summary>
            [11111111 11111111]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb8x8x1">
            <summary>
            [10000000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb16x8x1">
            <summary>
            [10000000 10000000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb32x8x1">
            <summary>
            [10000000 10000000 10000000 10000000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb64x8x1">
            <summary>
            [10000000 10000000 10000000 10000000 10000000 10000000 10000000 10000000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb16x16x1">
            <summary>
            [10000000 00000000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb32x16x1">
            <summary>
            [10000000 00000000 10000000 00000000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb64x16x1">
            <summary>
            [10000000 00000000 10000000 00000000 10000000 00000000 10000000 00000000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb4x2x1">
            <summary>
            [1010]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb6x2x1">
            <summary>
            [010101]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb8x2x1">
            <summary>
            [10101010]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb10x2x1">
            <summary>
            [10 10101010]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb12x2x1">
            <summary>
            [1010 10101010]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb14x2x1">
            <summary>
            [101010 10101010]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb16x2x1">
            <summary>
            [10101010 10101010]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb18x2x1">
            <summary>
            [10 10101010 10101010]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb32x2x1">
            <summary>
            [10101010 10101010 10101010 10101010]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb64x2x1">
            <summary>
            [10101010 10101010 10101010 10101010 10101010 10101010 10101010 10101010]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb3x1x1">
            <summary>
            [0b100]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb6x3x1">
            <summary>
            [0b100_100]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb9x3x1">
            <summary>
            [0b100_100_100]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb12x3x1">
            <summary>
            [0b100_100_100_100]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb15x3x1">
            <summary>
            [0b100_100_100_100_100]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb18x3x1">
            <summary>
            [0b100_100_100_100_100_100]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb21x3x1">
            <summary>
            [0b100_100_100_100_100_100_100]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb8x4x1">
            <summary>
            [10001000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb16x4x1">
            <summary>
            [10001000 10001000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb32x4x1">
            <summary>
            [10001000 10001000 10001000 10001000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb64x4x1">
            <summary>
            [10001000 10001000 10001000 10001000 10001000 10001000 10001000 10001000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb32x32x1">
            <summary>
            [10000000 00000000 00000000 0000000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb64x32x1">
            <summary>
            [10000000 00000000 00000000 0000000 10000000 00000000 00000000 0000000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb64x64x1">
            <summary>
            [10000000 00000000 00000000 0000000 00000000 00000000 00000000 0000000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb8x8x2">
            <summary>
            [11000000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb16x8x2">
            <summary>
            [11000000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb32x8x2">
            <summary>
            [11000000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb64x8x2">
            <summary>
            [11000000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb8x8x3">
            <summary>
            [11100000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb16x8x3">
            <summary>
            [11100000 11100000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb32x8x3">
            <summary>
            [11100000 11100000 11100000 11100000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb64x8x3">
            <summary>
            [11100000 11100000 11100000 11100000 11100000 11100000 11100000 11100000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb8x8x4">
            <summary>
            [11110000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb16x8x4">
            <summary>
            [11110000 11110000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb32x8x4">
            <summary>
            [11110000 11110000 11110000 11110000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb64x8x4">
            <summary>
            [11110000 11110000 11110000 11110000 11110000 11110000 11110000 11110000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb8x8x5">
            <summary>
            [11111000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb16x8x5">
            <summary>
            [11111000 11111000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb32x8x5">
            <summary>
            [11111000 11111000 11111000 11111000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb64x8x5">
            <summary>
            [11111000 11111000 11111000 11111000 11111000 11111000 11111000 11111000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb8x8x6">
            <summary>
            [11111100]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb16x8x6">
            <summary>
            [11111100 11111100]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb32x8x6">
            <summary>
            [11111100 11111100 11111100 11111100]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb64x8x6">
            <summary>
            [11111100 11111100 11111100 11111100 11111100 11111100 11111100 11111100]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb8x8x7">
            <summary>
            [11111110]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb16x8x7">
            <summary>
            [11111110 11111110]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb32x8x7">
            <summary>
            [11111110 11111110 11111110 11111110]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb64x8x7">
            <summary>
            [11111110 11111110 11111110 11111110 11111110 11111110 11111110 11111110]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb4x1x2">
            <summary>
            [0b1100]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb8x2x2">
            <summary>
            [11001100]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Msb12x3x2">
            <summary>
            [0b1100_1100_1100]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Even8">
            <summary>
            0x55 = [01010101]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Even16">
            <summary>
            0x5555 = [01010101 01010101]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Even32">
            <summary>
            0x55555555 = [01010101 01010101 01010101 01010101]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Even64">
            <summary>
            0x5555555555555555 = [01010101 01010101 01010101 01010101 01010101 01010101 01010101 01010101]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Even8x2">
            <summary>
            0x33 = [00110011]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Even16x2">
            <summary>
            0x3333 = [00110011 00110011]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Even32x2">
            <summary>
            0x33333333 = [00110011 00110011 00110011 00110011]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Even64x2">
            <summary>
            0x3333333333333333 = [00110011 00110011 00110011 00110011 00110011 00110011 00110011 00110011]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Odd8">
            <summary>
            [10101010]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Odd16">
            <summary>
            [10101010 10101010]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Odd32">
            <summary>
            [10101010 10101010 10101010 10101010]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Odd64">
            <summary>
            [10101010 10101010 10101010 10101010 10101010 10101010 10101010 10101010]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Odd8x2">
            <summary>
            [11001100]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Odd16x2">
            <summary>
            [11001100 11001100]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Odd32x2">
            <summary>
            [11001100 11001100 11001100 11001100]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.Odd64x2">
            <summary>
            [11001100 11001100 11001100 11001100 11001100 11001100 11001100 11001100]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.SignMask8">
            <summary>
            [10000000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.SignMask16">
            <summary>
            [10000000 00000000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.SignMask32">
            <summary>
            [10000000 00000000 00000000 00000000]
            </summary>
        </member>
        <member name="F:Z0.BitMasks.Literals.SignMask64">
            <summary>
            [10000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000]
            </summary>
        </member>
        <member name="T:Z0.BitMasks.Bp16">
            <summary>
            Defines a bit pattern set with members of bit-width <see cref='T:Z0.W16'/>
            </summary>
        </member>
        <member name="T:Z0.BitMasks.Bp32">
            <summary>
            Defines a bit pattern set with members of bit-width <see cref='T:Z0.W32'/>
            </summary>
        </member>
        <member name="T:Z0.BitMasks.Bp64">
            <summary>
            Defines a bit pattern set with members of bit-width <see cref='T:Z0.W64'/>
            </summary>
        </member>
        <member name="T:Z0.BitMasks.Bp8">
            <summary>
            Defines a bit pattern set with members of bit-width <see cref='T:Z0.W8'/>
            </summary>
        </member>
        <member name="M:Z0.BitMasks.alteven``1">
            <summary>
            Defines an alternating bit pattern 10 10...10
            </summary>
            <typeparam name="T">The primal unsigned type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.altodd``1">
            <summary>
            Defines an alternating bit pattern 01 01...01
            </summary>
            <typeparam name="T">The primal unsigned type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.pindex(System.Byte,System.Byte)">
            <summary>
            Defines a parity index j from a source integer i and a parity bit p, j := i*2 + p
            </summary>
            <param name="i">The source integer</param>
            <param name="p">The parity bit</param>
        </member>
        <member name="M:Z0.BitMasks.blsic(System.Byte)">
            <summary>
            Isolate least set bit and complement, computed by dst := ~src | (src - 1),
            where all bits in the target are set except for the least set bit in the source
            For example, [11101010] |> blisc = [11111101]
            </summary>
            <param name="src">The source vale</param>
        </member>
        <member name="M:Z0.BitMasks.blsic(System.UInt16)">
            <summary>
            Isolate least set bit and complement, computed by dst := ~src | (src - 1),
            where all bits in the target are set except for the least set bit in the source
            For example, [11101010] |> blisc = [11111101]
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.BitMasks.blsic(System.UInt32)">
            <summary>
            Isolate least set bit and complement, computed by dst := ~src | (src - 1),
            where all bits in the target are set except for the least set bit in the source
            For example, [11101010] |> blisc = [11111101]
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.BitMasks.blsic(System.UInt64)">
            <summary>
            Isolate least set bit and complement, computed by dst := ~src | (src - 1),
            where all bits in the target are set except for the least set bit in the source
            For example, [11101010] |> blisc = [11111101]
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.BitMasks.central``2(Z0.N8,``0,``1)">
            <summary>
            Defines a central bitmask over 8-bit segments with a parametric bit density
            D:[N2 | N4 | N6]
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="t">A mask type representative</param>
            <typeparam name="D">The bit density type</typeparam>
            <typeparam name="T">The primal mask type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.central``1(Z0.N8,Z0.N2,``0)">
            <summary>
            [00011000]
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A mask type representative</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.central``1(Z0.N8,Z0.N4,``0)">
            <summary>
            [00111100]
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A mask type representative</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.central``1(Z0.N8,Z0.N6,``0)">
            <summary>
            [01111110]
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A mask type representative</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.mask``2(Z0.CentralMask{Z0.N8,``0,``1})">
            <summary>
            [00011000]
            </summary>
            <param name="spec">The mask spec</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.cjsb``1(Z0.N8,Z0.N2,Z0.N1,``0)">
            <summary>
            [10011001]
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="cd">The central bit density</param>
            <param name="jsbd">The jsb bit density</param>
            <param name="t">The mask type representative</param>
            <typeparam name="T">The mask data type</typeparam>
            <remarks>CJSB := jsb | csb (8x2x1)</remarks>
        </member>
        <member name="M:Z0.BitMasks.cjsb``1(Z0.N8,Z0.N2,Z0.N2,``0)">
            <summary>
            [11011011]
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="cd">The central bit density</param>
            <param name="jsbd">The jsb bit density</param>
            <param name="t">The mask type representative</param>
            <typeparam name="T">The mask data type</typeparam>
            <remarks>CJSB := jsb | csb (8x2x2)</remarks>
        </member>
        <member name="M:Z0.BitMasks.cjsb``1(Z0.N8,Z0.N4,Z0.N1,``0)">
            <summary>
            [10111101]
            </summary>
            <param name="f">The frequency selector</param>
            <param name="cd">The central bit density</param>
            <param name="t">The mask type representative</param>
            <typeparam name="T">The mask data type</typeparam>
            <remarks>CJSB := jsb | csb (8x4x1)</remarks>
        </member>
        <member name="M:Z0.BitMasks.extract(System.SByte,System.Byte,System.Byte)">
            <summary>
            Extracts a contiguous range of bits from the source inclusively between two index positions
            </summary>
            <param name="src">The source value</param>
            <param name="k0">The bit position within the source where extraction should begin</param>
            <param name="k1">The bit position within the source where extraction should end</param>
        </member>
        <member name="M:Z0.BitMasks.extract(System.Byte,System.Byte,System.Byte)">
            <summary>
            Extracts a contiguous range of bits from the source inclusively between two index positions
            </summary>
            <param name="src">The source value</param>
            <param name="k0">The bit position within the source where extraction should begin</param>
            <param name="k1">The bit position within the source where extraction should end</param>
        </member>
        <member name="M:Z0.BitMasks.extract(System.Int16,System.Byte,System.Byte)">
            <summary>
            Extracts a contiguous range of bits from the source inclusively between two index positions
            </summary>
            <param name="src">The source value</param>
            <param name="k0">The bit position within the source where extraction should begin</param>
            <param name="k1">The bit position within the source where extraction should end</param>
        </member>
        <member name="M:Z0.BitMasks.extract(System.UInt16,System.Byte,System.Byte)">
            <summary>
            Extracts a contiguous range of bits from the source inclusively between two index positions
            </summary>
            <param name="src">The source value</param>
            <param name="k0">The bit position within the source where extraction should begin</param>
            <param name="k1">The bit position within the source where extraction should end</param>
        </member>
        <member name="M:Z0.BitMasks.extract(System.UInt32,System.Byte,System.Byte)">
            <summary>
            Extracts a contiguous range of bits from the source inclusively between two index positions
            </summary>
            <param name="src">The source value</param>
            <param name="k0">The bit position within the source where extraction should begin</param>
            <param name="k1">The bit position within the source where extraction should end</param>
        </member>
        <member name="M:Z0.BitMasks.extract(System.Int32,System.Byte,System.Byte)">
            <summary>
            Extracts a contiguous range of bits from the source inclusively between two index positions
            </summary>
            <param name="src">The source value</param>
            <param name="k0">The bit position within the source where extraction should begin</param>
            <param name="k1">The bit position within the source where extraction should end</param>
        </member>
        <member name="M:Z0.BitMasks.extract(System.UInt64,System.Byte,System.Byte)">
            <summary>
            Extracts a contiguous range of bits from the source inclusively between two index positions
            </summary>
            <param name="src">The source value</param>
            <param name="k0">The bit position within the source where extraction should begin</param>
            <param name="k1">The bit position within the source where extraction should end</param>
        </member>
        <member name="M:Z0.BitMasks.extract(System.Int64,System.Byte,System.Byte)">
            <summary>
            Extracts a contiguous range of bits from the source inclusively between two index positions
            </summary>
            <param name="src">The source value</param>
            <param name="k0">The bit position within the source where extraction should begin</param>
            <param name="k1">The bit position within the source where extraction should end</param>
        </member>
        <member name="M:Z0.BitMasks.extract(System.Single,System.Byte,System.Byte)">
            <summary>
            Extracts a contiguous range of bits from the source inclusively between two index positions
            </summary>
            <param name="src">The source value</param>
            <param name="k0">The bit position within the source where extraction should begin</param>
            <param name="k1">The bit position within the source where extraction should end</param>
        </member>
        <member name="M:Z0.BitMasks.extract(System.Double,System.Byte,System.Byte)">
            <summary>
            Extracts a contiguous range of bits from the source inclusively between two index positions
            </summary>
            <param name="src">The source value</param>
            <param name="k0">The bit position within the source where extraction should begin</param>
            <param name="k1">The bit position within the source where extraction should end</param>
        </member>
        <member name="M:Z0.BitMasks.gather(System.Byte,System.Byte)">
            <summary>
            unsigned int _pext_u32 (unsigned int a, unsigned int mask) PEXT r32a, r32b, reg/m32
            Copies mask-identified source bits to contiguous low bits in the returned target
            </summary>
            <param name="src">The source value</param>
            <param name="mask">The mask that defines the bits to select</param>
        </member>
        <member name="M:Z0.BitMasks.gather(System.UInt16,System.UInt16)">
            <summary>
            unsigned int _pext_u32 (unsigned int a, unsigned int mask) PEXT r32a, r32b, reg/m32
            Copies mask-identified source bits to contiguous low bits in the returned target
            </summary>
            <param name="src">The source value</param>
            <param name="mask">The mask that defines the bits to select</param>
        </member>
        <member name="M:Z0.BitMasks.gather(System.UInt32,System.UInt32)">
            <summary>
            unsigned int _pext_u32 (unsigned int a, unsigned int mask) PEXT r32a, r32b, reg/m32
            Copies mask-identified source bits to contiguous low bits in the returned target
            </summary>
            <param name="src">The source value</param>
            <param name="mask">The mask that defines the bits to select</param>
        </member>
        <member name="M:Z0.BitMasks.gather(System.UInt64,System.UInt64)">
            <summary>
            __int64 _pext_u64 (unsigned __int64 a, unsigned __int64 mask) PEXT r64a, r64b, reg/m64
            Copies mask-identified source bits to contiguous low bits in the returned target
            </summary>
            <param name="src">The source value</param>
            <param name="mask">The mask that defines the bits to select</param>
        </member>
        <member name="M:Z0.BitMasks.hi64(System.Int32)">
            <summary>
            Produces a sequence of enabled hi bits
            </summary>
            <param name="n">The number of bits to enable</param>
        </member>
        <member name="M:Z0.BitMasks.hi64(System.Byte)">
            <summary>
            Produces a sequence of enabled hi bits
            </summary>
            <param name="n">The number of bits to enable</param>
        </member>
        <member name="M:Z0.BitMasks.hi``1(System.Int32,``0)">
            <summary>
            Produces a sequence of n enabled bits in the index range [bitsize[T] - n, bitsize[T] - 1]
            </summary>
            <param name="n">The number of bits to enable</param>
            <param name="t">A mask type representative</param>
            <typeparam name="T">The mask type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.hi``1(``0)">
            <summary>
            Produces a sequence of N enabled hi bits
            </summary>
            <param name="n">The number of bits to enable</param>
            <typeparam name="N">The bit count type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.hi``2(``0,``1)">
            <summary>
            Produces a sequence of n enabled hi bits
            </summary>
            <param name="n">The number of bits to enable</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.jsb``1(Z0.N8,Z0.N1,``0)">
            <summary>
            [10000001] | JSB := (msb | lsb)(f,d) where f := 8 and d := 1
            </summary>
            <param name="f">The frequency selector</param>
            <param name="d">The bit density</param>
            <param name="t">A mask type representative</param>
            <typeparam name="T">The mask data type</typeparam>
            <remarks>JSB := msb | lsb (8x1)</remarks>
        </member>
        <member name="M:Z0.BitMasks.jsb``1(Z0.N8,Z0.N2,``0)">
            <summary>
            [11000011] | JSB := (msb | lsb)(f,d) where f := 8 and d := 2
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A mask type representative</param>
            <typeparam name="T">The mask data type</typeparam>
            <remarks>JSB := msb | lsb (8x2)</remarks>
        </member>
        <member name="M:Z0.BitMasks.jsb``1(Z0.N8,Z0.N3,``0)">
            <summary>
            [11100111] | JSB := (msb | lsb)(f,d) where f := 3 and d := 3
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A mask type representative</param>
            <typeparam name="T">The mask data type</typeparam>
            <remarks>JSB := msb | lsb (8x3)</remarks>
        </member>
        <member name="M:Z0.BitMasks.mask``1(Z0.JsbMask{Z0.N8,Z0.N1,``0})">
            <summary>
            [10000001]
            </summary>
            <param name="spec">The mask spec</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.mask``1(Z0.JsbMask{Z0.N8,Z0.N2,``0})">
            <summary>
            [11000011]
            </summary>
            <param name="spec">The mask spec</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.mask``1(Z0.JsbMask{Z0.N8,Z0.N3,``0})">
            <summary>
            [11100111]
            </summary>
            <param name="spec">The mask spec</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.lo64(System.Int32)">
            <summary>
            Produces a sequence of n enabled bits, starting from index 0 and extending to index n - 1
            </summary>
            <typeparam name="N">The enabled bit count type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.lo``1(System.Int32,``0)">
            <summary>
            Produces a sequence of N enabled bits, starting from index 0 and extending to index n - 1
            </summary>
        </member>
        <member name="M:Z0.BitMasks.lo``1(``0)">
            <summary>
            Produces a sequence of N enabled bits, starting from index 0 and extending to index n - 1
            </summary>
            <param name="n">The bit count type representative</param>
            <typeparam name="N">The enabled bit count type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.lo``2(``0,``1)">
            <summary>
            Produces a sequence of N enabled bits, starting from index 0 and extending to index n - 1
            </summary>
            <param name="n">The number of bits to enable</param>
            <param name="t">A mask type representative</param>
            <typeparam name="N">The enabled bit count type</typeparam>
            <typeparam name="T">The mask type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.lsb64(Z0.N16,Z0.N1)">
            <summary>
            [00000000 00000001]
            The least bit of each 16-bit segment is enabled
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.lsb(Z0.N32,Z0.N1,System.UInt32)">
            <summary>
            [00000000 00000000 00000000 0000001]
            The least bit is enabled
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A mask data type representative</param>
        </member>
        <member name="M:Z0.BitMasks.lsb64(Z0.N32,Z0.N1,System.UInt64)">
            <summary>
            [00000000 00000000 00000000 0000001]
            The least bit of each 32-bit segment is enabled
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A mask data type representative</param>
        </member>
        <member name="M:Z0.BitMasks.lsb``2(``0,Z0.N2,Z0.N1,``1)">
            <summary>
            [01 01 ... 01]
            Defines a width-variant LSB pattern that repeats every 2 bits with density 1
            </summary>
            <param name="w">The pattern width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A mask type representative</param>
            <typeparam name="N">The width type</typeparam>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.lsb``2(``0,Z0.N3,Z0.N1,``1)">
            <summary>
            [001 001 ... 001]
            Defines a width-variant LSB pattern that repeats every 3 bits with density 1
            </summary>
            <param name="w">The pattern width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A mask type representative</param>
            <typeparam name="N">The width type</typeparam>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.lsb``1(Z0.N1,Z0.N1,``0)">
            <summary>
            [00....01]
            The least bit, relative to the data type, is enabled
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A mask type representative</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.lsb``1(Z0.N2,Z0.N1,``0)">
            <summary>
            [01]
            The least bit of each 2-bit segment is enabled
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A mask type representative</param>
            <typeparam name="T">The mask data type</typeparam>
            <remarks>Creates a mask where the least significant bit out of each two bits is enabled</remarks>
        </member>
        <member name="M:Z0.BitMasks.lsb``1(Z0.N4,Z0.N1,``0)">
            <summary>
            [0001]
            The least bit of each 4-bit segment is enabled
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A mask type representative</param>
            <typeparam name="T">The mask data type</typeparam>
            <remarks>Creates a mask where the least significant bit out of each four bits is enabled</remarks>
        </member>
        <member name="M:Z0.BitMasks.lsb``1(Z0.N8,Z0.N1,``0)">
            <summary>
            [00000001]
            The least bit of each 8-bit segment is enabled
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A mask type representative</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.lsb``1(Z0.N16,Z0.N1,``0)">
            <summary>
            [00000000 00000001]
            The least bit of each 16-bit segment is enabled
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A mask type representative</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.lsb``1(Z0.N8,Z0.N2,``0)">
            <summary>
            [00000011]
            The least 2 bits of each 8-bits are enabled
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.lsb``1(Z0.N8,Z0.N3,``0)">
            <summary>
            [00000111]
            The least 3 bits of each 8-bits are enabled
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.lsb``1(Z0.N8,Z0.N4,``0)">
            <summary>
            [00001111]
            The least 4 bits of each 8-bits are enabled
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.lsb``1(Z0.N8,Z0.N5,``0)">
            <summary>
            [00011111]
            The least 5 bits of each 8-bits are enabled
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.lsb``1(Z0.N8,Z0.N6,``0)">
            <summary>
            [00111111]
            The least 6 bits of each 8-bits are enabled
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.lsb``1(Z0.N8,Z0.N7,``0)">
            <summary>
            [01111111]
            The least 7 bits of each 8-bits are enabled
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.mask``1(Z0.LsbMask{Z0.N1,Z0.N1,``0})">
            <summary>
            [00000001]
            </summary>
            <param name="spec">The mask spec</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.mask``1(Z0.LsbMask{Z0.N2,Z0.N1,``0})">
            <summary>
            [01]
            </summary>
            <param name="spec">The mask spec</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.mask``1(Z0.LsbMask{Z0.N4,Z0.N1,``0})">
            <summary>
            [0001]
            The least bit of each 4-bit segment is enabled
            </summary>
            <param name="spec">The mask spec</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.mask``1(Z0.LsbMask{Z0.N8,Z0.N1,``0})">
            <summary>
            [00000001]
            The least bit of each 8-bit segment is enabled
            </summary>
            <param name="spec">The mask spec</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.mask``1(Z0.LsbMask{Z0.N16,Z0.N1,``0})">
            <summary>
            [00000000 00000001]
            The least bit of each 16-bit segment is enabled
            </summary>
            <param name="spec">The mask spec</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.mask``1(Z0.LsbMask{Z0.N8,Z0.N2,``0})">
            <summary>
            [00000011]
            </summary>
            <param name="spec">The mask spec</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.mask``1(Z0.LsbMask{Z0.N8,Z0.N3,``0})">
            <summary>
            [000000111]
            </summary>
            <param name="spec">The mask spec</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.mask``1(Z0.LsbMask{Z0.N8,Z0.N4,``0})">
            <summary>
            [00000111]
            </summary>
            <param name="spec">The mask spec</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.mask``1(Z0.LsbMask{Z0.N8,Z0.N5,``0})">
            <summary>
            [00011111]
            </summary>
            <param name="spec">The mask spec</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.mask``1(Z0.LsbMask{Z0.N8,Z0.N6,``0})">
            <summary>
            [00111111]
            </summary>
            <param name="spec">The mask spec</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.mask``1(Z0.LsbMask{Z0.N8,Z0.N7,``0})">
            <summary>
            [01111111]
            </summary>
            <param name="spec">The mask spec</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.mix(Z0.N0,System.Byte,System.Byte)">
            <summary>
            Blends alternating even operand bits
            </summary>
            <param name="parity">The parity selector</param>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.BitMasks.mix(Z0.N1,System.Byte,System.Byte)">
            <summary>
            Blends alternating odd operand bits
            </summary>
            <param name="parity">The parity selector</param>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.BitMasks.mix(Z0.N0,System.UInt16,System.UInt16)">
            <summary>
            Blends alternating even operand bits
            </summary>
            <param name="parity">The parity selector</param>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.BitMasks.mix(Z0.N1,System.UInt16,System.UInt16)">
            <summary>
            Blends alternating odd operand bits
            </summary>
            <param name="parity">The parity selector</param>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.BitMasks.mix(Z0.N0,System.UInt32,System.UInt32)">
            <summary>
            Blends alternating even operand bits
            </summary>
            <param name="parity">The parity selector</param>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.BitMasks.mix(Z0.N1,System.UInt32,System.UInt32)">
            <summary>
            Blends alternating odd operand bits
            </summary>
            <param name="parity">The parity selector</param>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.BitMasks.mix(Z0.N0,System.UInt64,System.UInt64)">
            <summary>
            Blends alternating even operand bits
            </summary>
            <param name="parity">The parity selector</param>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.BitMasks.mix(Z0.N1,System.UInt64,System.UInt64)">
            <summary>
            Blends alternating odd operand bits
            </summary>
            <param name="parity">The parity selector</param>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.BitMasks.mix(System.Byte,System.Byte,System.Byte)">
            <summary>
            Blends alternating operand bits
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
            <param name="parity">The parity selector</param>
        </member>
        <member name="M:Z0.BitMasks.mix(System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Blends alternating operand bits
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
            <param name="parity">The parity selector</param>
        </member>
        <member name="M:Z0.BitMasks.mix(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Blends alternating operand bits
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
            <param name="parity">The parity selector</param>
        </member>
        <member name="M:Z0.BitMasks.mix(System.UInt64,System.UInt64,System.UInt64)">
            <summary>
            Blends alternating operand bits
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
            <param name="parity">The parity selector</param>
        </member>
        <member name="M:Z0.BitMasks.msb(Z0.N64,Z0.N16,Z0.N1)">
            <summary>
            [10000000 00000000]
            The greatest bit of each 16-bit segment over 64 bits of data is enabled
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
        </member>
        <member name="M:Z0.BitMasks.msb64(Z0.N64,Z0.N32,Z0.N1)">
            <summary>
            [10000000 00000000 00000000 0000000]
            The greatest bit of each 32-bit segment over 64 bits of data is enabled
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.msb``1(Z0.N1,Z0.N1,``0)">
            <summary>
            [1000...0000]
            The greatest bit, relative to the data type, is enabled
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A mask data type representative</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.msb``1(Z0.N2,Z0.N1,``0)">
            <summary>
            [10]
            The greatest bit of each 2-bit segment is enabled
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.msb``1(Z0.N4,Z0.N1,``0)">
            <summary>
            [1000]
            The greatest bit of each 4-bit segment is enabled
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.msb``1(Z0.N8,Z0.N1,``0)">
            <summary>
            [10000000]
            The greatest bit of each 8-bit segment is enabled
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.msb``1(Z0.N16,Z0.N1,``0)">
            <summary>
            [10000000 00000000]
            The greatest bit of each 16-bit segment is enabled
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.msb``1(Z0.N8,Z0.N2,``0)">
            <summary>
            [11000000]
            The greatest 2 bits of each 8-bit segment are enabled
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.msb``1(Z0.N8,Z0.N3,``0)">
            <summary>
            [11100000]
            The greatest 3 bits of each 8-bit segment are enabled
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.msb``1(Z0.N8,Z0.N4,``0)">
            <summary>
            [11110000]
            The greatest 4 bits of each 8-bit segment are enabled
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.msb``1(Z0.N8,Z0.N5,``0)">
            <summary>
            [11111000]
            The greatest 5 bits of each 8-bit segment are enabled
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.msb``1(Z0.N8,Z0.N6,``0)">
            <summary>
            [11111100]
            The greatest 6 bits of each 8-bit segment are enabled
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.msb``1(Z0.N8,Z0.N7,``0)">
            <summary>
            [11111110]
            The greatest 7 bits of each 8-bit segment are enabled
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A mask type representative</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.mask``1(Z0.MsbMask{Z0.N2,Z0.N1,``0})">
            <summary>
            [10]
            </summary>
            <param name="spec">The mask spec</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.mask``1(Z0.MsbMask{Z0.N4,Z0.N1,``0})">
            <summary>
            [10001000]
            </summary>
            <param name="spec">The mask spec</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.mask``1(Z0.MsbMask{Z0.N8,Z0.N1,``0})">
            <summary>
            [10000000]
            </summary>
            <param name="spec">The mask spec</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.mask``1(Z0.MsbMask{Z0.N16,Z0.N1,``0})">
            <summary>
            [10000000 00000000]
            </summary>
            <param name="spec">The mask spec</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.mask``1(Z0.MsbMask{Z0.N8,Z0.N2,``0})">
            <summary>
            [11000000]
            </summary>
            <param name="spec">The mask spec</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.mask``1(Z0.MsbMask{Z0.N8,Z0.N3,``0})">
            <summary>
            [11100000]
            </summary>
            <param name="spec">The mask spec</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.mask``1(Z0.MsbMask{Z0.N8,Z0.N4,``0})">
            <summary>
            [11110000]
            </summary>
            <param name="spec">The mask spec</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.mask``1(Z0.MsbMask{Z0.N8,Z0.N5,``0})">
            <summary>
            [11111000]
            </summary>
            <param name="spec">The mask spec</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.mask``1(Z0.MsbMask{Z0.N8,Z0.N6,``0})">
            <summary>
            [11111100]
            </summary>
            <param name="spec">The mask spec</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.mask``1(Z0.MsbMask{Z0.N8,Z0.N7,``0})">
            <summary>
            [11111110]
            </summary>
            <param name="spec">The mask spec</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.nlz(System.Byte)">
            <summary>
            Counts the number of leading zero bits in the source
            </summary>
            <param name="src">The bit source</param>
        </member>
        <member name="M:Z0.BitMasks.nlz(System.UInt16)">
            <summary>
            Counts the number of leading zero bits in the source
            </summary>
            <param name="src">The bit source</param>
        </member>
        <member name="M:Z0.BitMasks.nlz(System.UInt32)">
            <summary>
            _lzcnt_u32
            Counts the number of 0 bits prior to the first most significant 1 bit
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.BitMasks.nlz(System.UInt64)">
            <summary>
            _lzcnt_u64:
            Counts the number of 0 bits prior to the first most significant 1 bit
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.BitMasks.even``1(Z0.N2,Z0.N1,``0)">
            <summary>
            [01010101]
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A mask type representative</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.even``1(Z0.N2,Z0.N2,``0)">
            <summary>
            [00110011]
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A mask type representative</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.odd``1(Z0.N2,Z0.N1)">
            <summary>
            [10101010]
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A mask type representative</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.odd``1(Z0.N2,Z0.N2)">
            <summary>
            [11001100]
            </summary>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A mask type representative</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.mask``1(Z0.ParityMask{Z0.N2,Z0.N1,``0}@,Z0.N0)">
            <summary>
            [01010101]
            </summary>
        </member>
        <member name="M:Z0.BitMasks.mask``1(Z0.ParityMask{Z0.N2,Z0.N1,``0}@,Z0.N1)">
            <summary>
            [10101010]
            </summary>
            <param name="spec">The mask spec</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.mask``1(Z0.ParityMask{Z0.N2,Z0.N2,``0}@,Z0.N0)">
            <summary>
            [00110011]
            </summary>
        </member>
        <member name="M:Z0.BitMasks.mask``1(Z0.ParityMask{Z0.N2,Z0.N2,``0}@,Z0.N1)">
            <summary>
            [11001100]
            </summary>
            <param name="spec">The mask spec</param>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.scatter(System.Byte,System.Byte)">
            <summary>
            Deposits contiguous low bits from the source across a target according to a mask
            </summary>
            <param name="src">The source value</param>
            <param name="mask">The mask</param>
        </member>
        <member name="M:Z0.BitMasks.scatter(System.UInt16,System.UInt16)">
            <summary>
            Deposits contiguous low bits from the source across a target according to a mask
            </summary>
            <param name="src">The source value</param>
            <param name="mask">The mask</param>
        </member>
        <member name="M:Z0.BitMasks.scatter(System.UInt32,System.UInt32)">
            <summary>
            unsigned int _pdep_u32 (unsigned int a, unsigned int mask) PDEP r32a, r32b, reg/m32
            Deposits contiguous low bits from the source across a target according to a mask
            </summary>
            <param name="src">The source value</param>
            <param name="mask">The mask</param>
        </member>
        <member name="M:Z0.BitMasks.scatter(System.UInt64,System.UInt64)">
            <summary>
            unsigned __int64 _pdep_u64 (unsigned __int64 a, unsigned __int64 mask) PDEP r64a, r64b, reg/m64
            Deposits contiguous low bits from the source across a target according to a mask
            </summary>
            <param name="src">The source value</param>
            <param name="mask">The mask</param>
        </member>
        <member name="M:Z0.BitMasks.veven``3(Z0.N128,``0,``1,``2)">
            <summary>
            [01010101] | [00110011]
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A component type representative</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.veven``3(Z0.N256,``0,``1,``2)">
            <summary>
            [01010101] | [00110011]
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A component type representative</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.veven``1(Z0.N128,Z0.N2,Z0.N1,``0)">
            <summary>
            [01010101]
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A component type representative</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.veven``1(Z0.N256,Z0.N2,Z0.N1,``0)">
            <summary>
            [01010101]
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A component type representative</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.veven``1(Z0.N128,Z0.N2,Z0.N2,``0)">
            <summary>
            [00110011]
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A component type representative</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.veven``1(Z0.N256,Z0.N2,Z0.N2,``0)">
            <summary>
            [00110011]
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A component type representative</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vlsb``1(Z0.N128,Z0.N1,Z0.N1,``0)">
            <summary>
            [000...001]
            The least bit, relative to the component, is enabled
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A component type representative</param>
            <typeparam name="T">The component data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vlsb``1(Z0.N128,Z0.N2,Z0.N1,``0)">
            <summary>
            [01]
            The least bit of each 2-bit segment is enabled
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A component type representative</param>
            <typeparam name="T">The component data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vlsb``1(Z0.N128,Z0.N4,Z0.N1,``0)">
            <summary>
            [0001]
            The least bit of each 4-bit segment is enabled
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A component type representative</param>
            <typeparam name="T">The component data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vlsb``1(Z0.N128,Z0.N8,Z0.N1,``0)">
            <summary>
            [00000001]
            The least bit of each 8-bit segment is enabled
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A component type representative</param>
            <typeparam name="T">The component data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vlsb``1(Z0.N128,Z0.N16,Z0.N1,``0)">
            <summary>
            [00000000 00000001]
            The least bit of each 16-bit segment is enabled
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A component type representative</param>
            <typeparam name="T">The component data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vlsb``1(Z0.N128,Z0.N8,Z0.N2,``0)">
            <summary>
            [00000011]
            The least 2 bits of each 8-bits are enabled
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A component type representative</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vlsb``1(Z0.N128,Z0.N8,Z0.N3,``0)">
            <summary>
            [00000111]
            The least 3 bits of each 8-bits are enabled
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vlsb``1(Z0.N128,Z0.N8,Z0.N4,``0)">
            <summary>
            [00001111]
            The least 4 bits of each 8-bits are enabled
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A component type representative</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vlsb``1(Z0.N128,Z0.N8,Z0.N5,``0)">
            <summary>
            [00011111]
            The least 5 bits of each 8-bits are enabled
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A component type representative</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vlsb``1(Z0.N128,Z0.N8,Z0.N6,``0)">
            <summary>
            [00111111]
            The least 6 bits of each 8-bits are enabled
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A component type representative</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vlsb``1(Z0.N128,Z0.N8,Z0.N7,``0)">
            <summary>
            [01111111]
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <param name="t">A component type representative</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vlsb``1(Z0.N256,Z0.N1,Z0.N1,``0)">
            <summary>
            [00....01]
            The least bit of each component is enabled
            </summary>
            <param name="n">The repetition frequency</param>
            <typeparam name="T">The component data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vlsb``1(Z0.N256,Z0.N2,Z0.N1,``0)">
            <summary>
            [01]
            The least bit of each 2-bit segment is enabled
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <typeparam name="T">The component data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vlsb``1(Z0.N256,Z0.N4,Z0.N1,``0)">
            <summary>
            [00010001]
            The least bit of each 4-bit segment is enabled
            </summary>
            <param name="f">The repetition frequency</param>
            <typeparam name="T">The component data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vlsb``1(Z0.N256,Z0.N8,Z0.N1,``0)">
            <summary>
            [00000001]
            The least bit of each 8-bit segment is enabled
            </summary>
            <param name="f">The repetition frequency</param>
            <typeparam name="T">The component data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vlsb``1(Z0.N256,Z0.N16,Z0.N1,``0)">
            <summary>
            [00000000 00000001]
            The least significant bit out of each 16 bits is enabled
            </summary>
            <param name="f">The repetition frequency</param>
            <typeparam name="T">The component data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vlsb``1(Z0.N256,Z0.N8,Z0.N2,``0)">
            <summary>
            [00000011]
            The least significant 2 bits of each 8-bit segment are enabled
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vlsb``1(Z0.N256,Z0.N8,Z0.N3,``0)">
            <summary>
            [00000111]
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vlsb``1(Z0.N256,Z0.N8,Z0.N4,``0)">
            <summary>
            [00001111]
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vlsb``1(Z0.N256,Z0.N8,Z0.N5,``0)">
            <summary>
            [00011111]
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vlsb``1(Z0.N256,Z0.N8,Z0.N6,``0)">
            <summary>
            [00111111]
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vlsb``1(Z0.N256,Z0.N8,Z0.N7,``0)">
            <summary>
            [01111111]
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vlsb``1(Z0.N128,Z0.N8,System.Byte,``0)">
            <summary>
            The f least significant bits of each 8 bit segment are enabled
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">A value in the range [2,7] that defines the bit density</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vlsb``1(Z0.N256,Z0.N8,System.Byte,``0)">
            <summary>
            The f least significant bits of each 8 bit segment are enabled
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">A value in the range [2,7] that defines the bit density</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vmsb``1(Z0.N128,``0)">
            <summary>
            [100...000 ... 100...000]
            The greatest bit of each component is enabled
            </summary>
            <typeparam name="T">The component data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vmsb``1(Z0.N128,Z0.N2,Z0.N1,``0)">
            <summary>
            [01]
            The greatest bit of each 2-bit segment is enabled
            </summary>
            <param name="f">The repetition frequency</param>
            <typeparam name="T">The component data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vmsb``1(Z0.N128,Z0.N4,Z0.N1,``0)">
            <summary>
            [1000]
            The greatest bit of each 4-bit segment is enabled
            </summary>
            <param name="f">The repetition frequency</param>
            <typeparam name="T">The component data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vmsb``1(Z0.N128,Z0.N8,Z0.N1,``0)">
            <summary>
            [10000000]
            The greatest bit of each 8-bit segment is enabled
            </summary>
            <param name="f">The repetition frequency</param>
            <typeparam name="T">The component data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vmsb``1(Z0.N128,Z0.N16,Z0.N1,``0)">
            <summary>
            [10000000 00000000]
            The greatest bit of each 16-bit segment is enabled
            </summary>
            <param name="f">The repetition frequency</param>
            <typeparam name="T">The component data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vmsb``1(Z0.N128,Z0.N8,Z0.N2,``0)">
            <summary>
            [11000000]
            The 2 greatest bits of each 8-bit segment are enabled
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vmsb``1(Z0.N128,Z0.N8,Z0.N3,``0)">
            <summary>
            [11100000]
            The greatest 3 bits of each 8-bit segment are enabled
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vmsb``1(Z0.N128,Z0.N8,Z0.N4,``0)">
            <summary>
            [11110000]
            The greatest 4 bits of each 8-bit segment are enabled
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vmsb``1(Z0.N128,Z0.N8,Z0.N5,``0)">
            <summary>
            [11111000]
            The greatest 5 bits of each 8-bit segment are enabled
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vmsb``1(Z0.N128,Z0.N8,Z0.N6,``0)">
            <summary>
            [11111100]
            The greatest 6 bits of each 8-bit segment are enabled
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vmsb``1(Z0.N128,Z0.N8,Z0.N7,``0)">
            <summary>
            [11111110]
            The greatest 7 bits of each 8-bit segment are enabled
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vmsb``1(Z0.N128,Z0.N8,System.Byte,``0)">
            <summary>
            The f most significant bits of each 8 bits are enabled
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">A value in the range [2,7] that defines the bit density</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vmsb``1(Z0.N256,``0)">
            <summary>
            [100...00]
            The greatest bit of each component is enabled
            </summary>
            <param name="w">The target vector width</param>
            <typeparam name="T">The component data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vmsb``1(Z0.N256,Z0.N2,Z0.N1,``0)">
            <summary>
            [01
            The greatest bit of each 2-bit segment is enabled
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The component data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vmsb``1(Z0.N256,Z0.N4,Z0.N1,``0)">
            <summary>
            [1000]
            The greatest bit of each 4-bit segment is enabled
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The component data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vmsb``1(Z0.N256,Z0.N8,Z0.N1,``0)">
            <summary>
            [10000000]
            The greatest bit of each 8-bit segment is enabled
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The component data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vmsb``1(Z0.N256,Z0.N16,Z0.N1,``0)">
            <summary>
            [10000000 00000000]
            The greatest bit of each 16-bit segment is enabled
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The component data type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vmsb``1(Z0.N256,Z0.N8,Z0.N2,``0)">
            <summary>
            [11000000]
            The 2 greatest bits of each 8-bit segment are enabled
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vmsb``1(Z0.N256,Z0.N8,Z0.N3,``0)">
            <summary>
            [11100000]
            The 3 greatest bits of each 8-bit segment are enabled
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vmsb``1(Z0.N256,Z0.N8,Z0.N4,``0)">
            <summary>
            [11110000]
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vmsb``1(Z0.N256,Z0.N8,Z0.N5,``0)">
            <summary>
            [11111000]
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vmsb``1(Z0.N256,Z0.N8,Z0.N6,``0)">
            <summary>
            [11111100]
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vmsb``1(Z0.N256,Z0.N8,Z0.N7,``0)">
            <summary>
            [11111110]
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">The bit density</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.BitMasks.vmsb``1(Z0.N256,Z0.N8,System.Byte,``0)">
            <summary>
            Creates a mask where f most significant bits of each 8 bits are enabled
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">A value in the range [2,7] that defines the bit density</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.BitMasks.xlsb(System.Byte)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitMasks.xlsb(System.UInt16)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitMasks.xlsb(System.UInt32)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitMasks.xlsb(System.UInt64)" -->
        <member name="M:Z0.BitMasks.part4x3(System.UInt32,System.Byte@)">
            <summary>
            Partitions the first 12 bits of a 32-bit source value into 3 target segments each with an effective width of 4
            </summary>
            <param name="src">The source value</param>
            <param name="dst">A target span of sufficient length</param>
        </member>
        <member name="M:Z0.BitMasks.part4x4(System.UInt16,System.Byte@)">
            <summary>
            Partitions a 16-bit source value into 4 8-bit target segments
            </summary>
            <param name="src">The source value</param>
            <param name="dst">A target span of sufficient length</param>
        </member>
        <member name="M:Z0.BitMasks.part4x8(System.UInt32,System.Byte@)">
            <summary>
            Partitions a 32-bit source value into 4 segments of width 8
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The partition target</param>
        </member>
        <member name="M:Z0.BitParts.lsb32x1``1(``0)">
            <summary>
            [00000000 00000000 00000000 0000001 00000000 00000000 00000000 0000001]
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.BitParts.lsb8x1``1(``0)">
            <summary>
            [00000001 ... 00000001]
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.BitParts.part(System.UInt64,Z0.N63,Z0.N3,Z0.N8,System.Byte@)">
            <summary>
            Partitions the first 63 bits of a 64 bit source value into 21 8-bit target segments
            </summary>
            <param name="src">The source bits</param>
            <param name="dst">The receiving buffer</param>
        </member>
        <member name="M:Z0.BitParts.part(System.UInt16,Z0.N2,Z0.N8,System.Byte@)">
            <summary>
            Partitions a 16-bit source value into 2 segments of width 8 and is equivalent to <see cref='M:Z0.BitParts.part8x2(System.Byte,System.Byte@)'/>
            </summary>
            <param name="src">The bit source</param>
            <param name="dst">The partition target</param>
        </member>
        <member name="M:Z0.BitParts.part12x3(System.UInt32,System.Byte@)">
            <summary>
            Partitions the first 12 bits of a 32-bit source into 4 target segments each with an effective width of 3
            </summary>
            <param name="src">The source value</param>
            <param name="dst">A target span of sufficient length</param>
        </member>
        <member name="M:Z0.BitParts.part15x3(System.UInt16,System.Byte@)">
            <summary>
            Partitions the first 15 bits of a 16-bit source into 6 target segments each with an effective width of 3
            </summary>
            <param name="src">The source value</param>
            <param name="dst">A target span of sufficient length</param>
        </member>
        <member name="M:Z0.BitParts.part16x2(System.UInt16,System.Byte@)">
            <summary>
            Partitions a 16-bit source into 8 target segments each with an effective width of 2
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target memory location</param>
        </member>
        <member name="M:Z0.BitParts.part24x3(System.UInt32,System.Byte@)">
            <summary>
            Partitions the first 24 bits of a 32-bit source value into 9 8-bit target segments
            </summary>
            <param name="src">The source value</param>
            <param name="dst">A target span of sufficient length</param>
        </member>
        <member name="M:Z0.BitParts.part27x3(System.UInt32,System.Byte@)">
            <summary>
            Partitions the first 27 bits of a 32-bit source value into 9 8-bit target segments
            </summary>
            <param name="src">The source value</param>
            <param name="dst">A target span of sufficient length</param>
        </member>
        <member name="M:Z0.BitParts.part2x8(System.UInt16,System.Byte@)">
            <summary>
            Partitions a 16-bit source value into 2 segments of width 8
            </summary>
            <param name="src">The bit source</param>
            <param name="dst">The partition target</param>
        </member>
        <member name="M:Z0.BitParts.part30x3(System.UInt32,System.Byte@)">
            <summary>
            Partitions the first 30 bits of a 32-bit source value into 10 8-bitt target segments
            </summary>
            <param name="src">The source bits</param>
            <param name="dst">The receiving buffer</param>
        </member>
        <member name="M:Z0.BitParts.part32x16(System.UInt32,System.UInt16@)">
            <summary>
            Partitions a 64-bit source value into 4 segments of width 16
            </summary>
            <param name="src">The source value</param>
            <param name="dst">A target span of sufficient length</param>
        </member>
        <member name="M:Z0.BitParts.part32x2(System.UInt32,System.Byte@)">
            <summary>
            Partitions a 32-bit source into 16 target segments each with an effective width of 2
            </summary>
            <param name="src">The source value</param>
            <param name="dst">A target span of sufficient length</param>
        </member>
        <member name="M:Z0.BitParts.part4x2(System.UInt32,System.Byte@)">
            <summary>
            Partitions an 8-bit source value into 2 target segments each with an effective width of 4
            </summary>
            <param name="src">The source value</param>
            <param name="dst">A target span of sufficient length</param>
        </member>
        <member name="M:Z0.BitParts.Part4x5(System.UInt32,System.Byte@)">
            <summary>
            Partitions the first 20 bits of a 32-bit source value into 4 8-bit segments of width 5
            </summary>
            <param name="src">The bit source</param>
            <param name="dst">The partition target</param>
        </member>
        <member name="M:Z0.BitParts.part63x3(System.UInt64,System.Byte@)">
            <summary>
            Partitions the first 63 bits of a 64 bit source value into 21 8-bit target segments
            </summary>
            <param name="src">The source bits</param>
            <param name="dst">The receiving buffer</param>
        </member>
        <member name="M:Z0.BitParts.part64x1(System.UInt64,System.Byte@)">
            <summary>
            Partitions a 64-bit source into 64 8-bit targets, each of effective width 1
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target span</param>
        </member>
        <member name="M:Z0.BitParts.part64x1(System.UInt64,System.Span{Z0.Bit32})">
            <summary>
            Partitions a 64-bit source value into 64 individual bit values
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target span</param>
        </member>
        <member name="M:Z0.BitParts.part64x16(System.UInt64,System.UInt16@)">
            <summary>
            Partitions a 64-bit source value into 4 segments of width 16
            </summary>
            <param name="src">The source value</param>
            <param name="dst">A target span of sufficient length</param>
        </member>
        <member name="M:Z0.BitParts.part64x32(System.UInt64,System.UInt32@)">
            <summary>
            Partitions a 64-bit source value into 2 segments of width 32
            </summary>
            <param name="src">The source value</param>
            <param name="dst">A target span of sufficient length</param>
        </member>
        <member name="M:Z0.BitParts.part6x3(System.UInt32,System.Byte@)">
            <summary>
            Partitions the first 6 bits of a 32-bit source value into 2 target segments each with an effective width of 3
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target memory location</param>
        </member>
        <member name="M:Z0.BitParts.part8x2(System.Byte,System.Byte@)">
            <summary>
            Partitions the source into 4 target segments of physical width 8 and effective width 2
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target memory location</param>
        </member>
        <member name="M:Z0.BitParts.part8x2(System.UInt32,System.Byte@)">
            <summary>
            Partitions the first 8 bits of a 32-bit source into 4 target segments each with an effective width of 2
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target memory location</param>
        </member>
        <member name="M:Z0.BitParts.part8x4(System.UInt32,System.Byte@)">
            <summary>
            Partitions a 32-bit source value into 8 4-bit segments distributed across 8 bytes
            </summary>
            <param name="src">The bit source</param>
            <param name="dst">A target span of sufficient length</param>
        </member>
        <member name="M:Z0.BitParts.part8x8(System.UInt64,System.Byte@)">
            <summary>
            Partitions a 64-bit source value into 8 segments of width 8
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The partition target</param>
        </member>
        <member name="M:Z0.BitParts.part9x3(System.UInt32,System.Byte@)">
            <summary>
            Partitions the first 9 bits of a 32-bit source value into 3 target segments each with an effective width of 3
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target span</param>
        </member>
        <member name="T:Z0.Arrange4L">
            <summary>
            Defines literals that define symbol arrangements that may or may not be permutations
            </summary>
        </member>
        <member name="T:Z0.Blend2x64">
            <summary>
            Defines control mask values for constucting a 128-bit target by blending 2 64-bit segments from two source vectors
            </summary>
        </member>
        <member name="T:Z0.Blend4x32">
            <summary>
            Defines control mask values for constucting a 128-bit target by blending 
            4 32-bit segments from two 128-bit sources
            </summary>
        </member>
        <member name="F:Z0.Blend4x32.LLLL">
            <summary>
            ([0 1 2 3], [4 5 6 7]) -> [0 1 2 3]
            </summary>
        </member>
        <member name="F:Z0.Blend4x32.LLLR">
            <summary>
            ([0 1 2 3], [4 5 6 7]) -> [0 1 2 7]
            </summary>
        </member>
        <member name="F:Z0.Blend4x32.RLLL">
            <summary>
            ([0 1 2 3], [4 5 6 7]) -> [4 1 2 3]
            </summary>
        </member>
        <member name="F:Z0.Blend4x32.LLRL">
            <summary>
            ([0 1 2 3], [4 5 6 7]) -> [0 1 6 3]
            </summary>
        </member>
        <member name="F:Z0.Blend4x32.LLRR">
            <summary>
            ([0 1 2 3], [4 5 6 7]) -> [0 1 6 7]
            </summary>
        </member>
        <member name="F:Z0.Blend4x32.RRRR">
            <summary>
            ([0 1 2 3], [4 5 6 7]) -> [4 5 6 7]
            </summary>
        </member>
        <member name="T:Z0.Blend4x64">
            <summary>
            Defines control mask values for constucting a 256-bit target by blending 4 64-bit segments from two source vectors
            </summary>
        </member>
        <member name="T:Z0.Blend8x16">
            <summary>
            Defines control mask values for constucting a 128-bit target by 
            blending 8 16-bit segments from two source vectors
            </summary>
        </member>
        <member name="T:Z0.Blend8x32">
            <summary>
            Defines control mask values for constucting a 256-bit target by blending 
            8 32-bit segments from two source vectors
            </summary>
        </member>
        <member name="T:Z0.Perm16L">
            <summary>
            Defines canonical literals for representing terms of permutations on 16 symbols
            </summary>
        </member>
        <member name="T:Z0.Perm2x4">
            <summary>
            Identifies 2-element cycles over 4 symbols
            </summary>
        </member>
        <member name="F:Z0.Perm2x4.AC">
            <summary>
            ([0, 1, 2, 3], [4, 5, 6, 7]) -> [0, 1, 4, 5]
            </summary>
        </member>
        <member name="F:Z0.Perm2x4.CA">
            <summary>
            ([0, 1, 2, 3], [4, 5, 6, 7]) -> [4, 5, 0, 1]
            </summary>
        </member>
        <member name="F:Z0.Perm2x4.AD">
            <summary>
            ([0, 1, 2, 3], [4, 5, 6, 7]) -> [0, 1, 6, 7]
            </summary>
        </member>
        <member name="F:Z0.Perm2x4.DA">
            <summary>
            ([0, 1, 2, 3], [4, 5, 6, 7]) -> [6, 7, 0, 1]
            </summary>
        </member>
        <member name="F:Z0.Perm2x4.BC">
            <summary>
            ([0, 1, 2, 3], [4, 5, 6, 7]) -> [2, 3, 4, 5]
            </summary>
        </member>
        <member name="F:Z0.Perm2x4.CB">
            <summary>
            ([0, 1, 2, 3], [4, 5, 6, 7]) -> [4, 5, 2, 3]
            </summary>
        </member>
        <member name="F:Z0.Perm2x4.BD">
            <summary>
            ([0, 1, 2, 3], [4, 5, 6, 7]) -> [2, 3, 6, 7]
            </summary>
        </member>
        <member name="F:Z0.Perm2x4.DB">
            <summary>
            ([0, 1, 2, 3], [4, 5, 6, 7]) -> [6, 7, 2, 3]
            </summary>
        </member>
        <member name="T:Z0.Perm32L">
            <summary>
            Defines canonical literals for representing terms of permutations on 16 symbols
            </summary>
        </member>
        <member name="T:Z0.Perm4L">
            <summary>
            Identifies 4-element permutations
            </summary>
        </member>
        <member name="F:Z0.Perm4L.A">
            <summary>
            Identifies the first of four permutation symbols
            </summary>
        </member>
        <member name="F:Z0.Perm4L.B">
            <summary>
            Identifies the second of four permutation symbols
            </summary>
        </member>
        <member name="F:Z0.Perm4L.C">
            <summary>
            Identifies the third of four permutation symbols
            </summary>
        </member>
        <member name="F:Z0.Perm4L.D">
            <summary>
            Identifies the fourth of four permutation symbols
            </summary>
        </member>
        <member name="F:Z0.Perm4L.ABCD">
            <summary>
            ABCD -> ABCD
            </summary>
        </member>
        <member name="F:Z0.Perm4L.ABDC">
            <summary>
            ABCD -> ABDC
            </summary>
        </member>
        <member name="F:Z0.Perm4L.ACBD">
            <summary>
            ABCD -> ACBD
            </summary>
        </member>
        <member name="F:Z0.Perm4L.ACDB">
            <summary>
            ABCD -> ACDB
            </summary>
        </member>
        <member name="F:Z0.Perm4L.ADBC">
            <summary>
            ABCD -> ADBC
            </summary>
        </member>
        <member name="F:Z0.Perm4L.ADCB">
            <summary>
            ABCD -> ADCB
            </summary>
        </member>
        <member name="F:Z0.Perm4L.BACD">
            <summary>
            ABCD -> BACD
            </summary>
        </member>
        <member name="F:Z0.Perm4L.BADC">
            <summary>
            ABCD -> BADC
            </summary>
        </member>
        <member name="F:Z0.Perm4L.BCAD">
            <summary>
            ABCD -> BCAD
            </summary>
        </member>
        <member name="F:Z0.Perm4L.BCDA">
            <summary>
            ABCD -> BCDA
            </summary>
        </member>
        <member name="F:Z0.Perm4L.BDAC">
            <summary>
            ABCD -> BDAC
            </summary>
        </member>
        <member name="F:Z0.Perm4L.BDCA">
            <summary>
            ABCD -> BDCA
            </summary>
        </member>
        <member name="F:Z0.Perm4L.CABD">
            <summary>
            ABCD -> CABD
            </summary>
        </member>
        <member name="F:Z0.Perm4L.CADB">
            <summary>
            ABCD -> CADB
            </summary>
        </member>
        <member name="F:Z0.Perm4L.CBAD">
            <summary>
            ABCD -> CBAD
            </summary>
        </member>
        <member name="F:Z0.Perm4L.CBDA">
            <summary>
            ABCD -> CBDA
            </summary>
        </member>
        <member name="F:Z0.Perm4L.CDAB">
            <summary>
            ABCD -> CDAB
            </summary>
        </member>
        <member name="F:Z0.Perm4L.CDBA">
            <summary>
            ABCD -> CDBA
            </summary>
        </member>
        <member name="F:Z0.Perm4L.DABC">
            <summary>
            ABCD -> DABC
            </summary>
        </member>
        <member name="F:Z0.Perm4L.DACB">
            <summary>
            ABCD -> DACB
            </summary>
        </member>
        <member name="F:Z0.Perm4L.DBAC">
            <summary>
            ABCD -> DBAC
            </summary>
        </member>
        <member name="F:Z0.Perm4L.DBCA">
            <summary>
            ABCD -> DBCA
            </summary>
        </member>
        <member name="F:Z0.Perm4L.DCAB">
            <summary>
            ABCD -> DCAB
            </summary>
        </member>
        <member name="F:Z0.Perm4L.DCBA">
            <summary>
            ABCD -> DCBA
            </summary>
        </member>
        <member name="F:Z0.Perm4Sym.A">
            <summary>
            Identifies the first of four permutation symbols
            </summary>
        </member>
        <member name="F:Z0.Perm4Sym.B">
            <summary>
            Identifies the second of four permutation symbols
            </summary>
        </member>
        <member name="F:Z0.Perm4Sym.C">
            <summary>
            Identifies the third of four permutation symbols
            </summary>
        </member>
        <member name="F:Z0.Perm4Sym.D">
            <summary>
            Identifies the fourth of four permutation symbols
            </summary>
        </member>
        <member name="T:Z0.Perm8L">
            <summary>
            Defines canonical literals for representing terms of permutations on 8 symbols
            </summary>
        </member>
        <member name="F:Z0.Perm8L.A">
            <summary>
            Identifies the first permutation symbol
            </summary>
        </member>
        <member name="F:Z0.Perm8L.B">
            <summary>
            Identifies the second permutation symbol
            </summary>
        </member>
        <member name="F:Z0.Perm8L.C">
            <summary>
            Identifies the third permutation symbol
            </summary>
        </member>
        <member name="F:Z0.Perm8L.D">
            <summary>
            Identifies the fourth permutation symbol
            </summary>
        </member>
        <member name="F:Z0.Perm8L.E">
            <summary>
            Identifies the fifth permutation symbol
            </summary>
        </member>
        <member name="F:Z0.Perm8L.F">
            <summary>
            Identifies the sixth permutation symbol
            </summary>
        </member>
        <member name="F:Z0.Perm8L.G">
            <summary>
            Identifies the seventh permutation symbol
            </summary>
        </member>
        <member name="F:Z0.Perm8L.H">
            <summary>
            Identifies the eighth permutation symbol
            </summary>
        </member>
        <member name="F:Z0.Perm8Sym.A">
            <summary>
            Identifies the first permutation symbol
            </summary>
        </member>
        <member name="F:Z0.Perm8Sym.B">
            <summary>
            Identifies the second permutation symbol
            </summary>
        </member>
        <member name="F:Z0.Perm8Sym.C">
            <summary>
            Identifies the third permutation symbol
            </summary>
        </member>
        <member name="F:Z0.Perm8Sym.D">
            <summary>
            Identifies the fourth permutation symbol
            </summary>
        </member>
        <member name="F:Z0.Perm8Sym.E">
            <summary>
            Identifies the fifth permutation symbol
            </summary>
        </member>
        <member name="F:Z0.Perm8Sym.F">
            <summary>
            Identifies the sixth permutation symbol
            </summary>
        </member>
        <member name="F:Z0.Perm8Sym.G">
            <summary>
            Identifies the seventh permutation symbol
            </summary>
        </member>
        <member name="F:Z0.Perm8Sym.H">
            <summary>
            Identifies the eighth permutation symbol
            </summary>
        </member>
        <member name="F:Z0.MaskLiterals.Index8x8x0">
            <summary>
            [00000001]
            </summary>
        </member>
        <member name="F:Z0.MaskLiterals.Index8x8x1">
            <summary>
            [00000010]
            </summary>
        </member>
        <member name="F:Z0.MaskLiterals.Index8x8x2">
            <summary>
            [00000100]
            </summary>
        </member>
        <member name="T:Z0.CentralMask`3">
            <summary>
            Defines a specification for producing Central-oriented masks
            </summary>
            <typeparam name="F">The repetition frequency type</typeparam>
            <typeparam name="D">The bit density type</typeparam>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="T:Z0.IndexMask`2">
            <summary>
            Defines a specification for producing an index-oriented mask
            </summary>
            <typeparam name="N">The byte-relative bit index</typeparam>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="T:Z0.JsbMask`3">
            <summary>
            Defines a specification for producing joint lsb/msb mask compositions
            </summary>
            <typeparam name="F">The repetition frequency type</typeparam>
            <typeparam name="D">The bit density type</typeparam>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="T:Z0.LsbMask`3">
            <summary>
            Defines a specification for producing LSB-oriented masks
            </summary>
            <typeparam name="F">The repetition frequency type</typeparam>
            <typeparam name="D">The bit density type</typeparam>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="T:Z0.MaskSpec">
            <summary>
            Defines a specification for producing classified bitmasks
            </summary>
        </member>
        <member name="T:Z0.MsbMask`3">
            <summary>
            Defines a specification for producing MSB-oriented masks
            </summary>
            <typeparam name="F">The repetition frequency type</typeparam>
            <typeparam name="D">The bit density type</typeparam>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="T:Z0.ParityMask`3">
            <summary>
            Defines a specification for producing parity masks
            </summary>
            <typeparam name="F">The repetition frequency type</typeparam>
            <typeparam name="D">The bit density type</typeparam>
            <typeparam name="T">The mask data type</typeparam>
        </member>
        <member name="M:Z0.IRotator`1.Rotl(`0,System.UInt32)">
            <summary>
            Rotates bits leftwards, from LSB -> MSB
            </summary>
            <param name="count">The rotation magnitude</param>
        </member>
        <member name="M:Z0.IRotator`1.Rotr(`0,System.UInt32)">
            <summary>
            Rotates bits rightwards, from MSB -> LSB
            </summary>
            <param name="count">The rotation magnitude</param>
        </member>
        <member name="M:Z0.IRotatable`2.Rotl(System.UInt32)">
            <summary>
            Rotates bits leftwards, from LSB -> MSB
            </summary>
            <param name="count">The rotation magnitude</param>
        </member>
        <member name="M:Z0.IRotatable`2.Rotr(System.UInt32)">
            <summary>
            Rotates bits rightwards, from MSB -> LSB
            </summary>
            <param name="count">The rotation magnitude</param>
        </member>
        <member name="M:Z0.Bit.editor``1(``0@)">
            <summary>
            Wraps a bitview around a generic reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The generic type</typeparam>
        </member>
        <member name="M:Z0.Bit.parity(System.UInt32,Z0.BitState)">
            <summary>
            Defines a parity index j from a source integer i and a parity bit p, j := i*2 + p
            </summary>
            <param name="i">The source integer</param>
            <param name="p">The parity bit</param>
        </member>
        <member name="M:Z0.BitParser.parse(System.String)">
            <summary>
            Creates a bitspan from text encoding of a binary number
            </summary>
            <param name="src">The bit source</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N0,System.UInt16)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="n">The bit selector</param>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N1,System.UInt16)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N2,System.UInt16)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N3,System.UInt16)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N4,System.UInt16)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N5,System.UInt16)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N6,System.UInt16)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N7,System.UInt16)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N8,System.UInt16)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N9,System.UInt16)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N10,System.UInt16)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N11,System.UInt16)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N12,System.UInt16)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N13,System.UInt16)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N14,System.UInt16)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N15,System.UInt16)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N0,System.UInt32)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="n">The bit selector</param>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N1,System.UInt32)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N2,System.UInt32)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N3,System.UInt32)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N4,System.UInt32)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N5,System.UInt32)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N6,System.UInt32)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N7,System.UInt32)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N8,System.UInt32)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N9,System.UInt32)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N10,System.UInt32)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N11,System.UInt32)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N12,System.UInt32)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N13,System.UInt32)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N14,System.UInt32)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N15,System.UInt32)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N0,System.UInt64)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="n">The bit selector</param>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N1,System.UInt64)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N2,System.UInt64)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N3,System.UInt64)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N4,System.UInt64)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N5,System.UInt64)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N6,System.UInt64)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N7,System.UInt64)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N8,System.UInt64)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N9,System.UInt64)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N10,System.UInt64)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N11,System.UInt64)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N12,System.UInt64)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N13,System.UInt64)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N14,System.UInt64)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N15,System.UInt64)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N0,System.Byte)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="n">The bit selector</param>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N1,System.Byte)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N2,System.Byte)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N3,System.Byte)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N4,System.Byte)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N5,System.Byte)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N6,System.Byte)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="M:Z0.BitReader.bit(Z0.N7,System.Byte)">
            <summary>
            Reads the state of a naturally-identified bit
            </summary>
            <param name="src">The data source</param>
            <param name="n">The bit selector</param>
        </member>
        <member name="T:Z0.BitSize">
            <summary>
            Specifies data size in bits
            </summary>
        </member>
        <member name="F:Z0.BitSize.Count">
            <summary>
            Specifies a bit count
            </summary>
        </member>
        <member name="M:Z0.BitSize.measure``1">
            <summary>
            Computes the bit-size of a parametric type
            </summary>
            <typeparam name="T">The type to measure</typeparam>
        </member>
        <member name="M:Z0.BitSize.div``1(System.Int32,``0)">
            <summary>
            Computes the quotient q :=  a / bitsize[T] of an operand a and parametric type T
            </summary>
            <param name="a">The operand</param>
            <typeparam name="T">The parametric type from which a bit-width will be determined</typeparam>
        </member>
        <member name="M:Z0.BitSize.mod``1(System.Int32,``0)">
            <summary>
            Computes the remainder r :=  a % bitsize[T] of an operand a and parametric type T
            </summary>
            <param name="a">The operand</param>
            <typeparam name="T">The parametric type from which a bit-width will be determined</typeparam>
        </member>
        <member name="P:Z0.BitSize.Empty">
            <summary>
            The bit with no size
            </summary>
        </member>
        <member name="T:Z0.BitFormat">
            <summary>
            Controls formatting when bitstring content is rendered as text
            </summary>
        </member>
        <member name="F:Z0.BitFormat.TrimLeadingZeros">
            <summary>
            Indicates whether leading zeros should be trimmed
            </summary>
        </member>
        <member name="F:Z0.BitFormat.SpecifierPrefix">
            <summary>
            Indicates whether the '0b' prefix should be emitted
            </summary>
        </member>
        <member name="F:Z0.BitFormat.MaxBitCount">
            <summary>
            The maximum number of bits to be extracted/formatted from the source
            </summary>
        </member>
        <member name="F:Z0.BitFormat.BlockWidth">
            <summary>
            Optional contiguous digit sequence width; if unspecified the bitstring will be formatted without blocks
            </summary>
        </member>
        <member name="F:Z0.BitFormat.BlockSep">
            <summary>
            The character with which to intersperse blocks; if unspecified, a space will be used
            </summary>
        </member>
        <member name="F:Z0.BitFormat.RowWidth">
            <summary>
            The optional row width, applicable when formatting rectangular regions of bits
            </summary>
        </member>
        <member name="F:Z0.BitFormat.ZPad">
            <summary>
            The number of leading zeroes to pad
            </summary>
        </member>
        <member name="T:Z0.BitFormatter`1">
            <summary>
            Configurable bit data type formatter
            </summary>
        </member>
        <member name="M:Z0.bit.op_BitwiseAnd(Z0.bit,Z0.bit)">
            <summary>
            Computes the bitwise AND between the operands
            </summary>
            <param name="a">The left bit</param>
            <param name="b">The right bit</param>
        </member>
        <member name="M:Z0.bit.op_BitwiseOr(Z0.bit,Z0.bit)">
            <summary>
            Computes the bitwise OR between the operands
            </summary>
            <param name="a">The left bit</param>
            <param name="b">The right bit</param>
        </member>
        <member name="M:Z0.bit.op_ExclusiveOr(Z0.bit,Z0.bit)">
            <summary>
            Computes the bitwise XOR between the operands
            </summary>
            <param name="a">The left bit</param>
            <param name="b">The right bit</param>
        </member>
        <member name="M:Z0.bit.op_Addition(Z0.bit,Z0.bit)">
            <summary>
            Combines the states of the source bits
            </summary>
            <param name="a">The left bit</param>
            <param name="b">The right bit</param>
        </member>
        <member name="M:Z0.bit.op_OnesComplement(Z0.bit)">
            <summary>
            Inverts the state of the source bit
            </summary>
            <param name="a">The source bit</param>
        </member>
        <member name="M:Z0.bit.op_LogicalNot(Z0.bit)">
            <summary>
            Inverts the state of the source bit
            </summary>
            <param name="a">The source bit</param>
        </member>
        <member name="M:Z0.bit.op_Implicit(Z0.bit)~System.Boolean">
            <summary>
            Implicitly constructs a bool from a bit
            </summary>
            <param name="state">The state of the bit to construct</param>
        </member>
        <member name="M:Z0.bit.op_True(Z0.bit)">
            <summary>
            Returns true if the bit is enabled, false otherwise
            </summary>
            <param name="b">The bit to test</param>
        </member>
        <member name="M:Z0.bit.op_False(Z0.bit)">
            <summary>
            Returns false if the bit is disabled, true otherwise
            </summary>
            <param name="b">The bit to test</param>
        </member>
        <member name="M:Z0.bit.op_Explicit(Z0.bit)~System.Byte">
            <summary>
            Defines an explicit bit -> byte conversion
            </summary>
            <param name="src">The source bit</param>
        </member>
        <member name="M:Z0.bit.op_Explicit(Z0.bit)~System.SByte">
            <summary>
            Defines an explicit bit -> byte conversion
            </summary>
            <param name="src">The source bit</param>
        </member>
        <member name="M:Z0.bit.op_Explicit(System.Byte)~Z0.bit">
            <summary>
            Defines an explicit byte -> bit conversion
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.bit.op_Explicit(Z0.bit)~System.UInt16">
            <summary>
            Defines an explicit bit -> ushort conversion
            </summary>
            <param name="src">The source bit</param>
        </member>
        <member name="M:Z0.bit.op_Explicit(Z0.bit)~System.Int16">
            <summary>
            Defines an explicit bit -> ushort conversion
            </summary>
            <param name="src">The source bit</param>
        </member>
        <member name="M:Z0.bit.op_Explicit(System.UInt16)~Z0.bit">
            <summary>
            Defines an explicit ushort -> bit conversion
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.bit.op_Explicit(Z0.bit)~System.Int32">
            <summary>
            Defines an explicit bit -> int conversion
            </summary>
            <param name="src">The source bit</param>
        </member>
        <member name="M:Z0.bit.op_Implicit(System.Int32)~Z0.bit">
            <summary>
            Defines an *implicit* int -> bit conversion to aid sanity retention
            </summary>
            <param name="src">The source bit</param>
        </member>
        <member name="M:Z0.bit.op_Explicit(Z0.bit)~System.UInt32">
            <summary>
            Defines an explicit bit -> uint conversion
            </summary>
            <param name="src">The source bit</param>
        </member>
        <member name="M:Z0.bit.op_Explicit(Z0.bit)~System.Int64">
            <summary>
            Defines an explicit bit -> long conversion
            </summary>
            <param name="src">The source bit</param>
        </member>
        <member name="M:Z0.bit.op_Explicit(Z0.bit)~System.Single">
            <summary>
            Defines an explicit bit -> float conversion
            </summary>
            <param name="src">The source bit</param>
        </member>
        <member name="M:Z0.bit.op_Explicit(Z0.bit)~System.Double">
            <summary>
            Defines an explicit bit -> double conversion
            </summary>
            <param name="src">The source bit</param>
        </member>
        <member name="P:Z0.bit.Off">
            <summary>
            Constructs a disabled bit
            </summary>
        </member>
        <member name="P:Z0.bit.On">
            <summary>
            Constructs an enabled bit
            </summary>
        </member>
        <member name="M:Z0.bit.Promote``1">
            <summary>
            Promotes a bit to a numeric value where all target bits are enabled if the state of the
            bit is on; otherwise all target bits are disabled
            </summary>
            <param name="src">The source bit</param>
            <typeparam name="T">The target numeric type</typeparam>
        </member>
        <member name="T:Z0.Bit32">
            <summary>
            An anti-succinct representation of a bit
            </summary>
        </member>
        <member name="P:Z0.Bit32.Off">
            <summary>
            Constructs a disabled bit
            </summary>
        </member>
        <member name="P:Z0.Bit32.On">
            <summary>
            Constructs an enabled bit
            </summary>
        </member>
        <member name="M:Z0.Bit32.test(System.SByte,System.Byte)">
            <summary>
            Tests the state of an index-identified source bit
            </summary>
            <param name="src">The source value</param>
            <param name="pos">The 0-based index of the bit to test</param>
        </member>
        <member name="M:Z0.Bit32.test(System.Byte,System.Int32)">
            <summary>
            Tests the state of an index-identified source bit
            </summary>
            <param name="src">The source value</param>
            <param name="pos">The 0-based index of the bit to test</param>
        </member>
        <member name="M:Z0.Bit32.test(System.Int16,System.Int32)">
            <summary>
            Tests the state of an index-identified source bit
            </summary>
            <param name="src">The source value</param>
            <param name="pos">The 0-based index of the bit to test</param>
        </member>
        <member name="M:Z0.Bit32.test(System.UInt16,System.Int32)">
            <summary>
            Tests the state of an index-identified source bit
            </summary>
            <param name="src">The source value</param>
            <param name="pos">The 0-based index of the bit to test</param>
        </member>
        <member name="M:Z0.Bit32.test(System.Int32,System.Int32)">
            <summary>
            Tests the state of an index-identified source bit
            </summary>
            <param name="src">The source value</param>
            <param name="pos">The 0-based index of the bit to test</param>
        </member>
        <member name="M:Z0.Bit32.test(System.Int64,System.Int32)">
            <summary>
            Tests the state of an index-identified source bit
            </summary>
            <param name="src">The source value</param>
            <param name="pos">The 0-based index of the bit to test</param>
        </member>
        <member name="M:Z0.Bit32.test(System.UInt32,System.Int32)">
            <summary>
            Tests the state of an index-identified source bit
            </summary>
            <param name="src">The source value</param>
            <param name="pos">The 0-based index of the bit to test</param>
        </member>
        <member name="M:Z0.Bit32.test(System.UInt64,System.Int32)">
            <summary>
            Tests the state of an index-identified source bit
            </summary>
            <param name="src">The source value</param>
            <param name="pos">The 0-based index of the bit to test</param>
        </member>
        <member name="M:Z0.Bit32.set(System.SByte,System.Byte,Z0.Bit32)">
            <summary>
            Aligns an index-identified source bit with with a suplied state
            </summary>
            <param name="src">The source</param>
            <param name="pos">The source bit index</param>
            <param name="state">The state with which to align a source bit</param>
        </member>
        <member name="M:Z0.Bit32.set(System.Byte,System.Byte,Z0.Bit32)">
            <summary>
            Aligns an index-identified source bit with with a suplied state
            </summary>
            <param name="src">The source</param>
            <param name="pos">The source bit index</param>
            <param name="state">The state with which to align a source bit</param>
        </member>
        <member name="M:Z0.Bit32.set(System.Int16,System.Byte,Z0.Bit32)">
            <summary>
            Aligns an index-identified source bit with with a suplied state
            </summary>
            <param name="src">The source</param>
            <param name="pos">The source bit index</param>
            <param name="state">The state with which to align a source bit</param>
        </member>
        <member name="M:Z0.Bit32.set(System.UInt16,System.Byte,Z0.Bit32)">
            <summary>
            Aligns an index-identified source bit with with a suplied state
            </summary>
            <param name="src">The source</param>
            <param name="pos">The source bit index</param>
            <param name="state">The state with which to align a source bit</param>
        </member>
        <member name="M:Z0.Bit32.set(System.Int32,System.Byte,Z0.Bit32)">
            <summary>
            Aligns an index-identified source bit with with a suplied state
            </summary>
            <param name="src">The source</param>
            <param name="pos">The source bit index</param>
            <param name="state">The state with which to align a source bit</param>
        </member>
        <member name="M:Z0.Bit32.set(System.UInt32,System.Byte,Z0.Bit32)">
            <summary>
            Aligns an index-identified source bit with with a suplied state
            </summary>
            <param name="src">The source</param>
            <param name="pos">The source bit index</param>
            <param name="state">The state with which to align a source bit</param>
        </member>
        <member name="M:Z0.Bit32.set(System.Int64,System.Byte,Z0.Bit32)">
            <summary>
            Aligns an index-identified source bit with with a suplied state
            </summary>
            <param name="src">The source</param>
            <param name="pos">The source bit index</param>
            <param name="state">The state with which to align a source bit</param>
        </member>
        <member name="M:Z0.Bit32.set(System.UInt64,System.Byte,Z0.Bit32)">
            <summary>
            Aligns an index-identified source bit with with a suplied state
            </summary>
            <param name="src">The source</param>
            <param name="index">The source bit index</param>
            <param name="value">The state with which to align a source bit</param>
        </member>
        <member name="M:Z0.Bit32.identity(Z0.Bit32)">
            <summary>
            The identity function
            </summary>
            <param name="b">The source bit</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.Bit32.and(Z0.Bit32,Z0.Bit32)" -->
        <member name="M:Z0.Bit32.or(Z0.Bit32,Z0.Bit32)">
            <summary>
            Computes c = a | b
            </summary>
            <param name="a">The left bit</param>
            <param name="b">The right bit</param>
        </member>
        <member name="M:Z0.Bit32.xor(Z0.Bit32,Z0.Bit32)">
            <summary>
            Computes c = a ^ b
            </summary>
            <param name="a">The left bit</param>
            <param name="b">The right bit</param>
        </member>
        <member name="M:Z0.Bit32.not(Z0.Bit32)">
            <summary>
            Computes c := ~a = !a
            </summary>
            <param name="a">The source bit</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.Bit32.nand(Z0.Bit32,Z0.Bit32)" -->
        <member name="M:Z0.Bit32.nor(Z0.Bit32,Z0.Bit32)">
            <summary>
            Computes c := ~ (a | b)
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <remarks>See https://en.wikipedia.org/wiki/Logical_biconditional</remarks>
        </member>
        <member name="M:Z0.Bit32.xnor(Z0.Bit32,Z0.Bit32)">
            <summary>
            Computes c := ~ (a ^ b)
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <remarks>See https://en.wikipedia.org/wiki/Logical_biconditional</remarks>
        </member>
        <member name="M:Z0.Bit32.impl(Z0.Bit32,Z0.Bit32)">
            <summary>
            Computes c := a -> b := a | ~b
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <remarks>See https://en.wikipedia.org/wiki/Material_conditional</remarks>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.Bit32.nonimpl(Z0.Bit32,Z0.Bit32)" -->
        <member name="M:Z0.Bit32.cimpl(Z0.Bit32,Z0.Bit32)">
            <summary>
            Computes the converse implication c := ~a | b
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.Bit32.cnonimpl(Z0.Bit32,Z0.Bit32)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.Bit32.select(Z0.Bit32,Z0.Bit32,Z0.Bit32)" -->
        <member name="M:Z0.Bit32.op_True(Z0.Bit32)">
            <summary>
            Returns true if the bit is enabled, false otherwise
            </summary>
            <param name="b">The bit to test</param>
        </member>
        <member name="M:Z0.Bit32.op_False(Z0.Bit32)">
            <summary>
            Returns false if the bit is disabled, true otherwise
            </summary>
            <param name="b">The bit to test</param>
        </member>
        <member name="M:Z0.Bit32.op_Implicit(System.Boolean)~Z0.Bit32">
            <summary>
            Implicitly constructs a bit from a bool
            </summary>
            <param name="state">The state of the bit to construct</param>
        </member>
        <member name="M:Z0.Bit32.op_Implicit(Z0.Bit32)~System.Boolean">
            <summary>
            Implicitly constructs a bool from a bit
            </summary>
            <param name="state">The state of the bit to construct</param>
        </member>
        <member name="M:Z0.Bit32.op_Explicit(Z0.Bit32)~System.Byte">
            <summary>
            Defines an explicit bit -> byte conversion
            </summary>
            <param name="src">The source bit</param>
        </member>
        <member name="M:Z0.Bit32.op_Explicit(Z0.Bit32)~System.SByte">
            <summary>
            Defines an explicit bit -> byte conversion
            </summary>
            <param name="src">The source bit</param>
        </member>
        <member name="M:Z0.Bit32.op_Explicit(System.Byte)~Z0.Bit32">
            <summary>
            Defines an explicit byte -> bit conversion
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.Bit32.op_Explicit(Z0.Bit32)~System.UInt16">
            <summary>
            Defines an explicit bit -> ushort conversion
            </summary>
            <param name="src">The source bit</param>
        </member>
        <member name="M:Z0.Bit32.op_Explicit(Z0.Bit32)~System.Int16">
            <summary>
            Defines an explicit bit -> ushort conversion
            </summary>
            <param name="src">The source bit</param>
        </member>
        <member name="M:Z0.Bit32.op_Explicit(System.UInt16)~Z0.Bit32">
            <summary>
            Defines an explicit ushort -> bit conversion
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.Bit32.op_Explicit(Z0.Bit32)~System.Int32">
            <summary>
            Defines an explicit bit -> int conversion
            </summary>
            <param name="src">The source bit</param>
        </member>
        <member name="M:Z0.Bit32.op_Implicit(System.Int32)~Z0.Bit32">
            <summary>
            Defines an *implicit* int -> bit conversion to aid sanity retention
            </summary>
            <param name="src">The source bit</param>
        </member>
        <member name="M:Z0.Bit32.op_Explicit(Z0.Bit32)~System.UInt32">
            <summary>
            Defines an explicit bit -> uint conversion
            </summary>
            <param name="src">The source bit</param>
        </member>
        <member name="M:Z0.Bit32.op_Explicit(Z0.Bit32)~System.Int64">
            <summary>
            Defines an explicit bit -> long conversion
            </summary>
            <param name="src">The source bit</param>
        </member>
        <member name="M:Z0.Bit32.op_Explicit(Z0.Bit32)~System.Single">
            <summary>
            Defines an explicit bit -> float conversion
            </summary>
            <param name="src">The source bit</param>
        </member>
        <member name="M:Z0.Bit32.op_Explicit(Z0.Bit32)~System.Double">
            <summary>
            Defines an explicit bit -> double conversion
            </summary>
            <param name="src">The source bit</param>
        </member>
        <member name="M:Z0.Bit32.op_Explicit(System.UInt32)~Z0.Bit32">
            <summary>
            Defines an explicit uint -> bit conversion
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.Bit32.op_Explicit(Z0.Bit32)~System.UInt64">
            <summary>
            Defines an explicit bit -> ulong conversion
            </summary>
            <param name="src">The source bit</param>
        </member>
        <member name="M:Z0.Bit32.op_Explicit(System.UInt64)~Z0.Bit32">
            <summary>
            Defines an explicit ulong -> bit conversion
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.Bit32.op_Addition(Z0.Bit32,Z0.Bit32)">
            <summary>
            Combines the states of the source bits
            </summary>
            <param name="a">The left bit</param>
            <param name="b">The right bit</param>
        </member>
        <member name="M:Z0.Bit32.op_BitwiseAnd(Z0.Bit32,Z0.Bit32)">
            <summary>
            Computes the bitwise AND between the operands
            </summary>
            <param name="a">The left bit</param>
            <param name="b">The right bit</param>
        </member>
        <member name="M:Z0.Bit32.op_BitwiseOr(Z0.Bit32,Z0.Bit32)">
            <summary>
            Computes the bitwise OR between the operands
            </summary>
            <param name="a">The left bit</param>
            <param name="b">The right bit</param>
        </member>
        <member name="M:Z0.Bit32.op_ExclusiveOr(Z0.Bit32,Z0.Bit32)">
            <summary>
            Computes the bitwise XOR between the operands
            </summary>
            <param name="a">The left bit</param>
            <param name="b">The right bit</param>
        </member>
        <member name="M:Z0.Bit32.op_OnesComplement(Z0.Bit32)">
            <summary>
            Inverts the state of the source bit
            </summary>
            <param name="a">The source bit</param>
        </member>
        <member name="M:Z0.Bit32.op_LogicalNot(Z0.Bit32)">
            <summary>
            Inverts the state of the source bit
            </summary>
            <param name="a">The source bit</param>
        </member>
        <member name="M:Z0.Bit32.Promote``1">
            <summary>
            Promotes a bit to a numeric value where all target bits are enabled if the state of the
            bit is on; otherwise all target bits are disabled
            </summary>
            <param name="src">The source bit</param>
            <typeparam name="T">The target numeric type</typeparam>
        </member>
        <member name="T:Z0.Bit32Converter">
            <summary>
            Conversion provider for the bit data type
            </summary>
        </member>
        <member name="T:Z0.BitEdit`1">
            <summary>
            Represents a value as an ordered sequence of bits/bytes
            </summary>
        </member>
        <member name="F:Z0.BitEdit`1.Bytes">
            <summary>
            The data over which the view is constructed
            </summary>
        </member>
        <member name="P:Z0.BitEdit`1.ByteCount">
            <summary>
            The total number of represented bytes
            </summary>
        </member>
        <member name="P:Z0.BitEdit`1.BitCount">
            <summary>
            The total number of represented bits
            </summary>
        </member>
        <member name="P:Z0.BitEdit`1.Item(Z0.ByteSize)">
            <summary>
            Selects an offset-identified byte
            </summary>
        </member>
        <member name="P:Z0.BitEdit`1.Item(Z0.ByteSize,System.Byte)">
            <summary>
            Queries/Manipulates the source at the bit-level
            </summary>
        </member>
        <member name="T:Z0.BitState">
            <summary>
            Defines literals that correspond to potential bit states
            </summary>
        </member>
        <member name="F:Z0.BitState.Off">
            <summary>
            The bit, it is off
            </summary>
        </member>
        <member name="F:Z0.BitState.On">
            <summary>
            The bit, enabled it is
            </summary>
        </member>
        <member name="M:Z0.BitStream.from``1(System.Collections.Generic.IEnumerator{``0})">
            <summary>
            Transforms an primal enumerator into a bitstream
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitStream.from``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Transforms an primal source stream into a bitstream
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="T:Z0.BitView`1">
            <summary>
            Represents a value as an ordered sequence of bits/bytes
            </summary>
        </member>
        <member name="F:Z0.BitView`1.Bytes">
            <summary>
            The data over which the view is constructed
            </summary>
        </member>
        <member name="P:Z0.BitView`1.ByteCount">
            <summary>
            The total number of represented bytes
            </summary>
        </member>
        <member name="P:Z0.BitView`1.BitCount">
            <summary>
            The total number of represented bits
            </summary>
        </member>
        <member name="P:Z0.BitView`1.Item(Z0.ByteSize)">
            <summary>
            Selects an offset-identified byte
            </summary>
        </member>
        <member name="P:Z0.BitView`1.Item(Z0.ByteSize,System.Byte)">
            <summary>
            Queries/Manipulates the source at the bit-level
            </summary>
        </member>
        <member name="M:Z0.BitWriter.write(Z0.N0,System.UInt32,System.UInt32)">
            <summary>
            Transfers the state of a naturally-identified source bit to the corresponding bit in the target
            </summary>
            <param name="n">The bit selector</param>
            <param name="src">The source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.BitWriter.write(Z0.N1,System.UInt32,System.UInt32)">
            <summary>
            Transfers the state of a naturally-identified source bit to the corresponding bit in the target
            </summary>
            <param name="n">The bit selector</param>
            <param name="src">The source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.BitWriter.Write(Z0.N2,System.UInt32,System.UInt32)">
            <summary>
            Transfers the state of a naturally-identified source bit to the corresponding bit in the target
            </summary>
            <param name="n">The bit selector</param>
            <param name="src">The source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.BitWriter.write(Z0.N3,System.UInt32,System.UInt32)">
            <summary>
            Transfers the state of a naturally-identified source bit to the corresponding bit in the target
            </summary>
            <param name="n">The bit selector</param>
            <param name="src">The source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.BitWriter.write(Z0.N4,System.UInt32,System.UInt32)">
            <summary>
            Transfers the state of a naturally-identified source bit to the corresponding bit in the target
            </summary>
            <param name="n">The bit selector</param>
            <param name="src">The source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.BitWriter.write(Z0.N5,System.UInt32,System.UInt32)">
            <summary>
            Transfers the state of a naturally-identified source bit to the corresponding bit in the target
            </summary>
            <param name="n">The bit selector</param>
            <param name="src">The source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.BitWriter.Write(Z0.N6,System.UInt32,System.UInt32)">
            <summary>
            Transfers the state of a naturally-identified source bit to the corresponding bit in the target
            </summary>
            <param name="n">The bit selector</param>
            <param name="src">The source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.BitWriter.Write(Z0.N7,System.UInt32,System.UInt32)">
            <summary>
            Transfers the state of a naturally-identified source bit to the corresponding bit in the target
            </summary>
            <param name="n">The bit selector</param>
            <param name="src">The source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.BitWriter.write(Z0.N0,System.Byte,System.Byte)">
            <summary>
            Transfers the state of a naturally-identified source bit to the corresponding bit in the target
            </summary>
            <param name="n">The bit selector</param>
            <param name="src">The source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.BitWriter.write(Z0.N1,System.Byte,System.Byte)">
            <summary>
            Transfers the state of a naturally-identified source bit to the corresponding bit in the target
            </summary>
            <param name="n">The bit selector</param>
            <param name="src">The source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.BitWriter.write(Z0.N2,System.Byte,System.Byte)">
            <summary>
            Transfers the state of a naturally-identified source bit to the corresponding bit in the target
            </summary>
            <param name="n">The bit selector</param>
            <param name="src">The source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.BitWriter.write(Z0.N3,System.Byte,System.Byte)">
            <summary>
            Transfers the state of a naturally-identified source bit to the corresponding bit in the target
            </summary>
            <param name="n">The bit selector</param>
            <param name="src">The source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.BitWriter.write(Z0.N4,System.Byte,System.Byte)">
            <summary>
            Transfers the state of a naturally-identified source bit to the corresponding bit in the target
            </summary>
            <param name="n">The bit selector</param>
            <param name="src">The source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.BitWriter.write(Z0.N5,System.Byte,System.Byte)">
            <summary>
            Transfers the state of a naturally-identified source bit to the corresponding bit in the target
            </summary>
            <param name="n">The bit selector</param>
            <param name="src">The source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.BitWriter.write(Z0.N6,System.Byte,System.Byte)">
            <summary>
            Transfers the state of a naturally-identified source bit to the corresponding bit in the target
            </summary>
            <param name="n">The bit selector</param>
            <param name="src">The source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.BitWriter.write(Z0.N7,System.Byte,System.Byte)">
            <summary>
            Transfers the state of a naturally-identified source bit to the corresponding bit in the target
            </summary>
            <param name="n">The bit selector</param>
            <param name="src">The source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.CellBlocks.alloc(Z0.W8,Z0.N14)">
            <summary>
            Allocates a 14-byte block
            </summary>
            <param name="n">The byte-count selector</param>
        </member>
        <member name="M:Z0.CellBlocks.alloc(Z0.W8,Z0.N15)">
            <summary>
            Allocates a 15-byte block
            </summary>
            <param name="n">The byte-count selector</param>
        </member>
        <member name="M:Z0.CellBlocks.alloc(Z0.W8,Z0.N16)">
            <summary>
            Allocates a 16-byte block
            </summary>
            <param name="n">The byte-count selector</param>
        </member>
        <member name="M:Z0.CellBlocks.alloc(Z0.W8,Z0.N32)">
            <summary>
            Allocates a 32-byte block
            </summary>
            <param name="n">The byte-count selector</param>
        </member>
        <member name="M:Z0.CellBlocks.alloc(Z0.W8,Z0.N64)">
            <summary>
            Allocates a 64-byte block
            </summary>
            <param name="n">The byte-count selector</param>
        </member>
        <member name="M:Z0.CellBlocks.alloc(Z0.W8,Z0.N128)">
            <summary>
            Allocates a 128-byte block
            </summary>
            <param name="n">The byte-count selector</param>
        </member>
        <member name="M:Z0.CellBlocks.alloc(Z0.CellBlock128@,Z0.CellBlock128@)">
            <summary>
            Allocates 2 128-byte blocks
            </summary>
            <param name="n">The byte-count selector</param>
        </member>
        <member name="M:Z0.CellBlocks.alloc(Z0.CellBlock128@,Z0.CellBlock128@,Z0.CellBlock128@)">
            <summary>
            Allocates 3 128-byte blocks
            </summary>
            <param name="n">The byte-count selector</param>
        </member>
        <member name="M:Z0.CellBlocks.alloc(Z0.CellBlock128@,Z0.CellBlock128@,Z0.CellBlock128@,Z0.CellBlock128@)">
            <summary>
            Allocates 4 128-byte blocks
            </summary>
            <param name="n">The byte-count selector</param>
        </member>
        <member name="T:Z0.CellBlock1">
            <summary>
            1 byte of storage
            </summary>
        </member>
        <member name="T:Z0.CellBlock2">
            <summary>
            2 bytes of storage
            </summary>
        </member>
        <member name="T:Z0.CellBlock3">
            <summary>
            3 bytes of storage
            </summary>
        </member>
        <member name="T:Z0.CellBlock4">
            <summary>
            4 bytes of storage
            </summary>
        </member>
        <member name="T:Z0.CellBlock5">
            <summary>
            5 bytes of storage
            </summary>
        </member>
        <member name="T:Z0.CellBlock6">
            <summary>
            6 bytes of storage
            </summary>
        </member>
        <member name="T:Z0.CellBlock7">
            <summary>
            7 bytes of storage
            </summary>
        </member>
        <member name="T:Z0.CellBlock8">
            <summary>
            8 bytes of storage
            </summary>
        </member>
        <member name="T:Z0.CellBlock9">
            <summary>
            9 bytes of storage
            </summary>
        </member>
        <member name="T:Z0.CellBlock10">
            <summary>
            10 bytes of storage
            </summary>
        </member>
        <member name="T:Z0.CellBlock11">
            <summary>
            11 bytes of storage
            </summary>
        </member>
        <member name="T:Z0.CellBlock12">
            <summary>
            12 bytes of storage
            </summary>
        </member>
        <member name="T:Z0.CellBlock13">
            <summary>
            13 bytes of storage
            </summary>
        </member>
        <member name="T:Z0.CellBlock14">
            <summary>
            14 bytes of storage
            </summary>
        </member>
        <member name="T:Z0.CellBlock15">
            <summary>
            15 bytes of storage
            </summary>
        </member>
        <member name="T:Z0.CellBlock16">
            <summary>
            16 bytes of storage
            </summary>
        </member>
        <member name="T:Z0.CellBlock32">
            <summary>
            32 bytes of storage
            </summary>
        </member>
        <member name="T:Z0.CellBlock64">
            <summary>
            64 bytes of storage
            </summary>
        </member>
        <member name="T:Z0.CellBlock128">
            <summary>
            128 bytes of storage
            </summary>
        </member>
        <member name="T:Z0.CellBlock256">
            <summary>
            256 bytes of storage
            </summary>
        </member>
        <member name="T:Z0.CharBlock1">
            <summary>
            Defines a character block b with capacity(b) = 1x16u
            </summary>
        </member>
        <member name="P:Z0.CharBlock1.Data">
            <summary>
            Presents block content as an editable buffer
            </summary>
        </member>
        <member name="F:Z0.CharBlock1.CharCount">
            <summary>
            The block capacity
            </summary>
        </member>
        <member name="F:Z0.CharBlock10.Lo">
            <summary>
            The lower content
            </summary>
        </member>
        <member name="F:Z0.CharBlock10.Hi">
            <summary>
            The upper content
            </summary>
        </member>
        <member name="P:Z0.CharBlock10.Data">
            <summary>
            The block content presented as an editable buffer
            </summary>
        </member>
        <member name="F:Z0.CharBlock10.CharCount">
            <summary>
            The block capacity
            </summary>
        </member>
        <member name="F:Z0.CharBlock11.Lo">
            <summary>
            The lower content
            </summary>
        </member>
        <member name="F:Z0.CharBlock11.Hi">
            <summary>
            The upper content
            </summary>
        </member>
        <member name="P:Z0.CharBlock11.Data">
            <summary>
            The block content presented as an editable buffer
            </summary>
        </member>
        <member name="T:Z0.CharBlock2">
            <summary>
            Defines a character block b with capacity(b) = 2x16u
            </summary>
        </member>
        <member name="F:Z0.CharBlock2.Lo">
            <summary>
            The lower content
            </summary>
        </member>
        <member name="P:Z0.CharBlock2.Data">
            <summary>
            The block content presented as an editable buffer
            </summary>
        </member>
        <member name="F:Z0.CharBlock2.CharCount">
            <summary>
            The block capacity
            </summary>
        </member>
        <member name="T:Z0.CharBlock3">
            <summary>
            Defines a character block b with capacity(b) = 3x16u
            </summary>
        </member>
        <member name="F:Z0.CharBlock3.Lo">
            <summary>
            The lower content
            </summary>
        </member>
        <member name="P:Z0.CharBlock3.Data">
            <summary>
            The block content presented as an editable buffer
            </summary>
        </member>
        <member name="F:Z0.CharBlock3.CharCount">
            <summary>
            The block capacity
            </summary>
        </member>
        <member name="T:Z0.CharBlock4">
            <summary>
            Defines a character block b with capacity(b) = 4x16u
            </summary>
        </member>
        <member name="F:Z0.CharBlock4.Lo">
            <summary>
            The lower content
            </summary>
        </member>
        <member name="P:Z0.CharBlock4.Data">
            <summary>
            The block content presented as an editable buffer
            </summary>
        </member>
        <member name="F:Z0.CharBlock4.CharCount">
            <summary>
            The block capacity
            </summary>
        </member>
        <member name="T:Z0.CharBlock5">
            <summary>
            Defines a character block b with capacity(b) = 5
            </summary>
        </member>
        <member name="F:Z0.CharBlock5.Lo">
            <summary>
            The lower content
            </summary>
        </member>
        <member name="P:Z0.CharBlock5.Data">
            <summary>
            The block content presented as an editable buffer
            </summary>
        </member>
        <member name="F:Z0.CharBlock5.CharCount">
            <summary>
            The block capacity
            </summary>
        </member>
        <member name="T:Z0.CharBlock512">
            <summary>
            Defines a character block b with capacity(b) = 512x16u
            </summary>
        </member>
        <member name="F:Z0.CharBlock512.Lo">
            <summary>
            The upper content
            </summary>
        </member>
        <member name="F:Z0.CharBlock512.Hi">
            <summary>
            The lower segment
            </summary>
        </member>
        <member name="P:Z0.CharBlock512.Data">
            <summary>
            The block content presented as an editable buffer
            </summary>
        </member>
        <member name="F:Z0.CharBlock512.CharCount">
            <summary>
            The block capacity
            </summary>
        </member>
        <member name="T:Z0.CharBlock6">
            <summary>
            Defines a character block b with capacity(b) = 6
            </summary>
        </member>
        <member name="F:Z0.CharBlock6.Lo">
            <summary>
            The lower content
            </summary>
        </member>
        <member name="P:Z0.CharBlock6.Data">
            <summary>
            The block content presented as an editable buffer
            </summary>
        </member>
        <member name="F:Z0.CharBlock6.CharCount">
            <summary>
            The block capacity
            </summary>
        </member>
        <member name="F:Z0.CharBlock7.Lo">
            <summary>
            The lower content
            </summary>
        </member>
        <member name="F:Z0.CharBlock7.Hi">
            <summary>
            The upper content
            </summary>
        </member>
        <member name="P:Z0.CharBlock7.Data">
            <summary>
            The block content presented as an editable buffer
            </summary>
        </member>
        <member name="F:Z0.CharBlock7.CharCount">
            <summary>
            The block capacity
            </summary>
        </member>
        <member name="F:Z0.CharBlock8.Lo">
            <summary>
            The lower content
            </summary>
        </member>
        <member name="P:Z0.CharBlock8.Data">
            <summary>
            The block content presented as an editable buffer
            </summary>
        </member>
        <member name="F:Z0.CharBlock8.CharCount">
            <summary>
            The block capacity
            </summary>
        </member>
        <member name="F:Z0.CharBlock9.A">
            <summary>
            The upper segment
            </summary>
        </member>
        <member name="P:Z0.CharBlock9.Data">
            <summary>
            The block content presented as an editable buffer
            </summary>
        </member>
        <member name="F:Z0.CharBlock9.CharCount">
            <summary>
            The block capacity
            </summary>
        </member>
        <member name="F:Z0.CharBlock12.Lo">
            <summary>
            The lower content
            </summary>
        </member>
        <member name="F:Z0.CharBlock12.Hi">
            <summary>
            The upper content
            </summary>
        </member>
        <member name="P:Z0.CharBlock12.Data">
            <summary>
            The block content presented as an editable buffer
            </summary>
        </member>
        <member name="T:Z0.CharBlock13">
            <summary>
            Defines a character block b with capacity(b) = 13x16u
            </summary>
        </member>
        <member name="F:Z0.CharBlock13.Lo">
            <summary>
            The upper segment
            </summary>
        </member>
        <member name="F:Z0.CharBlock13.Hi">
            <summary>
            The upper content
            </summary>
        </member>
        <member name="P:Z0.CharBlock13.Data">
            <summary>
            The block content presented as an editable buffer
            </summary>
        </member>
        <member name="T:Z0.CharBlock14">
            <summary>
            Defines a character block b with capacity(b) = 14x16u
            </summary>
        </member>
        <member name="F:Z0.CharBlock14.Lo">
            <summary>
            The lower content
            </summary>
        </member>
        <member name="F:Z0.CharBlock14.Hi">
            <summary>
            The upper content
            </summary>
        </member>
        <member name="T:Z0.CharBlock15">
            <summary>
            Defines a character block b with capacity(b) = 15x16u
            </summary>
        </member>
        <member name="F:Z0.CharBlock15.Lo">
            <summary>
            The upper segment
            </summary>
        </member>
        <member name="F:Z0.CharBlock15.Hi">
            <summary>
            The upper content
            </summary>
        </member>
        <member name="T:Z0.CharBlock16">
            <summary>
            Defines a character block b with capacity(b) = 16x16u
            </summary>
        </member>
        <member name="F:Z0.CharBlock16.Lo">
            <summary>
            The lower content
            </summary>
        </member>
        <member name="F:Z0.CharBlock16.Hi">
            <summary>
            The upper content
            </summary>
        </member>
        <member name="T:Z0.CharBlock32">
            <summary>
            Defines a character block b with capacity(b) = 32x16u
            </summary>
        </member>
        <member name="F:Z0.CharBlock32.Lo">
            <summary>
            The lower content
            </summary>
        </member>
        <member name="F:Z0.CharBlock32.Hi">
            <summary>
            The upper content
            </summary>
        </member>
        <member name="T:Z0.CharBlock64">
            <summary>
            Defines a character block b with capacity(b) = 64x16u
            </summary>
        </member>
        <member name="F:Z0.CharBlock64.Lo">
            <summary>
            The lower content
            </summary>
        </member>
        <member name="T:Z0.CharBlock128">
            <summary>
            Defines a character block b with capacity(b) = 128x16u
            </summary>
        </member>
        <member name="F:Z0.CharBlock128.Lo">
            <summary>
            The lower content
            </summary>
        </member>
        <member name="F:Z0.CharBlock128.Hi">
            <summary>
            The lower segment
            </summary>
        </member>
        <member name="T:Z0.CharBlock256">
            <summary>
            Defines a character block b with capacity(b) = 256x16u
            </summary>
        </member>
        <member name="F:Z0.CharBlock256.Lo">
            <summary>
            The lower content
            </summary>
        </member>
        <member name="F:Z0.CharBlock256.Hi">
            <summary>
            The upper content
            </summary>
        </member>
        <member name="M:Z0.BlockedKinds.kind(System.Type)">
            <summary>
            Determines the block classifier for a blocked type
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.BlockedKinds.segment(System.Type)">
            <summary>
            Determines the segment kind classifier for a blocked type
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="T:Z0.SpanBlock128`1">
            <summary>
            Defines a span of contiguous memory that can be evenly partitioned into 8, 16, 32, 64 and 128-bit segments
            </summary>
        </member>
        <member name="P:Z0.SpanBlock128`1.Data">
            <summary>
            The backing storage
            </summary>
        </member>
        <member name="P:Z0.SpanBlock128`1.Head">
            <summary>
            The leading storage cell
            </summary>
        </member>
        <member name="P:Z0.SpanBlock128`1.IsEmpty">
            <summary>
            True if no capacity exists, false otherwise
            </summary>
        </member>
        <member name="P:Z0.SpanBlock128`1.CellCount">
            <summary>
            The number of allocated cells
            </summary>
        </member>
        <member name="P:Z0.SpanBlock128`1.BlockLength">
            <summary>
            The number of cells in a block
            </summary>
        </member>
        <member name="P:Z0.SpanBlock128`1.BlockCount">
            <summary>
            The number of covered blocks
            </summary>
        </member>
        <member name="P:Z0.SpanBlock128`1.BitCount">
            <summary>
            The number of covered bits
            </summary>
        </member>
        <member name="P:Z0.SpanBlock128`1.Item(System.Int32)">
            <summary>
            Mediates access to the underlying storage cells via linear index
            </summary>
        </member>
        <member name="P:Z0.SpanBlock128`1.Item(System.Int32,System.Int32)">
            <summary>
            Mediates access to the the underlying storage cells via block index and block-relative cell index
            </summary>
        </member>
        <member name="P:Z0.SpanBlock128`1.Bytes">
            <summary>
            Presents the source data as bytespan
            </summary>
        </member>
        <member name="M:Z0.SpanBlock128`1.Cell(System.Int32,System.Int32)">
            <summary>
            Mediates access to the the underlying storage cells via block index and block-relative cell index
            </summary>
            <param name="block">The block index</param>
            <param name="segment">The cell relative block index</param>
        </member>
        <member name="M:Z0.SpanBlock128`1.Block(System.Int32)">
            <summary>
            Retrieves an index-identified data block
            </summary>
            <param name="block">The block index</param>
        </member>
        <member name="M:Z0.SpanBlock128`1.Extract(System.Int32)">
            <summary>
            Extracts an index-identified block (non-allocating, but not free due to the price of creating a new wrapper)
            </summary>
            <param name="block">The block index</param>
        </member>
        <member name="M:Z0.SpanBlock128`1.Fill(`0)">
            <summary>
            Broadcasts a value to all blocked cells
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.SpanBlock128`1.Clear">
            <summary>
            Zero-fills all blocked cells
            </summary>
        </member>
        <member name="M:Z0.SpanBlock128`1.CopyTo(System.Span{`0})">
            <summary>
            Copies blocked content to a target span
            </summary>
            <param name="dst">The target span</param>
        </member>
        <member name="M:Z0.SpanBlock128`1.As``1">
            <summary>
            Reinterprets the storage cell type
            </summary>
            <typeparam name="S">The target cell type</typeparam>
        </member>
        <member name="T:Z0.SpanBlock16`1">
            <summary>
            Defines a span of contiguous memory that can be evenly partitioned into 8 and 16-bit segments
            </summary>
        </member>
        <member name="P:Z0.SpanBlock16`1.Data">
            <summary>
            The backing storage
            </summary>
        </member>
        <member name="P:Z0.SpanBlock16`1.Head">
            <summary>
            The leading storage cell
            </summary>
        </member>
        <member name="P:Z0.SpanBlock16`1.CellCount">
            <summary>
            The number of allocated cells
            </summary>
        </member>
        <member name="P:Z0.SpanBlock16`1.BlockLength">
            <summary>
            The number of cells in a block
            </summary>
        </member>
        <member name="P:Z0.SpanBlock16`1.BlockCount">
            <summary>
            The number of covered blocks
            </summary>
        </member>
        <member name="P:Z0.SpanBlock16`1.BitCount">
            <summary>
            The number of covered bits
            </summary>
        </member>
        <member name="P:Z0.SpanBlock16`1.Item(System.Int32)">
            <summary>
            Mediates access to the underlying storage cells via linear index
            </summary>
        </member>
        <member name="P:Z0.SpanBlock16`1.Item(System.Int32,System.Int32)">
            <summary>
            Mediates access to the the underlying storage cells via block index and block-relative cell index
            </summary>
        </member>
        <member name="P:Z0.SpanBlock16`1.Bytes">
            <summary>
            Presents the source data as bytespan
            </summary>
        </member>
        <member name="M:Z0.SpanBlock16`1.Cell(System.Int32,System.Int32)">
            <summary>
            Mediates access to the the underlying storage cells via block index and block-relative cell index
            </summary>
            <param name="block">The block index</param>
            <param name="segment">The cell relative block index</param>
        </member>
        <member name="M:Z0.SpanBlock16`1.Block(System.Int32)">
            <summary>
            Retrieves an index-identified data block
            </summary>
            <param name="block">The block index</param>
        </member>
        <member name="M:Z0.SpanBlock16`1.Extract(System.Int32)">
            <summary>
            Extracts an index-identified block (non-allocating, but not free due to the price of creating a new wrapper)
            </summary>
            <param name="block">The block index</param>
        </member>
        <member name="M:Z0.SpanBlock16`1.Fill(`0)">
            <summary>
            Broadcasts a value to all blocked cells
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.SpanBlock16`1.Clear">
            <summary>
            Zero-fills all blocked cells
            </summary>
        </member>
        <member name="M:Z0.SpanBlock16`1.CopyTo(System.Span{`0})">
            <summary>
            Copies blocked content to a target span
            </summary>
            <param name="dst">The target span</param>
        </member>
        <member name="M:Z0.SpanBlock16`1.As``1">
            <summary>
            Reinterprets the storage cell type
            </summary>
            <typeparam name="S">The target cell type</typeparam>
        </member>
        <member name="T:Z0.SpanBlock256`1">
            <summary>
            Defines a span of contiguous memory that can be evenly partitioned into 8, 16, 32, 64, 128 and 256-bit segments
            </summary>
        </member>
        <member name="P:Z0.SpanBlock256`1.Data">
            <summary>
            The unblocked storage cells
            </summary>
        </member>
        <member name="P:Z0.SpanBlock256`1.Head">
            <summary>
            The leading storage cell
            </summary>
        </member>
        <member name="P:Z0.SpanBlock256`1.IsEmpty">
            <summary>
            True if no capacity exists, false otherwise
            </summary>
        </member>
        <member name="P:Z0.SpanBlock256`1.CellCount">
            <summary>
            The number of covered cells
            </summary>
        </member>
        <member name="P:Z0.SpanBlock256`1.BlockLength">
            <summary>
            The number of cells in a block
            </summary>
        </member>
        <member name="P:Z0.SpanBlock256`1.BlockCount">
            <summary>
            The number of covered blocks
            </summary>
        </member>
        <member name="P:Z0.SpanBlock256`1.BitCount">
            <summary>
            The number of covered bits
            </summary>
        </member>
        <member name="P:Z0.SpanBlock256`1.Item(System.Int32)">
            <summary>
            Mediates access to the underlying storage cells via linear index
            </summary>
        </member>
        <member name="P:Z0.SpanBlock256`1.Item(System.Int32,System.Int32)">
            <summary>
            Mediates access to the the underlying storage cells via block index and block-relative cell index
            </summary>
        </member>
        <member name="P:Z0.SpanBlock256`1.Bytes">
            <summary>
            Presents the source data as bytespan
            </summary>
        </member>
        <member name="M:Z0.SpanBlock256`1.Cell(System.Int32,System.Int32)">
            <summary>
            Mediates access to the the underlying storage cells via block index and block-relative cell index
            </summary>
            <param name="block">The block index</param>
            <param name="segment">The cell relative block index</param>
        </member>
        <member name="M:Z0.SpanBlock256`1.Block(System.Int32)">
            <summary>
            Retrieves an index-identified data block
            </summary>
            <param name="block">The block index</param>
        </member>
        <member name="M:Z0.SpanBlock256`1.Extract(System.Int32)">
            <summary>
            Extracts an index-identified block (non-allocating, but not free due to the price of creating a new wrapper)
            </summary>
            <param name="block">The block index</param>
        </member>
        <member name="M:Z0.SpanBlock256`1.Fill(`0)">
            <summary>
            Broadcasts a value to all blocked cells
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.SpanBlock256`1.Clear">
            <summary>
            Zero-fills all blocked cells
            </summary>
        </member>
        <member name="M:Z0.SpanBlock256`1.CopyTo(System.Span{`0})">
            <summary>
            Copies blocked content to a target span
            </summary>
            <param name="dst">The target span</param>
        </member>
        <member name="M:Z0.SpanBlock256`1.As``1">
            <summary>
            Reinterprets the storage cell type
            </summary>
            <typeparam name="S">The target cell type</typeparam>
        </member>
        <member name="T:Z0.SpanBlock32`1">
            <summary>
            Defines a span of contiguous memory that can be evenly partitioned into 8, 16 and 32-bit segments
            </summary>
        </member>
        <member name="P:Z0.SpanBlock32`1.Head">
            <summary>
            The leading storage cell
            </summary>
        </member>
        <member name="P:Z0.SpanBlock32`1.CellCount">
            <summary>
            The number of allocated cells
            </summary>
        </member>
        <member name="P:Z0.SpanBlock32`1.BlockLength">
            <summary>
            The number of cells in a block
            </summary>
        </member>
        <member name="P:Z0.SpanBlock32`1.BlockCount">
            <summary>
            The number of covered blocks
            </summary>
        </member>
        <member name="P:Z0.SpanBlock32`1.BitCount">
            <summary>
            The number of covered bits
            </summary>
        </member>
        <member name="P:Z0.SpanBlock32`1.Item(System.Int32)">
            <summary>
            Mediates access to the underlying storage cells via linear index
            </summary>
        </member>
        <member name="P:Z0.SpanBlock32`1.Item(System.Int32,System.Int32)">
            <summary>
            Mediates access to the the underlying storage cells via block index and block-relative cell index
            </summary>
        </member>
        <member name="P:Z0.SpanBlock32`1.Bytes">
            <summary>
            Presents the source data as bytespan
            </summary>
        </member>
        <member name="M:Z0.SpanBlock32`1.Cell(System.Int32,System.Int32)">
            <summary>
            Mediates access to the the underlying storage cells via block index and block-relative cell index
            </summary>
            <param name="block">The block index</param>
            <param name="segment">The cell relative block index</param>
        </member>
        <member name="M:Z0.SpanBlock32`1.Block(System.Int32)">
            <summary>
            Retrieves an index-identified data block
            </summary>
            <param name="block">The block index</param>
        </member>
        <member name="M:Z0.SpanBlock32`1.Extract(System.Int32)">
            <summary>
            Extracts an index-identified block (non-allocating, but not free due to the price of creating a new wrapper)
            </summary>
            <param name="block">The block index</param>
        </member>
        <member name="M:Z0.SpanBlock32`1.Clear">
            <summary>
            Zero-fills all blocked cells
            </summary>
        </member>
        <member name="M:Z0.SpanBlock32`1.CopyTo(System.Span{`0})">
            <summary>
            Copies blocked content to a target span
            </summary>
            <param name="dst">The target span</param>
        </member>
        <member name="M:Z0.SpanBlock32`1.As``1">
            <summary>
            Reinterprets the storage cell type
            </summary>
            <typeparam name="S">The target cell type</typeparam>
        </member>
        <member name="T:Z0.SpanBlock512`1">
            <summary>
            Defines a span of contiguous memory that can be evenly partitioned into 8, 16, 32, 64, 128, 256 and 512-bit segments
            </summary>
        </member>
        <member name="P:Z0.SpanBlock512`1.Data">
            <summary>
            The unblocked storage cells
            </summary>
        </member>
        <member name="P:Z0.SpanBlock512`1.Head">
            <summary>
            The leading storage cell
            </summary>
        </member>
        <member name="P:Z0.SpanBlock512`1.IsEmpty">
            <summary>
            True if no capacity exists, false otherwise
            </summary>
        </member>
        <member name="P:Z0.SpanBlock512`1.CellCount">
            <summary>
            The number of allocated cells
            </summary>
        </member>
        <member name="P:Z0.SpanBlock512`1.BlockLength">
            <summary>
            The number of cells in a block
            </summary>
        </member>
        <member name="P:Z0.SpanBlock512`1.BlockCount">
            <summary>
            The number of covered blocks
            </summary>
        </member>
        <member name="P:Z0.SpanBlock512`1.BitCount">
            <summary>
            The number of covered bits
            </summary>
        </member>
        <member name="P:Z0.SpanBlock512`1.Item(System.Int32)">
            <summary>
            Mediates access to the underlying storage cells via linear index
            </summary>
        </member>
        <member name="P:Z0.SpanBlock512`1.Item(System.Int32,System.Int32)">
            <summary>
            Mediates access to the the underlying storage cells via block index and block-relative cell index
            </summary>
        </member>
        <member name="P:Z0.SpanBlock512`1.Bytes">
            <summary>
            Presents the source data as bytespan
            </summary>
        </member>
        <member name="M:Z0.SpanBlock512`1.Cell(System.Int32,System.Int32)">
            <summary>
            Mediates access to the the underlying storage cells via block index and block-relative cell index
            </summary>
            <param name="block">The block index</param>
            <param name="segment">The cell relative block index</param>
        </member>
        <member name="M:Z0.SpanBlock512`1.Block(System.Int32)">
            <summary>
            Retrieves an index-identified data block
            </summary>
            <param name="block">The block index</param>
        </member>
        <member name="M:Z0.SpanBlock512`1.Extract(System.Int32)">
            <summary>
            Extracts an index-identified block (non-allocating, but not free due to the price of creating a new wrapper)
            </summary>
            <param name="block">The block index</param>
        </member>
        <member name="M:Z0.SpanBlock512`1.LoBlock(System.Int32)">
            <summary>
            Retrieves the lower 256 bits of an index-identified block
            </summary>
            <param name="block">The block-relative index</param>
        </member>
        <member name="M:Z0.SpanBlock512`1.HiBlock(System.Int32)">
            <summary>
            Retrieves the upper 256 bits of an index-identified block
            </summary>
            <param name="block">The block-relative index</param>
        </member>
        <member name="M:Z0.SpanBlock512`1.Fill(`0)">
            <summary>
            Broadcasts a value to all blocked cells
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.SpanBlock512`1.Clear">
            <summary>
            Zero-fills all blocked cells
            </summary>
        </member>
        <member name="M:Z0.SpanBlock512`1.CopyTo(System.Span{`0})">
            <summary>
            Copies blocked content to a target span
            </summary>
            <param name="dst">The target span</param>
        </member>
        <member name="M:Z0.SpanBlock512`1.As``1">
            <summary>
            Reinterprets the storage cell type
            </summary>
            <typeparam name="S">The target cell type</typeparam>
        </member>
        <member name="T:Z0.SpanBlock64`1">
            <summary>
            Defines a span of contiguous memory that can be evenly partitioned into 8, 16, 32 and 64-bit segments
            </summary>
        </member>
        <member name="P:Z0.SpanBlock64`1.Data">
            <summary>
            The unblocked storage cells
            </summary>
        </member>
        <member name="P:Z0.SpanBlock64`1.Head">
            <summary>
            The leading storage cell
            </summary>
        </member>
        <member name="P:Z0.SpanBlock64`1.CellCount">
            <summary>
            The number of allocated cells
            </summary>
        </member>
        <member name="P:Z0.SpanBlock64`1.BlockLength">
            <summary>
            The number of cells in a block
            </summary>
        </member>
        <member name="P:Z0.SpanBlock64`1.BlockCount">
            <summary>
            The number of covered blocks
            </summary>
        </member>
        <member name="P:Z0.SpanBlock64`1.BitCount">
            <summary>
            The number of covered bits
            </summary>
        </member>
        <member name="P:Z0.SpanBlock64`1.Item(System.Int32)">
            <summary>
            Mediates access to the underlying storage cells via linear index
            </summary>
        </member>
        <member name="P:Z0.SpanBlock64`1.Item(System.Int32,System.Int32)">
            <summary>
            Mediates access to the the underlying storage cells via block index and block-relative cell index
            </summary>
        </member>
        <member name="P:Z0.SpanBlock64`1.Bytes">
            <summary>
            Presents the source data as bytespan
            </summary>
        </member>
        <member name="M:Z0.SpanBlock64`1.Cell(System.Int32,System.Int32)">
            <summary>
            Mediates access to the the underlying storage cells via block index and block-relative cell index
            </summary>
            <param name="block">The block index</param>
            <param name="segment">The cell relative block index</param>
        </member>
        <member name="M:Z0.SpanBlock64`1.Block(System.Int32)">
            <summary>
            Produces a span that covers the cells of an index-identified block
            </summary>
            <param name="block">The block index</param>
        </member>
        <member name="M:Z0.SpanBlock64`1.Extract(System.Int32)">
            <summary>
            Extracts an index-identified block (non-allocating, but not free due to the price of creating a new wrapper)
            </summary>
            <param name="block">The block index</param>
        </member>
        <member name="M:Z0.SpanBlock64`1.Fill(`0)">
            <summary>
            Broadcasts a value to all blocked cells
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.SpanBlock64`1.Clear">
            <summary>
            Zero-fills all blocked cells
            </summary>
        </member>
        <member name="M:Z0.SpanBlock64`1.CopyTo(System.Span{`0})">
            <summary>
            Copies blocked content to a target span
            </summary>
            <param name="dst">The target span</param>
        </member>
        <member name="M:Z0.SpanBlock64`1.As``1">
            <summary>
            Reinterprets the storage cell type
            </summary>
            <typeparam name="S">The target cell type</typeparam>
        </member>
        <member name="T:Z0.SpanBlock8`1">
            <summary>
            Defines a span of contiguous memory that can be evenly partitioned into 8-bit segments
            </summary>
        </member>
        <member name="P:Z0.SpanBlock8`1.Data">
            <summary>
            The backing storage
            </summary>
        </member>
        <member name="P:Z0.SpanBlock8`1.Head">
            <summary>
            The leading storage cell
            </summary>
        </member>
        <member name="P:Z0.SpanBlock8`1.CellCount">
            <summary>
            The number of allocated cells
            </summary>
        </member>
        <member name="P:Z0.SpanBlock8`1.BlockLength">
            <summary>
            The number of cells in a block
            </summary>
        </member>
        <member name="P:Z0.SpanBlock8`1.BlockCount">
            <summary>
            The number of covered blocks
            </summary>
        </member>
        <member name="P:Z0.SpanBlock8`1.BitCount">
            <summary>
            The number of covered bits
            </summary>
        </member>
        <member name="P:Z0.SpanBlock8`1.Item(System.Int32)">
            <summary>
            Mediates access to the underlying storage cells via linear index
            </summary>
        </member>
        <member name="P:Z0.SpanBlock8`1.Item(System.Int32,System.Int32)">
            <summary>
            Mediates access to the the underlying storage cells via block index and block-relative cell index
            </summary>
        </member>
        <member name="P:Z0.SpanBlock8`1.Bytes">
            <summary>
            Presents the source data as bytespan
            </summary>
        </member>
        <member name="M:Z0.SpanBlock8`1.Cell(System.Int32,System.Int32)">
            <summary>
            Mediates access to the the underlying storage cells via block index and block-relative cell index
            </summary>
            <param name="block">The block index</param>
            <param name="segment">The cell relative block index</param>
        </member>
        <member name="M:Z0.SpanBlock8`1.Block(System.Int32)">
            <summary>
            Retrieves an index-identified data block
            </summary>
            <param name="block">The block index</param>
        </member>
        <member name="M:Z0.SpanBlock8`1.Extract(System.Int32)">
            <summary>
            Extracts an index-identified block (non-allocating, but not free due to the price of creating a new wrapper)
            </summary>
            <param name="block">The block index</param>
        </member>
        <member name="M:Z0.SpanBlock8`1.Fill(`0)">
            <summary>
            Broadcasts a value to all blocked cells
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.SpanBlock8`1.Clear">
            <summary>
            Zero-fills all blocked cells
            </summary>
        </member>
        <member name="M:Z0.SpanBlock8`1.CopyTo(System.Span{`0})">
            <summary>
            Copies blocked content to a target span
            </summary>
            <param name="dst">The target span</param>
        </member>
        <member name="M:Z0.SpanBlock8`1.As``1">
            <summary>
            Reinterprets the storage cell type
            </summary>
            <typeparam name="S">The target cell type</typeparam>
        </member>
        <member name="M:Z0.NatSpan.bytes``1(System.Span{``0},Z0.N16)">
            <summary>
            Loads a bytespan of natural length 16 from a generic source span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.NatSpan.bytes``2(System.Span{``1},``0)">
            <summary>
            Loads a bytespan of natural length from a generic source span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.NatSpan.alloc``2(``0,``1)">
            <summary>
            Allocates span of natural length
            </summary>
            <param name="n">The cell count representative</param>
            <param name="t">A cell type representative</param>
            <typeparam name="N">The cell count type</typeparam>
            <typeparam name="T">The cell data type</typeparam>
        </member>
        <member name="M:Z0.NatSpan.broadcast``2(``1,Z0.NatSpan{``0,``1}@)">
            <summary>
            Fills a target block with replicated cell data
            </summary>
            <param name="data">The data used to fill the block</param>
            <param name="dst">The target block</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.NatSpan.load``2(``1@,``0)">
            <summary>
            Loads a natural block from a reference
            </summary>
            <param name="src">The source reference</param>
            <param name="n">The length representative</param>
            <typeparam name="N">The length type</typeparam>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.aligned``1(Z0.W8,System.Int32)">
            <summary>
            Determines whether a specified number of elements can be evenly covered by 8-bit segments
            </summary>
            <param name="count">The element count</param>
            <typeparam name="T">The block constituent type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.aligned``1(Z0.W16,System.Int32)">
            <summary>
            Determines whether a specified number of elements can be evenly covered by 16-bit segments
            </summary>
            <param name="count">The element count</param>
            <typeparam name="T">The block constituent type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.aligned``1(Z0.W32,System.Int32)">
            <summary>
            Determines whether a specified number of elements can be evenly covered by 32-bit segments
            </summary>
            <param name="count">The element count</param>
            <typeparam name="T">The block constituent type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.aligned``1(Z0.W64,System.Int32)">
            <summary>
            Determines whether a specified number of elements can be evenly covered by 64-bit segments
            </summary>
            <param name="count">The element count</param>
            <typeparam name="T">The block constituent type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.aligned``1(Z0.W128,System.Int32)">
            <summary>
            Determines whether a specified number of elements can be evenly covered by 128-bit segments
            </summary>
            <param name="count">The element count</param>
            <typeparam name="T">The block constituent type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.aligned``1(Z0.W256,System.Int32)">
            <summary>
            Determines whether a specified number of elements can be evenly covered by 256-bit segments
            </summary>
            <param name="count">The element count</param>
            <typeparam name="T">The block element type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.aligned``1(Z0.W512,System.Int32)">
            <summary>
            Determines whether a specified number of elements can be evenly covered by 512-bit segments
            </summary>
            <param name="count">The element count</param>
            <typeparam name="T">The block element type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.alloc``1(Z0.W8)">
            <summary>
            Allocates a single 8-bit block
            </summary>
            <param name="w">The block width selector</param>
            <param name="t">The cell type representative</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.alloc``1(Z0.W16)">
            <summary>
            Allocates a single 16-bit block
            </summary>
            <param name="w">The block width selector</param>
            <param name="t">The cell type representative</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.alloc``1(Z0.W32)">
            <summary>
            Allocates a single 32-bit block
            </summary>
            <param name="w">The block width selector</param>
            <param name="t">The cell type representative</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.alloc``1(Z0.W64)">
            <summary>
            Allocates a single 64-bit block
            </summary>
            <param name="w">The block width selector</param>
            <param name="t">The cell type representative</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.alloc``1(Z0.W128)">
            <summary>
            Allocates a single 128-bit block over cells of parametric kind
            </summary>
            <param name="w">The block width selector</param>
            <param name="t">The cell type representative</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.alloc``1(Z0.W256)">
            <summary>
            Allocates a single 256-bit block
            </summary>
            <param name="w">The block width selector</param>
            <param name="t">The cell type representative</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.alloc``1(Z0.W512)">
            <summary>
            Allocates a single 512-bit block
            </summary>
            <param name="w">The block width selector</param>
            <param name="t">The cell type representative</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.alloc``1(Z0.W8,System.UInt64,``0)">
            <summary>
            Allocates a specified number of 8-bit blocks, filled with an optional pattern
            </summary>
            <param name="w">The block width selector</param>
            <param name="count">The block allocation count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.alloc``1(Z0.W16,System.UInt64,``0)">
            <summary>
            Allocates a specified number of 16-bit blocks, filled with an optional pattern
            </summary>
            <param name="w">The block width selector</param>
            <param name="count">The block allocation count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.alloc``1(Z0.W32,System.UInt64,``0)">
            <summary>
            Allocates a specified number of 32-bit blocks, filled with an optional pattern
            </summary>
            <param name="w">The block width selector</param>
            <param name="count">The block allocation count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.alloc``1(Z0.W64,System.UInt64,``0)">
            <summary>
            Allocates a specified number of 64-bit blocks, filled with an optional pattern
            </summary>
            <param name="w">The block width selector</param>
            <param name="count">The block allocation count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.alloc``1(Z0.W128,System.UInt64,``0)">
            <summary>
            Allocates a specified number of 128-bit blocks
            </summary>
            <param name="w">The block width selector</param>
            <param name="count">The block allocation count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.alloc``1(Z0.W256,System.UInt64,``0)">
            <summary>
            Allocates a specified number of 256-bit blocks
            </summary>
            <param name="w">The block width selector</param>
            <param name="count">The block allocation count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.alloc``1(Z0.W512,System.UInt64,``0)">
            <summary>
            Allocates a specified number of 512-bit blocks
            </summary>
            <param name="w">The block width selector</param>
            <param name="blocks">The block allocation count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.alloc``1(Z0.W8,System.Int64,``0)">
            <summary>
            Allocates a specified number of 8-bit blocks, filled with an optional pattern
            </summary>
            <param name="w">The block width selector</param>
            <param name="count">The block allocation count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.alloc``1(Z0.W16,System.Int64,``0)">
            <summary>
            Allocates a specified number of 16-bit blocks, filled with an optional pattern
            </summary>
            <param name="w">The block width selector</param>
            <param name="count">The block allocation count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.alloc``1(Z0.W32,System.Int64,``0)">
            <summary>
            Allocates a specified number of 32-bit blocks, filled with an optional pattern
            </summary>
            <param name="w">The block width selector</param>
            <param name="count">The block allocation count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.alloc``1(Z0.W64,System.Int64,``0)">
            <summary>
            Allocates a specified number of 64-bit blocks, filled with an optional pattern
            </summary>
            <param name="w">The block width selector</param>
            <param name="count">The block allocation count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.alloc``1(Z0.W128,System.Int64,``0)">
            <summary>
            Allocates a specified number of 128-bit blocks
            </summary>
            <param name="w">The block width selector</param>
            <param name="count">The block allocation count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.alloc``1(Z0.W256,System.Int64,``0)">
            <summary>
            Allocates a specified number of 256-bit blocks
            </summary>
            <param name="w">The block width selector</param>
            <param name="blocks">The block allocation count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.alloc``1(Z0.W512,System.Int64,``0)">
            <summary>
            Allocates a specified number of 512-bit blocks
            </summary>
            <param name="w">The block width selector</param>
            <param name="blocks">The block allocation count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.bitcount(System.UInt32,System.UInt32)">
            <summary>
            Computes the number of bits covered by a specified cell count and width
            </summary>
            <param name="cellcount">The number of allocated cells</param>
            <param name="cellwidth">The bit-width of a cell</param>
        </member>
        <member name="M:Z0.SpanBlocks.bitcount``1(System.UInt32)">
            <summary>
            Computes  the number of bits covered by a specified cell count of parametric type
            </summary>
            <param name="cellcount">The number of allocated cells</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.bitcover(System.UInt32,System.UInt32)">
            <summary>
            Computes the number of blocks required to cover a specified number of bits
            </summary>
            <param name="bitcount">The source bit count</param>
            <param name="blockwidth">The block width in bits</param>
        </member>
        <member name="M:Z0.SpanBlocks.bitcover``1(System.UInt32)">
            <summary>
            Computes the number of blocks required to cover a specified number of bits
            </summary>
            <param name="dstblockbits">The target block size in bits</param>
        </member>
        <member name="M:Z0.SpanBlocks.blockcount``1(Z0.W8,System.Int32)">
            <summary>
            Computes the whole number of blocks that cover a specified count of T-cells
            </summary>
            <param name="w">The block width</param>
            <param name="cells">The cell count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.blockcount``1(Z0.W16,System.Int32)">
            <summary>
            Computes the whole number of blocks that cover a specified count of T-cells
            </summary>
            <param name="w">The block width</param>
            <param name="cells">The cell count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.blockcount``1(Z0.W32,System.Int32)">
            <summary>
            Computes the whole number of blocks that cover a specified count of T-cells
            </summary>
            <param name="w">The block width</param>
            <param name="cells">The cell count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.blockcount``1(Z0.W64,System.Int32)">
            <summary>
            Computes the whole number of blocks that cover a specified count of T-cells
            </summary>
            <param name="w">The block width</param>
            <param name="cells">The cell count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.blockcount``1(Z0.W128,System.Int32)">
            <summary>
            Computes the whole number of blocks that cover a specified count of T-cells
            </summary>
            <param name="w">The block width</param>
            <param name="cells">The cell count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.blockcount``1(Z0.W256,System.Int32)">
            <summary>
            Computes the whole number of blocks that cover a specified count of T-cells
            </summary>
            <param name="w">The block width</param>
            <param name="cells">The cell count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.blockcount``1(Z0.W512,System.Int32)">
            <summary>
            Computes the whole number of blocks that cover a specified count of T-cells
            </summary>
            <param name="w">The block width</param>
            <param name="cells">The cell count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.blockcount``1(Z0.W8,System.Int32,System.Int32@)">
            <summary>
            Computes the whole number of blocks that cover a specified count of T-cells
            and reveals the number of cells that remain uncovered
            </summary>
            <param name="w">The block width</param>
            <param name="cells">The cell count</param>
            <param name="uncovered">The number of cells that remain uncovered</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.blockcount``1(Z0.W16,System.Int32,System.Int32@)">
            <summary>
            Computes the whole number of blocks that cover a specified count of T-cells
            and reveals the number of cells that remain uncovered
            </summary>
            <param name="w">The block width</param>
            <param name="cells">The cell count</param>
            <param name="uncovered">The number of cells that remain uncovered</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.blockcount``1(Z0.W32,System.Int32,System.Int32@)">
            <summary>
            Computes the whole number of blocks that cover a specified count of T-cells
            and reveals the number of cells that remain uncovered
            </summary>
            <param name="w">The block width</param>
            <param name="cells">The cell count</param>
            <param name="uncovered">The number of cells that remain uncovered</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.blockcount``1(Z0.W64,System.Int32,System.Int32@)">
            <summary>
            Computes the whole number of blocks that cover a specified count of T-cells
            and reveals the number of cells that remain uncovered
            </summary>
            <param name="w">The block width</param>
            <param name="cells">The cell count</param>
            <param name="uncovered">The number of cells that remain uncovered</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.blockcount``1(Z0.W128,System.Int32,System.Int32@)">
            <summary>
            Computes the whole number of blocks that cover a specified count of T-cells
            and reveals the number of cells that remain uncovered
            </summary>
            <param name="w">The block width</param>
            <param name="cells">The cell count</param>
            <param name="uncovered">The number of cells that remain uncovered</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.blockcount``1(Z0.W256,System.Int32,System.Int32@)">
            <summary>
            Computes the whole number of blocks that cover a specified count of T-cells
            and reveals the number of cells that remain uncovered
            </summary>
            <param name="w">The block width</param>
            <param name="cells">The cell count</param>
            <param name="uncovered">The number of cells that remain uncovered</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.blockcount``1(Z0.W512,System.Int32,System.Int32@)">
            <summary>
            Computes the whole number of blocks that cover a specified count of T-cells
            and reveals the number of cells that remain uncovered
            </summary>
            <param name="w">The block width</param>
            <param name="cells">The cell count</param>
            <param name="uncovered">The number of cells that remain uncovered</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.blockcount``3(Z0.N256)">
            <summary>
            Computes the minimum number of 256-bit blocks that can hold a table of data
            </summary>
            <param name="srclen">The length of the source data</param>
            <typeparam name="M">The row type </typeparam>
            <typeparam name="N">The column type</typeparam>
            <typeparam name="T">The scalar type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.blockcount``3(Z0.W512)">
            <summary>
            Computes the minimum number of 512-bit blocks that can hold a table of data
            </summary>
            <param name="srclen">The length of the source data</param>
            <typeparam name="M">The row type </typeparam>
            <typeparam name="N">The column type</typeparam>
            <typeparam name="T">The scalar type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.blocklength``1(Z0.W8,``0)">
            <summary>
            Computes the number of cells that comprise a single 8-bit block
            </summary>
            <param name="w">The block width selector</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.blocklength``1(Z0.W16,``0)">
            <summary>
            Computes the number of cells that comprise a single 16-bit block
            </summary>
            <param name="w">The block width selector</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.blocklength``1(Z0.W32,``0)">
            <summary>
            Computes the number of cells that comprise a single 32-bit block
            </summary>
            <param name="w">The block width selector</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.blocklength``1(Z0.W64,``0)">
            <summary>
            Computes the number of cells that comprise a single 64-bit block
            </summary>
            <param name="w">The block width selector</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.blocklength``1(Z0.W128,``0)">
            <summary>
            Computes the number of cells that comprise a single 128-bit block
            </summary>
            <param name="w">The block width selector</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.blocklength``1(Z0.W256,``0)">
            <summary>
            Computes the number of elements that comprise a 256-bit block
            </summary>
            <param name="w">The block width selector</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.blocklength``1(Z0.W512,``0)">
            <summary>
            Computes the number of elements that comprise a 512-bit block
            </summary>
            <param name="w">The block width selector</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.blocklength``2(``0,``1)">
            <summary>
            Computes the number of T-cells that comprise an N-block
            </summary>
            <param name="w">The block width representative</param>
            <param name="t">The cell type representative</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.bytecount(System.Int32,System.Int32)">
            <summary>
            Computes the number of bytes covered by a specified cell count and width
            </summary>
            <param name="cellcount">The number of allocated cells</param>
            <param name="cellwidth">The bit-width of a cell</param>
        </member>
        <member name="M:Z0.SpanBlocks.bytecount``1(System.Int32)">
            <summary>
            Computes  the number of bytes covered by a specified cell count of parametric type
            </summary>
            <param name="cellcount">The number of allocated cells</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.cellalloc``1(Z0.W8,System.UInt64)">
            <summary>
            Allocates a sequence of 8-bit blocks sufficient to cover a specified number of cells
            </summary>
            <param name="n">The block width selector</param>
            <param name="cellcount">The number of cells to cover</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.cellalloc``1(Z0.W16,System.UInt64)">
            <summary>
            Allocates a sequence of 16-bit blocks sufficient to cover a specified number of cells
            </summary>
            <param name="n">The block width selector</param>
            <param name="cellcount">The number of cells to cover</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.cellalloc``1(Z0.W32,System.UInt64)">
            <summary>
            Allocates a sequence of 32-bit blocks sufficient to cover a specified number of cells
            </summary>
            <param name="n">The block width selector</param>
            <param name="cellcount">The number of cells to cover</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.cellalloc``1(Z0.W64,System.UInt64)">
            <summary>
            Allocates a sequence of 64-bit blocks sufficient to cover a specified number of cells
            </summary>
            <param name="n">The block width selector</param>
            <param name="cellcount">The number of cells to cover</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.cellalloc``1(Z0.W128,System.UInt64)">
            <summary>
            Allocates a sequence of 128-bit blocks sufficient to cover a specified number of cells
            </summary>
            <param name="n">The block width selector</param>
            <param name="cellcount">The number of cells to cover</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.cellalloc``1(Z0.W256,System.UInt64)">
            <summary>
            Allocates a sequence of 256-bit blocks sufficient to cover a specified number of cells
            </summary>
            <param name="n">The block width selector</param>
            <param name="cellcount">The number of cells to cover</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.cellalloc``1(Z0.W512,System.UInt64)">
            <summary>
            Allocates a sequence of 512-bit blocks sufficient to cover a specified number of cells
            </summary>
            <param name="n">The block width selector</param>
            <param name="cellcount">The number of cells to cover</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.cellblocks``1(Z0.W8,System.Int32)">
            <summary>
            Calculates the number of cells that comprise a specified number of blocks
            </summary>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.cellblocks``1(Z0.W16,System.Int32)">
            <summary>
            Calculates the number of cells that comprise a specified number of blocks
            </summary>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.cellblocks``1(Z0.W32,System.Int32)">
            <summary>
            Calculates the number of cells that comprise a specified number of blocks
            </summary>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.cellblocks``1(Z0.W64,System.Int32)">
            <summary>
            Calculates the number of cells that comprise a specified number of blocks
            </summary>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.cellblocks``1(Z0.W128,System.Int32)">
            <summary>
            Calculates the number of cells that comprise a specified number of blocks
            </summary>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.cellblocks``1(Z0.W256,System.Int32)">
            <summary>
            Calculates the number of cells that comprise a specified number of blocks
            </summary>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.cellblocks``1(Z0.W512,System.Int32)">
            <summary>
            Calculates the number of cells that comprise a specified number of blocks
            </summary>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.cellcover``1(Z0.W8,System.UInt64)">
            <summary>
            Computes the minimum number of 8-bit blocks required to cover a specified number of cells
            </summary>
            <param name="cellcount">The number of cells to cover</param>
            <typeparam name="T">The element type</typeparam>
            <remarks>If a constant/literal value is supplied for the cellcount parameter, the jitter will
            resolve the computation to a constant an no runtime computations will occur</remarks>
        </member>
        <member name="M:Z0.SpanBlocks.cellcover``1(Z0.W16,System.UInt64)">
            <summary>
            Computes the minimum number of 32-bit blocks required to cover a specified number of cells
            </summary>
            <param name="cellcount">The number of cells to cover</param>
            <typeparam name="T">The element type</typeparam>
            <remarks>If a constant/literal value is supplied for the cellcount parameter, the jitter will
            resolve the computation to a constant an no runtime computations will occur</remarks>
        </member>
        <member name="M:Z0.SpanBlocks.cellcover``1(Z0.W32,System.UInt64)">
            <summary>
            Computes the minimum number of 32-bit blocks required to cover a specified number of cells
            </summary>
            <param name="cellcount">The number of cells to cover</param>
            <typeparam name="T">The element type</typeparam>
            <remarks>If a constant/literal value is supplied for the cellcount parameter, the jitter will
            resolve the computation to a constant an no runtime computations will occur</remarks>
        </member>
        <member name="M:Z0.SpanBlocks.cellcover``1(Z0.W64,System.UInt64)">
            <summary>
            Computes the minimum number of 64-bit blocks required to cover a specified number of cells
            </summary>
            <param name="cellcount">The number of cells to cover</param>
            <typeparam name="T">The element type</typeparam>
            <remarks>If a constant/literal value is supplied for the cellcount parameter, the jitter will
            resolve the computation to a constant an no runtime computations will occur</remarks>
        </member>
        <member name="M:Z0.SpanBlocks.cellcover``1(Z0.W128,System.UInt64)">
            <summary>
            Computes the minimum number of 128-bit blocks required to cover a specified number of cells
            </summary>
            <param name="cellcount">The number of cells to cover</param>
            <typeparam name="T">The element type</typeparam>
            <remarks>If a constant/literal value is supplied for the cellcount parameter, the jitter will
            resolve the computation to a constant an no runtime computations will occur</remarks>
        </member>
        <member name="M:Z0.SpanBlocks.cellcover``1(Z0.W256,System.UInt64)">
            <summary>
            Computes the minimum number of 256-bit blocks required to cover a specified number of cells
            </summary>
            <param name="cellcount">The number of cells to cover</param>
            <typeparam name="T">The element type</typeparam>
            <remarks>If a constant/literal value is supplied for the cellcount parameter, the jitter will
            resolve the computation to a constant an no runtime computations will occur</remarks>
        </member>
        <member name="M:Z0.SpanBlocks.cellcover``1(Z0.W512,System.UInt64)">
            <summary>
            Computes the minimum number of 512-bit blocks required to cover a specified number of cells
            </summary>
            <param name="cellcount">The number of cells to cover</param>
            <typeparam name="T">The element type</typeparam>
            <remarks>If a constant/literal value is supplied for the cellcount parameter, the jitter will
            resolve the computation to a constant an no runtime computations will occur</remarks>
        </member>
        <member name="M:Z0.SpanBlocks.cellcover``4(``0,``1,``2,``3)">
            <summary>
            Computes the minimum numbet of W-blocks over T-cells required to cover a grid of natural dimensions MxN
            </summary>
            <param name="w">The block width represntative</param>
            <param name="m">The col count representative</param>
            <param name="n">The row count representative</param>
            <param name="t">The cell type representative</param>
            <typeparam name="W">The block type</typeparam>
            <typeparam name="M">The row type</typeparam>
            <typeparam name="N">The col type</typeparam>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.cellsize``1">
            <summary>
            Calculates the number of bytes required to represent a block constituent
            </summary>
            <typeparam name="T">The block constituent type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.convert``2(Z0.SpanBlock256{``0})">
            <summary>
            If possible, applies the conversion S -> T for each cell in the source block
            </summary>
            <param name="src">The source span</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.create(Z0.W8,System.Byte)">
            <summary>
            Creates a 8-bit blocked container from 1 8-bit cell
            </summary>
        </member>
        <member name="M:Z0.SpanBlocks.create(Z0.W16,System.UInt16)">
            <summary>
            Creates a 16-bit blocked container from 1 16-bit cell
            </summary>
        </member>
        <member name="M:Z0.SpanBlocks.create(Z0.W16,System.UInt64)">
            <summary>
            Creates a 16-bit blocked container from 1 64-bit cell
            </summary>
        </member>
        <member name="M:Z0.SpanBlocks.create(Z0.W32,System.UInt64)">
            <summary>
            Creates a 32-bit blocked container from 1 64-bit cell
            </summary>
        </member>
        <member name="M:Z0.SpanBlocks.create(Z0.W32,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Creates a 32-bit blocked container from 4 8-bit cells
            </summary>
        </member>
        <member name="M:Z0.SpanBlocks.create(Z0.W32,System.UInt16,System.UInt16)">
            <summary>
            Creates a 32-bit blocked container from 2 16-bit cells
            </summary>
        </member>
        <member name="M:Z0.SpanBlocks.create(Z0.W32,System.UInt32)">
            <summary>
            Creates a 32-bit blocked container from 1 32-bit cell
            </summary>
        </member>
        <member name="M:Z0.SpanBlocks.create(Z0.W64,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Creates a 64-bit blocked container from 8 8-bit cells
            </summary>
        </member>
        <member name="M:Z0.SpanBlocks.create(Z0.W64,System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Creates a 64-bit blocked container from 4 16-bit cells
            </summary>
        </member>
        <member name="M:Z0.SpanBlocks.create(Z0.W64,System.UInt32,System.UInt32)">
            <summary>
            Creates a 64-bit data block from 2 32-bit cells
            </summary>
        </member>
        <member name="M:Z0.SpanBlocks.create(Z0.W64,System.UInt64)">
            <summary>
            Creates a 64-bit data block from 1 64-bit cell
            </summary>
        </member>
        <member name="M:Z0.SpanBlocks.create(Z0.W128,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Creates a 128-bit blocked span from 8-bit cells
            </summary>
        </member>
        <member name="M:Z0.SpanBlocks.create(Z0.W128,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Creates a 128-bit blocked span from 16-bit cells
            </summary>
        </member>
        <member name="M:Z0.SpanBlocks.create(Z0.W128,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Creates a 128-bit blocked span from 4 32-bit cells
            </summary>
        </member>
        <member name="M:Z0.SpanBlocks.create(Z0.W128,System.UInt64,System.UInt64)">
            <summary>
            Creates a 128-bit blocked container from 2 64-bit cells
            </summary>
        </member>
        <member name="M:Z0.SpanBlocks.create(Z0.W256,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Creates a 256-bit blocked container from 32 8-bit cells
            </summary>
        </member>
        <member name="M:Z0.SpanBlocks.create(Z0.W256,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Creates a 256-bit blocked container from 16 16-bit cells
            </summary>
        </member>
        <member name="M:Z0.SpanBlocks.create(Z0.W256,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Creates a 256-bit blocked container from 8 32-bit cells
            </summary>
        </member>
        <member name="M:Z0.SpanBlocks.create(Z0.W256,System.UInt64,System.UInt64,System.UInt64,System.UInt64)">
            <summary>
            Creates a 256-bit blocked container from 4 64-bit cells
            </summary>
        </member>
        <member name="M:Z0.SpanBlocks.create(Z0.W512,System.UInt64,System.UInt64,System.UInt64,System.UInt64,System.UInt64,System.UInt64,System.UInt64,System.UInt64)">
            <summary>
            Creates a 512-bit blocked container from 8 64-bit cells
            </summary>
        </member>
        <member name="M:Z0.SpanBlocks.create(Z0.W512,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Creates a 512-bit blocked container from 16 32-bit cells
            </summary>
        </member>
        <member name="M:Z0.SpanBlocks.init``1(Z0.W8,System.Span{``0})">
            <summary>
            Loads a single 16-bit block from the leading elements of a source span (unchecked)
            </summary>
            <param name="w">The block width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.init``1(Z0.W16,System.Span{``0})">
            <summary>
            Loads a single 16-bit block from the leading elements of a source span (unchecked)
            </summary>
            <param name="w">The block width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.init``1(Z0.W32,System.Span{``0})">
            <summary>
            Loads a single 32-bit block from the leading elements of a source span (unchecked)
            </summary>
            <param name="w">The block width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.init``1(Z0.W64,System.Span{``0})">
            <summary>
            Loads a single 64-bit block from the leading elements of a source span (unchecked)
            </summary>
            <param name="w">The block width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.init``1(Z0.W128,System.Span{``0})">
            <summary>
            Loads a single 128-bit block from the leading elements of a source span (unchecked)
            </summary>
            <param name="w">The block width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.init``1(Z0.W256,System.Span{``0})">
            <summary>
            Loads a single 256-bit block from the leading elements of a source span (unchecked)
            </summary>
            <param name="w">The block width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.init``1(Z0.W512,System.Span{``0})">
            <summary>
            Loads a single 512-bit block from the leading elements of a source span (unchecked)
            </summary>
            <param name="w">The block width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.load``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>
            Allocates and deposits vector content to a data block
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The component type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.load``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>
            Allocates and deposits vector content to a data block
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The primitive type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.load``1(Z0.Vector512{``0})">
            <summary>
            Allocates and deposits vector content to a data block
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The primitive type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.load``1(Z0.W8,System.Span{``0},System.Int32)">
            <summary>
            Loads 8-bit segments from a span, raising an error if said source does not evenly partition
            </summary>
            <param name="w">The block width selector</param>
            <param name="src">The data source</param>
            <param name="offset">The source offset</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.load``1(Z0.W16,System.Span{``0},System.Int32)">
            <summary>
            Loads 16-bit segments from a span, raising an error if said source does not evenly partition
            </summary>
            <param name="w">The block width selector</param>
            <param name="src">The data source</param>
            <param name="offset">The source offset</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.load``1(Z0.W32,System.Span{``0},System.Int32)">
            <summary>
            Loads 32-bit segments from a span, raising an error if said source does not evenly partition
            </summary>
            <param name="w">The block width selector</param>
            <param name="src">The data source</param>
            <param name="offset">The source offset</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.load``1(Z0.W64,System.Span{``0},System.Int32)">
            <summary>
            Loads 64-bit segments from a span, raising an error if said source does not evenly partition
            </summary>
            <param name="w">The block width selector</param>
            <param name="src">The data source</param>
            <param name="offset">The source offset</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.load``1(Z0.W128,System.Span{``0},System.Int32)">
            <summary>
            Loads 128-bit segments from a span, raising an error if said source does not evenly partition
            </summary>
            <param name="w">The block width selector</param>
            <param name="src">The data source</param>
            <param name="offset">The source offset</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.load``1(Z0.W256,System.Span{``0},System.Int32)">
            <summary>
            Loads 256-bit segments from a span, raising an error if said source does not evenly partition
            </summary>
            <param name="w">The block width selector</param>
            <param name="src">The data source</param>
            <param name="offset">The source offset</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.load``1(Z0.W512,System.Span{``0},System.Int32)">
            <summary>
            Loads 256-bit segments from a span, raising an error if said source does not evenly partition
            </summary>
            <param name="w">The block width selector</param>
            <param name="src">The data source</param>
            <param name="offset">The source offset</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.load``1(Z0.W8,``0@,System.Int32)">
            <summary>
            Loads a specified count of 8-bit blocks from a reference
            </summary>
            <param name="w">The target block width</param>
            <param name="src">The source reference</param>
            <typeparam name="T">The blocked data type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.load``1(Z0.W16,``0@)">
            <summary>
            Loads a single 16-bit block from a reference
            </summary>
            <param name="w">The target block width</param>
            <param name="src">The source reference</param>
            <typeparam name="T">The blocked data type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.load``1(Z0.W16,``0@,System.Int32)">
            <summary>
            Loads a specified count of 16-bit blocks from a reference
            </summary>
            <param name="w">The target block width</param>
            <param name="src">The source reference</param>
            <typeparam name="T">The blocked data type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.load``1(Z0.W32,``0@)">
            <summary>
            Loads a single 32-bit block from a reference
            </summary>
            <param name="w">The target block width</param>
            <param name="src">The source reference</param>
            <typeparam name="T">The blocked data type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.load``1(Z0.W32,``0@,System.Int32)">
            <summary>
            Loads a specified count of 32-bit block from a reference
            </summary>
            <param name="w">The target block width</param>
            <param name="src">The source reference</param>
            <typeparam name="T">The blocked data type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.load``1(Z0.W64,``0@)">
            <summary>
            Loads a single 64-bit block from a reference
            </summary>
            <param name="w">The target block width</param>
            <param name="src">The source reference</param>
            <typeparam name="T">The blocked data type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.load``1(Z0.W64,``0@,System.Int32)">
            <summary>
            Loads a specified count of 64-bit blocks from a reference
            </summary>
            <param name="w">The target block width</param>
            <param name="src">The source reference</param>
            <typeparam name="T">The blocked data type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.load``1(Z0.W128,``0@)">
            <summary>
            Loads a single 128-bit block from a reference
            </summary>
            <param name="w">The target block width</param>
            <param name="src">The source reference</param>
            <typeparam name="T">The blocked data type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.load``1(Z0.W128,``0@,System.Int32)">
            <summary>
            Loads a specified count of 128-bit blocks from a reference
            </summary>
            <param name="w">The target block width</param>
            <param name="src">The source reference</param>
            <typeparam name="T">The blocked data type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.load``1(Z0.W256,``0@)">
            <summary>
            Loads a single 256-bit block from a reference
            </summary>
            <param name="w">The target block width</param>
            <param name="src">The source reference</param>
            <typeparam name="T">The blocked data type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.load``1(Z0.W256,``0@,System.Int32)">
            <summary>
            Loads a specified count of 256-bit block sfrom a reference
            </summary>
            <param name="w">The target block width</param>
            <param name="src">The source reference</param>
            <typeparam name="T">The blocked data type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.load``1(Z0.W512,``0@)">
            <summary>
            Loads a single 512-bit blocks from a reference
            </summary>
            <param name="w">The target block width</param>
            <param name="src">The source reference</param>
            <typeparam name="T">The blocked data type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.load``1(Z0.W512,``0@,System.Int32)">
            <summary>
            Loads a specified count of 512-bit blocks from a reference
            </summary>
            <param name="w">The target block width</param>
            <param name="src">The source reference</param>
            <typeparam name="T">The blocked data type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.parts``1(Z0.W8,``0[])">
            <summary>
            Creates a sequence of 8-bit blocks from a parameter array and raises an error if the data source is not block-aligned
            </summary>
            <param name="w">The block width selector</param>
            <param name="src">The source data</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.parts``1(Z0.W16,``0[])">
            <summary>
            Creates 16-bit blocked container from a parameter array and raises an error if the data source is not block-aligned
            </summary>
            <param name="w">The block width selector</param>
            <param name="src">The source data</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.parts``1(Z0.W32,``0[])">
            <summary>
            Creates 32-bit blocked span from a parameter array and raises an error if the data source is not block-aligned
            </summary>
            <param name="w">The block width selector</param>
            <param name="src">The source data</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.parts``1(Z0.W64,``0[])">
            <summary>
            Creates 64-bit blocked span from a parameter array and raises an error if the data source is not block-aligned
            </summary>
            <param name="w">The block width selector</param>
            <param name="src">The source data</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.parts``1(Z0.W128,``0[])">
            <summary>
            Creates 128-bit blocked span from a parameter array and raises an error if the data source is improperly blocked
            </summary>
            <param name="w">The block width selector</param>
            <param name="src">The source data</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.parts``1(Z0.W256,``0[])">
            <summary>
            Creates 256-bit blocked span from a parameter array and raises an error if the data source is improperly blocked
            </summary>
            <param name="w">The block width selector</param>
            <param name="src">The source data</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.parts``1(Z0.W512,``0[])">
            <summary>
            Creates 512-bit blocked span from a parameter array and raises an error if the data source is improperly blocked
            </summary>
            <param name="w">The block width selector</param>
            <param name="src">The source data</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.pvoid``1(``0@)">
            <summary>
            Converts a generic reference into a void pointer
            </summary>
            <param name="src">The memory reference</param>
            <typeparam name="T">The type of the referenced data</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.ptr``1(``0@)">
            <summary>
            Presents generic reference as a generic pointer
            </summary>
            <param name="src">The memory reference</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.ptr``1(Z0.SpanBlock16{``0}@)">
            <summary>
            Returns a generic pointer to the leading cell of the first block of a 16-bit blocked container
            </summary>
            <param name="src">The source block</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.ptr``1(Z0.SpanBlock32{``0}@)">
            <summary>
            Returns a generic pointer to the leading cell of the first block of a 32-bit blocked container
            </summary>
            <param name="src">The source block</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.ptr``1(Z0.SpanBlock64{``0}@)">
            <summary>
            Returns a generic pointer to the leading cell of the first block of a 64-bit blocked container
            </summary>
            <param name="src">The source block</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.ptr``1(Z0.SpanBlock128{``0}@)">
            <summary>
            Returns a generic pointer to the leading cell of the first block of a 128-bit blocked container
            </summary>
            <param name="src">The source block</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.ptr``1(Z0.SpanBlock256{``0}@)">
            <summary>
            Returns a generic pointer to the leading cell of the first block of a 256-bit blocked container
            </summary>
            <param name="src">The source block</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.ptr``1(Z0.SpanBlock16{``0}@,System.Int32)">
            <summary>
            Returns a generic pointer to the leading cell of an index-identified block of a 16-bit blocked container
            </summary>
            <param name="src">The source block</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.ptr``1(Z0.SpanBlock32{``0}@,System.Int32)">
            <summary>
            Returns a generic pointer to the leading cell of an index-identified block of a 32-bit blocked container
            </summary>
            <param name="src">The source block</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.ptr``1(Z0.SpanBlock64{``0}@,System.Int32)">
            <summary>
            Returns a generic pointer to the leading cell of an index-identified block of a 64-bit blocked container
            </summary>
            <param name="src">The source block</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.ptr``1(Z0.SpanBlock128{``0}@,System.Int32)">
            <summary>
            Returns a generic pointer to the leading cell of an index-identified block of a 128-bit blocked container
            </summary>
            <param name="src">The source block</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.ptr``1(Z0.SpanBlock256{``0}@,System.Int32)">
            <summary>
            Returns a generic pointer to the leading cell of an index-identified block of a 256-bit blocked container
            </summary>
            <param name="src">The source block</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.rectangle``1(Z0.W8,System.UInt64,System.UInt64)">
            <summary>
            Allocates the minimum number of blocks required to block-align tabular data in 8-bit blocks
            </summary>
            <param name="w">The block width selector</param>
            <param name="m">The row count</param>
            <param name="n">The col count</param>
            <typeparam name="T">The storage cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.rectangle``1(Z0.W16,System.UInt64,System.UInt64)">
            <summary>
            Allocates the minimum number of blocks required to block-align tabular data in 16-bit blocks
            </summary>
            <param name="w">The block width selector</param>
            <param name="m">The row count</param>
            <param name="n">The col count</param>
            <typeparam name="T">The storage cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.rectangle``1(Z0.W32,System.UInt64,System.UInt64)">
            <summary>
            Allocates the minimum number of blocks required to block-align tabular data in 32-bit blocks
            </summary>
            <param name="w">The block width selector</param>
            <param name="m">The row count</param>
            <param name="n">The col count</param>
            <typeparam name="T">The storage cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.rectangle``1(Z0.W64,System.UInt64,System.UInt64)">
            <summary>
            Allocates the minimum number of blocks required to block-align tabular data in 64-bit blocks
            </summary>
            <param name="w">The block width selector</param>
            <param name="m">The row count</param>
            <param name="n">The col count</param>
            <typeparam name="T">The storage cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.rectangle``1(Z0.W128,System.UInt64,System.UInt64)">
            <summary>
            Allocates the minimum number of blocks required to block-align tabular data in 64-bit blocks
            </summary>
            <param name="w">The block width selector</param>
            <param name="m">The row count</param>
            <param name="n">The col count</param>
            <typeparam name="T">The storage cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.rectangle``1(Z0.W256,System.UInt64,System.UInt64)">
            <summary>
            Allocates the minimum number of blocks required to block-align tabular data in 256-bit blocks
            </summary>
            <param name="w">The block width selector</param>
            <param name="m">The row count</param>
            <param name="n">The col count</param>
            <typeparam name="T">The storage cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.safeload``1(Z0.W8,System.Span{``0})">
            <summary>
            Loads a sequence of 16-bit blocks from an unblocked span, reallocating if the source span isn't properly blocked
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The data type</typeparam>
            <remarks>The use of this method is discouraged</remarks>
        </member>
        <member name="M:Z0.SpanBlocks.safeload``1(Z0.W16,System.Span{``0})">
            <summary>
            Loads a sequence of 16-bit blocks from an unblocked span, reallocating if the source span isn't properly blocked
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The data type</typeparam>
            <remarks>The use of this method is discouraged</remarks>
        </member>
        <member name="M:Z0.SpanBlocks.safeload``1(Z0.W32,System.Span{``0})">
            <summary>
            Loads 32-bit blocked span from an unblocked span, reallocating if the source span isn't properly blocked
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The data type</typeparam>
            <remarks>The use of this method is discouraged</remarks>
        </member>
        <member name="M:Z0.SpanBlocks.safeload``1(Z0.W64,System.Span{``0})">
            <summary>
            Loads 64-bit blocked span from an unblocked span, reallocating if the source span isn't properly blocked
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The data type</typeparam>
            <remarks>The use of this method is discouraged</remarks>
        </member>
        <member name="M:Z0.SpanBlocks.safeload``1(Z0.W128,System.Span{``0})">
            <summary>
            Loads 128-bit blocked span from an unblocked span, reallocating if the source span isn't properly blocked
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The data type</typeparam>
            <remarks>The use of this method is discouraged</remarks>
        </member>
        <member name="M:Z0.SpanBlocks.safeload``1(Z0.W256,System.Span{``0})">
            <summary>
            Loads 256-bit blocked span from an unblocked span, reallocating if the source span isn't properly blocked
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The data type</typeparam>
            <remarks>The use of this method is discouranged unless absolutely necessary</remarks>
        </member>
        <member name="M:Z0.SpanBlocks.safeload``1(Z0.W512,System.Span{``0})">
            <summary>
            Loads 512-bit blocked span from an unblocked span, reallocating if the source span isn't properly blocked
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The data type</typeparam>
            <remarks>The use of this method is discouranged unless absolutely necessary</remarks>
        </member>
        <member name="M:Z0.SpanBlocks.single``1(Z0.W8)">
            <summary>
            Allocates a single 8-bit block
            </summary>
            <param name="w">The block width selector</param>
            <param name="t">The cell type representative</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.single``1(Z0.W16)">
            <summary>
            Allocates a single 16-bit block
            </summary>
            <param name="w">The block width selector</param>
            <param name="t">The cell type representative</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.single``1(Z0.W32)">
            <summary>
            Allocates a single 32-bit block
            </summary>
            <param name="w">The block width selector</param>
            <param name="t">The cell type representative</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.single``1(Z0.W64)">
            <summary>
            Allocates a single 64-bit block
            </summary>
            <param name="w">The block width selector</param>
            <param name="t">The cell type representative</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.single``1(Z0.W128)">
            <summary>
            Allocates a single 128-bit block
            </summary>
            <param name="w">The block width selector</param>
            <param name="t">The cell type representative</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.single``1(Z0.W256)">
            <summary>
            Allocates a single 256-bit block
            </summary>
            <param name="w">The block width selector</param>
            <param name="t">The cell type representative</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.single``1(Z0.W512)">
            <summary>
            Allocates a single 512-bit block
            </summary>
            <param name="w">The block width selector</param>
            <param name="t">The cell type representative</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.square``1(Z0.W8,System.UInt64)">
            <summary>
            Allocates the minimum number of blocks required to block-align tabular data of square dimension in 32-bit blocks
            </summary>
            <param name="w">The block width selector</param>
            <param name="n">The square tabular order</param>
            <typeparam name="T">The storage cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.square``1(Z0.W16,System.UInt64)">
            <summary>
            Allocates the minimum number of blocks required to block-align tabular data of square dimension in 32-bit blocks
            </summary>
            <param name="w">The block width selector</param>
            <param name="n">The square tabular order</param>
            <typeparam name="T">The storage cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.square``1(Z0.W32,System.UInt64)">
            <summary>
            Allocates the minimum number of blocks required to block-align tabular data of square dimension in 32-bit blocks
            </summary>
            <param name="w">The block width selector</param>
            <param name="n">The square tabular order</param>
            <typeparam name="T">The storage cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.square``1(Z0.W64,System.UInt64)">
            <summary>
            Allocates the minimum number of blocks required to block-align tabular data of square dimension in 64-bit blocks
            </summary>
            <param name="w">The block width selector</param>
            <param name="n">The square tabular order</param>
            <typeparam name="T">The storage cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.square``1(Z0.W128,System.UInt64)">
            <summary>
            Allocates the minimum number of blocks required to block-align tabular data of square dimension in 128-bit blocks
            </summary>
            <param name="w">The block width selector</param>
            <param name="n">The square tabular order</param>
            <typeparam name="T">The storage cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.square``1(Z0.W256,System.UInt64)">
            <summary>
            Allocates the minimum number of blocks required to block-align tabular data of square dimension in 256-bit blocks
            </summary>
            <param name="w">The block width selector</param>
            <param name="n">The square tabular order</param>
            <typeparam name="T">The storage cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.unsafeload``1(Z0.W8,System.Span{``0})">
            <summary>
            Loads a span into a blocked container without checks
            </summary>
            <param name="w">The block width selector</param>
            <param name="src">The source span</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.unsafeload``1(Z0.W16,System.Span{``0})">
            <summary>
            Loads a span into a blocked container without checks
            </summary>
            <param name="w">The block width selector</param>
            <param name="src">The source span</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.unsafeload``1(Z0.W32,System.Span{``0})">
            <summary>
            Loads a span into a blocked container without checks
            </summary>
            <param name="w">The block width selector</param>
            <param name="src">The source span</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.unsafeload``1(Z0.W64,System.Span{``0})">
            <summary>
            Loads a span into a blocked container without checks
            </summary>
            <param name="w">The block width selector</param>
            <param name="src">The source span</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.unsafeload``1(Z0.W128,System.Span{``0})">
            <summary>
            Loads a span into a blocked container without checks
            </summary>
            <param name="w">The block width selector</param>
            <param name="src">The source span</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.unsafeload``1(Z0.W256,System.Span{``0})">
            <summary>
            Loads a span into a blocked container without checks
            </summary>
            <param name="w">The block width selector</param>
            <param name="src">The source span</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.unsafeload``1(Z0.W512,System.Span{``0})">
            <summary>
            Loads a span into a blocked container without checks
            </summary>
            <param name="w">The block width selector</param>
            <param name="src">The source span</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBlocks.vload(Z0.SpanBlock128{System.Byte}@)">
            <summary>
            _m128i _mm_lddqu_si128 (__m128i const* mem_addr) LDDQU xmm, m128
            Loads a 256-bit cpu vector from the leading block of a blocked container
            </summary>
            <param name="src">A readonly blocked storage container</param>
        </member>
        <member name="M:Z0.SpanBlocks.vload(Z0.SpanBlock128{System.SByte}@)">
            <summary>
            __m128i _mm_lddqu_si128 (__m128i const* mem_addr) LDDQU xmm, m128
            Loads a 256-bit cpu vector from the leading block of a blocked container
            </summary>
            <param name="src">A readonly blocked storage container</param>
        </member>
        <member name="M:Z0.SpanBlocks.vload(Z0.SpanBlock128{System.Int16}@)">
            <summary>
            __m128i _mm_lddqu_si128 (__m128i const* mem_addr) LDDQU xmm, m128
            Loads a 256-bit cpu vector from the leading block of a blocked container
            </summary>
            <param name="src">A readonly blocked storage container</param>
        </member>
        <member name="M:Z0.SpanBlocks.vload(Z0.SpanBlock128{System.UInt16}@)">
            <summary>
            __m128i _mm_lddqu_si128 (__m128i const* mem_addr) LDDQU xmm, m128
            Loads a 256-bit cpu vector from the leading block of a blocked container
            </summary>
            <param name="src">A readonly blocked storage container</param>
        </member>
        <member name="M:Z0.SpanBlocks.vload(Z0.SpanBlock128{System.Int32}@)">
            <summary>
            __m128i _mm_lddqu_si128 (__m128i const* mem_addr) LDDQU xmm, m128
            Loads a 256-bit cpu vector from the leading block of a blocked container
            </summary>
            <param name="src">A readonly blocked storage container</param>
        </member>
        <member name="M:Z0.SpanBlocks.vload(Z0.SpanBlock128{System.UInt32}@)">
            <summary>
            __m128i _mm_lddqu_si128 (__m128i const* mem_addr) LDDQU xmm, m128
            Loads a 256-bit cpu vector from the leading block of a blocked container
            </summary>
            <param name="src">A readonly blocked storage container</param>
        </member>
        <member name="M:Z0.SpanBlocks.vload(Z0.SpanBlock128{System.Int64}@)">
            <summary>
            __m128i _mm_lddqu_si128 (__m128i const* mem_addr) LDDQU xmm, m128
            Loads a 256-bit cpu vector from the leading block of a blocked container
            </summary>
            <param name="src">A readonly memory reference</param>
        </member>
        <member name="M:Z0.SpanBlocks.vload(Z0.SpanBlock128{System.UInt64}@)">
            <summary>
            __m128i _mm_lddqu_si128 (__m128i const* mem_addr) LDDQU xmm, m128
            Loads a 128-bit cpu vector from an unaligned memory location
            </summary>
            <param name="src">A readonly blocked storage container</param>
        </member>
        <member name="M:Z0.SpanBlocks.vload(Z0.SpanBlock256{System.Byte}@)">
            <summary>
            __m256i _mm256_lddqu_si256 (__m256i const * mem_addr) VLDDQU ymm, m256
            Loads a 256-bit cpu vector from the leading block of a blocked container
            </summary>
            <param name="src">A readonly blocked storage container</param>
        </member>
        <member name="M:Z0.SpanBlocks.vload(Z0.SpanBlock256{System.SByte}@)">
            <summary>
            __m256i _mm256_lddqu_si256 (__m256i const * mem_addr) VLDDQU ymm, m256
            Loads a 256-bit cpu vector from the leading block of a blocked container
            </summary>
            <param name="src">A readonly blocked storage container</param>
        </member>
        <member name="M:Z0.SpanBlocks.vload(Z0.SpanBlock256{System.Int16}@)">
            <summary>
            __m256i _mm256_lddqu_si256 (__m256i const * mem_addr) VLDDQU ymm, m256
            Loads a 256-bit cpu vector from the leading block of a blocked container
            </summary>
            <param name="src">A readonly blocked storage container</param>
        </member>
        <member name="M:Z0.SpanBlocks.vload(Z0.SpanBlock256{System.UInt16}@)">
            <summary>
            __m256i _mm256_lddqu_si256 (__m256i const * mem_addr) VLDDQU ymm, m256
            Loads a 256-bit cpu vector from the leading block of a blocked container
            </summary>
            <param name="src">A readonly blocked storage container</param>
        </member>
        <member name="M:Z0.SpanBlocks.vload(Z0.SpanBlock256{System.Int32}@)">
            <summary>
            __m256i _mm256_lddqu_si256 (__m256i const * mem_addr) VLDDQU ymm, m256
            Loads a 256-bit cpu vector from the leading block of a blocked container
            </summary>
            <param name="src">A readonly blocked storage container</param>
        </member>
        <member name="M:Z0.SpanBlocks.vload(Z0.SpanBlock256{System.UInt32}@)">
            <summary>
            __m256i _mm256_lddqu_si256 (__m256i const * mem_addr) VLDDQU ymm, m256
            Loads a 256-bit cpu vector from the leading block of a blocked container
            </summary>
            <param name="src">A readonly blocked storage container</param>
        </member>
        <member name="M:Z0.SpanBlocks.vload(Z0.SpanBlock256{System.Int64}@)">
            <summary>
            __m256i _mm256_lddqu_si256 (__m256i const * mem_addr) VLDDQU ymm, m256
            Loads a 256-bit cpu vector from the leading block of a blocked container
            </summary>
            <param name="src">A readonly blocked storage container</param>
        </member>
        <member name="M:Z0.SpanBlocks.vload(Z0.SpanBlock256{System.UInt64}@)">
            <summary>
            __m256i _mm256_lddqu_si256 (__m256i const * mem_addr) VLDDQU ymm, m256
            Loads a 256-bit cpu vector from the leading block of a blocked container
            </summary>
            <param name="src">A readonly blocked storage container</param>
        </member>
        <member name="M:Z0.SpanBuffers.parts``2(System.Int32)">
            <summary>
            Allocates a span-predicated S/T ring buffer
            </summary>
            <param name="capacity">The segment count</param>
            <typeparam name="S">The segmented type</typeparam>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBuffers.parts``2(System.Span{``0})">
            <summary>
            Covers an S-span with an S/T ring buffer
            </summary>
            <param name="src">The data source</param>
            <typeparam name="S">The segmented type</typeparam>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBuffers.ring``1(System.Int32)">
            <summary>
            Allocates a span-predicated T-ring buffer
            </summary>
            <param name="capacity">The T-cell count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBuffers.ring``1(System.Span{``0})">
            <summary>
            Covers a span with a ring buffer
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBuffers.stack``1(System.Int32)">
            <summary>
            Allocates a span-predicated T-stack
            </summary>
            <param name="capacity">The T-cell count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SpanBuffers.stack``1(System.Span{``0})">
            <summary>
            Covers a span with a stack buffer
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Blocked``1(System.Span{``0},Z0.W8)">
            <summary>
            Constructs a 32-bit blocked span from an unblocked span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Blocked``1(System.Span{``0},Z0.W16)">
            <summary>
            Constructs a 32-bit blocked span from an unblocked span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Blocked``1(System.Span{``0},Z0.W32)">
            <summary>
            Constructs a 32-bit blocked span from an unblocked span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Blocked``1(System.Span{``0},Z0.W64)">
            <summary>
            Constructs a 16-bit blocked span from an unblocked span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Blocked``1(System.Span{``0},Z0.W128)">
            <summary>
            Constructs a 128-bit blocked span from an unblocked span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Blocked``1(System.Span{``0},Z0.W256)">
            <summary>
            Constructs a 128-bit blocked span from an unblocked span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Blocked``1(System.Span{``0},Z0.W512)">
            <summary>
            Constructs a 128-bit blocked span from an unblocked span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.BXTend.BlockRef``1(Z0.SpanBlock8{``0}@,System.Int32)">
            <summary>
            Returns a reference to the leading cell of an index-identified block
            </summary>
            <param name="src">The blocked container</param>
            <param name="index">The block index, a number in the range 0..k-1 where k is the total number of covered blocks</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.BlockRef``1(Z0.SpanBlock16{``0}@,System.Int32)">
            <summary>
            Returns a reference to the leading cell of an index-identified block
            </summary>
            <param name="src">The blocked container</param>
            <param name="index">The block index, a number in the range 0..k-1 where k is the total number of covered blocks</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.BlockRef``1(Z0.SpanBlock32{``0}@,System.Int32)">
            <summary>
            Returns a reference to the leading cell of an index-identified block
            </summary>
            <param name="src">The blocked container</param>
            <param name="index">The block index, a number in the range 0..k-1 where k is the total number of covered blocks</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.BlockRef``1(Z0.SpanBlock64{``0}@,System.Int32)">
            <summary>
            Returns a reference to the leading cell of an index-identified block
            </summary>
            <param name="src">The blocked container</param>
            <param name="index">The block index, a number in the range 0..k-1 where k is the total number of covered blocks</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.BlockRef``1(Z0.SpanBlock128{``0}@,System.Int32)">
            <summary>
            Returns a reference to the leading cell of an index-identified block
            </summary>
            <param name="src">The blocked container</param>
            <param name="index">The block index, a number in the range 0..k-1 where k is the total number of covered blocks</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.BlockRef``1(Z0.SpanBlock256{``0}@,System.Int32)">
            <summary>
            Returns a reference to the leading cell of an index-identified block
            </summary>
            <param name="src">The blocked container</param>
            <param name="index">The block index, a number in the range 0..k-1 where k is the total number of covered blocks</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.BlockRef``1(Z0.SpanBlock256{``0}@,System.UInt32)">
            <summary>
            Returns a reference to the leading cell of an index-identified block
            </summary>
            <param name="src">The blocked container</param>
            <param name="index">The block index, a number in the range 0..k-1 where k is the total number of covered blocks</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.BlockRef``1(Z0.SpanBlock512{``0}@,System.Int32)">
            <summary>
            Returns a reference to the leading cell of an index-identified block
            </summary>
            <param name="src">The blocked container</param>
            <param name="index">The block index, a number in the range 0..k-1 where k is the total number of covered blocks</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Format``1(Z0.SpanBlock8{``0},System.Char,System.Int32)">
            <summary>
            Formats blocked content
            </summary>
            <param name="src">The source block sequence</param>
            <param name="delimiter">The cell delimiter</param>
            <param name="pad">The dell padding</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Format``1(Z0.SpanBlock16{``0},System.Char,System.Int32)">
            <summary>
            Formats blocked content
            </summary>
            <param name="src">The source block sequence</param>
            <param name="delimiter">The cell delimiter</param>
            <param name="pad">The dell padding</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Format``1(Z0.SpanBlock32{``0},System.Char,System.Int32)">
            <summary>
            Formats blocked content
            </summary>
            <param name="src">The source block sequence</param>
            <param name="delimiter">The cell delimiter</param>
            <param name="pad">The dell padding</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Format``1(Z0.SpanBlock64{``0},System.Char,System.Int32)">
            <summary>
            Formats blocked content
            </summary>
            <param name="src">The source block sequence</param>
            <param name="delimiter">The cell delimiter</param>
            <param name="pad">The dell padding</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Format``1(Z0.SpanBlock128{``0},System.Char,System.Int32)">
            <summary>
            Formats blocked content
            </summary>
            <param name="src">The source block sequence</param>
            <param name="delimiter">The cell delimiter</param>
            <param name="pad">The dell padding</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Format``1(Z0.SpanBlock256{``0},System.Char,System.Int32)">
            <summary>
            Formats blocked content
            </summary>
            <param name="src">The source block sequence</param>
            <param name="delimiter">The cell delimiter</param>
            <param name="pad">The dell padding</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Format``1(Z0.SpanBlock512{``0},System.Char,System.Int32)">
            <summary>
            Formats blocked content
            </summary>
            <param name="src">The source block sequence</param>
            <param name="delimiter">The cell delimiter</param>
            <param name="pad">The dell padding</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.FormatHex``1(Z0.SpanBlock8{``0},System.Char,System.Boolean)">
            <summary>
            Formats blocked content as a sequence of hex values
            </summary>
            <param name="src">The source block</param>
            <param name="sep">The character to use when separating digits</param>
            <param name="specifier">Whether to prefix each number with the canonical hex specifier, "0x"</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BXTend.FormatHex``1(Z0.SpanBlock16{``0},System.Char,System.Boolean)">
            <summary>
            Formats blocked content as a sequence of hex values
            </summary>
            <param name="src">The source block</param>
            <param name="sep">The character to use when separating digits</param>
            <param name="specifier">Whether to prefix each number with the canonical hex specifier, "0x"</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BXTend.FormatHex``1(Z0.SpanBlock32{``0},System.Char,System.Boolean)">
            <summary>
            Formats blocked content as a sequence of hex values
            </summary>
            <param name="src">The source block</param>
            <param name="bracket">Whether to enclose the formatted hex within brackets</param>
            <param name="sep">The character to use when separating digits</param>
            <param name="specifier">Whether to prefix each number with the canonical hex specifier, "0x"</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BXTend.FormatHex``1(Z0.SpanBlock64{``0},System.Char,System.Boolean)">
            <summary>
            Formats blocked content as a sequence of hex values
            </summary>
            <param name="src">The source block</param>
            <param name="bracket">Whether to enclose the formatted hex within brackets</param>
            <param name="sep">The character to use when separating digits</param>
            <param name="specifier">Whether to prefix each number with the canonical hex specifier, "0x"</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BXTend.FormatHex``1(Z0.SpanBlock128{``0},System.Char,System.Boolean)">
            <summary>
            Formats blocked content as a sequence of hex values
            </summary>
            <param name="src">The source span</param>
            <param name="bracket">Whether to enclose the formatted hex within brackets</param>
            <param name="sep">The character to use when separating digits</param>
            <param name="specifier">Whether to prefix each number with the canonical hex specifier, "0x"</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BXTend.FormatHex``1(Z0.SpanBlock256{``0},System.Char,System.Boolean)">
            <summary>
            Formats blocked content as a sequence of hex values
            </summary>
            <param name="src">The source span</param>
            <param name="bracket">Whether to enclose the formatted hex within brackets</param>
            <param name="sep">The character to use when separating digits</param>
            <param name="specifier">Whether to prefix each number with the canonical hex specifier, "0x"</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BXTend.FormatHex``1(Z0.SpanBlock512{``0},System.Char,System.Boolean)">
            <summary>
            Formats blocked content as a sequence of hex values
            </summary>
            <param name="src">The source span</param>
            <param name="bracket">Whether to enclose the formatted hex within brackets</param>
            <param name="sep">The character to use when separating digits</param>
            <param name="specifier">Whether to prefix each number with the canonical hex specifier, "0x"</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BXTend.HiBlock``1(Z0.SpanBlock128{``0}@,System.Int32)">
            <summary>
            Extracts the upper half of an index-identified block
            </summary>
            <param name="src">The source block container</param>
            <param name="block">The 64-bit block-relative index</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.LoBlock``1(Z0.SpanBlock128{``0}@,System.Int32)">
            <summary>
            Extracts the lower half of an index-identified block
            </summary>
            <param name="src">The source block container</param>
            <param name="block">The 64-bit block-relative index</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Reblock``1(Z0.SpanBlock32{``0}@,Z0.W16)">
            <summary>
            Converts 64-bit blocks to 32-bit blocks without allocation
            </summary>
            <param name="src">The source blocks</param>
            <param name="n">The target block width</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Reblock``1(Z0.SpanBlock64{``0}@,Z0.W32)">
            <summary>
            Converts 64-bit blocks to 32-bit blocks without allocation
            </summary>
            <param name="src">The source blocks</param>
            <param name="n">The target block width</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Reblock``1(Z0.SpanBlock128{``0}@,Z0.W16)">
            <summary>
            Converts 128-bit blocks to 16-bit blocks without allocation
            </summary>
            <param name="src">The source blocks</param>
            <param name="n">The target block width</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Reblock``1(Z0.SpanBlock128{``0}@,Z0.W32)">
            <summary>
            Converts 128-bit blocks to 32-bit blocks without allocation
            </summary>
            <param name="src">The source blocks</param>
            <param name="n">The target block width</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Reblock``1(Z0.SpanBlock128{``0}@,Z0.W64)">
            <summary>
            Converts 128-bit blocks to 64-bit blocks without allocation
            </summary>
            <param name="src">The source blocks</param>
            <param name="n">The target block width</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Reblock``1(Z0.SpanBlock256{``0}@,Z0.W16)">
            <summary>
            Converts 256-bit blocks to 16-bit blocks without allocation
            </summary>
            <param name="src">The source blocks</param>
            <param name="n">The target block width</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Reblock``1(Z0.SpanBlock256{``0}@,Z0.W32)">
            <summary>
            Converts 256-bit blocks to 32-bit blocks without allocation
            </summary>
            <param name="src">The source blocks</param>
            <param name="n">The target block width</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Reblock``1(Z0.SpanBlock256{``0}@,Z0.W64)">
            <summary>
            Converts 256-bit blocks to 64-bit blocks without allocation
            </summary>
            <param name="src">The source blocks</param>
            <param name="n">The target block width</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Reblock``1(Z0.SpanBlock256{``0}@,Z0.W128)">
            <summary>
            Converts 256-bit blocks to 64-bit blocks without allocation
            </summary>
            <param name="src">The source blocks</param>
            <param name="n">The target block width</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Replicate``1(Z0.SpanBlock8{``0}@)">
            <summary>
            Clones a 32-bit blocked container
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Replicate``1(Z0.SpanBlock8{``0}@,System.Span{``0})">
            <summary>
            Clones a 32-bit blocked container
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Replicate``1(Z0.SpanBlock16{``0}@,System.Span{``0})">
            <summary>
            Clones a 32-bit blocked container
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Replicate``1(Z0.SpanBlock32{``0}@,System.Span{``0})">
            <summary>
            Clones a 32-bit blocked container
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Replicate``1(Z0.SpanBlock64{``0}@,System.Span{``0})">
            <summary>
            Clones a blocked span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Replicate``1(Z0.SpanBlock128{``0}@,System.Span{``0})">
            <summary>
            Clones a blocked span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Replicate``1(Z0.SpanBlock256{``0}@)">
            <summary>
            Clones a 256-bit data block
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Replicate``1(Z0.SpanBlock256{``0}@,System.Span{``0})">
            <summary>
            Clones a 256-bit data block
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Replicate``1(Z0.SpanBlock512{``0}@,System.Span{``0})">
            <summary>
            Clones a 512-bit data block
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Slice``1(Z0.SpanBlock8{``0}@,System.Int32)">
            <summary>
            Slices a blocked data source at the cellular level
            </summary>
            <param name="src">The source data</param>
            <param name="offset">The cell-relative offset at which to dice</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Slice``1(Z0.SpanBlock8{``0}@,System.Int32,System.Int32)">
            <summary>
            Slices a blocked data source at the cellular level
            </summary>
            <param name="src">The source data</param>
            <param name="offset">The cell-relative offset at which to dice</param>
            <param name="length">The cell-relative slice length</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Slice``1(Z0.SpanBlock16{``0}@,System.Int32)">
            <summary>
            Slices a blocked data source at the cellular level
            </summary>
            <param name="src">The source data</param>
            <param name="offset">The cell-relative offset at which to dice</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Slice``1(Z0.SpanBlock16{``0}@,System.Int32,System.Int32)">
            <summary>
            Slices a blocked data source at the cellular level
            </summary>
            <param name="src">The source data</param>
            <param name="offset">The cell-relative offset at which to dice</param>
            <param name="length">The cell-relative slice length</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Slice``1(Z0.SpanBlock32{``0}@,System.Int32)">
            <summary>
            Slices a blocked data source at the cellular level
            </summary>
            <param name="src">The source data</param>
            <param name="offset">The cell-relative offset at which to dice</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Slice``1(Z0.SpanBlock32{``0}@,System.Int32,System.Int32)">
            <summary>
            Slices a blocked data source at the cellular level
            </summary>
            <param name="src">The source data</param>
            <param name="offset">The cell-relative offset at which to dice</param>
            <param name="length">The cell-relative slice length</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Slice``1(Z0.SpanBlock64{``0}@,System.Int32)">
            <summary>
            Slices a blocked data source at the cellular level
            </summary>
            <param name="src">The source data</param>
            <param name="offset">The cell-relative offset at which to dice</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Slice``1(Z0.SpanBlock64{``0}@,System.Int32,System.Int32)">
            <summary>
            Slices a blocked data source at the cellular level
            </summary>
            <param name="src">The source data</param>
            <param name="offset">The cell-relative offset at which to dice</param>
            <param name="length">The cell-relative slice length</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Slice``1(Z0.SpanBlock128{``0}@,System.Int32)">
            <summary>
            Slices a blocked data source at the cellular level
            </summary>
            <param name="src">The source data</param>
            <param name="offset">The cell-relative offset at which to dice</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Slice``1(Z0.SpanBlock128{``0}@,System.Int32,System.Int32)">
            <summary>
            Slices a blocked data source at the cellular level
            </summary>
            <param name="src">The source data</param>
            <param name="offset">The cell-relative offset at which to dice</param>
            <param name="length">The cell-relative slice length</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Slice``1(Z0.SpanBlock256{``0}@,System.Int32)">
            <summary>
            Slices a blocked data source at the cellular level
            </summary>
            <param name="src">The source data</param>
            <param name="offset">The cell-relative offset at which to dice</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Slice``1(Z0.SpanBlock256{``0}@,System.Int32,System.Int32)">
            <summary>
            Slices a blocked data source at the cellular level
            </summary>
            <param name="src">The source data</param>
            <param name="offset">The cell-relative offset at which to dice</param>
            <param name="length">The cell-relative slice length</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BXTend.Slice``1(Z0.SpanBlock512{``0}@,System.Int32,System.Int32)">
            <summary>
            Slices a blocked data source at the cellular level
            </summary>
            <param name="src">The source data</param>
            <param name="offset">The cell-relative offset at which to dice</param>
            <param name="length">The cell-relative slice length</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.DataBlocks.head32(Z0.BitBlock32@)">
            <summary>
            Presents the leading source storage cell as reference to an unsigned 32-bit integer
            </summary>
            <param name="src">The storage source</param>
        </member>
        <member name="M:Z0.DataBlocks.head8(Z0.BitBlock8@)">
            <summary>
            Presents the leading source storage cell as a byte reference
            </summary>
            <param name="src">The storage source</param>
        </member>
        <member name="M:Z0.DataBlocks.head8(Z0.BitBlock16@)">
            <summary>
            Presents the leading source storage cell as a byte reference
            </summary>
            <param name="src">The storage source</param>
        </member>
        <member name="M:Z0.DataBlocks.head8(Z0.BitBlock32@)">
            <summary>
            Presents the leading source storage cell as a byte reference
            </summary>
            <param name="src">The storage source</param>
        </member>
        <member name="M:Z0.DataBlocks.head8(Z0.BitBlock64@)">
            <summary>
            Presents the leading source storage cell as a byte reference
            </summary>
            <param name="src">The storage source</param>
        </member>
        <member name="M:Z0.DataBlocks.head8(Z0.BitBlock128@)">
            <summary>
            Presents the leading source storage cell as a byte reference
            </summary>
            <param name="src">The storage source</param>
        </member>
        <member name="M:Z0.DataBlocks.head8(Z0.BitBlock256@)">
            <summary>
            Presents the leading source storage cell as a byte reference
            </summary>
            <param name="src">The storage source</param>
        </member>
        <member name="M:Z0.DataBlocks.head8(Z0.BitBlock512@)">
            <summary>
            Presents the leading source storage cell as a byte reference
            </summary>
            <param name="src">The storage source</param>
        </member>
        <member name="M:Z0.DataBlocks.head8(Z0.BitStack1024@)">
            <summary>
            Presents the leading source storage cell as a byte reference
            </summary>
            <param name="src">The storage source</param>
        </member>
        <member name="T:Z0.BitBlock128">
            <summary>
            Defines 16 bytes = 512 bits of stack-allocated storage
            </summary>
        </member>
        <member name="T:Z0.BitBlock256">
            <summary>
            Covers 32 bytes = 256 bits of stack-allocated storage
            </summary>
        </member>
        <member name="T:Z0.BitBlock512">
            <summary>
            Covers 64 bytes = 512 bits of stack-allocated storage
            </summary>
        </member>
        <member name="T:Z0.BitStack1024">
            <summary>
            Covers 128 bytes = 1024 bits of stack-allocated storage
            </summary>
        </member>
        <member name="M:Z0.Stacks.alloc(Z0.W8)">
            <summary>
            Stack allocates 8 bits of storage
            </summary>
            <param name="w">The storage width</param>
        </member>
        <member name="M:Z0.Stacks.alloc(Z0.W16)">
            <summary>
            Stack allocates 16 bits of storage
            </summary>
            <param name="w">The storage width</param>
        </member>
        <member name="M:Z0.Stacks.alloc(Z0.W32)">
            <summary>
            Stack allocates 32 bits of storage
            </summary>
            <param name="w">The storage width</param>
        </member>
        <member name="M:Z0.Stacks.alloc(Z0.W64)">
            <summary>
            Stack allocates 64 bits of storage
            </summary>
            <param name="w">The storage width</param>
        </member>
        <member name="M:Z0.Stacks.alloc(Z0.W128)">
            <summary>
            Stack allocates 16 bytes = 128 bits of storage
            </summary>
            <param name="w">The storage width</param>
            <param name="seg">The segment width</param>
        </member>
        <member name="M:Z0.Stacks.alloc(Z0.W256)">
            <summary>
            Stack allocates 32 bytes = 256-bits of storage
            </summary>
            <param name="w">The storage width</param>
            <param name="seg">The segment width</param>
        </member>
        <member name="M:Z0.Stacks.alloc(Z0.W512)">
            <summary>
            Stack allocates 64 bytes = 512-bits of storage
            </summary>
            <param name="w">The storage width</param>
            <param name="seg">The segment width</param>
        </member>
        <member name="M:Z0.Stacks.alloc(Z0.W1024)">
            <summary>
            Stack allocates 128 bytes = 1024-bits of storage
            </summary>
            <param name="w">The storage width</param>
        </member>
        <member name="M:Z0.Stacks.char2">
            <summary>
            Allocates a 2-character storage stack
            </summary>
        </member>
        <member name="M:Z0.Stacks.char4">
            <summary>
            Allocates a 4-character storage stack
            </summary>
        </member>
        <member name="M:Z0.Stacks.char8">
            <summary>
            Allocates an 8-character storage stack
            </summary>
        </member>
        <member name="M:Z0.Stacks.char16">
            <summary>
            Allocates a 16-character storage stack
            </summary>
        </member>
        <member name="M:Z0.Stacks.char32">
            <summary>
            Allocates a 32-character storage stack
            </summary>
        </member>
        <member name="M:Z0.Stacks.char64">
            <summary>
            Allocates a 64-character storage stack
            </summary>
        </member>
        <member name="M:Z0.Stacks.cell``1(Z0.BitBlock64@,System.Int32,``0)">
            <summary>
            Queries/manipulates an index-identified generic cell value
            </summary>
            <param name="src">The source storage</param>
            <param name="index">The source index, relative to the cell type</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.Stacks.cell``1(Z0.BitBlock128@,System.Int32,``0)">
            <summary>
            Queries/manipulates an index-identified generic cell value
            </summary>
            <param name="src">The source storage</param>
            <param name="index">The source index, relative to the cell type</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.Stacks.cell``1(Z0.BitBlock256@,System.Int32,``0)">
            <summary>
            Queries/manipulates an index-identified generic cell value
            </summary>
            <param name="src">The source storage</param>
            <param name="index">The source index, relative to the cell type</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.Stacks.cell``1(Z0.BitBlock512@,System.Int32,``0)">
            <summary>
            Queries/manipulates an index-identified generic cell value
            </summary>
            <param name="src">The source storage</param>
            <param name="index">The source index, relative to the cell type</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.Stacks.cell``1(Z0.BitStack1024@,System.Int32,``0)">
            <summary>
            Queries/manipulates an index-identified generic cell value
            </summary>
            <param name="src">The source storage</param>
            <param name="index">The source index, relative to the cell type</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.Stacks.cell(Z0.Stacked.CharStack2@,System.Int32)">
            <summary>
            Queries/manipulates a index-identified character in a storage stack
            </summary>
            <param name="src">The character storage</param>
            <param name="index">The character index</param>
        </member>
        <member name="M:Z0.Stacks.cell(Z0.Stacked.CharStack4@,System.Int32)">
            <summary>
            Queries/manipulates a index-identified character in a storage stack
            </summary>
            <param name="src">The character storage</param>
            <param name="index">The character index</param>
        </member>
        <member name="M:Z0.Stacks.cell(Z0.Stacked.CharStack8@,System.Int32)">
            <summary>
            Queries/manipulates a index-identified character in a storage stack
            </summary>
            <param name="src">The character storage</param>
            <param name="index">The character index</param>
        </member>
        <member name="M:Z0.Stacks.cell(Z0.Stacked.CharStack16@,System.Int32)">
            <summary>
            Queries/manipulates a index-identified character in a storage stack
            </summary>
            <param name="src">The character storage</param>
            <param name="index">The character index</param>
        </member>
        <member name="M:Z0.Stacks.cell(Z0.Stacked.CharStack32@,System.Int32)">
            <summary>
            Queries/manipulates a index-identified character in a storage stack
            </summary>
            <param name="src">The character storage</param>
            <param name="index">The character index</param>
        </member>
        <member name="M:Z0.Stacks.cell(Z0.Stacked.CharStack64@,System.Int32)">
            <summary>
            Queries/manipulates a index-identified character in a storage stack
            </summary>
            <param name="src">The character storage</param>
            <param name="index">The character index</param>
        </member>
        <member name="M:Z0.Stacks.head``1(Z0.BitBlock64@,``0)">
            <summary>
            Presents the leading source storage cell as a generic reference
            </summary>
            <param name="src">The source storage</param>
            <param name="t">A cell type representative</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.Stacks.head``1(Z0.BitBlock128@,``0)">
            <summary>
            Presents the leading source storage cell as a generic reference
            </summary>
            <param name="src">The source storage</param>
            <param name="t">A cell type representative</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.Stacks.head``1(Z0.BitBlock256@,``0)">
            <summary>
            Presents the leading source storage cell as a generic reference
            </summary>
            <param name="src">The source storage</param>
            <param name="t">A cell type representative</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.Stacks.head``1(Z0.BitBlock512@,``0)">
            <summary>
            Presents the leading source storage cell as a generic reference
            </summary>
            <param name="src">The source storage</param>
            <param name="t">A cell type representative</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.Stacks.head``1(Z0.BitStack1024@,``0)">
            <summary>
            Presents the leading source storage cell as a generic reference
            </summary>
            <param name="src">The source storage</param>
            <param name="t">A cell type representative</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.Stacks.head(Z0.Stacked.CharStack2@)">
            <summary>
            Retrieves a reference to the leading character storage cell
            </summary>
            <param name="src">The character storage source</param>
        </member>
        <member name="M:Z0.Stacks.head(Z0.Stacked.CharStack4@)">
            <summary>
            Retrieves a reference to the leading character storage cell
            </summary>
            <param name="src">The character storage source</param>
        </member>
        <member name="M:Z0.Stacks.head(Z0.Stacked.CharStack8@)">
            <summary>
            Retrieves a reference to the leading character storage cell
            </summary>
            <param name="src">The character storage source</param>
        </member>
        <member name="M:Z0.Stacks.head(Z0.Stacked.CharStack16@)">
            <summary>
            Retrieves a reference to the leading character storage cell
            </summary>
            <param name="src">The character storage source</param>
        </member>
        <member name="M:Z0.Stacks.head(Z0.Stacked.CharStack32@)">
            <summary>
            Retrieves a reference to the leading character storage cell
            </summary>
            <param name="src">The character storage source</param>
        </member>
        <member name="M:Z0.Stacks.head(Z0.Stacked.CharStack64@)">
            <summary>
            Retrieves a reference to the leading character storage cell
            </summary>
            <param name="src">The character storage source</param>
        </member>
        <member name="M:Z0.Stacks.head64(Z0.BitBlock64@)">
            <summary>
            Presents the leading source storage cell as reference to an unsigned 64-bit integer
            </summary>
            <param name="src">The storage source</param>
        </member>
        <member name="M:Z0.Stacks.head64(Z0.BitBlock128@)">
            <summary>
            Presents the leading source storage cell as reference to an unsigned 64-bit integer
            </summary>
            <param name="src">The storage source</param>
        </member>
        <member name="M:Z0.Stacks.head64(Z0.BitBlock256@)">
            <summary>
            Presents the leading source storage cell as reference to an unsigned 64-bit integer
            </summary>
            <param name="src">The storage source</param>
        </member>
        <member name="M:Z0.Stacks.head64(Z0.BitBlock512@)">
            <summary>
            Presents the leading source storage cell as reference to an unsigned 64-bit integer
            </summary>
            <param name="src">The storage source</param>
        </member>
        <member name="M:Z0.Stacks.head64(Z0.BitStack1024@)">
            <summary>
            Presents the leading source storage cell as reference to an unsigned 64-bit integer
            </summary>
            <param name="src">The storage source</param>
        </member>
        <member name="M:Z0.Stacks.span``1(Z0.BitBlock64@,``0)">
            <summary>
            Fills a span with data from a stack storage block
            </summary>
            <param name="src">The stack storage source</param>
            <param name="t">A span cell type representative</param>
            <typeparam name="T">The span cell type</typeparam>
        </member>
        <member name="M:Z0.Stacks.span``1(Z0.BitBlock128@,``0)">
            <summary>
            Fills a span with data from a stack storage block
            </summary>
            <param name="src">The stack storage source</param>
            <param name="t">A span cell type representative</param>
            <typeparam name="T">The span cell type</typeparam>
        </member>
        <member name="M:Z0.Stacks.span``1(Z0.BitBlock256@,``0)">
            <summary>
            Fills a span with data from a stack storage block
            </summary>
            <param name="src">The stack storage source</param>
            <param name="t">A span cell type representative</param>
            <typeparam name="T">The span cell type</typeparam>
        </member>
        <member name="M:Z0.Stacks.span``1(Z0.BitBlock512@,``0)">
            <summary>
            Fills a span with data from a stack storage block
            </summary>
            <param name="src">The stack storage source</param>
            <param name="t">A span cell type representative</param>
            <typeparam name="T">The span cell type</typeparam>
        </member>
        <member name="M:Z0.Stacks.span``1(Z0.BitStack1024@,``0)">
            <summary>
            Fills a span with data from a stack storage block
            </summary>
            <param name="src">The stack storage source</param>
            <param name="t">A span cell type representative</param>
            <typeparam name="T">The span cell type</typeparam>
        </member>
        <member name="T:Z0.BoxedNumber">
            <summary>
            A numbered box
            </summary>
        </member>
        <member name="F:Z0.BoxedNumber.Boxed">
            <summary>
            In the box
            </summary>
        </member>
        <member name="F:Z0.BoxedNumber.Kind">
            <summary>
            Box discriminator for runtime efficiency
            </summary>
        </member>
        <member name="M:Z0.BoxedNumber.From``1(``0)">
            <summary>
            Puts an enum value into a (numeric) box
            </summary>
            <param name="e">The enumeration value</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.BoxedNumberConverter.Convert``1(Z0.BoxedNumber)">
            <summary>
            Pulls a number of kind parametric from a box - whose kind it matters not
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The target numeric type</typeparam>
        </member>
        <member name="M:Z0.BoxedNumberConverter.Convert``1(``0)">
            <summary>
            Puts a number in a box of kind parametric
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="T:Z0.Buffers">
            <summary>
            Api for buffer manipulation
            </summary>
        </member>
        <member name="M:Z0.Buffers.clear(Z0.NativeBuffers@,System.Byte)">
            <summary>
            Zero-fills a token-identified buffer and returns the cleared memory content
            </summary>
        </member>
        <member name="M:Z0.Buffers.cover(Z0.BufferToken)">
            <summary>
            Covers a token-identified buffer with a bytespan
            </summary>
        </member>
        <member name="M:Z0.Buffers.cover``1(Z0.BufferToken)">
            <summary>
            Covers a token-identified buffer with a span
            </summary>
        </member>
        <member name="M:Z0.Buffers.liberate(System.Span{System.Byte})">
            <summary>
            Enables bytespan execution
            </summary>
            <param name="src">The buffer to let it be what it wants</param>
        </member>
        <member name="M:Z0.Buffers.liberate(System.ReadOnlySpan{System.Byte})">
            <summary>
            This may not be the best idea to solve your problem
            </summary>
            <param name="src">The buffer to let it be what it wants</param>
        </member>
        <member name="M:Z0.Buffers.liberate(System.Byte@,System.Int32)">
            <summary>
            Enables execution over a reference-identified memory segment of specified length
            </summary>
            <param name="src">The buffer to let it be what it wants</param>
        </member>
        <member name="M:Z0.Buffers.liberate(System.IntPtr,System.Int32)">
            <summary>
            Enables an executable memory segment
            </summary>
            <param name="src">The leading cell pointer</param>
            <param name="length">The length of the segment, in bytes</param>
        </member>
        <member name="M:Z0.Buffers.liberate``1(``0@,System.Int32)">
            <summary>
            Enables en executable memory segment
            </summary>
            <param name="src">The leading cell reference</param>
            <param name="length">The length of the segment, in bytes</param>
            <typeparam name="T">The memory cell type</typeparam>
        </member>
        <member name="M:Z0.Buffers.VirtualProtectEx(System.IntPtr,System.IntPtr,System.UIntPtr,System.UInt32,System.UInt32@)">
            <summary>
            Windows API that applies memory protection attributes
            </summary>
        </member>
        <member name="M:Z0.Buffers.native(System.UInt32)">
            <summary>
            Allocates a native buffer
            </summary>
            <param name="length">The buffer length in bytes</param>
        </member>
        <member name="M:Z0.Buffers.release(System.IntPtr)">
            <summary>
            Deallocates a native allocation
            </summary>
            <param name="handle">The allocation handle</param>
        </member>
        <member name="M:Z0.Buffers.sequence(System.UInt32,System.Byte)">
            <summary>
            Creates a buffer sequence that owns the underlying memory allocation and releases it upon disposal
            </summary>
            <param name="size">The size of each buffer</param>
            <param name="length">The sequence length</param>
        </member>
        <member name="M:Z0.Buffers.sequence(System.UInt32,System.Byte,Z0.NativeBuffer@)">
            <summary>
            Creates a caller-owed buffer sequence
            </summary>
            <param name="size">The size of each buffer</param>
            <param name="length">The sequence length</param>
            <param name="allocation">The allocation handle that defines ownership</param>
        </member>
        <member name="M:Z0.Buffers.tokenize``1(System.IntPtr,System.UInt32,System.UInt32)">
            <summary>
            Creates an array of tokens that identify a sequence of buffers
            </summary>
            <param name="base">The base address</param>
            <param name="size">The number of bytes covered by each represented buffer</param>
            <param name="count">The length of the buffer sequence</param>
        </member>
        <member name="M:Z0.Buffers.tokenize(System.IntPtr,System.UInt32,System.UInt32)">
            <summary>
            Creates an array of tokens that identify a sequence of buffers
            </summary>
            <param name="base">The base address</param>
            <param name="size">The number of bytes covered by each buffer</param>
            <param name="count">The length of the buffer sequence</param>
        </member>
        <member name="M:Z0.Buffers.read8(System.Byte@)">
            <summary>
            Reads a byte
            </summary>
            <param name="src">The source reference</param>
        </member>
        <member name="M:Z0.Buffers.store8(System.Byte,System.Byte@)">
            <summary>
            Projects a source byte onto a byte reference
            </summary>
            <param name="src">The source data</param>
            <param name="dst">The target reference</param>
        </member>
        <member name="M:Z0.Buffers.write(System.UInt64,System.Byte@)">
            <summary>
            Projects 64 source bits onto a contiguous sequence of 8 bytes
            </summary>
            <param name="src">The source data</param>
            <param name="dst">The target reference</param>
        </member>
        <member name="P:Z0.IBufferTokenSource.Item(Z0.BufferSeqId)">
            <summary>
            Returns the token of an index-identified buffer
            </summary>
        </member>
        <member name="T:Z0.BufferToken">
            <summary>
            Describes an allocated buffer
            </summary>
        </member>
        <member name="P:Z0.BufferToken.Handle">
            <summary>
            The location of the represented buffer allocation
            </summary>
        </member>
        <member name="P:Z0.BufferToken.Size">
            <summary>
            The size, in bytes, of the represented buffer
            </summary>
        </member>
        <member name="T:Z0.NativeBuffer">
            <summary>
            Represents a native buffer allocation
            </summary>
        </member>
        <member name="P:Z0.NativeBuffer.Data">
            <summary>
            Presents the allocation via a span
            </summary>
        </member>
        <member name="T:Z0.NativeBuffers">
            <summary>
            Covers a sequence of allocated buffers
            </summary>
        </member>
        <member name="M:Z0.NativeBuffers.Buffer(System.Byte)">
            <summary>
            Presents an index-identified buffer as a span of bytes
            </summary>
            <param name="index">The buffer index</param>
        </member>
        <member name="M:Z0.NativeBuffers.Buffer``1(System.Byte)">
            <summary>
            Covers a token-identified buffer with a span over cells of unmanaged type
            </summary>
            <param name="index">The buffer index</param>
        </member>
        <member name="M:Z0.NativeBuffers.Token(System.Byte)">
            <summary>
            Retrieves an index-identified token
            </summary>
            <param name="index">The buffer index</param>
        </member>
        <member name="P:Z0.NativeBuffers.Item(System.Byte)">
            <summary>
            Retrieves an index-identified token
            </summary>
            <param name="index">The buffer index</param>
        </member>
        <member name="P:Z0.NativeBuffers.Item(Z0.BufferSeqId)">
            <summary>
            Retrieves a token identified by sequence id
            </summary>
            <param name="index">The buffer index</param>
        </member>
        <member name="T:Z0.PartRing`2">
            <summary>
            Defines a mutable circular S-cell buffer partitioned into T-cell parts
            </summary>
        </member>
        <member name="F:Z0.RingBuffer`1.InPos">
            <summary>
            The current position of the writer
            </summary>
        </member>
        <member name="F:Z0.RingBuffer`1.OutPos">
            <summary>
            The current position of the reader
            </summary>
        </member>
        <member name="F:Z0.RingBuffer`1.Count">
            <summary>
            The number of elements stored in the queue
            </summary>
        </member>
        <member name="M:Z0.ByteRead.read``1(System.ReadOnlySpan{System.Byte})">
            <summary>
            Reads at most size[T] bytes as determined by the length of the data source
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The unsigned numeric type</typeparam>
        </member>
        <member name="M:Z0.ByteRead.read(System.ReadOnlySpan{System.Byte})">
            <summary>
            Reads at most 8 bytes from the data source, as determined by source length
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.ByteRead.read(System.Byte@,System.Byte)">
            <summary>
            Reads up to 8 bytes from a data source reference, as determined by a specified {count} of bytes,
            and will likely incinerate the process with a segmentation fault if there aren't {count} bytes to read
            </summary>
            <param name="src">The data source</param>
            <param name="count">The number of bytes to read</param>
        </member>
        <member name="M:Z0.ByteRead.Read1(System.Byte@,Z0.N1)">
            <summary>
            Reads 1 byte from a data source reference
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.ByteRead.Read2(System.Byte@,Z0.N2)">
            <summary>
            Reads 2 bytes from a data source reference
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.ByteRead.Read3(System.Byte@,Z0.N3)">
            <summary>
            Reads 3 bytes from a data source reference
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.ByteRead.Read4(System.Byte@,Z0.N4)">
            <summary>
            Reads 4 bytes from a data source reference
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.ByteRead.Read5(System.Byte@,Z0.N5)">
            <summary>
            Reads 5 bytes from a data source reference
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.ByteRead.Read6(System.Byte@,Z0.N6)">
            <summary>
            Reads 6 bytes from a data source reference
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.ByteRead.Read7(System.Byte@,Z0.N7)">
            <summary>
            Reads 7 bytes from a data source reference
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.ByteRead.Read8(System.Byte@,Z0.N8)">
            <summary>
            Reads 8 bytes from a data source reference
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.ByteRead.ReadAll(System.Int16@)">
            <summary>
            Reads the bytes that define a numeric value
            </summary>
            <param name="src">The value to read</param>
        </member>
        <member name="M:Z0.ByteRead.ReadAll(System.UInt16@)">
            <summary>
            Reads the bytes that define a numeric value
            </summary>
            <param name="src">The value to read</param>
        </member>
        <member name="M:Z0.ByteRead.read(System.UInt16,Z0.N0)">
            <summary>
            Reads a source byte, identified by natural index
            </summary>
            <param name="src">The data source</param>
            <param name="n">The byte index selector</param>
        </member>
        <member name="M:Z0.ByteRead.read(System.UInt16,Z0.N1)">
            <summary>
            Reads a source byte, identified by natural index
            </summary>
            <param name="src">The data source</param>
            <param name="n">The byte index selector</param>
        </member>
        <member name="M:Z0.ByteRead.ReadAll(System.Int32@)">
            <summary>
            Reads the bytes that define a numeric value
            </summary>
            <param name="src">The value to read</param>
        </member>
        <member name="M:Z0.ByteRead.ReadAll(System.UInt32@)">
            <summary>
            Reads the bytes that define a numeric value
            </summary>
            <param name="src">The value to read</param>
        </member>
        <member name="M:Z0.ByteRead.read(System.UInt32,Z0.N0)">
            <summary>
            Reads a source byte, identified by natural index
            </summary>
            <param name="src">The data source</param>
            <param name="n">The byte index selector</param>
        </member>
        <member name="M:Z0.ByteRead.read(System.UInt32,Z0.N1)">
            <summary>
            Reads a source byte, identified by natural index
            </summary>
            <param name="src">The data source</param>
            <param name="n">The byte index selector</param>
        </member>
        <member name="M:Z0.ByteRead.read(System.UInt32,Z0.N2)">
            <summary>
            Reads a source byte, identified by natural index
            </summary>
            <param name="src">The data source</param>
            <param name="n">The byte index selector</param>
        </member>
        <member name="M:Z0.ByteRead.read(System.UInt32,Z0.N3)">
            <summary>
            Reads a source byte, identified by natural index
            </summary>
            <param name="src">The data source</param>
            <param name="n">The byte index selector</param>
        </member>
        <member name="M:Z0.ByteRead.ReadAll(System.Int64@)">
            <summary>
            Reads the bytes that define a numeric value
            </summary>
            <param name="src">The value to read</param>
        </member>
        <member name="M:Z0.ByteRead.ReadAll(System.UInt64@)">
            <summary>
            Reads the bytes that define a numeric value
            </summary>
            <param name="src">The value to read</param>
        </member>
        <member name="M:Z0.ByteRead.ReadAll(System.Single@)">
            <summary>
            Reads the bytes that define a numeric value
            </summary>
            <param name="src">The value to read</param>
        </member>
        <member name="M:Z0.ByteRead.ReadAll(System.Double@)">
            <summary>
            Reads the bytes that define a numeric value
            </summary>
            <param name="src">The value to read</param>
        </member>
        <member name="M:Z0.ByteRead.read(System.UInt64,Z0.N0)">
            <summary>
            Reads a source byte, identified by natural index
            </summary>
            <param name="src">The data source</param>
            <param name="n">The byte index selector</param>
        </member>
        <member name="M:Z0.ByteRead.read(System.UInt64,Z0.N1)">
            <summary>
            Reads a source byte, identified by natural index
            </summary>
            <param name="src">The data source</param>
            <param name="n">The byte index selector</param>
        </member>
        <member name="M:Z0.ByteRead.read(System.UInt64,Z0.N2)">
            <summary>
            Reads a source byte, identified by natural index
            </summary>
            <param name="src">The data source</param>
            <param name="n">The byte index selector</param>
        </member>
        <member name="M:Z0.ByteRead.read(System.UInt64,Z0.N3)">
            <summary>
            Reads a source byte, identified by natural index
            </summary>
            <param name="src">The data source</param>
            <param name="n">The byte index selector</param>
        </member>
        <member name="M:Z0.ByteRead.read(System.UInt64,Z0.N4)">
            <summary>
            Reads a source byte, identified by natural index
            </summary>
            <param name="src">The data source</param>
            <param name="n">The byte index selector</param>
        </member>
        <member name="M:Z0.ByteRead.read(System.UInt64,Z0.N5)">
            <summary>
            Reads a source byte, identified by natural index
            </summary>
            <param name="src">The data source</param>
            <param name="n">The byte index selector</param>
        </member>
        <member name="M:Z0.ByteRead.read(System.UInt64,Z0.N6)">
            <summary>
            Reads a source byte, identified by natural index
            </summary>
            <param name="src">The data source</param>
            <param name="n">The byte index selector</param>
        </member>
        <member name="M:Z0.ByteRead.read(System.UInt64,Z0.N7)">
            <summary>
            Reads a source byte, identified by natural index
            </summary>
            <param name="src">The data source</param>
            <param name="n">The byte index selector</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.Bytes.nand(System.Byte,System.Byte)" -->
        <member name="M:Z0.Bytes.nor(System.Byte,System.Byte)">
            <summary>
            Computes the bitwise nor c := ~(a | b) for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.Bytes.nor(System.Byte@,System.Byte@,System.Byte@)">
            <summary>
            Computes the bitwise nor c := ~(a | b) for operands a and b
            and deposits the result to a reference-identified location
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <param name="dst">The target reference</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.Bytes.nonimpl(System.Byte,System.Byte)" -->
        <member name="M:Z0.Bytes.impl(System.Byte,System.Byte)">
            <summary>
            Computes the material implication c := a | ~b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.Bytes.impl(System.Byte@,System.Byte@,System.Byte@)">
            <summary>
            Computes the material implication c := a | ~b for operands a and b
            and deposits the result to a reference-identified location
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <param name="dst">The target reference</param>
        </member>
        <member name="M:Z0.Bytes.cimpl(System.Byte,System.Byte)">
            <summary>
            Computes the converse implication c := ~a | b for operands a and b
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.Bytes.cimpl(System.Byte@,System.Byte@,System.Byte@)">
            <summary>
            Computes the converse implication c := ~a | b for operands a and b
            and deposits the result to a reference-identified location
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <param name="dst">The target reference</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.Bytes.cnonimpl(System.Byte,System.Byte)" -->
        <member name="M:Z0.Bytes.select(System.Byte,System.Byte,System.Byte)">
            <summary>
            Computes the bitwise select among the operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <param name="c">The third operand</param>
        </member>
        <member name="M:Z0.Bytes.or(System.Byte,System.Byte,System.Byte)">
            <summary>
            Joins three operands via <see cref='T:Z0.BitLogicKinds.Or'/>
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <param name="c">The third operand</param>
        </member>
        <member name="M:Z0.Bytes.or(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Joins four operands via the <see cref='T:Z0.BitLogicKinds.Or'/> operator
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <param name="c">The third operand</param>
            <param name="d">The fourth operand</param>
        </member>
        <member name="T:Z0.ByteSize">
            <summary>
            Specifies data size in bytes
            </summary>
        </member>
        <member name="F:Z0.ByteSize.Count">
            <summary>
            Specifies a byte count
            </summary>
        </member>
        <member name="M:Z0.ByteWrite.to``1(``0@,System.Span{System.Byte})">
            <summary>
            Reads a byte array from an unmanaged source value and stored the result in a caller-allocated target
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target array</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.ByteWrite.one``1(``0@,System.Int32)">
            <summary>
            Reads/writes a byte from/to a reference
            </summary>
            <param name="src">The source reference</param>
            <param name="offset">The 0-based/byte-relative offset</param>
            <typeparam name="T">The data type</typeparam>
        </member>
        <member name="M:Z0.ByteWrite.write``1(``0@,System.Span{System.Byte})">
            <summary>
            Writes a structural value value to a span
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target span</param>
            <param name="offset">The target span offset</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="T:Z0.IByte">
            <summary>
            A byte, just one
            </summary>
        </member>
        <member name="M:Z0.CellBuffers.alloc(Z0.W128,System.Byte)">
            <summary>
            Allocates a buffer sequence over segments of width = 128 bits / 16 bytes
            </summary>
            <param name="count">The number of buffers in the sequence</param>
            <typeparam name="F">The buffer segment type</typeparam>
        </member>
        <member name="M:Z0.CellBuffers.alloc(Z0.W256,System.Byte)">
            <summary>
            Allocates a buffer sequence over segments of width = 256 bits / 32 bytes
            </summary>
            <param name="count">The number of buffers in the sequence</param>
            <typeparam name="F">The buffer segment type</typeparam>
        </member>
        <member name="M:Z0.CellBuffers.alloc(Z0.W512,System.Byte)">
            <summary>
            Allocates a buffer sequence over segments of width = 512 bits / 64 bytes
            </summary>
            <param name="count">The number of buffers in the sequence</param>
            <typeparam name="F">The buffer segment type</typeparam>
        </member>
        <member name="M:Z0.CellBuffers.alloc``1(System.Byte)">
            <summary>
            Allocates a buffer sequence over segments of fixed type
            </summary>
            <param name="count">The number of buffers in the sequence</param>
            <typeparam name="F">The buffer segment type</typeparam>
        </member>
        <member name="P:Z0.CellBuffers`1.Head">
            <summary>
            The leading buffer
            </summary>
        </member>
        <member name="M:Z0.CellBuffers`1.Buffer(System.Byte)">
            <summary>
            Retrieves the content of an index-identified buffer
            </summary>
            <param name="index">The buffer index</param>
        </member>
        <member name="M:Z0.CellBuffers`1.Bytes(System.Byte)">
            <summary>
            Presents an index-identified buffer as a span of bytes
            </summary>
            <param name="index">The buffer index</param>
        </member>
        <member name="P:Z0.CellBuffers`1.Item(System.Byte)">
            <summary>
            Presents an index-identified buffer as a span of bytes
            </summary>
            <param name="index">The buffer index</param>
        </member>
        <member name="M:Z0.CellBuffers`1.Token(System.Byte)">
            <summary>
            Retrieves an index-identified token
            </summary>
            <param name="index">The buffer index</param>
        </member>
        <member name="M:Z0.CellBuffers`1.Clear(System.Byte)">
            <summary>
            Zero-fills a token-identified buffer and returns the cleared memory content
            </summary>
        </member>
        <member name="M:Z0.CellBuffers`1.Fill``1(System.Byte,System.ReadOnlySpan{``0})">
            <summary>
            Fills a token-identified buffer with content from a source span and returns the covering span
            </summary>
            <param name="index">The buffer index</param>
            <param name="src">The source content</param>
            <typeparam name="T">The content cell type</typeparam>
        </member>
        <member name="T:Z0.CellBufferToken`1">
            <summary>
            Describes a fixed-width allocated buffer
            </summary>
        </member>
        <member name="P:Z0.CellBufferToken`1.Handle">
            <summary>
            The location of the represented buffer allocation
            </summary>
        </member>
        <member name="P:Z0.CellBufferToken`1.Size">
            <summary>
            The size, in bytes, of the represented buffer
            </summary>
        </member>
        <member name="M:Z0.CellBufferToken`1.Content``1">
            <summary>
            Covers a token-identified buffer with a span
            </summary>
        </member>
        <member name="M:Z0.CellBufferToken`1.Fill``1(System.ReadOnlySpan{``0})">
            <summary>
            Fills a token-identified buffer with data from a source span and returns the target memory to the caller as a span
            </summary>
            <param name="src">The source content</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.CellBufferToken`1.Clear">
            <summary>
            Zero-fills a token-identified buffer
            </summary>
        </member>
        <member name="M:Z0.Cells.alloc``1">
            <summary>
            Creates a fixed-type value of parametric type
            </summary>
            <typeparam name="F">The fixed type</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.Cells.alloc(Z0.W8)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.Cells.alloc(Z0.W16)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.Cells.alloc(Z0.W32)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.Cells.alloc(Z0.W64)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.Cells.alloc(Z0.W128)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.Cells.alloc(Z0.W256)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.Cells.alloc(Z0.W512)" -->
        <member name="M:Z0.Cells.bytes``1(``0@)">
            <summary>
            Presents a fixed value as a span of bytes
            </summary>
            <param name="src">The fixed source value</param>
            <typeparam name="F">The fixed type</typeparam>
        </member>
        <member name="M:Z0.Cells.byteview``1(``0@)">
            <summary>
            Presents a fixed source value as a readonly span of bytes
            </summary>
            <param name="src">The source value</param>
            <typeparam name="F">The fixed type</typeparam>
        </member>
        <member name="M:Z0.Cells.cell``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>
            Initializes a 128-bit value with a 128-bit source vector
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.Cells.cell``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>
            Initializes a 256-bit value with a 256-bit source vector
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.Cells.cell``2(``0@,System.Int32)">
            <summary>
            Queries/manipulates a cell within a fixed storage block
            </summary>
            <param name="src">The storage block</param>
            <param name="index">The 0-based type-relative cell index</param>
            <typeparam name="T">The reference cell type</typeparam>
        </member>
        <member name="M:Z0.Cells.cell``1(Z0.Cell8@,System.Int32)">
            <summary>
            Queries/manipulates a generic cell within an 8-bit storage block
            </summary>
            <param name="src">The storage block</param>
            <param name="index">The 0-based type-relative cell index</param>
            <typeparam name="T">The reference cell type</typeparam>
        </member>
        <member name="M:Z0.Cells.cell``1(Z0.Cell16@,System.Int32)">
            <summary>
            Queries/manipulates a generic cell within a 16-bit storage block
            </summary>
            <param name="src">The storage block</param>
            <param name="index">The 0-based type-relative cell index</param>
            <typeparam name="T">The reference cell type</typeparam>
        </member>
        <member name="M:Z0.Cells.cell``1(Z0.Cell32@,System.Int32)">
            <summary>
            Queries/manipulates a generic cell within a 32-bit storage block
            </summary>
            <param name="src">The storage block</param>
            <param name="index">The 0-based type-relative cell index</param>
            <typeparam name="T">The reference cell type</typeparam>
        </member>
        <member name="M:Z0.Cells.cell``1(Z0.Cell64@,System.Int32)">
            <summary>
            Queries/manipulates a generic cell within a 64-bit storage block
            </summary>
            <param name="src">The storage block</param>
            <param name="index">The 0-based type-relative cell index</param>
            <typeparam name="T">The reference cell type</typeparam>
        </member>
        <member name="M:Z0.Cells.cell``1(Z0.Cell128@,System.Int32)">
            <summary>
            Queries/manipulates a generic cell within a 128-bit storage block
            </summary>
            <param name="src">The storage block</param>
            <param name="index">The 0-based type-relative cell index</param>
            <typeparam name="T">The reference cell type</typeparam>
        </member>
        <member name="M:Z0.Cells.cell``1(Z0.Cell256@,System.Int32)">
            <summary>
            Queries/manipulates a generic cell within a 256-bit storage block
            </summary>
            <param name="src">The storage block</param>
            <param name="index">The 0-based type-relative cell index</param>
            <typeparam name="T">The reference cell type</typeparam>
        </member>
        <member name="M:Z0.Cells.deposit``2(``0@,``1@)">
            <summary>
            Writes source data to a fixed target which, hopefully, is of sufficient size
            </summary>
            <param name="src">The source</param>
            <param name="dst">The target</param>
            <typeparam name="T">The source type</typeparam>
            <typeparam name="F">The fixed target type</typeparam>
        </member>
        <member name="M:Z0.Cells.edit``1(Z0.Cell8@)">
            <summary>
            Presents an 8-bit value as a single-celled T-parametric span
            </summary>
            <param name="src">The source value</param>
            <typeparam name="F">The fixed type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.Cells.edit``1(Z0.Cell16@)">
            <summary>
            Presents a 16-bit value as a T-parametric span
            </summary>
            <param name="src">The source value</param>
            <typeparam name="F">The fixed type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.Cells.edit``1(Z0.Cell32@)">
            <summary>
            Presents a 32-bit value as a T-parametric span
            </summary>
            <param name="src">The source value</param>
            <typeparam name="F">The fixed type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.Cells.edit``1(Z0.Cell64@)">
            <summary>
            Presents a 64-bit value as a T-parametric span
            </summary>
            <param name="src">The source value</param>
            <typeparam name="F">The fixed type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.Cells.edit``1(Z0.Cell128@)">
            <summary>
            Presents a 128-bit value as a T-parametric span
            </summary>
            <param name="src">The source value</param>
            <typeparam name="F">The fixed type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.Cells.edit``1(Z0.Cell256@)">
            <summary>
            Presents a 256-bit value as a T-parametric span
            </summary>
            <param name="src">The source value</param>
            <typeparam name="F">The fixed type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.Cells.edit``1(Z0.Cell512@)">
            <summary>
            Presents a 256-bit value as a T-parametric span
            </summary>
            <param name="src">The source value</param>
            <typeparam name="F">The fixed type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.Cells.from``1(System.Runtime.Intrinsics.Vector128{``0}@)">
            <summary>
            Presents a 128-bit vector as a 128-bit fixed block
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.Cells.from``1(System.Runtime.Intrinsics.Vector256{``0}@)">
            <summary>
            Presents a 256-bit vector as a 256-bit fixed block
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.Cells.from``1(Z0.Vector512{``0}@)">
            <summary>
            Presents a 512-bit vector as a 512-bit fixed block
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.Cells.first``1(Z0.Cell8@)">
            <summary>
            Returns a generic reference to the leading storage cell of an 8-bit storage block
            </summary>
            <param name="src">The storage block</param>
            <typeparam name="T">The reference cell type, of maximal width=8</typeparam>
        </member>
        <member name="M:Z0.Cells.first``1(Z0.Cell16@)">
            <summary>
            Returns a generic reference to the leading storage cell of a 16-bit storage block
            </summary>
            <param name="src">The storage block</param>
            <typeparam name="T">The reference cell type, of maximal width=16</typeparam>
        </member>
        <member name="M:Z0.Cells.first``1(Z0.Cell32@)">
            <summary>
            Returns a generic reference to the leading storage cell of a 32-bit storage block
            </summary>
            <param name="src">The storage block</param>
            <typeparam name="T">The reference cell type, of maximal width=32</typeparam>
        </member>
        <member name="M:Z0.Cells.first``1(Z0.Cell64@)">
            <summary>
            Returns a generic reference to the leading storage cell of a 64-bit storage block
            </summary>
            <param name="src">The storage block</param>
            <typeparam name="T">The reference cell type, of maximal width=64</typeparam>
        </member>
        <member name="M:Z0.Cells.first``1(Z0.Cell128@)">
            <summary>
            Returns a generic reference to the leading storage cell of a 128-bit storage block
            </summary>
            <param name="src">The storage block</param>
            <typeparam name="T">The reference cell type, of maximal width=128</typeparam>
        </member>
        <member name="M:Z0.Cells.first``1(Z0.Cell256@)">
            <summary>
            Returns a generic reference to the leading storage cell of a 256-bit storage block
            </summary>
            <param name="src">The storage block</param>
            <typeparam name="T">The reference cell type, of maximal width=256</typeparam>
        </member>
        <member name="M:Z0.Cells.first``1(Z0.Cell512@)">
            <summary>
            Returns a generic reference to the leading storage cell of a 512-bit storage block
            </summary>
            <param name="src">The storage block</param>
            <typeparam name="T">The reference cell type, of maximal width=512</typeparam>
        </member>
        <member name="M:Z0.Cells.head``2(``0@)">
            <summary>
            Returns a generic reference to the leading storage cell of a fixed storage block
            </summary>
            <param name="src">The storage block</param>
            <typeparam name="T">The reference cell type</typeparam>
        </member>
        <member name="M:Z0.Cells.deposit``2(``0@,System.Int32,``1@,System.Int32)">
            <summary>
            Writes a specified number of source elements to a fixed target
            </summary>
            <param name="src">The source</param>
            <param name="count">The number of source elements to write</param>
            <param name="dst">The target</param>
            <param name="offset">The element-relative offset into the target</param>
            <typeparam name="S">The source cell type</typeparam>
        </member>
        <member name="M:Z0.Cells.view``1(Z0.Cell8@)">
            <summary>
            Presents an 8-bit value as a single-celled T-parametric readonly span
            </summary>
            <param name="src">The source value</param>
            <typeparam name="F">The fixed type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.Cells.view``1(Z0.Cell16@)">
            <summary>
            Presents a 32-bit value as a T-parametric readonly span
            </summary>
            <param name="src">The source value</param>
            <typeparam name="F">The fixed type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.Cells.view``1(Z0.Cell32@)">
            <summary>
            Presents a 32-bit value as a T-parametric readonly span
            </summary>
            <param name="src">The source value</param>
            <typeparam name="F">The fixed type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.Cells.view``1(Z0.Cell64@)">
            <summary>
            Presents a 64-bit value as a T-parametric readonly span
            </summary>
            <param name="src">The source value</param>
            <typeparam name="F">The fixed type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.Cells.view``1(Z0.Cell128@)">
            <summary>
            Presents a 128-bit value as a T-parametric readonly span
            </summary>
            <param name="src">The source value</param>
            <typeparam name="F">The fixed type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.Cells.view``1(Z0.Cell256@)">
            <summary>
            Presents a 256-bit value as a T-parametric readonly span
            </summary>
            <param name="src">The source value</param>
            <typeparam name="F">The fixed type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.Cells.view``1(Z0.Cell512@)">
            <summary>
            Presents a 512-bit value as a T-parametric readonly span
            </summary>
            <param name="src">The source value</param>
            <typeparam name="F">The fixed type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="T:Z0.CellKind">
            <summary>
            Defines cell data type classifiers
            </summary>
        </member>
        <member name="T:Z0.IDataCell">
            <summary>
            Characterizes a type that occupies a fixed amount of space at runtime
            </summary>
        </member>
        <member name="P:Z0.IDataCell.BitWidth">
            <summary>
            The invariant number of bits covered by the reifying type
            </summary>
        </member>
        <member name="M:Z0.XCell.CellStream``1(Z0.IPolyrand)">
            <summary>
            Creates a stream of fixed values
            </summary>
            <param name="random">The random source</param>
            <typeparam name="F">The fixed type</typeparam>
        </member>
        <member name="M:Z0.XCell.ToCell``1(System.Runtime.Intrinsics.Vector128{``0}@)">
            <summary>
            Presents a 128-bit vector as a 128-bit fixed block
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.XCell.ToCell``1(System.Runtime.Intrinsics.Vector256{``0}@)">
            <summary>
            Presents a 256-bit vector as a 256-bit fixed block
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.CellDelegates.define``1(System.Func{``0,``0},Z0.U8)">
            <summary>
            Creates a fixed 8-bit binary operator from caller-supplied delegate
            </summary>
            <param name="f">The source delegate</param>
        </member>
        <member name="M:Z0.CellDelegates.define``1(System.Func{``0,``0},Z0.U16)">
            <summary>
            Creates a fixed 16-bit binary operator from caller-supplied delegate
            </summary>
            <param name="f">The source delegate</param>
        </member>
        <member name="M:Z0.CellDelegates.define``1(System.Func{``0,``0},Z0.U32)">
            <summary>
            Creates a fixed 32-bit binary operator from caller-supplied delegate
            </summary>
            <param name="f">The source delegate</param>
        </member>
        <member name="M:Z0.CellDelegates.define``1(System.Func{``0,``0},Z0.U64)">
            <summary>
            Creates a fixed 64-bit binary operator from caller-supplied delegate
            </summary>
            <param name="f">The source delegate</param>
        </member>
        <member name="M:Z0.CellDelegates.define``1(System.Func{``0,``0,``0},Z0.U8)">
            <summary>
            Creates a fixed 16-bit binary operator from caller-supplied delegate
            </summary>
            <param name="f">The source delegate</param>
        </member>
        <member name="M:Z0.CellDelegates.define``1(System.Func{``0,``0,``0},Z0.U16)">
            <summary>
            Creates a fixed 16-bit binary operator from caller-supplied delegate
            </summary>
            <param name="f">The source delegate</param>
        </member>
        <member name="M:Z0.CellDelegates.define``1(System.Func{``0,``0,``0},Z0.U32)">
            <summary>
            Creates a fixed 32-bit binary operator from caller-supplied delegate
            </summary>
            <param name="f">The source delegate</param>
        </member>
        <member name="M:Z0.CellDelegates.define``1(System.Func{``0,``0,``0},Z0.U64)">
            <summary>
            Creates a fixed 64-bit binary operator from caller-supplied delegate
            </summary>
            <param name="f">The source delegate</param>
        </member>
        <member name="M:Z0.CellDelegates.define``2(Z0.UnaryOp{``1})">
            <summary>
            Manufactures a fixed-parametric unary operator from T-parametric unary operator
            </summary>
            <param name="f">The source operator</param>
            <typeparam name="F">The target operand type</typeparam>
            <typeparam name="T">The source operand type</typeparam>
        </member>
        <member name="M:Z0.CellDelegates.define``2(Z0.BinaryOp{``1})">
            <summary>
            Manufactures a fixed-parametric binary operator from T-parametric binary operator
            </summary>
            <param name="f">The source operator</param>
            <typeparam name="F">The target operand type</typeparam>
            <typeparam name="T">The source operand type</typeparam>
        </member>
        <member name="M:Z0.CellDelegates.revert``2(Z0.UnaryOp{``0})">
            <summary>
            Manufactures a T-parametric unary operator from a fixed-parametric unary operator
            </summary>
            <param name="f">The source operator</param>
            <typeparam name="F">The source operand type</typeparam>
            <typeparam name="T">The target operand type</typeparam>
        </member>
        <member name="M:Z0.CellDelegates.revert``2(Z0.BinaryOp{``0})">
            <summary>
            Manufactures a T-parametric binary operator from a fixed-parametric binary operator
            </summary>
            <param name="f">The source operator</param>
            <typeparam name="F">The source operand type</typeparam>
            <typeparam name="T">The target operand type</typeparam>
        </member>
        <member name="M:Z0.CellDelegates.define``1(System.Func{System.Runtime.Intrinsics.Vector128{``0},System.Runtime.Intrinsics.Vector128{``0}})">
            <summary>
            Creates a fixed 128-bit unary operator from caller-supplied delegate
            </summary>
            <param name="f">The source delegate</param>
        </member>
        <member name="M:Z0.CellDelegates.define``1(System.Func{System.Runtime.Intrinsics.Vector256{``0},System.Runtime.Intrinsics.Vector256{``0}})">
            <summary>
            Creates a fixed 256-bit binary operator from caller-supplied delegate
            </summary>
            <param name="f">The source delegate</param>
        </member>
        <member name="M:Z0.CellDelegates.define``1(System.Func{System.Runtime.Intrinsics.Vector128{``0},System.Runtime.Intrinsics.Vector128{``0},System.Runtime.Intrinsics.Vector128{``0}})">
            <summary>
            Creates a fixed 128-bit binary operator from caller-supplied delegate
            </summary>
            <param name="f">The source delegate</param>
        </member>
        <member name="M:Z0.CellDelegates.define``1(System.Func{System.Runtime.Intrinsics.Vector256{``0},System.Runtime.Intrinsics.Vector256{``0},System.Runtime.Intrinsics.Vector256{``0}})">
            <summary>
            Creates a fixed 256-bit binary operator from caller-supplied delegate
            </summary>
            <param name="f">The source delegate</param>
        </member>
        <member name="M:Z0.CellOps.apply``1(Z0.UnaryOp128,System.Runtime.Intrinsics.Vector128{``0})">
            <summary>
            Evaluates a 128-bit unary operator over a vector
            </summary>
            <param name="f">The operator</param>
            <param name="x">The source vector</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.CellOps.apply``1(Z0.UnaryOp256,System.Runtime.Intrinsics.Vector256{``0})">
            <summary>
            Evaluates a 256-bit unary operator over a vector
            </summary>
            <param name="f">The operator</param>
            <param name="x">The source vector</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.CellOps.apply``1(Z0.UnaryOp512,Z0.Vector512{``0}@)">
            <summary>
            Evaluates a 512-bit unary operator over a vector
            </summary>
            <param name="f">The operator</param>
            <param name="x">The source vector</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.CellOps.apply``1(Z0.BinaryOp128,System.Runtime.Intrinsics.Vector128{``0},System.Runtime.Intrinsics.Vector128{``0})">
            <summary>
            Evaluates a 128-bit binary operator over a pair of vectors
            </summary>
            <param name="f">The operator</param>
            <param name="x">The first vector</param>
            <param name="y">The second vector</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.CellOps.apply``1(Z0.BinaryOp256,System.Runtime.Intrinsics.Vector256{``0},System.Runtime.Intrinsics.Vector256{``0})">
            <summary>
            Evaluates a 256-bit binary operator over a pair of vectors
            </summary>
            <param name="f">The operator</param>
            <param name="x">The first vector</param>
            <param name="y">The second vector</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.CellOps.apply``1(Z0.BinaryOp512,Z0.Vector512{``0},Z0.Vector512{``0})">
            <summary>
            Evaluates a 512-bit binary operator over a pair of vectors
            </summary>
            <param name="f">The operator</param>
            <param name="x">The first vector</param>
            <param name="y">The second vector</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.CellOps.define``1(System.Func{System.Runtime.Intrinsics.Vector128{``0},System.Runtime.Intrinsics.Vector128{``0}})">
            <summary>
            Creates a fixed 128-bit unary operator from caller-supplied delegate
            </summary>
            <param name="f">The source delegate</param>
        </member>
        <member name="M:Z0.CellOps.define``1(System.Func{System.Runtime.Intrinsics.Vector256{``0},System.Runtime.Intrinsics.Vector256{``0}})">
            <summary>
            Creates a fixed 256-bit binary operator from caller-supplied delegate
            </summary>
            <param name="f">The source delegate</param>
        </member>
        <member name="M:Z0.CellOps.define``1(System.Func{System.Runtime.Intrinsics.Vector128{``0},System.Runtime.Intrinsics.Vector128{``0},System.Runtime.Intrinsics.Vector128{``0}})">
            <summary>
            Creates a fixed 128-bit binary operator from caller-supplied delegate
            </summary>
            <param name="f">The source delegate</param>
        </member>
        <member name="M:Z0.CellOps.define``1(System.Func{System.Runtime.Intrinsics.Vector256{``0},System.Runtime.Intrinsics.Vector256{``0},System.Runtime.Intrinsics.Vector256{``0}})">
            <summary>
            Creates a fixed 256-bit binary operator from caller-supplied delegate
            </summary>
            <param name="f">The source delegate</param>
        </member>
        <member name="T:Z0.ICellOpKind">
            <summary>
            Characterizes a fixed operator descriptor which both characterizes and describes
            an operator defined over operands of fixed-width
            </summary>
        </member>
        <member name="P:Z0.ICellOpKind.OperandWidth">
            <summary>
            The operand width
            </summary>
        </member>
        <member name="P:Z0.ICellOpKind.OperandType">
            <summary>
            The fixed operand type
            </summary>
        </member>
        <member name="P:Z0.ICellOpKind.OperatorType">
            <summary>
            The fixed delegate type
            </summary>
        </member>
        <member name="T:Z0.ICellOpKind`2">
            <summary>
            Characterizes a width-parametric fixed operator descriptor which both characterizes and describes
            an operator defined over operands of fixed-width
            </summary>
            <typeparam name="W">The operand width</typeparam>
        </member>
        <member name="T:Z0.ICellOpKind`3">
            <summary>
            Characterizes a width, operand and operator-parametric descriptor which both characterizes and describes
            an operator defined over operands of fixed-width
            </summary>
            <typeparam name="W">The operand width</typeparam>
            <typeparam name="T">The operand type</typeparam>
            <typeparam name="D">The operator type</typeparam>
        </member>
        <member name="F:Z0.CellDelegate.Id">
            <summary>
            The operation identity
            </summary>
        </member>
        <member name="P:Z0.CellOpKind.OperandWidth">
            <summary>
            The operand width
            </summary>
        </member>
        <member name="P:Z0.CellOpKind.OperandType">
            <summary>
            The fixed operand type
            </summary>
        </member>
        <member name="P:Z0.CellOpKind.OperatorType">
            <summary>
            The fixed delegate type
            </summary>
        </member>
        <member name="P:Z0.CellOpKind`2.OperandType">
            <summary>
            The fixed operand type
            </summary>
        </member>
        <member name="P:Z0.CellOpKind`2.OperatorType">
            <summary>
            The fixed delegate type
            </summary>
        </member>
        <member name="P:Z0.CellOpKind`2.OperandWidth">
            <summary>
            The operand width
            </summary>
        </member>
        <member name="T:Z0.CellOpKind`3">
            <summary>
            Classifies and describes operations defined over fixed operands
            </summary>
            <typeparam name="W">The operand width</typeparam>
            <typeparam name="T">The operand type</typeparam>
            <typeparam name="D">The operator type</typeparam>
        </member>
        <member name="M:Z0.ClassifierMap.create``1(Z0.W8,``0[])">
            <summary>
            Creates a 0-based classifier map with at most <see cref='F:Z0.Pow2.T08'/> entries with indices of type <see cref='T:System.Byte'/>
            </summary>
            <param name="w">The map width selector</param>
            <param name="src">The source classifiers</param>
            <typeparam name="K">The classifier type</typeparam>
        </member>
        <member name="M:Z0.ClassifierMap.create``1(Z0.W16,``0[])">
            <summary>
            Creates a 0-based classifier map with at most <see cref='F:Z0.Pow2.T16'/> entries with indices of type <see cref='T:System.UInt16'/>
            </summary>
            <param name="w">The map width selector</param>
            <param name="src">The source classifiers</param>
            <typeparam name="K">The classifier type</typeparam>
        </member>
        <member name="M:Z0.ClassifierMap.create``1(Z0.W32,``0[])">
            <summary>
            Creates a 0-based classifier map with at most <see cref='F:Z0.Pow2.T32'/> entries with indices of type <see cref='T:System.UInt32'/>
            </summary>
            <param name="w">The map width selector</param>
            <param name="src">The source classifiers</param>
            <typeparam name="K">The classifier type</typeparam>
        </member>
        <member name="M:Z0.ClassifierMap.create``1(Z0.W64,``0[])">
            <summary>
            Creates a 0-based classifier map with at most <see cref='F:Z0.Pow2.T32'/> entries with indices of type <see cref='T:System.UInt64'/>
            </summary>
            <param name="w">The map width selector</param>
            <param name="src">The source classifiers</param>
            <typeparam name="K">The classifier type</typeparam>
        </member>
        <member name="T:Z0.IClrArtifactRef">
            <summary>
            Characterizes an clr artifact reference
            </summary>
        </member>
        <member name="P:Z0.IClrArtifactRef.Kind">
            <summary>
            The artifact classifier
            </summary>
        </member>
        <member name="P:Z0.IClrArtifactRef.Key">
            <summary>
            The artifact key that, together with the artifact kind, forms an identity
            </summary>
        </member>
        <member name="P:Z0.IClrArtifactRef.Name">
            <summary>
            The name of the referenced artifact
            </summary>
        </member>
        <member name="T:Z0.ArgModifier">
            <summary>
            Classifies method *value* parameters
            </summary>
        </member>
        <member name="F:Z0.ArgModifier.None">
            <summary>
            No classification conferred
            </summary>
        </member>
        <member name="F:Z0.ArgModifier.In">
            <summary>
            Classifies paramters that are declared with the "in" modifier
            </summary>
        </member>
        <member name="F:Z0.ArgModifier.Out">
            <summary>
            Classifies paramters that are declared with the "out" modifier
            </summary>
        </member>
        <member name="F:Z0.ArgModifier.Ref">
            <summary>
            Classifies paramters that are declared with the "ref" modifier
            </summary>
        </member>
        <member name="F:Z0.ArgModifier.Literal">
            <summary>
            Classifies paramters that require literal values
            </summary>
        </member>
        <member name="F:Z0.ArgModifier.PrimalValue">
            <summary>
            Classifies paramters that require primitive values
            </summary>
        </member>
        <member name="F:Z0.ArgModifier.NumericValue">
            <summary>
            Classifies paramters that require primitive numeric values
            </summary>
        </member>
        <member name="F:Z0.ArgModifier.Text">
            <summary>
            Classifies paramters that are of <see cref='T:System.String'/> type
            </summary>
        </member>
        <member name="T:Z0.ArgRefKind">
            <summary>
            Defines a parameter reference partition that aligns with .net core system capabilities
            </summary>
        </member>
        <member name="F:Z0.ArgRefKind.None">
            <summary>
            The empty class
            </summary>
        </member>
        <member name="F:Z0.ArgRefKind.In">
            <summary>
            Classifies paramters that are declared with the "in" modifier
            </summary>
        </member>
        <member name="F:Z0.ArgRefKind.Out">
            <summary>
            Classifies paramters that are declared with the "out" modifier
            </summary>
        </member>
        <member name="F:Z0.ArgRefKind.Ref">
            <summary>
            Classifies paramters that are declared with the "ref" modifier
            </summary>
        </member>
        <member name="T:Z0.CliArtifactKind`1">
            <summary>
            Captures an artifact classifier via parametricity
            </summary>
        </member>
        <member name="T:Z0.CliArtfactRef">
            <summary>
            Defines a reference to an artifact
            </summary>
        </member>
        <member name="T:Z0.CliTypeRef`1">
            <summary>
            Defines a reference to a type
            </summary>
        </member>
        <member name="T:Z0.ClrArtifactCache">
            <summary>
            Defines a key-value association from an artifact to an entity of arbitrary type
            </summary>
        </member>
        <member name="T:Z0.ClrArtifactCache`1">
            <summary>
            Defines a key-value association from an artifact to an entity of parametric type
            </summary>
        </member>
        <member name="T:Z0.ClrArtifactKey">
            <summary>
            Identifies a metadata element
            </summary>
        </member>
        <member name="T:Z0.ClrArtifactKinds">
            <summary>
            Defines a set of types that projects each <see cref='T:System.Reflection.Metadata.Ecma335.TableIndex'/> literal into the type-system
            </summary>
        </member>
        <member name="T:Z0.ClrArtifactKinds.Module">
            <summary>
            Encodes the <see cref='!:I.IModule' /> literal as a type
            </summary>
        </member>
        <member name="T:Z0.ClrArtifactKinds.TypeRef">
            <summary>
            Encodes the <see cref='F:System.Reflection.Metadata.Ecma335.TableIndex.TypeRef' /> literal as a type
            </summary>
        </member>
        <member name="T:Z0.ClrArtifactKinds.TypeDef">
            <summary>
            Encodes the <see cref='F:System.Reflection.Metadata.Ecma335.TableIndex.TypeDef' /> literal as a type
            </summary>
        </member>
        <member name="T:Z0.ClrArtifactKinds.FieldPtr">
            <summary>
            Encodes the <see cref='F:System.Reflection.Metadata.Ecma335.TableIndex.FieldPtr' /> literal as a type
            </summary>
        </member>
        <member name="T:Z0.ClrArtifactKinds.Field">
            <summary>
            Encodes the <see cref='F:System.Reflection.Metadata.Ecma335.TableIndex.Field' /> literal as a type
            </summary>
        </member>
        <member name="T:Z0.ClrArtifactRef`1">
            <summary>
            Defines a reference to clr-specific artifact
            </summary>
        </member>
        <member name="T:Z0.ClrMemberIdentity">
            <summary>
            Identifies a metadata element
            </summary>
        </member>
        <member name="T:Z0.ClrMemberName">
            <summary>
            Defines an assembly-qualified type name
            </summary>
        </member>
        <member name="F:Z0.ClrQuerySpec.Default">
            <summary>
             The default query sort
            </summary>
        </member>
        <member name="F:Z0.ClrQuerySpec.Public">
            <summary>
             All declared non-public members
            </summary>
        </member>
        <member name="F:Z0.ClrQuerySpec.NonPublic">
            <summary>
             All declared non-public members
            </summary>
        </member>
        <member name="F:Z0.ClrQuerySpec.Static">
            <summary>
            All declared static members
            </summary>
        </member>
        <member name="F:Z0.ClrQuerySpec.Instance">
            <summary>
             All instance members
            </summary>
        </member>
        <member name="F:Z0.ClrQuerySpec.DeclaredInstance">
            <summary>
            All declared instance members
            </summary>
        </member>
        <member name="F:Z0.ClrQuerySpec.PublicStatic">
            <summary>
             All public static members, declared or inherited
            </summary>
        </member>
        <member name="F:Z0.ClrQuerySpec.PublicInstance">
            <summary>
             All public instance members, declared or inherited
            </summary>
        </member>
        <member name="F:Z0.ClrQuerySpec.NonPublicStatic">
            <summary>
             All declared non-public static members
            </summary>
        </member>
        <member name="F:Z0.ClrQuerySpec.NonPublicInstance">
            <summary>
             All declared non-public instance members
            </summary>
        </member>
        <member name="F:Z0.ClrQuerySpec.World">
            <summary>
            All of the knowable things
            </summary>
        </member>
        <member name="F:Z0.ClrQuerySpec.All">
            <summary>
             All members, declared or inherited
            </summary>
        </member>
        <member name="T:Z0.ClrTypeName">
            <summary>
            Defines an assembly-qualified type name
            </summary>
        </member>
        <member name="T:Z0.ClrArtifacts">
            <summary>
            Defines the primary interface for clr artifact interrogation
            </summary>
            <summary>
            Defines the primary interface for clr artifact interrogation
            </summary>
        </member>
        <member name="M:Z0.ClrArtifacts.fields(System.Type)">
            <summary>
            Returns a <see cref='T:System.Reflection.FieldInfo'/> array of the fields defined by the source
            </summary>
            <param name="src">The source type</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.ClrArtifacts.vFields(System.Type)" -->
        <member name="M:Z0.ClrArtifacts.metadata(System.Reflection.Assembly,Z0.SegRef@)">
            <summary>
            Returns a reference to the cli metadata for an assembly
            </summary>
            <param name="src">The source assembly</param>
        </member>
        <member name="M:Z0.ClrArtifacts.nested(System.Type)">
            <summary>
            Returns an unfiltered <see cref='T:System.Type'/> array of the nested types defined by the source
            </summary>
            <param name="src">The source type</param>
        </member>
        <member name="M:Z0.ClrArtifacts.nested(System.Type,Z0.ClrQuerySpec)">
            <summary>
            Returns a filtered <see cref='T:System.Type'/> array of the nested types defined by the source
            </summary>
            <param name="src">The source types</param>
            <param name="filter">The filter to apply</param>
        </member>
        <member name="M:Z0.ClrArtifacts.vNested(System.Type)">
            <summary>
            Returns an unfiltered <see cref='!:TypeType'/> view of the nested types defined by the source
            </summary>
            <param name="src">The source type</param>
        </member>
        <member name="M:Z0.ClrArtifacts.reference``1(``0)">
            <summary>
            Defines a reference to an artifact of parametric type
            </summary>
            <param name="src">The source artifact</param>
            <typeparam name="A">The artifact type</typeparam>
        </member>
        <member name="M:Z0.ClrArtifacts.reference(Z0.ClrArtifactKey)">
            <summary>
            Defines an <see cref='T:Z0.CliArtfactRef'/> predicated on an a <see cref='T:Z0.ClrArtifactKey'/>
            </summary>
            <param name="src">The defining type</param>
        </member>
        <member name="M:Z0.ClrArtifacts.facet(Z0.ClrArtifactKey,Z0.ClrArtifactKey,Z0.asci32@,Z0.variant@)">
            <summary>
            Defines a facet closed over a <see cref='T:Z0.ClrArtifactKey'/>
            </summary>
            <param name="src">The source artifact identifier</param>
            <param name="dst">The target artifact identifier</param>
            <param name="name">The facet name</param>
            <param name="value">The facet value</param>
        </member>
        <member name="M:Z0.ClrArtifacts.facet(Z0.ClrArtifactKey,Z0.ClrArtifactKey,System.String,Z0.variant@)">
            <summary>
            Defines a facet closed over a <see cref='T:Z0.ClrArtifactKey'/>
            </summary>
            <param name="src">The source artifact identifier</param>
            <param name="dst">The target artifact identifier</param>
            <param name="name">The facet name</param>
            <param name="value">The facet value</param>
        </member>
        <member name="M:Z0.ClrArtifacts.facet``1(Z0.ClrArtifactKey,Z0.ClrArtifactKey,System.String,``0)">
            <summary>
            Defines a facet closed over a <see cref='T:Z0.ClrArtifactKey'/>
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
            <param name="name"></param>
            <param name="value"></param>
            <typeparam name="A"></typeparam>
        </member>
        <member name="T:Z0.MethodParameter">
            <summary>
            Represents a method (value, not type) parameter
            </summary>
        </member>
        <member name="T:Z0.ParametricTarget">
            <summary>
            Classifies targets of generic arguments
            </summary>
        </member>
        <member name="F:Z0.ParametricTarget.Class">
            <summary>
            Indicates A generic argument targets a class
            </summary>
        </member>
        <member name="F:Z0.ParametricTarget.Struct">
            <summary>
            Indicates A generic argument targets a struct
            </summary>
        </member>
        <member name="F:Z0.ParametricTarget.Interface">
            <summary>
            Indicates A generic argument targets an interface
            </summary>
        </member>
        <member name="F:Z0.ParametricTarget.Delegate">
            <summary>
            Indicates A generic argument targets a delgate
            </summary>
        </member>
        <member name="F:Z0.ParametricTarget.Type">
            <summary>
            A generic argument applies to a type of some sort
            </summary>
        </member>
        <member name="F:Z0.ParametricTarget.Method">
            <summary>
            Indicates A generic argument targets a method
            </summary>
        </member>
        <member name="T:Z0.TaggedMember`2">
            <summary>
            Pairs a member attribute value with its target
            </summary>
        </member>
        <member name="F:Z0.TaggedMember`2.Member">
            <summary>
            The target member
            </summary>
        </member>
        <member name="F:Z0.TaggedMember`2.Tag">
            <summary>
            The tag value
            </summary>
        </member>
        <member name="T:Z0.TypeParameter">
            <summary>
            Represents a type parameter in a generic artifact definition
            </summary>
        </member>
        <member name="T:Z0.TypeParameters">
            <summary>
            Represents the open type parameters defined by a method
            </summary>
        </member>
        <member name="T:Z0.TypeSig">
            <summary>
            A succinct type signature
            </summary>
        </member>
        <member name="F:Z0.CliRecords.EnumLiteralRecord.PartId">
            <summary>
            The part in which the enum is defined
            </summary>
        </member>
        <member name="F:Z0.CliRecords.EnumLiteralRecord.TypeName">
            <summary>
            The name of the defining type
            </summary>
        </member>
        <member name="F:Z0.CliRecords.EnumLiteralRecord.TypeId">
            <summary>
            The metadata token of the defining type
            </summary>
        </member>
        <member name="F:Z0.CliRecords.EnumLiteralRecord.FieldName">
            <summary>
            The name of the literal identifier
            </summary>
        </member>
        <member name="F:Z0.CliRecords.EnumLiteralRecord.FieldId">
            <summary>
            The metadata token of the defining field
            </summary>
        </member>
        <member name="F:Z0.CliRecords.EnumLiteralRecord.DataType">
            <summary>
            The kind of primitive specialized by the enum
            </summary>
        </member>
        <member name="F:Z0.CliRecords.EnumLiteralRecord.Position">
            <summary>
            The literal declaration order within the defining enum
            </summary>
        </member>
        <member name="F:Z0.CliRecords.EnumLiteralRecord.LiteralValue">
            <summary>
            The primitive value
            </summary>
        </member>
        <member name="M:Z0.ClrDynamic.pointer(System.Reflection.Emit.DynamicMethod)">
            <summary>
            Finds the magical function pointer for a dynamic method
            </summary>
            <param name="method">The source method</param>
            <remarks>See https://stackoverflow.com/questions/45972562/c-sharp-how-to-get-runtimemethodhandle-from-dynamicmethod</remarks>
        </member>
        <member name="M:Z0.ClrDynamic.pointer(Z0.DynamicDelegate)">
            <summary>
            Creates a dynamic pointer from an untyped dynamic delegate
            </summary>
            <param name="src">The source delegate</param>
            <param name="handle">A proxy for the unmanaged pointer</param>
        </member>
        <member name="M:Z0.ClrDynamic.pointer``1(Z0.DynamicDelegate{``0})">
            <summary>
            Creates a dynamic pointer from a generic dynamic delegate
            </summary>
            <param name="src">The source delegate</param>
            <param name="handle">A proxy for the unmanaged pointer</param>
            <typeparam name="D">The delegate type</typeparam>
        </member>
        <member name="M:Z0.ClrDynamic.bytes(System.Reflection.Emit.DynamicMethod)">
            <summary>
            See https://stackoverflow.com/questions/4148297/resolving-the-tokens-found-in-the-il-from-a-dynamic-method/35711376#35711376
            </summary>
        </member>
        <member name="M:Z0.ClrDynamic.size(System.Reflection.MethodInfo)">
            <summary>
            Returns the size of the method, if known; otherwise, returns the monoidal zero
            </summary>
            <param name="src">The source method</param>
        </member>
        <member name="M:Z0.ClrDynamic.jit(System.Type)">
            <summary>
            Jits the method declared by a specified type
            </summary>
            <param name="src">The source type</param>
        </member>
        <member name="M:Z0.ClrPrimitives.numeric(System.Type)">
            <summary>
            Determines the numeric kind, if any, of a system type
            </summary>
            <param name="src">The source type</param>
        </member>
        <member name="M:Z0.ClrPrimitives.width(Z0.PrimalKind)">
            <summary>
            Computes the bit-width of the represented primitive
            </summary>
            <param name="f">The literal's bitfield</param>
        </member>
        <member name="M:Z0.ClrPrimitives.sign(Z0.PrimalKind)">
            <summary>
            Gets the numeric sign, if any, of the represented primitive
            </summary>
            <param name="f">The literal's bitfield</param>
        </member>
        <member name="M:Z0.ClrPrimitives.select(Z0.PrimalKind,Z0.PrimalBits.Field)">
            <summary>
            Gets the value of an identified bitfield segment
            </summary>
            <param name="src">The source bitfield</param>
            <param name="i">The segment identifier</param>
        </member>
        <member name="M:Z0.ClrPrimitives.filter(Z0.PrimalKind,Z0.PrimalBits.Field)">
            <summary>
            Isolates an identified bitfield segment
            </summary>
            <param name="src">The source bitfield</param>
            <param name="i">The segment identifier</param>
        </member>
        <member name="M:Z0.ClrQuery.ctor(System.Type,System.Type[])">
            <summary>
            Searches a type for an instance constructor that matches a specified signature
            </summary>
            <param name="declaring">The type to search</param>
            <param name="args">The method parameter types in ordinal position</param>
        </member>
        <member name="M:Z0.ClrQuery.ctor``1(System.Type[])">
            <summary>
            Searches a type for an instance constructor that matches a specified signature
            </summary>
            <param name="args">The method parameter types in ordinal position</param>
            <typeparam name="T">The type to search</typeparam>
        </member>
        <member name="M:Z0.ClrQuery.fields(System.Type)">
            <summary>
            Selects all instance/static and public/non-public fields declared or inherited by a type
            </summary>
            <param name="src">The type to examine</param>
        </member>
        <member name="M:Z0.ClrQuery.IsLiteral(System.Reflection.FieldInfo)">
            <summary>
            Returns true if the source field is a literal, false otherwise
            </summary>
            <param name="src">The field to test</param>
        </member>
        <member name="M:Z0.ClrQuery.IsStatic(System.Type)">
            <summary>
            Determines whether a type is static
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.ClrQuery.member``2(``0,``1)">
            <summary>
            Defines a tagged member
            </summary>
            <param name="m">The member</param>
            <param name="t">The tag</param>
            <typeparam name="M">The member type</typeparam>
            <typeparam name="T">The tag type</typeparam>
        </member>
        <member name="M:Z0.ClrQuery.method``3(System.String)">
            <summary>
            Searches a type for any method that matches the supplied signature
            </summary>
            <param name="name">The name of the method</param>
            <typeparam name="T">The type to search</typeparam>
            <typeparam name="A1">The first argument type</typeparam>
            <typeparam name="A2">The second argument type</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.ClrQuery.methods(System.Type)" -->
        <member name="M:Z0.ClrQuery.properties(System.Type)">
            <summary>
            Selects all instance/static and public/non-public properties declared or inherited by a type
            </summary>
            <param name="src">The type to examine</param>
        </member>
        <member name="F:Z0.ClrTypeCodes.null">
            <summary>
            0
            </summary>
        </member>
        <member name="F:Z0.ClrTypeCodes.obj">
            <summary>
            1
            </summary>
        </member>
        <member name="F:Z0.ClrTypeCodes.dbnull">
            <summary>
            2
            </summary>
        </member>
        <member name="F:Z0.ClrTypeCodes.u1">
            <summary>
            3
            </summary>
        </member>
        <member name="F:Z0.ClrTypeCodes.c16">
            <summary>
            4
            </summary>
        </member>
        <member name="F:Z0.ClrTypeCodes.i8">
            <summary>
            5
            </summary>
        </member>
        <member name="F:Z0.ClrTypeCodes.u8">
            <summary>
            6
            </summary>
        </member>
        <member name="F:Z0.ClrTypeCodes.i16">
            <summary>
            7
            </summary>
        </member>
        <member name="F:Z0.ClrTypeCodes.u16">
            <summary>
            8
            </summary>
        </member>
        <member name="F:Z0.ClrTypeCodes.i32">
            <summary>
            9
            </summary>
        </member>
        <member name="F:Z0.ClrTypeCodes.u32">
            <summary>
            10
            </summary>
        </member>
        <member name="F:Z0.ClrTypeCodes.i64">
            <summary>
            11
            </summary>
        </member>
        <member name="F:Z0.ClrTypeCodes.u64">
            <summary>
            12
            </summary>
        </member>
        <member name="F:Z0.ClrTypeCodes.f32">
            <summary>
            13
            </summary>
        </member>
        <member name="F:Z0.ClrTypeCodes.f64">
            <summary>
            14
            </summary>
        </member>
        <member name="F:Z0.ClrTypeCodes.f128">
            <summary>
            15
            </summary>
        </member>
        <member name="F:Z0.ClrTypeCodes.dt">
            <summary>
            16
            </summary>
        </member>
        <member name="F:Z0.ClrTypeCodes._">
            <summary>
            17
            </summary>
        </member>
        <member name="F:Z0.ClrTypeCodes.s">
            <summary>
            18
            </summary>
        </member>
        <member name="T:Z0.IClrRuntimeType">
            <summary>
            Characterizes a model of a CLR type during runtime
            </summary>
        </member>
        <member name="P:Z0.IClrRuntimeType.NestedTypes">
            <summary>
            Models of the types nested within the subject, if any
            </summary>
        </member>
        <member name="T:Z0.IClrRuntimeType`1">
            <summary>
            Characterizes an F-bound polyorphic type model reification
            </summary>
            <typeparam name="M">The reifying type</typeparam>
        </member>
        <member name="T:Z0.IClrRuntimeType`2">
            <summary>
            Characterizes a subject-parametric type model
            </summary>
            <typeparam name="M">The reified model type</typeparam>
            <typeparam name="T">The subject of the model</typeparam>
        </member>
        <member name="P:Z0.IClrRuntimeType`2.Untyped">
            <summary>
            The equivalent non-parametric model
            </summary>
        </member>
        <member name="T:Z0.IClrRuntimeType`3">
            <summary>
            Characterizes an F-bound polymorphic and subject-parametric type model
            </summary>
            <typeparam name="X">The reifying type</typeparam>
            <typeparam name="M">The reifying type of the equivalent non-parametric model</typeparam>
            <typeparam name="T">The subject of the model</typeparam>
        </member>
        <member name="T:Z0.ClrDataMember">
            <summary>
            Unifies fields and properties from a structural metadata represetnation perspective
            </summary>
        </member>
        <member name="F:Z0.ClrDataMember.Member">
            <summary>
            The represented member
            </summary>
        </member>
        <member name="P:Z0.ClrDataMember.Name">
            <summary>
            The member name
            </summary>
        </member>
        <member name="P:Z0.ClrDataMember.DataType">
            <summary>
            The type of data represented by the member
            </summary>
        </member>
        <member name="M:Z0.ClrEnum.Literals``1">
            <summary>
            Gets the literals defined by an enumeration
            </summary>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="T:Z0.ClrEnum`1">
            <summary>
            Represents a parametrically-identified clr enum
            </summary>
        </member>
        <member name="M:Z0.ClrEnum`1.LiteralValues">
            <summary>
            Gets the literals defined by an enumeration
            </summary>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="T:Z0.ClrFieldValue">
            <summary>
            Pairs a field with a weakly-typed value
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Z0.ClrFieldValues`1" -->
        <!-- Badly formed XML comment ignored for member "T:Z0.ClrFieldValue`1" -->
        <member name="T:Z0.ClrInterfaceMap">
            <summary>
            Captures the same information found in a <see cref="T:System.Reflection.InterfaceMapping"/>
            </summary>
        </member>
        <member name="T:Z0.ClrStruct`1">
            <summary>
            Represents a parametrically-identified clr struct
            </summary>
        </member>
        <member name="T:Z0.ClrType`1">
            <summary>
            Represents a parametrically-identified clr type
            </summary>
        </member>
        <member name="T:Z0.ClrViews">
            <summary>
            Defines the primary interface for clr artifact interrogation
            </summary>
        </member>
        <member name="M:Z0.ClrViews.view(System.Reflection.Module)">
            <summary>
            Defines a <see cref='T:Z0.ClrArtifacts.ModuleView'/> over the source
            </summary>
            <param name="src">The source module</param>
        </member>
        <member name="M:Z0.ClrViews.view(System.Reflection.MethodInfo)">
            <summary>
            Defines a <see cref='T:Z0.ClrArtifacts.MethodView'/> over the source
            </summary>
            <param name="src">The source module</param>
        </member>
        <member name="M:Z0.ClrViews.view(System.Reflection.FieldInfo)">
            <summary>
            Defines a <see cref='T:Z0.ClrArtifacts.FieldView'/> over the source
            </summary>
            <param name="src">The source module</param>
        </member>
        <member name="M:Z0.ClrViews.view(System.Reflection.ParameterInfo)">
            <summary>
            Defines a <see cref='T:Z0.ClrArtifacts.ValueParamView'/> over the source
            </summary>
            <param name="src">The source module</param>
        </member>
        <member name="T:Z0.DynamicDelegate">
            <summary>
            Encloses a delegate that was manufactured dynamically
            </summary>
        </member>
        <member name="F:Z0.DynamicDelegate.Id">
            <summary>
            The delegate identity
            </summary>
        </member>
        <member name="F:Z0.DynamicDelegate.SourceMethod">
            <summary>
            The method invoked by the dynamic operator that provides the substance of the operation
            </summary>
        </member>
        <member name="F:Z0.DynamicDelegate.TargetMethod">
            <summary>
            The dynamically-generated method that backs the dynamic operator
            </summary>
        </member>
        <member name="F:Z0.DynamicDelegate.DynamicOp">
            <summary>
            The dynamic operation
            </summary>
        </member>
        <member name="M:Z0.DynamicDelegate.Invoke(System.Object[])">
            <summary>
            Invokes the dynamic delegate dynamically
            </summary>
            <param name="args">The arguments to pass to the delegate</param>
        </member>
        <member name="M:Z0.DynamicDelegate.As``1">
            <summary>
            The existing delegate, parametrically
            </summary>
            <typeparam name="D">The target delegate type</typeparam>
        </member>
        <member name="T:Z0.DynamicDelegate`1">
            <summary>
            Encloses a generic delegate that was manufactured dynamically
            </summary>
        </member>
        <member name="P:Z0.DynamicDelegate`1.Id">
            <summary>
            The delegate identity
            </summary>
        </member>
        <member name="F:Z0.DynamicDelegate`1.Source">
            <summary>
            The method invoked by the dynamic operator that provides the substance of the operation
            </summary>
        </member>
        <member name="F:Z0.DynamicDelegate`1.Target">
            <summary>
            The dynamically-generated method that backs the dynamic operator
            </summary>
        </member>
        <member name="F:Z0.DynamicDelegate`1.DynamicOp">
            <summary>
            The dynamic operation
            </summary>
        </member>
        <member name="T:Z0.DynamicDelegate`2">
            <summary>
            Encloses a generic delegate that was manufactured dynamically
            </summary>
        </member>
        <member name="P:Z0.DynamicDelegate`2.Id">
            <summary>
            The delegate identity
            </summary>
        </member>
        <member name="F:Z0.DynamicDelegate`2.Source">
            <summary>
            The method invoked by the dynamic operator that provides the substance of the operation
            </summary>
        </member>
        <member name="F:Z0.DynamicDelegate`2.Target">
            <summary>
            The dynamically-generated method that backs the dynamic operator
            </summary>
        </member>
        <member name="F:Z0.DynamicDelegate`2.DynamicOp">
            <summary>
            The dynamic operation
            </summary>
        </member>
        <member name="T:Z0.DynamicPointer">
            <summary>
            Encloses a pointer to the native definition of a dynamic delegate
            </summary>
        </member>
        <member name="M:Z0.DynamicPointer.pointer(System.Reflection.Emit.DynamicMethod)">
            <summary>
            Finds the magical function pointer for a dynamic method
            </summary>
            <param name="method">The source method</param>
            <remarks>See https://stackoverflow.com/questions/45972562/c-sharp-how-to-get-runtimemethodhandle-from-dynamicmethod</remarks>
        </member>
        <member name="M:Z0.XClrQuery.AssemblyVersion(System.Reflection.Assembly)">
            <summary>
            Convenience accessor for the assembly's version
            </summary>
            <param name="a">The source assembly</param>
        </member>
        <member name="M:Z0.XClrQuery.GetSimpleName(System.Reflection.Assembly)">
            <summary>
            Gets the simple name of an assembly
            </summary>
            <param name="a">The source assembly</param>
        </member>
        <member name="M:Z0.XClrQuery.GetTag``1(System.Reflection.Assembly)">
            <summary>
            Gets the identified assembly attribute if present, otherwise NULL
            </summary>
            <param name="a">The source assembly</param>
            <typeparam name="A">The type of attribute for which to search</typeparam>
        </member>
        <member name="M:Z0.XClrQuery.IndexTaggedTypes``1(System.Reflection.Assembly,System.Func{System.Type,System.Boolean})">
            <summary>
            Gets the type attributions for the specified assembly
            </summary>
            <param name="a">The source assembly</param>
            <typeparam name="A">The attribute type</typeparam>
        </member>
        <member name="M:Z0.XClrQuery.Product(System.Reflection.Assembly)">
            <summary>
            Gets the value of <see cref="T:System.Reflection.AssemblyProductAttribute"/> if it exists
            </summary>
            <param name="a">The source assembly</param>
        </member>
        <member name="M:Z0.XClrQuery.Title(System.Reflection.Assembly)">
            <summary>
            Gets the value of <see cref="T:System.Reflection.AssemblyTitleAttribute"/> if it exists
            </summary>
            <param name="a">The source assembly</param>
        </member>
        <member name="M:Z0.XClrQuery.Company(System.Reflection.Assembly)">
            <summary>
            Gets the value of <see cref="T:System.Reflection.AssemblyCompanyAttribute"/> if it exists
            </summary>
            <param name="a">The source assembly</param>
        </member>
        <member name="M:Z0.XClrQuery.DefaultAlias(System.Reflection.Assembly)">
            <summary>
            Gets the value of <see cref="T:System.Reflection.AssemblyDefaultAliasAttribute"/> if it exists
            </summary>
            <param name="a">The source assembly</param>
        </member>
        <member name="M:Z0.XClrQuery.Tag``1(System.Reflection.Assembly)">
            <summary>
            Gets the identified assembly attribute if present, otherwise NULL
            </summary>
            <param name="a">The source assembly</param>
            <typeparam name="A">The type of attribute for which to search</typeparam>
        </member>
        <member name="M:Z0.XClrQuery.Tagged``1(System.Reflection.Assembly)">
            <summary>
            Determines whether an assembly has an attribute of a given type
            </summary>
            <param name="a">The source assembly</param>
            <typeparam name="T">The attribute type</typeparam>
        </member>
        <member name="M:Z0.XClrQuery.Mutable(System.Reflection.FieldInfo[])">
            <summary>
            Selects the mutable fields from a stream
            </summary>
            <param name="src">The source stream</param>
        </member>
        <member name="M:Z0.XClrQuery.Immutable(System.Reflection.FieldInfo[])">
            <summary>
            Selects the immutable fields from a stream
            </summary>
            <param name="src">The source stream</param>
        </member>
        <member name="M:Z0.XClrQuery.Literals(System.Reflection.FieldInfo[])">
            <summary>
            Selects literal fields from the source
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.XClrQuery.Literals(System.Reflection.FieldInfo[],System.Type)">
            <summary>
            Selects literal fields of specified type from the source
            </summary>
            <param name="src">The data source</param>
            <param name="match">The field type to match</param>
        </member>
        <member name="M:Z0.XClrQuery.LiteralValues(System.Reflection.FieldInfo[])">
            <summary>
            Queries literal fields for their values
            </summary>
            <param name="src">The source stream</param>
        </member>
        <member name="M:Z0.XClrQuery.LiteralValues``1(System.Reflection.FieldInfo[])">
            <summary>
            Queries literal fields for values of parametric type
            </summary>
            <param name="src">The source stream</param>
        </member>
        <member name="M:Z0.XClrQuery.Public(System.Reflection.FieldInfo[])">
            <summary>
            Selects the public fields from a stream
            </summary>
            <param name="src">The source stream</param>
        </member>
        <member name="M:Z0.XClrQuery.NonPublic(System.Reflection.FieldInfo[])">
            <summary>
            Selects the non-public fields from a stream
            </summary>
            <param name="src">The source stream</param>
        </member>
        <member name="M:Z0.XClrQuery.Static(System.Reflection.FieldInfo[])">
            <summary>
            Selects the static fields from a stream
            </summary>
            <param name="src">The source stream</param>
        </member>
        <member name="M:Z0.XClrQuery.Instance(System.Reflection.FieldInfo[])">
            <summary>
            Selects the instance fields from a stream
            </summary>
            <param name="src">The source stream</param>
        </member>
        <member name="M:Z0.XClrQuery.WithTypeNameLike(System.Reflection.FieldInfo[],System.String)">
            <summary>
            Selects the fields from the stream for which the field type name contains the search string
            </summary>
            <param name="src">The source stream</param>
            <param name="search">The search string</param>
        </member>
        <member name="M:Z0.XClrQuery.IsCompilerGenerated(System.Reflection.FieldInfo)">
            <summary>
            Determines whether a field has been generated by the compiler
            </summary>
            <param name="f">The field to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.Value(System.Reflection.FieldInfo,System.Object)">
            <summary>
            Attempts to retrieve the value of an instance or static field
            </summary>
            <param name="field">The field</param>
            <param name="instance">The object instance, if applicable</param>
        </member>
        <member name="M:Z0.XClrQuery.Value``1(System.Reflection.FieldInfo,System.Object)">
            <summary>
            Attempts to retrieves the value of a field
            </summary>
            <typeparam name="V">The value type</typeparam>
            <param name="member">The field</param>
            <param name="instance">The object instance, if applicable</param>
        </member>
        <member name="M:Z0.XClrQuery.Tagged``1(System.Collections.Generic.IEnumerable{``0},System.Type)">
            <summary>
            Selects the members with a particular attribute
            </summary>
            <param name="src">The members to examine</param>
            <param name="name">The name to match</param>
        </member>
        <member name="M:Z0.XClrQuery.Unignored``1(``0[])">
            <summary>
            Selects source members that are not tagged with <see cref='T:Z0.IgnoreAttribute'/>
            </summary>
            <param name="src">The members to examine</param>
            <param name="name">The name to match</param>
        </member>
        <member name="M:Z0.XClrQuery.WithNameLike``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Selects the members with names that contain the supplied search field
            </summary>
            <param name="src">The members to examine</param>
            <param name="search">The name to match</param>
        </member>
        <member name="M:Z0.XClrQuery.WithNameLike``1(``0[],System.String)">
            <summary>
            Selects the members with names that contain the supplied search field
            </summary>
            <param name="src">The members to examine</param>
            <param name="search">The name to match</param>
        </member>
        <member name="M:Z0.XClrQuery.WithNameLike``1(``0[],System.String[])">
            <summary>
            Selects the members with names that contain the supplied search field
            </summary>
            <param name="src">The members to examine</param>
            <param name="search">The name to match</param>
        </member>
        <member name="M:Z0.XClrQuery.WithNameStartingWith``1(``0[],System.String[])">
            <summary>
            Selects the members with names that contain the supplied search field
            </summary>
            <param name="src">The members to examine</param>
            <param name="search">The name to match</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.XClrQuery.HasGenericName(System.Reflection.MemberInfo)" -->
        <member name="M:Z0.XClrQuery.MemberValue(System.Reflection.MemberInfo,System.Object)">
            <summary>
            Gets the value of a specified field or property
            </summary>
            <param name="m">The field or property</param>
            <param name="o">The object on which the member is defined</param>
        </member>
        <member name="M:Z0.XClrQuery.MemberValue``1(System.Reflection.MemberInfo,System.Object)">
            <summary>
            Gets the value of the identified member field or property
            </summary>
            <typeparam name="T">The value type</typeparam>
            <param name="m">The member</param>
            <param name="o">The instance from which to access the member</param>
        </member>
        <member name="M:Z0.XClrQuery.Tag``1(System.Reflection.MemberInfo)">
            <summary>
            Gets the value of a member attribute if it exists
            </summary>
            <typeparam name="A">The attribute type</typeparam>
            <param name="m">The member</param>
        </member>
        <member name="M:Z0.XClrQuery.Tagged(System.Reflection.MemberInfo,System.Type)">
            <summary>
            Determines whether an attribute of specified type is attached to a member
            </summary>
            <param name="m">The member to test</param>
            <param name="tAttrib">The target attribute type</param>
        </member>
        <member name="M:Z0.XClrQuery.Tagged``1(System.Reflection.MemberInfo)">
            <summary>
            Determines whether an attribute is applied to a subject
            </summary>
            <param name="m">The subject to examine</param>
            <typeparam name="T">The type of attribute for which to check</typeparam>
        </member>
        <member name="M:Z0.XClrQuery.Untagged``1(System.Reflection.MemberInfo)">
            <summary>
            Returns true if a parametrically-identified attribute is not applied to the subject
            </summary>
            <param name="m">The subject to examine</param>
            <typeparam name="T">The type of attribute for which to check</typeparam>
        </member>
        <member name="M:Z0.XClrQuery.WithName``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>
            Selects the members with a particular name
            </summary>
            <param name="src">The members to examine</param>
            <param name="name">The name to match</param>
        </member>
        <member name="M:Z0.XClrQuery.WithName``1(``0[],System.String)">
            <summary>
            Selects the members with a particular name
            </summary>
            <param name="src">The members to examine</param>
            <param name="name">The name to match</param>
        </member>
        <member name="M:Z0.XClrQuery.WithName``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.HashSet{System.String})">
            <summary>
            Selects the members with a name that exists within a supplied set
            </summary>
            <param name="src">The members to examine</param>
            <param name="name">The name to match</param>
        </member>
        <member name="M:Z0.XClrQuery.Unignored(System.Reflection.MethodInfo[])">
            <summary>
            Selects source methods that are not tagged with <see cref='T:Z0.IgnoreAttribute'/>
            </summary>
            <param name="src">The source methods</param>
            <param name="name">The name to match</param>
        </member>
        <member name="M:Z0.XClrQuery.Static(System.Reflection.MethodInfo[])">
            <summary>
            Selects the static methods from a stream
            </summary>
            <param name="src">The methods to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.Concrete(System.Reflection.MethodInfo[])">
            <summary>
            Selects the concrete (not abstract) methods from a stream
            </summary>
            <param name="src">The methods to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.Public(System.Reflection.MethodInfo[])">
            <summary>
            Selects the public methods from a stream
            </summary>
            <param name="src">The methods to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.Returns``1(System.Reflection.MethodInfo[])">
            <summary>
            Selects the methods from a stream that return a particular type of value
            </summary>
            <param name="src">The methods to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.Returns(System.Reflection.MethodInfo[],System.Type)">
            <summary>
            Selects methods from a stream that return a particular type of value
            </summary>
            <param name="src">The methods to examine</param>
            <param name="rt">The method return type</param>
        </member>
        <member name="M:Z0.XClrQuery.Tagged``1(System.Reflection.MethodInfo[])">
            <summary>
            Selects the methods that are adorned with parametrically-identified attribute
            </summary>
            <param name="src">The methods to examine</param>
            <typeparam name="A">The attribute type</typeparam>
        </member>
        <member name="M:Z0.XClrQuery.ClosedGeneric(System.Reflection.MethodInfo[])">
            <summary>
            Selects the closed generic methods from a stream
            </summary>
            <param name="src">The methods to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.CreateDelegate``1(System.Reflection.MethodInfo)">
            <summary>
            Creates a delegate for a static method via the expression api
            </summary>
            <typeparam name="D">The type of the constructed delegate</typeparam>
            <param name="m">The method that will be invoked when delegate is activated</param>
        </member>
        <member name="M:Z0.XClrQuery.Exclude(System.Reflection.MethodInfo[],System.String[])">
            <summary>
            Filters out the source methods with names that match those from a specified array
            </summary>
            <param name="src">The source methods</param>
            <param name="names">The exclusion filter</param>
        </member>
        <member name="M:Z0.XClrQuery.Exclude(System.Reflection.MethodInfo[],System.Collections.Generic.ISet{System.String})">
            <summary>
            Filters out the source methods with names that match those from a specified set
            </summary>
            <param name="src">The source methods</param>
            <param name="names">The exclusion filter</param>
        </member>
        <member name="M:Z0.XClrQuery.GenericArguments(System.Reflection.MethodInfo)">
            <summary>
            Returns the arguments supplied to a constructed generic method; if the method is
            nongeneric, a generic type definition or some other variant, an empty result is returned
            </summary>
            <param name="src">The method to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.GenericDefinitions(System.Reflection.MethodInfo[])">
            <summary>
            For the generic methods in a stream, selects their respective definitions
            </summary>
            <param name="src">The methods to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.GenericParameters(System.Reflection.MethodInfo,System.Boolean)">
            <summary>
            If a method is non-generic, returns an empty list.
            If a method is open generic, returns a list describing the open parameters
            If a method is closed generic, returns a list describing the closed parameters
            </summary>
            <param name="m">The method to examine</param>
            <param name="effective">Whether to yield effective types or types as reported by the framework reflection api</param>
        </member>
        <member name="M:Z0.XClrQuery.GenericParameters(System.Reflection.MethodInfo)">
            <summary>
            Returns the generic parameters specified by a generic method definition or, if constructed,
            the parameters specified by the definition on which the construction was predicated. If nongeneric,
            returns an empty result
            </summary>
            <param name="src">The method to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.MakeGenericMethods(System.Reflection.MethodInfo,System.Type[])">
            <summary>
            Creates generic methods of parametric arity *1*
            </summary>
            <param name="src"></param>
            <param name="args"></param>
        </member>
        <member name="M:Z0.XClrQuery.MemberOf(System.Reflection.MethodInfo[],Z0.GenericState)">
            <summary>
            For the generic methods in a stream, selects their respective definitions
            </summary>
            <param name="src">The methods to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.NonGeneric(System.Reflection.MethodInfo[])">
            <summary>
            Selects the non-generic methods from a stream
            </summary>
            <param name="src">The methods to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.OpenGeneric(System.Reflection.MethodInfo[])">
            <summary>
            Queries the source for open generic methods
            </summary>
            <param name="src">The source methods</param>
        </member>
        <member name="M:Z0.XClrQuery.OpenGeneric(System.Reflection.MethodInfo[],System.Int32)">
            <summary>
            Queries the source for open generic methods that have a specified argument count
            </summary>
            <param name="src">The source methods</param>
            <param name="args">The target argument count</param>
        </member>
        <member name="M:Z0.XClrQuery.OpenTypeParameters(System.Reflection.MethodInfo,System.Boolean)">
            <summary>
            For a non-constructed generic method or a generic method definition, returns an array of the method's type parameters; otherwise, returns an empty array
            </summary>
            <param name="m">The method to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.Parameters(System.Reflection.MethodInfo)">
            <summary>
            Selects the method parameters that satisfy a predicate
            </summary>
            <param name="src">The method to examine</param>
            <param name="predicate">The predicate to match</param>
        </member>
        <member name="M:Z0.XClrQuery.Parameters(System.Reflection.MethodInfo,System.Func{System.Reflection.ParameterInfo,System.Boolean})">
            <summary>
            Selects the method parameters that satisfy a predicate
            </summary>
            <param name="src">The method to examine</param>
            <param name="predicate">The predicate to match</param>
        </member>
        <member name="M:Z0.XClrQuery.WithParameter(System.Reflection.MethodInfo[],System.Func{System.Reflection.ParameterInfo,System.Boolean})">
            <summary>
            Selects the methods from a stream where at least one parameter satisfies a specified predicate
            </summary>
            <param name="src">The method to examine</param>
            <param name="predicate">The predicate to match</param>
        </member>
        <member name="M:Z0.XClrQuery.IsOpenGeneric(System.Reflection.MethodInfo)">
            <summary>
            Returns true if the method accepts generic parameters, false otherwise
            </summary>
            <param name="m">The method to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.IsOpenGeneric(System.Reflection.MethodInfo,System.Int32)">
            <summary>
            Returns true if the method has a specified count of open generic parameters, false otherwise
            </summary>
            <param name="m">The method to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.IsClosedGeneric(System.Reflection.MethodInfo)">
            <summary>
            Returns true if the method has unspecified generic parameters, false otherwise
            </summary>
            <param name="src">The method to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.IsNonGeneric(System.Reflection.MethodInfo)">
            <summary>
            Returns true if the method has unspecified generic parameters, false otherwise
            </summary>
            <param name="src">The method to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.HasVoidReturn(System.Reflection.MethodInfo)">
            <summary>
            Determines whether a method has a void return and, consequently, cannot be a function
            </summary>
            <param name="m">The method to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.IsAction(System.Reflection.MethodInfo)">
            <summary>
            Determines whether a method has a void return
            </summary>
            <param name="m">The method to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.IsFunction(System.Reflection.MethodInfo)">
            <summary>
            Determines whether a method is a function
            </summary>
            <param name="m">The method to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.ArityValue(System.Reflection.MethodInfo)">
            <summary>
            Determines the number of parameters defined by a method
            </summary>
            <param name="m">The method to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.HasArityValue(System.Reflection.MethodInfo,System.Int32)">
            <summary>
            Determines whether a method has a specified arity
            </summary>
            <param name="m">The method to examine</param>
            <param name="arity">The arity to match</param>
        </member>
        <member name="M:Z0.XClrQuery.IsImplicitConverter(System.Reflection.MethodInfo)">
            <summary>
            Determines whether the method is an implicit conversion operator
            </summary>
            <param name="m">The method to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.IsExplicitConverter(System.Reflection.MethodInfo)">
            <summary>
            Determines whether the method is an explicit conversion operator
            </summary>
            <param name="m">The method to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.IsConversionOperator(System.Reflection.MethodInfo)">
            <summary>
            Determines whether a method is an implicit or explicit conversion operation
            </summary>
            <param name="m">The method to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.ParameterTypes(System.Reflection.MethodInfo)">
            <summary>
            Returns a method's parameter types
            </summary>
            <param name="m">The method to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.EffectiveParameterTypes(System.Reflection.MethodInfo)">
            <summary>
            Returns a method's parameter types
            </summary>
            <param name="m">The method to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.ParameterTypes(System.Reflection.MethodInfo,System.Boolean)">
            <summary>
            Returns a method's parameter types
            </summary>
            <param name="m">The method to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.ParameterType(System.Reflection.MethodInfo,System.Int32)">
            <summary>
            Determines the type of an index-identified parameter
            </summary>
            <param name="m">The method to examine</param>
            <param name="index">The parameter index</param>
        </member>
        <member name="M:Z0.XClrQuery.Reify(System.Reflection.MethodInfo,System.Type[])">
            <summary>
            Reifies a method if it is open generic; otherwise, returns the original method
            </summary>
            <param name="m">The source method</param>
            <param name="args">The types over which to close the method</param>
        </member>
        <member name="M:Z0.XClrQuery.Reify``1(System.Reflection.MethodInfo)">
            <summary>
            Reifies a 1-parameter generic method with a parametric type argument
            </summary>
            <param name="src">The source method</param>
            <param name="args">The type arguments</param>
        </member>
        <member name="M:Z0.XClrQuery.Reify``2(System.Reflection.MethodInfo)">
            <summary>
            Reifies a 2-parameter generic method with a parametric type argument
            </summary>
            <param name="src">The source method</param>
            <param name="args">The type arguments</param>
        </member>
        <member name="M:Z0.XClrQuery.Reify(System.Collections.Generic.IEnumerable{System.Reflection.MethodInfo},System.Type[])">
            <summary>
            Reifies generic source methods with supplied type arguments
            </summary>
            <param name="src">The source method</param>
            <param name="args">The type arguments</param>
        </member>
        <member name="M:Z0.XClrQuery.SuppliedTypeArgs(System.Reflection.MethodInfo,System.Boolean)">
            <summary>
            For a closed generic method, returns the supplied arguments; otherwise, returns an empty array
            </summary>
            <param name="m">The method to examine</param>
            <param name="effective">Whether to yield effective types or types as reported by the framework reflection api</param>
        </member>
        <member name="M:Z0.XClrQuery.Tag``1(System.Reflection.MethodInfo)">
            <summary>
            Gets the value of a member attribute if it exists
            </summary>
            <typeparam name="A">The attribute type</typeparam>
            <param name="m">The member</param>
        </member>
        <member name="M:Z0.XClrQuery.Tag``1(System.Reflection.MethodInfo,``0@)">
            <summary>
            Gets the value of a member attribute if it exists
            </summary>
            <typeparam name="A">The attribute type</typeparam>
            <param name="m">The member</param>
        </member>
        <member name="M:Z0.XClrQuery.WithArity(System.Reflection.MethodInfo[],System.Int32)">
            <summary>
            Selects functions from a stream
            </summary>
            <param name="src">The methods to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.WithParameterCount(System.Reflection.MethodInfo[],System.Int32)">
            <summary>
             Selects methods from a stream that have a specified parameter count
            </summary>
            <param name="src">The methods to examine</param>
            <param name="t">The parameter type to match</param>
        </member>
        <member name="M:Z0.XClrQuery.WithGenericParameterType(System.Reflection.MethodInfo[],System.Type)">
            <summary>
            Selects generic methods from a stream that have a specified generic type definition parameter
            </summary>
            <param name="src">The methods to examine</param>
            <param name="typedef">The type definition to match</param>
        </member>
        <member name="M:Z0.XClrQuery.WithParameterType(System.Reflection.MethodInfo[],System.Type)">
            <summary>
             Selects methods from a stream that declare a parameter that has a specified type
            </summary>
            <param name="src">The methods to examine</param>
            <param name="t">The parameter type to match</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.XClrQuery.WithParameterType``1(System.Reflection.MethodInfo[])" -->
        <member name="M:Z0.XClrQuery.WithParameterTypes(System.Reflection.MethodInfo[],System.Type[])">
            <summary>
             Selects methods from a stream that have specified parameter types
            </summary>
            <param name="src">The methods to examine</param>
            <param name="t">The parameter type to match</param>
        </member>
        <member name="M:Z0.XClrQuery.ConversionOperators(System.Reflection.MethodInfo[])">
            <summary>
            Selects the conversion operators from a stream
            </summary>
            <param name="src">The methods to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.WithoutConversionOperators(System.Reflection.MethodInfo[])">
            <summary>
            Removes any conversion operations from the stream
            </summary>
            <param name="src">The methods to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.Abstract(System.Reflection.MethodInfo[])">
            <summary>
            Selects the abstract methods from a stream
            </summary>
            <param name="src">The methods to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.Instance(System.Reflection.MethodInfo[])">
            <summary>
            Selects the instance methods from a stream
            </summary>
            <param name="src">The methods to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.NonPublic(System.Reflection.MethodInfo[])">
            <summary>
            Selects the non-public methods from a stream
            </summary>
            <param name="src">The methods to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.IsParametric(System.Reflection.ParameterInfo)">
            <summary>
            Determines whether a parameter's type is of some generic kind
            </summary>
            <param name="src">The source parameter</param>
        </member>
        <member name="M:Z0.XClrQuery.RefKind(System.Reflection.ParameterInfo)">
            <summary>
            Determines the variance of a parameter
            </summary>
            <param name="src">The source parameter</param>
        </member>
        <member name="M:Z0.XClrQuery.Tagged``1(System.Reflection.ParameterInfo)">
            <summary>
            Determines whether a parameter has a parametrically-identified attribute
            </summary>
            <param name="p">The parameter to examine</param>
            <typeparam name="A">The attribute type to check</typeparam>
        </member>
        <member name="M:Z0.XClrQuery.Instance(System.Reflection.PropertyInfo[])">
            <summary>
            Selects the instance properties from an array
            </summary>
            <param name="src">The source stream</param>
        </member>
        <member name="M:Z0.XClrQuery.PropertyTypes(System.Reflection.PropertyInfo[])">
            <summary>
            Selects the property type from each source property
            </summary>
            <param name="src">The source properties</param>
        </member>
        <member name="M:Z0.XClrQuery.Reifies(System.Reflection.PropertyInfo[],System.Type)">
            <summary>
            Selects the properties from a stream that reify a specified interface type
            </summary>
            <param name="src">The source stream</param>
            <param name="tInterface">The interface type</param>
        </member>
        <member name="M:Z0.XClrQuery.Static(System.Reflection.PropertyInfo[])">
            <summary>
            Selects the static properties from an array
            </summary>
            <param name="src">The source array</param>
        </member>
        <member name="M:Z0.XClrQuery.Tagged``1(System.Reflection.PropertyInfo[])">
            <summary>
            Selects properaties from a source stream to which a parametrically-identified attribute is attached
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="A">The attribute type</typeparam>
        </member>
        <member name="M:Z0.XClrQuery.WithGet(System.Reflection.PropertyInfo[])">
            <summary>
            Selects the properties with get methods from the stream
            </summary>
            <param name="src">The properties to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.WithPublicGet(System.Reflection.PropertyInfo[])">
            <summary>
            Selects the properties from a stream that have public accessesors
            </summary>
            <param name="src">The source stream</param>
        </member>
        <member name="M:Z0.XClrQuery.WithPropertyType(System.Reflection.PropertyInfo[],System.Type[])">
            <summary>
            Selects the source properties with property types that match one of the types in a caller-supplied parameter array
            </summary>
            <param name="src">The properties to filter</param>
            <param name="match">The property type match target</param>
        </member>
        <member name="M:Z0.XClrQuery.WithSet(System.Reflection.PropertyInfo[])">
            <summary>
            Selects the properties with set methods from the stream
            </summary>
            <param name="src">The properties to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.WithPublicSet(System.Reflection.PropertyInfo[])">
            <summary>
            Selects the properties from a stream that have public manipulators
            </summary>
            <param name="src">The source stream</param>
        </member>
        <member name="M:Z0.XClrQuery.DisplayName(System.Reflection.PropertyInfo)">
            <summary>
            Gets the display name specified by the eponymous attribute, if attributed; otherwise, returns the reflected property name
            </summary>
            <param name="src">The source property</param>
        </member>
        <member name="M:Z0.XClrQuery.HasPublicGetter(System.Reflection.PropertyInfo)">
            <summary>
            Determines whether the property has a public getter
            </summary>
            <param name="p">The property to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.HasPublicGetterAndSetter(System.Reflection.PropertyInfo)">
            <summary>
            Determines whether the property has both a public getter and setter
            </summary>
            <param name="p">The property to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.HasPublicSetter(System.Reflection.PropertyInfo)">
            <summary>
            Determines whether the property has a public setter
            </summary>
            <param name="p">The property to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.IsIndexer(System.Reflection.PropertyInfo)">
            <summary>
            Determines whether a property is an indexer
            </summary>
            <param name="p">The property to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.Read(System.Reflection.PropertyInfo,System.Object)">
            <summary>
            Attempts to retrieve the value of an instance or static property
            </summary>
            <param name="p">The property</param>
            <param name="instance">The object instance, if applicable</param>
        </member>
        <member name="M:Z0.XClrQuery.Value``1(System.Reflection.PropertyInfo,System.Object)">
            <summary>
            Attempts to retrieves the value of a static or instance property
            </summary>
            <typeparam name="V">The value type</typeparam>
            <param name="member">The property</param>
            <param name="instance">The object instance, if applicable</param>
        </member>
        <member name="M:Z0.XClrQuery.WithGetAndSet(System.Reflection.PropertyInfo[])">
            <summary>
            Selects the properties with both get/set methods from the stream
            </summary>
            <param name="src">The properties to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.WithPropertyType(System.Reflection.PropertyInfo[],System.Type)">
            <summary>
            Selects the properties from a stream of a specified type
            </summary>
            <param name="src">The source stream</param>
        </member>
        <member name="M:Z0.XClrQuery.angled(System.String)">
            <summary>
            Encloses text between less than and greater than characters
            </summary>
            <param name="content">The content to enclose</param>
        </member>
        <member name="M:Z0.XClrQuery.DisplayName(System.Reflection.MethodInfo)">
            <summary>
            Constructs a display name for a method
            </summary>
            <param name="src">The source method</param>
        </member>
        <member name="M:Z0.XClrQuery.DisplayName``1(System.Reflection.MethodBase)">
            <summary>
            Constructs a display name for a generic method specialized for a specified type
            </summary>
            <typeparam name="T">The relative type</typeparam>
            <param name="src">The source method</param>
        </member>
        <member name="M:Z0.XClrQuery.TypeParameters(System.Reflection.MethodInfo)">
            <summary>
            Describes a method's type parameters, if any
            </summary>
            <param name="method">The method to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.Metadata(System.Reflection.MethodInfo)">
            <summary>
            Derives a signature from reflected method metadata
            </summary>
            <param name="src">The source method</param>
        </member>
        <member name="M:Z0.XClrQuery.DisplayName(System.Type)">
            <summary>
            Constructs a display name for a type
            </summary>
            <param name="src">The source type</param>
        </member>
        <member name="M:Z0.XClrQuery.Abstract(System.Type[])">
            <summary>
            Selects the abstract types from a stream
            </summary>
            <param name="src">The source stream</param>
        </member>
        <member name="M:Z0.XClrQuery.DeclaredMethods(System.Type[])">
            <summary>
            Selects the public/non-public static/instance methods declared by a stream of types
            </summary>
            <param name="src">The types to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.Delegates(System.Type[])">
            <summary>
            Returns all source types which are delegates
            </summary>
            <param name="src">The source types</param>
        </member>
        <member name="M:Z0.XClrQuery.Fields(System.Type[])">
            <summary>
            Selects all fields from the source types
            </summary>
            <param name="src">The types to search</param>
        </member>
        <member name="M:Z0.XClrQuery.LiteralFields(System.Type[])">
            <summary>
            Selects all literal fields from the source types
            </summary>
            <param name="src">The types to search</param>
        </member>
        <member name="M:Z0.XClrQuery.Methods(System.Type[])">
            <summary>
            Selects all methods from the source types
            </summary>
            <param name="src">The types to search</param>
        </member>
        <member name="M:Z0.XClrQuery.Nested(System.Type[])">
            <summary>
            Selects all nested types declared by an array of source types
            </summary>
            <param name="src">The source types</param>
        </member>
        <member name="M:Z0.XClrQuery.NonPublic(System.Type[])">
            <summary>
            Selects the non-public types from a stream
            </summary>
            <param name="src">The source stream</param>
        </member>
        <member name="M:Z0.XClrQuery.Properties(System.Type[])">
            <summary>
            Selects all properties from the source types
            </summary>
            <param name="src">The types to search</param>
        </member>
        <member name="M:Z0.XClrQuery.Public(System.Type[])">
            <summary>
            Selects the public types from a stream
            </summary>
            <param name="src">The source stream</param>
        </member>
        <member name="M:Z0.XClrQuery.Realize``1(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Selects the types from a stream that implement a specific interface
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The interface type</typeparam>
        </member>
        <member name="M:Z0.XClrQuery.Static(System.Type[])">
            <summary>
            Selects the static types from a stream
            </summary>
            <param name="src">The source stream</param>
        </member>
        <member name="M:Z0.XClrQuery.StaticMethods(System.Type[])">
            <summary>
            Selects all static methods declared by the source types
            </summary>
            <param name="src">The types to search</param>
        </member>
        <member name="M:Z0.XClrQuery.StaticProperties(System.Type[])">
            <summary>
            Selects all static properties declared by the source types
            </summary>
            <param name="src">The types to search</param>
        </member>
        <member name="M:Z0.XClrQuery.Tagged``1(System.Collections.Generic.IEnumerable{System.Type})">
            <summary>
            Selects source types from the stream to which a parametrically-identified attribute is applied
            </summary>
            <param name="src">The source stypes</param>
            <typeparam name="A">The attribute type</typeparam>
        </member>
        <member name="M:Z0.XClrQuery.Tagged``1(System.Type[])">
            <summary>
            Selects source types from the stream to which a parametrically-identified attribute is applied
            </summary>
            <param name="src">The source stypes</param>
            <typeparam name="A">The attribute type</typeparam>
        </member>
        <member name="M:Z0.XClrQuery.CloseEnumerableType(System.Type)">
            <summary>
            Recursively close an IEnumerable generic type
            </summary>
            <param name="seq">The sequence type</param>
            <remarks>
            Adapted from https://blogs.msdn.microsoft.com/mattwar/2007/07/30/linq-building-an-iqueryable-provider-part-i/
            </remarks>
        </member>
        <member name="M:Z0.XClrQuery.DeclaredFields(System.Type)">
            <summary>
            Queries the source <see cref='T:System.Type'/> for <see cref='T:System.Reflection.FieldInfo'/> members determined by the <see cref='F:Z0.ReflectionFlags.BF_Declared'/> flags
            </summary>
            <param name="src">The source type</param>
        </member>
        <member name="M:Z0.XClrQuery.DeclaredInstanceFields(System.Type)">
            <summary>
            Queries the source <see cref='T:System.Type'/> for <see cref='T:System.Reflection.FieldInfo'/> members determined by the <see cref='F:Z0.ReflectionFlags.BF_DeclaredInstance'/> flags
            </summary>
            <param name="src">The source type</param>
        </member>
        <member name="M:Z0.XClrQuery.DeclaredMethods(System.Type)">
            <summary>
            Queries the source <see cref='T:System.Type'/> for <see cref='F:Z0.ReflectionFlags.BF_Declared'/> <see cref='T:System.Reflection.MethodInfo'/> members
            </summary>
            <param name="src">The source type</param>
        </member>
        <member name="M:Z0.XClrQuery.DeclaredMethods(System.Type,System.String)">
            <summary>
            Queries the source <see cref='T:System.Type'/> for <see cref='F:Z0.ReflectionFlags.BF_Declared'/> <see cref='T:System.Reflection.MethodInfo'/> members with a specified name
            </summary>
            <param name="src">The source type</param>
        </member>
        <member name="M:Z0.XClrQuery.DeclaredProperties(System.Type)">
            <summary>
            Queries the source <see cref='T:System.Type'/> for <see cref='T:System.Reflection.PropertyInfo'/> members determined by the <see cref='F:Z0.ReflectionFlags.BF_All'/> flags
            </summary>
            <param name="src">The source type</param>
        </member>
        <member name="M:Z0.XClrQuery.DeclaredStaticMethods(System.Type)">
            <summary>
            Queries the source <see cref='T:System.Type'/> for <see cref='T:System.Reflection.MethodInfo'/> members determined by the <see cref='F:Z0.ReflectionFlags.BF_DeclaredStatic'/> flags
            </summary>
            <param name="src">The source type</param>
        </member>
        <member name="M:Z0.XClrQuery.EffectiveType(System.Type)">
            <summary>
            Computes the effective type of the source <see cref='T:System.Type'/>
            </summary>
            <param name="src">The source type</param>
        </member>
        <member name="M:Z0.XClrQuery.ElementType(System.Type)">
            <summary>
            Queries the source <see cref='T:System.Type'/> for the <see cref='T:System.Type'/> it wraps
            </summary>
            <param name="src">The source type</param>
        </member>
        <member name="M:Z0.XClrQuery.Events(System.Type)">
            <summary>
            Queries the source <see cref='T:System.Type'/> for the <see cref='T:System.Reflection.EventInfo'/> members determined by the <see cref='F:Z0.ReflectionFlags.BF_World'/> flags
            </summary>
            <param name="src">The source type</param>
        </member>
        <member name="M:Z0.XClrQuery.Field(System.Type,System.String)">
            <summary>
            Attempts to retrieve a name-identified field from a type
            </summary>
            <param name="src">The type to examine</param>
            <param name="name">The name of the field</param>
            <param name="declared">Whether the field is required to be declared by the source type</param>
        </member>
        <member name="M:Z0.XClrQuery.Fields(System.Type)">
            <summary>
            Queries the source <see cref='T:System.Type'/> for the <see cref='T:System.Reflection.FieldInfo'/> members determined by the <see cref='F:Z0.ReflectionFlags.BF_All'/> flags
            </summary>
            <param name="src">The source type</param>
        </member>
        <member name="M:Z0.XClrQuery.GenericDefinition2(System.Type)">
            <summary>
            For a generic type or reference to a generic type, retrieves the generic type definition;
            otherwise, returns the void type
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.GenericParameters(System.Type,System.Boolean)">
            <summary>
            If a type is non-generic, returns an empty list.
            If a type is open generic, returns a list of generic arguments
            If a type is closed generic, returns a list of the types that were supplied as arguments to construct the type
            </summary>
            <param name="m">The method to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.HasDefaultPublicConstructor(System.Type)">
            <summary>
            Determines whether a type has a public default constructor
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.HasDefaultPublicConstructor``1">
            <summary>
            Determines whether a type has a public default constructor
            </summary>
            <typeparam name="T">The type to examine</typeparam>
        </member>
        <member name="M:Z0.XClrQuery.InstanceMethods(System.Type)">
            <summary>
            Retrieves the public and non-public instance methods declared by a type
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.Instantiate``1(System.Type,System.Object[])">
            <summary>
            Creates an instance of a type and casts the instance value as specified by a type parameter
            </summary>
            <typeparam name="T">The cast instance type</typeparam>
            <param name="t">The type for which an instance will be created</param>
            <param name="args">Arguments matched with/passed to an instance constructor defined by the type</param>
        </member>
        <member name="M:Z0.XClrQuery.Interfaces(System.Type)">
            <summary>
            Returns all interfaces realized by the type, including those inherited from
            supertypes
            </summary>
            <param name="src">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.IsClosedGeneric(System.Type,System.Boolean)">
            <summary>
            Determines whether a type is a constructed generic type
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.IsConcrete(System.Type)">
            <summary>
            Returns true if the source type is either non-generic or a generic type that has been closed over all parameters
            </summary>
            <param name="src">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.IsDelegate(System.Type)">
            <summary>
            Determines whether the specified type is a delegate type
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.IsEmpty(System.Type)">
            <summary>
            Returns true if the source type is null or void; otherwise, returns false
            </summary>
            <param name="src">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.IsGenericRef(System.Type)">
            <summary>
            Determines whether a type is a reference to a generic type
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.IsLiteral``1(``0)">
            <summary>
            Determines whether the enum value corresponds to a defined literal
            </summary>
            <param name="src">The enum value to check</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.XClrQuery.IsNonEmpty(System.Type)">
            <summary>
            Returns true if the source type is non-null and non-void; otherwise, returns false
            </summary>
            <param name="src">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.IsNullableType(System.Type)">
            <summary>
            Determines whether a type is nullable
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.IsNullable``1(System.Type)">
            <summary>
            Determine whether a type is a nullable type with a given underlying type
            </summary>
            <typeparam name="T">The underlying type</typeparam>
            <param name="t">The type to check</param>
            <returns>
            Returns true if t is both a nullable type and is of type T
            </returns>
        </member>
        <member name="M:Z0.XClrQuery.IsOpenGeneric(System.Type,System.Boolean)">
            <summary>
            Determines whether a type is an unconstructed generic type, also called an open generic type
            </summary>
            <param name="src">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.IsRef(System.Type)">
            <summary>
            Determines whether the type is a (memory) reference
            </summary>
            <param name="src">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.IsStatic(System.Type)">
            <summary>
            Determines whether a type is static
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.IsStruct(System.Type)">
            <summary>
            Determines whether a type is a struct
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.IsSystemDefined(System.Type)">
            <summary>
            Determines whether a type is system-defined primitive
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.IsPrimalNumeric(System.Type)">
            <summary>
            Determines whether a type is a system-defined and architecture-suppored numeric type or a system-defined variation thereof
            </summary>
            <param name="t">The type to examine</param>
            <remarks>
            Variations accounted for include
            A) System-defined nullable parametric closures over the type
            B) System-defined reference types that cover the type, including ref/out parameters and such
            C) THe system-defined pseudo-refinement mechanism known as an Enum
            </remarks>
        </member>
        <member name="M:Z0.XClrQuery.IsIntegral(System.Type)">
            <summary>
            Determines whether a type is a system-defined and architecture-supported integral type or a system-defined variation thereof
            </summary>
            <param name="t">The type to examine</param>
            <remarks>
            Variations accounted for include
            A) System-defined nullable parametric closures over the type
            B) System-defined reference types that cover the type, including ref/out parameters and such
            C) THe system-defined pseudo-refinement mechanism known as an Enum
            </remarks>
        </member>
        <member name="M:Z0.XClrQuery.IsUnsignedInt(System.Type)">
            <summary>
            Determines whether a type is a system-defined and architecture-supported signed integral type or a system-defined variation thereof
            </summary>
            <param name="t">The type to examine</param>
            <remarks>
            Variations accounted for include
            A) System-defined nullable parametric closures over the type
            B) System-defined reference types that cover the type, including ref/out parameters and such
            C) THe system-defined pseudo-refinement mechanism known as an Enum
            </remarks>
        </member>
        <member name="M:Z0.XClrQuery.IsSignedInt(System.Type)">
            <summary>
            Determines whether a type is a system-defined and architecture-supported unsigned integral type or a system-defined variation thereof
            </summary>
            <param name="t">The type to examine</param>
            <remarks>
            Variations accounted for include
            A) System-defined nullable parametric closures over the type
            B) System-defined reference types that cover the type, including ref/out parameters and such
            C) THe system-defined pseudo-refinement mechanism known as an Enum
            </remarks>
        </member>
        <member name="M:Z0.XClrQuery.IsFloatingPoint(System.Type)">
            <summary>
            Determines whether a type is a system-defined and architecture-supported floating-point type or a system-defined variation thereof
            </summary>
            <param name="t">The type to examine</param>
            <remarks>
            Variations accounted for include
            A) System-defined nullable parametric closures over the type
            B) System-defined reference types that cover the type, including ref/out parameters and such
            C) THe system-defined pseudo-refinement mechanism known as an Enum
            </remarks>
        </member>
        <member name="M:Z0.XClrQuery.IsBool(System.Type)">
            <summary>
            Determines whether a supplied type is predicated on a bool, including nullable wrappers and references
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.IsString(System.Type)">
            <summary>
            Determines whether a supplied type is predicated on a string, including references
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.IsObject(System.Type)">
            <summary>
            Determines whether a supplied type is predicated on a string, including references
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.IsVoid(System.Type)">
            <summary>
            Determines whether a supplied type is of type Void
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.IsChar(System.Type)">
            <summary>
            Determines whether a supplied type is predicated on a char, including nullable wrappers and references
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.IsByte(System.Type)">
            <summary>
            Determines whether a type is the system-defined 8-bit unsigned integer type or a system-defined variation thereof
            </summary>
            <param name="t">The type to examine</param>
            <remarks>
            Variations accounted for include
            A) System-defined nullable parametric closures over the type
            B) System-defined reference types that cover the type, including ref/out parameters and such
            C) THe system-defined pseudo-refinement mechanism known as an Enum
            </remarks>
        </member>
        <member name="M:Z0.XClrQuery.IsSByte(System.Type)">
            <summary>
            Determines whether a type the system-defined 8-bit signed integer type or a system-defined variation thereof
            </summary>
            <param name="t">The type to examine</param>
            <remarks>
            Variations accounted for include
            A) System-defined nullable parametric closures over the type
            B) System-defined reference types that cover the type, including ref/out parameters and such
            C) THe system-defined pseudo-refinement mechanism known as an Enum
            </remarks>
        </member>
        <member name="M:Z0.XClrQuery.IsUInt8(System.Type)">
            <summary>
            Determines whether a type the system-defined 8-bit unsigned integer type or a system-defined variation thereof
            </summary>
            <param name="t">The type to examine</param>
            <remarks>
            Variations accounted for include
            A) System-defined nullable parametric closures over the type
            B) System-defined reference types that cover the type, including ref/out parameters and such
            C) THe system-defined pseudo-refinement mechanism known as an Enum
            </remarks>
        </member>
        <member name="M:Z0.XClrQuery.IsInt8(System.Type)">
            <summary>
            Determines whether a type the system-defined 8-bit signed integer type or a system-defined variation thereof
            </summary>
            <param name="t">The type to examine</param>
            <remarks>
            Variations accounted for include
            A) System-defined nullable parametric closures over the type
            B) System-defined reference types that cover the type, including ref/out parameters and such
            C) THe system-defined pseudo-refinement mechanism known as an Enum
            </remarks>
        </member>
        <member name="M:Z0.XClrQuery.IsUInt16(System.Type)">
            <summary>
            Determines whether a type the system-defined 16-bit unsigned integer type or a system-defined variation thereof
            </summary>
            <param name="t">The type to examine</param>
            <remarks>
            Variations accounted for include
            A) System-defined nullable parametric closures over the type
            B) System-defined reference types that cover the type, including ref/out parameters and such
            C) THe system-defined pseudo-refinement mechanism known as an Enum
            </remarks>
        </member>
        <member name="M:Z0.XClrQuery.IsInt16(System.Type)">
            <summary>
            Determines whether a type the system-defined 16-bit signed integer type or a system-defined variation thereof
            </summary>
            <param name="t">The type to examine</param>
            <remarks>
            Variations accounted for include
            A) System-defined nullable parametric closures over the type
            B) System-defined reference types that cover the type, including ref/out parameters and such
            C) THe system-defined pseudo-refinement mechanism known as an Enum
            </remarks>
        </member>
        <member name="M:Z0.XClrQuery.IsUInt32(System.Type)">
            <summary>
            Determines whether a type the system-defined 32-bit unsigned integer type or a system-defined variation thereof
            </summary>
            <param name="t">The type to examine</param>
            <remarks>
            Variations accounted for include
            A) System-defined nullable parametric closures over the type
            B) System-defined reference types that cover the type, including ref/out parameters and such
            C) THe system-defined pseudo-refinement mechanism known as an Enum
            </remarks>
        </member>
        <member name="M:Z0.XClrQuery.IsInt32(System.Type)">
            <summary>
            Determines whether a type the system-defined 32-bit signed integer type or a system-defined variation thereof
            </summary>
            <param name="t">The type to examine</param>
            <remarks>
            Variations accounted for include
            A) System-defined nullable parametric closures over the type
            B) System-defined reference types that cover the type, including ref/out parameters and such
            C) THe system-defined pseudo-refinement mechanism known as an Enum
            </remarks>
        </member>
        <member name="M:Z0.XClrQuery.IsUInt64(System.Type)">
            <summary>
            Determines whether a type the system-defined 64-bit unsigned integer type or a system-defined variation thereof
            </summary>
            <param name="t">The type to examine</param>
            <remarks>
            Variations accounted for include
            A) System-defined nullable parametric closures over the type
            B) System-defined reference types that cover the type, including ref/out parameters and such
            C) THe system-defined pseudo-refinement mechanism known as an Enum
            </remarks>
        </member>
        <member name="M:Z0.XClrQuery.IsInt64(System.Type)">
            <summary>
            Determines whether a type the system-defined 64-bit signed integer type or a system-defined variation thereof
            </summary>
            <param name="t">The type to examine</param>
            <remarks>
            Variations accounted for include
            A) System-defined nullable parametric closures over the type
            B) System-defined reference types that cover the type, including ref/out parameters and such
            C) THe system-defined pseudo-refinement mechanism known as an Enum
            </remarks>
        </member>
        <member name="M:Z0.XClrQuery.IsSingle(System.Type)">
            <summary>
            Determines whether a type the system-defined 32-bit floating-point type or a system-defined variation thereof
            </summary>
            <param name="t">The type to examine</param>
            <remarks>
            Variations accounted for include
            A) System-defined nullable parametric closures over the type
            B) System-defined reference types that cover the type, including ref/out parameters and such
            C) THe system-defined pseudo-refinement mechanism known as an Enum
            </remarks>
        </member>
        <member name="M:Z0.XClrQuery.IsFloat32(System.Type)">
            <summary>
            Determines whether a type the system-defined 32-bit floating-point type or a system-defined variation thereof
            </summary>
            <param name="t">The type to examine</param>
            <remarks>
            Variations accounted for include
            A) System-defined nullable parametric closures over the type
            B) System-defined reference types that cover the type, including ref/out parameters and such
            C) THe system-defined pseudo-refinement mechanism known as an Enum
            </remarks>
        </member>
        <member name="M:Z0.XClrQuery.IsDouble(System.Type)">
            <summary>
            Determines whether a type the system-defined 64-bit floating-point type or a system-defined variation thereof
            </summary>
            <param name="t">The type to examine</param>
            <remarks>
            Variations accounted for include
            A) System-defined nullable parametric closures over the type
            B) System-defined reference types that cover the type, including ref/out parameters and such
            C) THe system-defined pseudo-refinement mechanism known as an Enum
            </remarks>
        </member>
        <member name="M:Z0.XClrQuery.IsFloat64(System.Type)">
            <summary>
            Determines whether a type the system-defined 64-bit floating-point type or a system-defined variation thereof
            </summary>
            <param name="t">The type to examine</param>
            <remarks>
            Variations accounted for include
            A) System-defined nullable parametric closures over the type
            B) System-defined reference types that cover the type, including ref/out parameters and such
            C) THe system-defined pseudo-refinement mechanism known as an Enum
            </remarks>
        </member>
        <member name="M:Z0.XClrQuery.IsDecimal(System.Type)">
            <summary>
            Determines whether a supplied type is predicated on a double, including enums, nullable wrappers and references
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.IsTypeOf(System.Type,System.Type)">
            <summary>
            Determines whether a source type is predicated on a specified match type, including nullable wrappers, references and enums
            </summary>
            <typeparam name="T">The type to match</typeparam>
            <param name="candidate">The source type</param>
            <param name="match">The type to match</param>
        </member>
        <member name="M:Z0.XClrQuery.IsTypeOf``1(System.Type)">
            <summary>
            Determines whether a source type is predicated on a parametric type, including nullable wrappers, references and enums
            </summary>
            <param name="match">The source type</param>
            <typeparam name="T">The type to match</typeparam>
        </member>
        <member name="M:Z0.XClrQuery.IsUnManaged(System.Type)">
            <summary>
            Determines whether a type is unmanaged
            </summary>
            <param name="t">The type to test</param>
            <remarks>Idea from https://stackoverflow.com/questions/53968920/how-do-i-check-if-a-type-fits-the-unmanaged-constraint-in-c</remarks>
        </member>
        <member name="M:Z0.XClrQuery.LiteralFields(System.Type)">
            <summary>
            Queries the source <see cref='T:System.Type'/> for <see cref='T:System.Reflection.FieldInfo'/> members determined by the
            <see cref='F:Z0.ReflectionFlags.BF_Declared'/> flags where <see cref='P:System.Reflection.FieldInfo.IsLiteral'/> is true
            </summary>
            <param name="src">The source type</param>
        </member>
        <member name="M:Z0.XClrQuery.LiteralFields(System.Type,System.Type)">
            <summary>
            Queries the source <see cref='T:System.Type'/> for <see cref='T:System.Reflection.FieldInfo'/> members determined by the
            <see cref='F:Z0.ReflectionFlags.BF_Declared'/> flags where <see cref='P:System.Reflection.FieldInfo.IsLiteral'/> is true with field types that match
            a specified type
            </summary>
            <param name="src">The source type</param>
            <param name="match">The literal field type to match</param>
        </member>
        <member name="M:Z0.XClrQuery.LiteralFieldValue``1(System.Type,System.String,``0)">
            <summary>
            Queries the source <see cref='T:System.Type'/> for the value of a name-identified literal <see cref='T:System.Reflection.FieldInfo'/>
            </summary>
            <param name="src">The source type</param>
            <param name="name">The field name</param>
            <param name="fallback">The value returned if the field doesn't exist</param>
            <typeparam name="T">The literal value type</typeparam>
        </member>
        <member name="M:Z0.XClrQuery.LiteralFieldValues``1(System.Type,System.ReadOnlySpan{System.Reflection.FieldInfo}@)">
            <summary>
            Fetches the values of literal fields declared by a specified type that are of specified parametric type
            </summary>
            <param name="src">The source type</param>
            <param name="fields">The fields for which values are specified</param>
            <typeparam name="T">The literal field type</typeparam>
        </member>
        <member name="M:Z0.XClrQuery.LiteralValues``1(System.Type)">
            <summary>
            Selects the literal fields defined by a type and extracts/casts their values
            </summary>
            <param name="src">The source type</param>
            <typeparam name="T">The target value type</typeparam>
        </member>
        <member name="M:Z0.XClrQuery.LiteralValueIndex``1(System.Type,System.String,System.Nullable{System.Int32})">
            <summary>
            Enumerates the literals defined by a type indexed by declaration order and which have names that match a specified filter
            </summary>
            <param name="src">The source type</param>
            <param name="declared">Whether a literal is required to be declared by the type</param>
        </member>
        <member name="M:Z0.XClrQuery.MatchMethod(System.Type,System.String,System.Type[])">
            <summary>
            Searches a type for any method that matches the supplied signature
            </summary>
            <param name="declarer">The type to search</param>
            <param name="name">The name of the method</param>
            <param name="paramTypes">The method parameter types in ordinal position</param>
        </member>
        <member name="M:Z0.XClrQuery.Method(System.Type,System.String)">
            <summary>
            Selects the first method found on the type, if any, that has a specified name
            </summary>
            <param name="src">The type to examine</param>
            <param name="name">The name to match</param>
        </member>
        <member name="M:Z0.XClrQuery.Methods(System.Type)">
            <summary>
            Selects all methods available through the type
            </summary>
            <param name="src">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.NonSpecialMethods(System.Type)">
            <summary>
            Selects all methods declared by a type; however, property getters/setters and other
            compiler-generated artifacts are excluded
            </summary>
            <param name="src">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.OpenTypeParameters(System.Type)">
            <summary>
            For a non-constructed generic type or a generic type definition, returns an
            array of defined type parameters; otherwise, returns an empty array
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.OpenTypeParameterCount(System.Type)">
            <summary>
            Returns the number of open generic paramters defined by the source type
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.Properties(System.Type)">
            <summary>
            Retrieves all declared or inheraited by a type
            </summary>
            <param name="src">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.PropertyAttributions``1(System.Type)">
            <summary>
            Retrieves the type's properties together with applied attributes
            </summary>
            <typeparam name="A">The attribute type</typeparam>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.PublicFields(System.Type)">
            <summary>
            Selects all public static/instance fields from the source
            </summary>
            <param name="src">The source type</param>
        </member>
        <member name="M:Z0.XClrQuery.PublicInstanceMethods(System.Type)">
            <summary>
            Selects all public instance fields from the source
            </summary>
            <param name="src">The source type</param>
        </member>
        <member name="M:Z0.XClrQuery.PublicInstanceFields(System.Type)">
            <summary>
            Selects all public instance fields from the source
            </summary>
            <param name="src">The source type</param>
        </member>
        <member name="M:Z0.XClrQuery.Reifies(System.Type,System.Type)">
            <summary>
            Determines whether a type implements a specified interface
            </summary>
            <param name="src">The type to examine</param>
            <param name="tInterface">The interface type to test</param>
        </member>
        <member name="M:Z0.XClrQuery.Reifies``1(System.Type)">
            <summary>
            Determines whether a type implements a parametrically-specific interface
            </summary>
            <typeparam name="T">The interface type</typeparam>
            <param name="src">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.RootType(System.Type)">
            <summary>
            If a value type and not an enum, returns the type;
            If an enum returns the underlying integral type;
            If a nullable value typethat is not an enum, returns the underlying type;
            if nullable enum, returns the non-nullable underlying integral type
            If a pointer returns the pointer type
            Otherwise, returns the effective type
            </summary>
            <param name="src">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.StaticMethods(System.Type)">
            <summary>
            Gets the static methods defined on a specified type
            </summary>
            <param name="src">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.StaticMethods(System.Type,System.String)">
            <summary>
            Retrieves the public and non-public static methods declared by a type that have a specific name
            </summary>
            <param name="t">The type to examine</param>
            <param name="InstanceType">Whether to selct static or instance </param>
        </member>
        <member name="M:Z0.XClrQuery.StaticProperties(System.Type)">
            <summary>
            Gets the static properties declared by a specified type
            </summary>
            <param name="this">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.StaticProperties(System.Type,System.Boolean)">
            <summary>
            Gets the static methods defined on a specified type
            </summary>
            <param name="this">The type to examine</param>
            <param name="get">Specifies whether to require selected properties to provide get accessors</param>
        </member>
        <member name="M:Z0.XClrQuery.StaticProperties(System.Type,System.Boolean,System.Boolean)">
            <summary>
            Gets the static properties defined on a specified type that provided get/set accessors/manipulators
            per the provided specifiation
            </summary>
            <param name="this">The type to examine</param>
            <param name="get">Specifies whether to include or exclude properties with get accessors</param>
            <param name="set">Specifies whether to include or exclude properties with set accessors</param>
        </member>
        <member name="M:Z0.XClrQuery.Tag``1(System.Type,System.Boolean)">
            <summary>
            Gets the value of a member attribute if it exists
            </summary>
            <typeparam name="A">The attribute type</typeparam>
            <param name="m">The member</param>
        </member>
        <member name="M:Z0.XClrQuery.Tagged``1(System.Type)">
            <summary>
            Determines whether an attribute is applied to a type
            </summary>
            <param name="src">The source type</param>
            <typeparam name="A">The attribute type</typeparam>
        </member>
        <member name="M:Z0.XClrQuery.TEffective(System.Type)">
            <summary>
            If the source type is a type reference, returns the referenced type; otherwise, returns the original type
            </summary>
            <param name="src">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.TEnumBase(System.Type)">
            <summary>
            If source type is an enum, returns the integral base type; otherwise returns the empty type
            </summary>
            <param name="src">The source type</param>
        </member>
        <member name="M:Z0.XClrQuery.TNullableBase(System.Type)">
            <summary>
            If source type is n nullable value type, returns the underlying type; otherwise returns the empty type
            </summary>
            <param name="src">The source type</param>
        </member>
        <member name="M:Z0.XClrQuery.TPointer(System.Type)">
            <summary>
            If the source type is a pointer, returns the type to which the pointer points; otherwise, returns the empty type
            </summary>
            <param name="src">The source type</param>
        </member>
        <member name="M:Z0.XClrQuery.Concrete(System.Type[])">
            <summary>
            Selects the concrete types from a stream
            </summary>
            <param name="src">The source stream</param>
        </member>
        <member name="M:Z0.XClrQuery.Interfaces(System.Type[])">
            <summary>
            Returns all source types which ar interfaces
            </summary>
            <param name="src">The source types</param>
        </member>
        <member name="M:Z0.XClrQuery.Classes(System.Type[])">
            <summary>
            Returns all source types which are classes
            </summary>
            <param name="src">The source types</param>
        </member>
        <member name="M:Z0.XClrQuery.Structs(System.Type[])">
            <summary>
            Returns all source types which are structs
            </summary>
            <param name="src">The source types</param>
        </member>
        <member name="M:Z0.XClrQuery.Enums(System.Type[])">
            <summary>
            Returns all source types which are enums
            </summary>
            <param name="src">The source types</param>
        </member>
        <member name="M:Z0.XClrQuery.InNamespace(System.Type[],System.String)">
            <summary>
            Selects the types from a specified namespace
            </summary>
            <param name="src">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.UndeclaredMethods(System.Type)">
            <summary>
            Selects the methods available through the type that were not declared by the type
            </summary>
            <param name="src">The type to examine</param>
        </member>
        <member name="M:Z0.XClrQuery.Unwrap(System.Type)">
            <summary>
            Returns the underlying system type if enclosed by a source type, otherwise returns the source type
            </summary>
            <param name="src">The source type</param>
        </member>
        <member name="M:Z0.XClrQuery.WorldMethods(System.Type)">
            <summary>
            All of the methods belong to us
            </summary>
            <param name="src">The type to examine</param>
        </member>
        <member name="F:Z0.SemanticIndex`3.keyType">
            <summary>
            The key's system type
            </summary>
        </member>
        <member name="F:Z0.SemanticIndex`3.keyKind">
            <summary>
            The key's primal type
            </summary>
        </member>
        <member name="F:Z0.SemanticIndex`3.Data">
            <summary>
            The indexed data
            </summary>
        </member>
        <member name="T:Z0.IByteContainer`1">
            <summary>
            Characterizes a container that reifies an asci sequence
            </summary>
            <typeparam name="A">The asci sequence type</typeparam>
        </member>
        <member name="P:Z0.IBytes.View">
            <summary>
            The sequence presented as an encoded byte span
            </summary>
        </member>
        <member name="P:Z0.IBytes.Capacity">
            <summary>
            The maximum number of asci characters the sequence can cover
            </summary>
        </member>
        <member name="P:Z0.IBytes.Length">
            <summary>
            Specifies the number of characters that precede a null terminator, if any; otherwise, returns the capacity
            </summary>
        </member>
        <member name="M:Z0.IMaterialized`2.Redefine(`1)">
            <summary>
            Replaces materialized content forced from a source
            </summary>
            <param name="src"></param>
        </member>
        <member name="T:Z0.IContentIndex`1">
            <summary>
            Characterizes a finite container over sequentially-indexed discrete content - an array
            </summary>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="T:Z0.INonEmptySet`1">
            <summary>
            Characterizes a reified nonempty set
            </summary>
            <typeparam name="F">The reifying type</typeparam>
        </member>
        <member name="T:Z0.INonEmptySet`2">
            <summary>
            Characterizes a reified nonempty set with evidence of non-absence
            </summary>
            <typeparam name="F">The reifying type</typeparam>
            <typeparam name="T">The member type</typeparam>
        </member>
        <member name="T:Z0.IOrdered`1">
            <summary>
            Characterizes a totally ordered structure
            </summary>
            <typeparam name="T">The structure reification type</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.IOrdered`1.Lt(`0)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.IOrdered`1.LtEq(`0)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.IOrdered`1.Gt(`0)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.IOrdered`1.GtEq(`0)" -->
        <member name="T:Z0.ISequential`1">
            <summary>
            Characterizes a sequence of individuals t(i) that can be bijectively identified with a subset of distinct nonnegative integers
            </summary>
            <typeparam name="T">The individual type</typeparam>
        </member>
        <member name="T:Z0.ISequential`2">
            <summary>
            Characterizes an index-parametric sequential
            </summary>
            <typeparam name="I">The sequence index type</typeparam>
            <typeparam name="T">The individual type</typeparam>
        </member>
        <member name="T:Z0.ISequentialHost`2">
            <summary>
            Characterizes a reified sequential
            </summary>
            <typeparam name="H">The reifying type</typeparam>
            <typeparam name="T">The individual type</typeparam>
        </member>
        <member name="T:Z0.ISequentialHost`3">
            <summary>
            Characterizes an index-parametric reified sequential
            </summary>
            <typeparam name="H">The reifying type</typeparam>
            <typeparam name="I">The sequence index type</typeparam>
            <typeparam name="T">The individual type</typeparam>
        </member>
        <member name="M:Z0.IValueSet`2.Contains(`1@)">
            <summary>
            Determines whether a value is a member
            </summary>
            <param name="candidate">The potential member</param>
        </member>
        <member name="M:Z0.IValueSet`2.IsSubset(`0@,System.Boolean)">
            <summary>
            Determines whether the current set is a subset of a specified set.
            </summary>
            <param name="rhs">The candidate superset</param>
            <param name="proper">Specifies whether only proper subsets are considered "subsets"</param>
        </member>
        <member name="M:Z0.IValueSet`2.IsSuperset(`0@,System.Boolean)">
            <summary>
            Determines whether the current set is a superset of a specified set.
            </summary>
            <param name="rhs">The candidate subset</param>
            <param name="proper">Specifies whether only proper subsets are considered "subsets"</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.IValueSet`2.Union(`0@)" -->
        <member name="M:Z0.IValueSet`2.Intersect(`0@)">
            <summary>
            Calculates the intersection between the current set and a specified set and
            returns a new set that embodies this result
            </summary>
            <param name="rhs">The set with which to intersect</param>
        </member>
        <member name="M:Z0.IValueSet`2.Difference(`0@,System.Boolean)">
            <summary>
            Calculates the set difference, or symmetric difference, between the current
            set and a specified set and returns a new set that embodies this result
            </summary>
            <param name="rhs">The set that should be differenced</param>
            <remarks>See https://en.wikipedia.org/wiki/Symmetric_difference</remarks>
        </member>
        <member name="P:Z0.IVariant.DataWidth">
            <summary>
            The number of bits that are used to store the enclosed data
            </summary>
        </member>
        <member name="P:Z0.IVariant.CellKind">
            <summary>
            The numeric data type if unsegmented or, if segmented, the numeric cell kind
            </summary>
        </member>
        <member name="P:Z0.ISegmentedVariant`1.CellCount">
            <summary>
            If covering scalar data, the cell count will always be 1; when blocked or vector data
            is enclosed the cell count will vary based on the specific type
            </summary>
        </member>
        <member name="P:Z0.ISegmentedVariant`1.CellWidth">
            <summary>
            If covering scalar data, will specify the width of the scalar type; otherwise,
            it will specify the width of a vector or block cell
            </summary>
        </member>
        <member name="P:Z0.ISegmentedVariant`1.Segmented">
            <summary>
            For scalar data this bit will always be off; otherwise, it will be on
            </summary>
        </member>
        <member name="T:Z0.ArraySpan`1">
            <summary>
            An array that works like a span, more-or-less
            </summary>
        </member>
        <member name="T:Z0.ConstSet`1">
            <summary>
            Contains a finite set of values
            </summary>
        </member>
        <member name="M:Z0.ConstSet`1.IsSubset(Z0.ConstSet{`0},System.Boolean)">
            <summary>
            Determines whether the current set is a subset of a specified set.
            </summary>
            <param name="rhs">The candidate superset</param>
            <param name="proper">Specifies whether only proper subsets are considered "subsets"</param>
        </member>
        <member name="M:Z0.ConstSet`1.IsSuperset(Z0.ConstSet{`0},System.Boolean)">
            <summary>
            Determines whether the current set is a superset of a specified set.
            </summary>
            <param name="rhs">The candidate subset</param>
            <param name="proper">Specifies whether only proper subsets are considered "subsets"</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.ConstSet`1.Union(System.Collections.Generic.HashSet{`0})" -->
        <member name="M:Z0.ConstSet`1.Intersect(System.Collections.Generic.HashSet{`0})">
            <summary>
            Calculates the intersection between the current set and a specified set and
            returns a new set that embodies this result
            </summary>
            <param name="src">The set with which to intersect</param>
        </member>
        <member name="M:Z0.ConstSet`1.Difference(System.Collections.Generic.HashSet{`0},System.Boolean)">
            <summary>
            Calculates the set difference, or symmetric difference, between the current set and a specified set
            and returns a new set that embodies this result
            </summary>
            <param name="src">The set that should be differenced</param>
            <remarks>See https://en.wikipedia.org/wiki/Symmetric_difference</remarks>
        </member>
        <member name="M:Z0.ConstSet`1.Intersects(Z0.ConstSet{`0})">
            <summary>
            Determine whether the current set and a specified set have a nonemtpy intersection
            </summary>
            <param name="rhs">The set to compare</param>
        </member>
        <member name="T:Z0.Deferred`1">
            <summary>
            Defines a LINQ-monadic cover for a deferred finite or infinite parametric sequence
            </summary>
        </member>
        <member name="M:Z0.Deferred`1.op_Implicit(`0[])~Z0.Deferred{`0}">
            <summary>
            Implicitly constructs a sequence from an array
            </summary>
            <param name="src">The source array</param>
        </member>
        <member name="T:Z0.Multiset`1">
            <summary>
            Implementation of a basic multiset
            </summary>
            <remarks>See https://en.wikipedia.org/wiki/Multiset</remarks>
        </member>
        <member name="M:Z0.Multiset`1.AddRange(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Adds a sequence of items to the set
            </summary>
            <param name="src">The source items</param>
        </member>
        <member name="M:Z0.Multiset`1.DistinctCounts(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Selects the occurrence count for each item in the source
            </summary>
            <param name="src">The soruce items</param>
        </member>
        <member name="P:Z0.Multiset`1.Duplicates">
            <summary>
            Selects the members that occur more than once
            </summary>
        </member>
        <member name="M:Z0.Multiset`1.IsMember(`0)">
            <summary>
            Determines whether an item exists in the set
            </summary>
            <param name="candidate">The search item</param>
        </member>
        <member name="M:Z0.Multiset`1.Occurrences">
            <summary>
            Selects all contained items with their occurrence counts
            </summary>
            <param name="item">The item</param>
            <param name="count">The number of itmes the item occurs</param>
        </member>
        <member name="M:Z0.Multiset`1.DistinctCount(`0)">
            <summary>
            Retrieves the times a specified item appears in the set
            </summary>
            <param name="subject">The item to count</param>
        </member>
        <member name="P:Z0.Multiset`1.Members">
            <summary>
            Enumerates the distinct members
            </summary>
        </member>
        <member name="T:Z0.ValueSet`1">
            <summary>
            Contains a finite set of values
            </summary>
        </member>
        <member name="M:Z0.ValueSet`1.IsSubset(Z0.ValueSet{`0}@,System.Boolean)">
            <summary>
            Determines whether the current set is a subset of a specified set.
            </summary>
            <param name="rhs">The candidate superset</param>
            <param name="proper">Specifies whether only proper subsets are considered "subsets"</param>
        </member>
        <member name="M:Z0.ValueSet`1.IsSuperset(Z0.ValueSet{`0}@,System.Boolean)">
            <summary>
            Determines whether the current set is a superset of a specified set.
            </summary>
            <param name="rhs">The candidate subset</param>
            <param name="proper">Specifies whether only proper subsets are considered "subsets"</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.ValueSet`1.Union(Z0.ValueSet{`0}@)" -->
        <member name="M:Z0.ValueSet`1.Intersect(Z0.ValueSet{`0}@)">
            <summary>
            Calculates the intersection between the current set and a specified set and
            returns a new set that embodies this result
            </summary>
            <param name="src">The set with which to intersect</param>
        </member>
        <member name="M:Z0.ValueSet`1.Difference(Z0.ValueSet{`0},System.Boolean)">
            <summary>
            Calculates the set difference, or symmetric difference, between the current set and a specified set
            and returns a new set that embodies this result
            </summary>
            <param name="src">The set that should be differenced</param>
            <remarks>See https://en.wikipedia.org/wiki/Symmetric_difference</remarks>
        </member>
        <member name="M:Z0.ValueSet`1.Intersects(Z0.ValueSet{`0}@)">
            <summary>
            Determine whether the current set and a specified set have a nonemtpy intersection
            </summary>
            <param name="rhs">The set to compare</param>
        </member>
        <member name="M:Z0.Seq.count``1(Z0.ValueIndex{``0}@)">
            <summary>
            Tests the source index for non-emptiness
            </summary>
            <param name="src">The index to test</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.Seq.nonempty``1(Z0.ValueIndex{``0}@)">
            <summary>
            Tests the source index for non-emptiness
            </summary>
            <param name="src">The index to test</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.Seq.empty``1(Z0.ValueIndex{``0}@)">
            <summary>
            Tests the source index for emptiness
            </summary>
            <param name="src">The index to test</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.Seq.reverse``1(``0[])">
            <summary>
            Reverses an array in-place
            </summary>
            <param name="src">The source array</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.Seq.indexed``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates an indexed sequence from a stream
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.Seq.indexed``2(System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Creates an indexed sequence from a stream
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.Seq.indexed``1(``0[])">
            <summary>
            Creates an indexed sequence from a parameter array
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.Seq.values``1(``0[])">
            <summary>
            Creates an index from an array
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.Seq.values``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates an index from a stream
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.Seq.view``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a <see cref='T:Z0.IndexedView`1'/> from a <see cref ='T:System.Collections.Generic.IEnumerable`1'/>
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.Seq.view``1(``0[])">
            <summary>
            Creates a <see cref='T:Z0.IndexedView`1'/> from an array
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.Seq.view``2(``1[],``0)">
            <summary>
            Creates a <see cref='T:Z0.IndexedView`2'/> from an array
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The cell type</typeparam>
            <typeparam name="I">The index type</typeparam>
        </member>
        <member name="M:Z0.Seq.defer``1(``0,``0[])">
            <summary>
            Constructs a nonempty stream
            </summary>
            <param name="head">The first element in the stream</param>
            <param name="tail">The remaining elements of the stream</param>
            <typeparam name="T">The streamed element type</typeparam>
        </member>
        <member name="M:Z0.Seq.defer``1(``0[])">
            <summary>
            Constructs a stream, possibly empty
            </summary>
            <param name="src">The stream elements</param>
            <typeparam name="T">The streamed element type</typeparam>
        </member>
        <member name="M:Z0.Seq.concat``1(Z0.Deferred{``0},Z0.Deferred{``0})">
            <summary>
            Concatenates the source streams to create a unified stream
            </summary>
            <param name="head">The first part of the sequence</param>
            <param name="tail">The last part of the sequence</param>
            <typeparam name="T">The streamed element type</typeparam>
        </member>
        <member name="M:Z0.Seq.concat``1(Z0.Deferred{``0},Z0.Deferred{``0},Z0.Deferred{``0})">
            <summary>
            Concatenates the source streams to create a unified stream
            </summary>
            <param name="s1">The leading segment</param>
            <param name="s2">The second segment</param>
            <param name="s3">The terminal segment</param>
            <typeparam name="T">The streamed element type</typeparam>
        </member>
        <member name="M:Z0.Seq.join``1(System.Collections.Generic.IEnumerable{``0}[])">
            <summary>
            All of your streams belong to us
            </summary>
            <param name="src">The source streams</param>
            <typeparam name="T">The streamed element type</typeparam>
        </member>
        <member name="M:Z0.Seq.fold``2(System.ReadOnlySpan{``1},``0)">
            <summary>
            Reduces a stream to a single value via a specified monoid
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The stream element type</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.Sets.union``1(Z0.ValueSet{``0}@,Z0.ValueSet{``0}@)" -->
        <member name="T:Z0.DistributionKind">
            <summary>
            Defines statistical distribution classifiers
            </summary>
        </member>
        <member name="F:Z0.DistributionKind.Uniform">
            <summary>
            Identifies a uniform distribution
            </summary>
        </member>
        <member name="F:Z0.DistributionKind.UniformRange">
            <summary>
            Identifies a uniform distribution bound to a particular range
            </summary>
        </member>
        <member name="F:Z0.DistributionKind.UniformBits">
            <summary>
            Identifies a bitwise uniform distribution
            </summary>
        </member>
        <member name="F:Z0.DistributionKind.Bernoulli">
            <summary>
            Identifies a Bernoulli distribution
            </summary>
        </member>
        <member name="F:Z0.DistributionKind.Beta">
            <summary>
            Identifies a Beta distribution
            </summary>
        </member>
        <member name="F:Z0.DistributionKind.Binomial">
            <summary>
            Identifies a Binomial distribution
            </summary>
        </member>
        <member name="F:Z0.DistributionKind.Cauchy">
            <summary>
            Identifies a Cauchy distribution
            </summary>
        </member>
        <member name="T:Z0.ExtractTermCode">
            <summary>
            Defines literals that indicate the reason for exraction termination
            </summary>
        </member>
        <member name="F:Z0.ExtractTermCode.CTC_Zx7">
            <summary>
            Identifies the pattern 00 00 00 00 00 00 00
            </summary>
        </member>
        <member name="F:Z0.ExtractTermCode.CTC_CALL32_INTR">
            <summary>
            Identifies the partial pattern e8 ?? ?? ?? ?? cc
            </summary>
        </member>
        <member name="T:Z0.IMultiplicative`2">
            <summary>
            Characterizes structural multiplication
            </summary>
            <typeparam name="S">The structure type</typeparam>
            <typeparam name="T">The individual type</typeparam>
        </member>
        <member name="T:Z0.Observations`1">
            <summary>
            Defines an observation sequence
            </summary>
        </member>
        <member name="F:Z0.Observations`1.Count">
            <summary>
            The number of observations that comprise the sample
            </summary>
        </member>
        <member name="F:Z0.Observations`1.Dim">
            <summary>
            The sample dimensionality
            </summary>
        </member>
        <member name="M:Z0.Observations`1.Observation(System.Int32)">
            <summary>
            Retrieves a single index-identified observation vector
            </summary>
            <param name="vecix">The vector index</param>
        </member>
        <member name="M:Z0.Observations`1.Slice(System.Int32,System.Int32)">
            <summary>
            Selects a contiguous sequence of observations beginning at a specified offset
            </summary>
            <param name="offset">The offset</param>
            <param name="count">The observation count</param>
        </member>
        <member name="P:Z0.Observations`1.Length">
            <summary>
            The data length
            </summary>
        </member>
        <member name="T:Z0.Sink`1">
            <summary>
            Defines a receiver-predicated sink
            </summary>
        </member>
        <member name="T:Z0.TheEmpty">
            <summary>
            Represents the nothingness of the void
            </summary>
        </member>
        <member name="P:Z0.TheEmpty.The">
            <summary>
            The only one
            </summary>
        </member>
        <member name="T:Z0.TheEmpty`1">
            <summary>
            Represents the nothingness of the parametric void
            </summary>
        </member>
        <member name="M:Z0.TheEmpty`1.The(`0)">
            <summary>
            The only parametric one
            </summary>            
        </member>
        <member name="T:Z0.YeaOrNea">
            <summary>
            A binary choice, symbolically
            </summary>
        </member>
        <member name="F:Z0.YeaOrNea.Y">
            <summary>
            Aye
            </summary>
        </member>
        <member name="F:Z0.YeaOrNea.N">
            <summary>
            ~Aye
            </summary>
        </member>
        <member name="M:Z0.Converters.convert``2(``0)">
            <summary>
            Converts an incoming value of the target type to a value of specified type, if possible
            </summary>
            <param name="src">The value to convert</param>
        </member>
        <member name="M:Z0.Converter`2.Convert(`0@,`1@)">
            <summary>
            Converts an incoming value of the target type to a value of specified type, if possible
            </summary>
            <param name="src">The value to convert</param>
        </member>
        <member name="M:Z0.Converter`2.Convert(`1@,`0@)">
            <summary>
            Converts an incoming value of the target type to a value of specified type, if possible
            </summary>
            <param name="src">The value to convert</param>
        </member>
        <member name="T:Z0.IAs`2">
            <summary>
            Characterizes a value imagination service
            </summary>
            <typeparam name="S">The numeric source type</typeparam>
            <typeparam name="T">The numeric target type</typeparam>
        </member>
        <member name="M:Z0.IAs`2.As(`0)">
            <summary>
            Presents src:S as dst:T
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="T:Z0.IAs`3">
            <summary>
            Characterizes a numeric value presentation service F-bound polymorphic reification
            </summary>
            <typeparam name="F">The reification type</typeparam>
            <typeparam name="S">The numeric source type</typeparam>
            <typeparam name="T">The numeric target type</typeparam>
        </member>
        <member name="T:Z0.IBiconverter">
            <summary>
            Characterizes a weakly-typed two-way converter
            </summary>
        </member>
        <member name="P:Z0.IBiconverter.TargetType">
            <summary>
            The supported type
            </summary>
        </member>
        <member name="M:Z0.IBiconverter.ConvertToTarget(System.Object)">
            <summary>
            Converts an incoming value to a value of target type, if possible
            </summary>
            <param name="src">The value to convert</param>
        </member>
        <member name="M:Z0.IBiconverter.ConvertFromTarget(System.Object,System.Type)">
            <summary>
            Converts an incoming value of the target type to a value of specified type, if possible
            </summary>
            <param name="src">The value to convert</param>
        </member>
        <member name="T:Z0.IBiconverter`1">
            <summary>
            Characterizes a strongly-typed two-way converter
            </summary>
        </member>
        <member name="T:Z0.IConversionProvider`1">
            <summary>
            Characterizes a service that exposes a two-way converter
            </summary>
            <typeparam name="S">The conversion type </typeparam>
        </member>
        <member name="T:Z0.IConverter`2">
            <summary>
            Characterizes a two-way converter
            </summary>
            <typeparam name="A">The source type</typeparam>
            <typeparam name="B">The target type</typeparam>
        </member>
        <member name="T:Z0.CorrelationToken">
            <summary>
            Correlates a value with a key that uniquely identifies the value within some context
            </summary>
        </member>
        <member name="P:Z0.IEncoded`2.Encoded">
            <summary>
            The encoded data
            </summary>
        </member>
        <member name="T:Z0.BasedCodeBlock">
            <summary>
            Encoded x86 bytes extracted from a memory source with a known (nonzero) location
            </summary>
        </member>
        <member name="P:Z0.BasedCodeBlock.Base">
            <summary>
            The head of the memory location from which the data originated
            </summary>
        </member>
        <member name="P:Z0.BasedCodeBlock.Encoded">
            <summary>
            The encoded content
            </summary>
        </member>
        <member name="P:Z0.BasedCodeBlock.Data">
            <summary>
            The encoded content as byte array
            </summary>
        </member>
        <member name="T:Z0.BinaryCode">
            <summary>
            Encoded x86 bytes extracted from a memory source
            </summary>
        </member>
        <member name="P:Z0.BinaryCode.Encoded">
            <summary>
            The encoded bytes
            </summary>
        </member>
        <member name="P:Z0.BinaryCode.Data">
            <summary>
            The encoded content as byte array
            </summary>
        </member>
        <member name="P:Z0.BinaryCode.View">
            <summary>
            Covers the encoded content with a readonly span
            </summary>
        </member>
        <member name="P:Z0.BinaryCode.Edit">
            <summary>
            Covers the encoded content with a span
            </summary>
        </member>
        <member name="P:Z0.BinaryCode.Ref">
            <summary>
            Returns a reference to the encoded data
            </summary>
        </member>
        <member name="P:Z0.BinaryCode.Empty">
            <summary>
            The canonical zero
            </summary>
        </member>
        <member name="F:Z0.CilMethod.Base">
            <summary>
            The code's base address
            </summary>
        </member>
        <member name="F:Z0.CilMethod.Name">
            <summary>
            The operation uri
            </summary>
        </member>
        <member name="F:Z0.CilMethod.Encoded">
            <summary>
            The encoded cil
            </summary>
        </member>
        <member name="F:Z0.Hex.MinScalarCode">
            <summary>
            The asci code of the '0' digit
            </summary>
        </member>
        <member name="F:Z0.Hex.MaxScalarCode">
            <summary>
            The asci code of the '9' digit
            </summary>
        </member>
        <member name="F:Z0.Hex.MinCharCodeU">
            <summary>
            The asci code of the 'A' digit
            </summary>
        </member>
        <member name="F:Z0.Hex.MaxCharCodeU">
            <summary>
            The asci code of the 'F' digit
            </summary>
        </member>
        <member name="F:Z0.Hex.MinCharCodeL">
            <summary>
            The asci code of the 'a' digit
            </summary>
        </member>
        <member name="F:Z0.Hex.MaxCharCodeL">
            <summary>
            The asci code of the 'f' digit
            </summary>
        </member>
        <member name="P:Z0.Hex.UpperDigits">
            <summary>
            Defines the asci character codes for uppercase hex digits 1,2, ..., 9, A, ..., F
            </summary>
        </member>
        <member name="P:Z0.Hex.LowerDigits">
            <summary>
            Defines the asci character codes for uppercase hex digits 1,2, ..., 9, a, ..., f
            </summary>
        </member>
        <member name="M:Z0.Hex.chars(System.Byte,System.Char@,System.Char@)">
            <summary>
            Computes the 2-character hex representation of a byte
            </summary>
            <param name="src">The byte value</param>
        </member>
        <member name="M:Z0.Hex.chars(System.Byte)">
            <summary>
            Computes the 2-character hex representation of a byte
            </summary>
            <param name="src">The byte value</param>
        </member>
        <member name="M:Z0.Hex.chars(System.UInt16)">
            <summary>
            Computes the 4-character hex representation of an unsigned 16-bit integer
            </summary>
            <param name="src">The byte value</param>
        </member>
        <member name="M:Z0.Hex.chars(System.UInt32)">
            <summary>
            Computes the 8-character hex representation of an unsigned 32-bit integer
            </summary>
            <param name="src">The byte value</param>
        </member>
        <member name="M:Z0.Hex.chars(System.UInt64)">
            <summary>
            Computes the 16-character hex representation of an unsigned 64-bit integer
            </summary>
            <param name="src">The byte value</param>
        </member>
        <member name="M:Z0.Hex.chars(System.SByte)">
            <summary>
            Computes the 2-character hex representation of a signed byte
            </summary>
            <param name="src">The byte value</param>
        </member>
        <member name="M:Z0.Hex.chars(System.Int16)">
            <summary>
            Computes the 4-character hex representation of a signed 16-bit integer
            </summary>
            <param name="src">The byte value</param>
        </member>
        <member name="M:Z0.Hex.chars(System.Int32)">
            <summary>
            Computes the 8-character hex representation of a signed 32-bit integer
            </summary>
            <param name="src">The byte value</param>
        </member>
        <member name="M:Z0.Hex.chars(System.Int64)">
            <summary>
            Computes the 16-character hex representation of a signed 64-bit integer
            </summary>
            <param name="src">The byte value</param>
        </member>
        <member name="M:Z0.Hex.hexchar``1(System.Byte,``0)">
            <summary>
            Presents the source value as a sequence of hex symbols
            </summary>
            <param name="src">The source value</param>
            <param name="case">The case selector</param>
        </member>
        <member name="M:Z0.Hex.lookup``2(Z0.HexLookupEntry{``0,``1}[])">
            <summary>
            Creates an index that correlates 8-bit unsigned integers [0..255] with arbitrary parametric values
            </summary>
            <param name="src">The values to correlate</param>
            <typeparam name="T">The value type</typeparam>
        </member>
        <member name="M:Z0.Hex.lookup``2(Z0.HexLookupEntry{``0,``1}[],``1[])">
            <summary>
            Creates an index that correlates up to 255 unsigned 8-bit integers with arbitrary structural T-parameteric values
            </summary>
            <param name="src">The values to correlate</param>
            <typeparam name="T">The value type</typeparam>
        </member>
        <member name="M:Z0.Hex.partition(Z0.HexIndex{Z0.Hex1},System.UInt32)">
            <summary>
            Partitions a bitstring into blocks of a specified maximum width
            </summary>
            <param name="width">The maximum block width</param>
        </member>
        <member name="M:Z0.HexTest.scalar(System.Char)">
            <summary>
            Determines whether a character corresponds to one of the lower hex codes
            </summary>
            <param name="c">The character to test</param>
        </member>
        <member name="M:Z0.HexTest.upper(System.Char)">
            <summary>
            Determines whether a character corresponds to one of the uppercase hex code characters
            </summary>
            <param name="c">The character to test</param>
        </member>
        <member name="M:Z0.HexTest.lower(System.Char)">
            <summary>
            Determines whether a character corresponds to one of the lowercase hex code characters
            </summary>
            <param name="c">The character to test</param>
        </member>
        <member name="T:Z0.Hex1Seq">
            <summary>
            Defines identifiers corresponding to the hex digits 0 and 1
            </summary>
        </member>
        <member name="F:Z0.Hex1Seq.x00">
            <summary>
            Identifies the hex value 0x00 := 0
            </summary>
        </member>
        <member name="F:Z0.Hex1Seq.x01">
            <summary>
            Identifies the hex value 0x01 := 1
            </summary>
        </member>
        <member name="T:Z0.Hex2Seq">
            <summary>
            Defines identifiers corresponding to the hex digits 0,..,3
            </summary>
        </member>
        <member name="F:Z0.Hex2Seq.x00">
            <summary>
            Identifies the hex value 0x00 := 0
            </summary>
        </member>
        <member name="F:Z0.Hex2Seq.x01">
            <summary>
            Identifies the hex value 0x01 := 1
            </summary>
        </member>
        <member name="F:Z0.Hex2Seq.x02">
            <summary>
            Identifies the hex value 0x02 := 2
            </summary>
        </member>
        <member name="F:Z0.Hex2Seq.x03">
            <summary>
            Identifies the hex value 0x03 := 3
            </summary>
        </member>
        <member name="T:Z0.Hex3Seq">
            <summary>
            Defines identifiers corresponding to the hex digits 0,..,7
            </summary>
        </member>
        <member name="F:Z0.Hex3Seq.x00">
            <summary>
            Identifies the hex value 0x00 := 0
            </summary>
        </member>
        <member name="F:Z0.Hex3Seq.x01">
            <summary>
            Identifies the hex value 0x01 := 1
            </summary>
        </member>
        <member name="F:Z0.Hex3Seq.x02">
            <summary>
            Identifies the hex value 0x02 := 2
            </summary>
        </member>
        <member name="F:Z0.Hex3Seq.x03">
            <summary>
            Identifies the hex value 0x03 := 3
            </summary>
        </member>
        <member name="F:Z0.Hex3Seq.x04">
            <summary>
            Identifies the hex value 0x04 := 4
            </summary>
        </member>
        <member name="F:Z0.Hex3Seq.x05">
            <summary>
            Identifies the hex value 0x05 := 5
            </summary>
        </member>
        <member name="F:Z0.Hex3Seq.x06">
            <summary>
            Identifies the hex value 0x06 := 6
            </summary>
        </member>
        <member name="F:Z0.Hex3Seq.x07">
            <summary>
            Identifies the hex value 0x07 := 7
            </summary>
        </member>
        <member name="T:Z0.Hex4Seq">
            <summary>
            Defines identifiers corresponding to each value that can be represented with a 4-bit unsigned integer
            </summary>
        </member>
        <member name="F:Z0.Hex4Seq.x00">
            <summary>
            Identifies the hex value 0x00 := 0
            </summary>
        </member>
        <member name="F:Z0.Hex4Seq.x01">
            <summary>
            Identifies the hex value 0x01 := 1
            </summary>
        </member>
        <member name="F:Z0.Hex4Seq.x02">
            <summary>
            Identifies the hex value 0x02 := 2
            </summary>
        </member>
        <member name="F:Z0.Hex4Seq.x03">
            <summary>
            Identifies the hex value 0x03 := 3
            </summary>
        </member>
        <member name="F:Z0.Hex4Seq.x04">
            <summary>
            Identifies the hex value 0x04 := 4
            </summary>
        </member>
        <member name="F:Z0.Hex4Seq.x05">
            <summary>
            Identifies the hex value 0x05 := 5
            </summary>
        </member>
        <member name="F:Z0.Hex4Seq.x06">
            <summary>
            Identifies the hex value 0x06 := 6
            </summary>
        </member>
        <member name="F:Z0.Hex4Seq.x07">
            <summary>
            Identifies the hex value 0x07 := 7
            </summary>
        </member>
        <member name="F:Z0.Hex4Seq.x08">
            <summary>
            Identifies the hex value 0x08 := 8
            </summary>
        </member>
        <member name="F:Z0.Hex4Seq.x09">
            <summary>
            Identifies the hex value 0x09 := 9
            </summary>
        </member>
        <member name="F:Z0.Hex4Seq.x0A">
            <summary>
            Identifies the hex value 0x0A := 10
            </summary>
        </member>
        <member name="F:Z0.Hex4Seq.x0B">
            <summary>
            Identifies the hex value 0x0B := 11
            </summary>
        </member>
        <member name="F:Z0.Hex4Seq.x0C">
            <summary>
            Identifies the hex value 0x0C := 12
            </summary>
        </member>
        <member name="F:Z0.Hex4Seq.x0D">
            <summary>
            Identifies the hex value 0x0D := 13
            </summary>
        </member>
        <member name="F:Z0.Hex4Seq.x0E">
            <summary>
            Identifies the hex value 0x0E := 14
            </summary>
        </member>
        <member name="F:Z0.Hex4Seq.x0F">
            <summary>
            Identifies the hex value 0x0F := 15
            </summary>
        </member>
        <member name="T:Z0.Hex5Seq">
            <summary>
            Defines identifiers corresponding to each value that can be represented with a 5-bit unsigned integer
            </summary>
        </member>
        <member name="F:Z0.Hex5Seq.x00">
            <summary>
            Defines 0x00 = 0
            </summary>
        </member>
        <member name="F:Z0.Hex5Seq.x01">
            <summary>
            Defines 0x01 = 1
            </summary>
        </member>
        <member name="F:Z0.Hex5Seq.x02">
            <summary>
            Defines 0x02 = 2
            </summary>
        </member>
        <member name="F:Z0.Hex5Seq.x03">
            <summary>
            Defines 0x03 = 3
            </summary>
        </member>
        <member name="F:Z0.Hex5Seq.x04">
            <summary>
            Defines 0x04 = 4
            </summary>
        </member>
        <member name="F:Z0.Hex5Seq.x05">
            <summary>
            Defines 0x05 = 5
            </summary>
        </member>
        <member name="F:Z0.Hex5Seq.x06">
            <summary>
            Defines 0x06 = 6
            </summary>
        </member>
        <member name="F:Z0.Hex5Seq.x07">
            <summary>
            Defines 0x07 = 7
            </summary>
        </member>
        <member name="F:Z0.Hex5Seq.x08">
            <summary>
            Defines 0x08 = 8
            </summary>
        </member>
        <member name="F:Z0.Hex5Seq.x09">
            <summary>
            Defines 0x09 = 9
            </summary>
        </member>
        <member name="F:Z0.Hex5Seq.x0a">
            <summary>
            Defines 0x0a = 10
            </summary>
        </member>
        <member name="F:Z0.Hex5Seq.x0b">
            <summary>
            Defines 0x0b = 11
            </summary>
        </member>
        <member name="F:Z0.Hex5Seq.x0c">
            <summary>
            Defines 0x0c = 12
            </summary>
        </member>
        <member name="F:Z0.Hex5Seq.x0d">
            <summary>
            Defines 0x0d = 13
            </summary>
        </member>
        <member name="F:Z0.Hex5Seq.x0e">
            <summary>
            Defines 0x0e = 14
            </summary>
        </member>
        <member name="F:Z0.Hex5Seq.x0f">
            <summary>
            Defines 0x0f = 15
            </summary>
        </member>
        <member name="F:Z0.Hex5Seq.x10">
            <summary>
            Defines 0x10 = 16
            </summary>
        </member>
        <member name="F:Z0.Hex5Seq.x11">
            <summary>
            Defines 0x11 = 17
            </summary>
        </member>
        <member name="F:Z0.Hex5Seq.x12">
            <summary>
            Defines 0x12 = 18
            </summary>
        </member>
        <member name="F:Z0.Hex5Seq.x13">
            <summary>
            Defines 0x13 = 19
            </summary>
        </member>
        <member name="F:Z0.Hex5Seq.x14">
            <summary>
            Defines 0x14 = 20
            </summary>
        </member>
        <member name="F:Z0.Hex5Seq.x15">
            <summary>
            Defines 0x15 = 21
            </summary>
        </member>
        <member name="F:Z0.Hex5Seq.x16">
            <summary>
            Defines 0x16 = 22
            </summary>
        </member>
        <member name="F:Z0.Hex5Seq.x17">
            <summary>
            Defines 0x17 = 23
            </summary>
        </member>
        <member name="F:Z0.Hex5Seq.x18">
            <summary>
            Defines 0x18 = 24
            </summary>
        </member>
        <member name="F:Z0.Hex5Seq.x19">
            <summary>
            Defines 0x19 = 25
            </summary>
        </member>
        <member name="F:Z0.Hex5Seq.x1a">
            <summary>
            Defines 0x1a = 26
            </summary>
        </member>
        <member name="F:Z0.Hex5Seq.x1b">
            <summary>
            Defines 0x1b = 27
            </summary>
        </member>
        <member name="F:Z0.Hex5Seq.x1c">
            <summary>
            Defines 0x1c = 28
            </summary>
        </member>
        <member name="F:Z0.Hex5Seq.x1d">
            <summary>
            Defines 0x1d = 29
            </summary>
        </member>
        <member name="F:Z0.Hex5Seq.x1e">
            <summary>
            Defines 0x1e = 30
            </summary>
        </member>
        <member name="F:Z0.Hex5Seq.x1f">
            <summary>
            Defines 0x1f = 31
            </summary>
        </member>
        <member name="T:Z0.Hex6Seq">
            <summary>
            Defines identifiers corresponding to each value that can be represented with a 6-bit unsigned integer
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x00">
            <summary>
            Defines 0x00 = 0
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x01">
            <summary>
            Defines 0x01 = 1
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x02">
            <summary>
            Defines 0x02 = 2
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x03">
            <summary>
            Defines 0x03 = 3
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x04">
            <summary>
            Defines 0x04 = 4
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x05">
            <summary>
            Defines 0x05 = 5
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x06">
            <summary>
            Defines 0x06 = 6
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x07">
            <summary>
            Defines 0x07 = 7
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x08">
            <summary>
            Defines 0x08 = 8
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x09">
            <summary>
            Defines 0x09 = 9
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x0a">
            <summary>
            Defines 0x0a = 10
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x0b">
            <summary>
            Defines 0x0b = 11
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x0c">
            <summary>
            Defines 0x0c = 12
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x0d">
            <summary>
            Defines 0x0d = 13
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x0e">
            <summary>
            Defines 0x0e = 14
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x0f">
            <summary>
            Defines 0x0f = 15
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x10">
            <summary>
            Defines 0x10 = 16
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x11">
            <summary>
            Defines 0x11 = 17
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x12">
            <summary>
            Defines 0x12 = 18
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x13">
            <summary>
            Defines 0x13 = 19
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x14">
            <summary>
            Defines 0x14 = 20
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x15">
            <summary>
            Defines 0x15 = 21
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x16">
            <summary>
            Defines 0x16 = 22
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x17">
            <summary>
            Defines 0x17 = 23
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x18">
            <summary>
            Defines 0x18 = 24
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x19">
            <summary>
            Defines 0x19 = 25
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x1a">
            <summary>
            Defines 0x1a = 26
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x1b">
            <summary>
            Defines 0x1b = 27
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x1c">
            <summary>
            Defines 0x1c = 28
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x1d">
            <summary>
            Defines 0x1d = 29
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x1e">
            <summary>
            Defines 0x1e = 30
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x1f">
            <summary>
            Defines 0x1f = 31
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x20">
            <summary>
            Defines 0x20 = 32
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x21">
            <summary>
            Defines 0x21 = 33
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x22">
            <summary>
            Defines 0x22 = 34
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x23">
            <summary>
            Defines 0x23 = 35
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x24">
            <summary>
            Defines 0x24 = 36
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x25">
            <summary>
            Defines 0x25 = 37
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x26">
            <summary>
            Defines 0x26 = 38
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x27">
            <summary>
            Defines 0x27 = 39
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x28">
            <summary>
            Defines 0x28 = 40
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x29">
            <summary>
            Defines 0x29 = 41
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x2a">
            <summary>
            Defines 0x2a = 42
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x2b">
            <summary>
            Defines 0x2b = 43
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x2c">
            <summary>
            Defines 0x2c = 44
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x2d">
            <summary>
            Defines 0x2d = 45
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x2e">
            <summary>
            Defines 0x2e = 46
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x2f">
            <summary>
            Defines 0x2f = 47
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x30">
            <summary>
            Defines 0x30 = 48
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x31">
            <summary>
            Defines 0x31 = 49
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x32">
            <summary>
            Defines 0x32 = 50
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x33">
            <summary>
            Defines 0x33 = 51
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x34">
            <summary>
            Defines 0x34 = 52
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x35">
            <summary>
            Defines 0x35 = 53
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x36">
            <summary>
            Defines 0x36 = 54
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x37">
            <summary>
            Defines 0x37 = 55
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x38">
            <summary>
            Defines 0x38 = 56
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x39">
            <summary>
            Defines 0x39 = 57
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x3a">
            <summary>
            Defines 0x3a = 58
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x3b">
            <summary>
            Defines 0x3b = 59
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x3c">
            <summary>
            Defines 0x3c = 60
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x3d">
            <summary>
            Defines 0x3d = 61
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x3e">
            <summary>
            Defines 0x3e = 62
            </summary>
        </member>
        <member name="F:Z0.Hex6Seq.x3f">
            <summary>
            Defines 0x3f = 63
            </summary>
        </member>
        <member name="T:Z0.Hex7Seq">
            <summary>
            Defines identifiers corresponding to each value that can be represented with an 8-bit unsigned integer
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x00">
            <summary>
            Defines 0x00 = 0
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x01">
            <summary>
            Defines 0x01 = 1
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x02">
            <summary>
            Defines 0x02 = 2
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x03">
            <summary>
            Defines 0x03 = 3
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x04">
            <summary>
            Defines 0x04 = 4
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x05">
            <summary>
            Defines 0x05 = 5
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x06">
            <summary>
            Defines 0x06 = 6
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x07">
            <summary>
            Defines 0x07 = 7
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x08">
            <summary>
            Defines 0x08 = 8
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x09">
            <summary>
            Defines 0x09 = 9
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x0a">
            <summary>
            Defines 0x0a = 10
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x0b">
            <summary>
            Defines 0x0b = 11
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x0c">
            <summary>
            Defines 0x0c = 12
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x0d">
            <summary>
            Defines 0x0d = 13
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x0e">
            <summary>
            Defines 0x0e = 14
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x0f">
            <summary>
            Defines 0x0f = 15
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x10">
            <summary>
            Defines 0x10 = 16
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x11">
            <summary>
            Defines 0x11 = 17
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x12">
            <summary>
            Defines 0x12 = 18
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x13">
            <summary>
            Defines 0x13 = 19
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x14">
            <summary>
            Defines 0x14 = 20
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x15">
            <summary>
            Defines 0x15 = 21
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x16">
            <summary>
            Defines 0x16 = 22
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x17">
            <summary>
            Defines 0x17 = 23
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x18">
            <summary>
            Defines 0x18 = 24
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x19">
            <summary>
            Defines 0x19 = 25
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x1a">
            <summary>
            Defines 0x1a = 26
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x1b">
            <summary>
            Defines 0x1b = 27
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x1c">
            <summary>
            Defines 0x1c = 28
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x1d">
            <summary>
            Defines 0x1d = 29
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x1e">
            <summary>
            Defines 0x1e = 30
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x1f">
            <summary>
            Defines 0x1f = 31
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x20">
            <summary>
            Defines 0x20 = 32
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x21">
            <summary>
            Defines 0x21 = 33
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x22">
            <summary>
            Defines 0x22 = 34
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x23">
            <summary>
            Defines 0x23 = 35
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x24">
            <summary>
            Defines 0x24 = 36
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x25">
            <summary>
            Defines 0x25 = 37
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x26">
            <summary>
            Defines 0x26 = 38
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x27">
            <summary>
            Defines 0x27 = 39
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x28">
            <summary>
            Defines 0x28 = 40
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x29">
            <summary>
            Defines 0x29 = 41
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x2a">
            <summary>
            Defines 0x2a = 42
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x2b">
            <summary>
            Defines 0x2b = 43
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x2c">
            <summary>
            Defines 0x2c = 44
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x2d">
            <summary>
            Defines 0x2d = 45
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x2e">
            <summary>
            Defines 0x2e = 46
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x2f">
            <summary>
            Defines 0x2f = 47
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x30">
            <summary>
            Defines 0x30 = 48
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x31">
            <summary>
            Defines 0x31 = 49
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x32">
            <summary>
            Defines 0x32 = 50
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x33">
            <summary>
            Defines 0x33 = 51
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x34">
            <summary>
            Defines 0x34 = 52
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x35">
            <summary>
            Defines 0x35 = 53
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x36">
            <summary>
            Defines 0x36 = 54
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x37">
            <summary>
            Defines 0x37 = 55
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x38">
            <summary>
            Defines 0x38 = 56
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x39">
            <summary>
            Defines 0x39 = 57
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x3a">
            <summary>
            Defines 0x3a = 58
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x3b">
            <summary>
            Defines 0x3b = 59
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x3c">
            <summary>
            Defines 0x3c = 60
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x3d">
            <summary>
            Defines 0x3d = 61
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x3e">
            <summary>
            Defines 0x3e = 62
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x3f">
            <summary>
            Defines 0x3f = 63
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x40">
            <summary>
            Defines 0x40 = 64
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x41">
            <summary>
            Defines 0x41 = 65
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x42">
            <summary>
            Defines 0x42 = 66
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x43">
            <summary>
            Defines 0x43 = 67
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x44">
            <summary>
            Defines 0x44 = 68
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x45">
            <summary>
            Defines 0x45 = 69
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x46">
            <summary>
            Defines 0x46 = 70
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x47">
            <summary>
            Defines 0x47 = 71
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x48">
            <summary>
            Defines 0x48 = 72
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x49">
            <summary>
            Defines 0x49 = 73
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x4a">
            <summary>
            Defines 0x4a = 74
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x4b">
            <summary>
            Defines 0x4b = 75
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x4c">
            <summary>
            Defines 0x4c = 76
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x4d">
            <summary>
            Defines 0x4d = 77
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x4e">
            <summary>
            Defines 0x4e = 78
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x4f">
            <summary>
            Defines 0x4f = 79
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x50">
            <summary>
            Defines 0x50 = 80
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x51">
            <summary>
            Defines 0x51 = 81
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x52">
            <summary>
            Defines 0x52 = 82
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x53">
            <summary>
            Defines 0x53 = 83
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x54">
            <summary>
            Defines 0x54 = 84
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x55">
            <summary>
            Defines 0x55 = 85
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x56">
            <summary>
            Defines 0x56 = 86
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x57">
            <summary>
            Defines 0x57 = 87
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x58">
            <summary>
            Defines 0x58 = 88
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x59">
            <summary>
            Defines 0x59 = 89
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x5a">
            <summary>
            Defines 0x5a = 90
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x5b">
            <summary>
            Defines 0x5b = 91
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x5c">
            <summary>
            Defines 0x5c = 92
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x5d">
            <summary>
            Defines 0x5d = 93
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x5e">
            <summary>
            Defines 0x5e = 94
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x5f">
            <summary>
            Defines 0x5f = 95
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x60">
            <summary>
            Defines 0x60 = 96
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x61">
            <summary>
            Defines 0x61 = 97
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x62">
            <summary>
            Defines 0x62 = 98
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x63">
            <summary>
            Defines 0x63 = 99
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x64">
            <summary>
            Defines 0x64 = 100
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x65">
            <summary>
            Defines 0x65 = 101
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x66">
            <summary>
            Defines 0x66 = 102
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x67">
            <summary>
            Defines 0x67 = 103
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x68">
            <summary>
            Defines 0x68 = 104
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x69">
            <summary>
            Defines 0x69 = 105
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x6a">
            <summary>
            Defines 0x6a = 106
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x6b">
            <summary>
            Defines 0x6b = 107
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x6c">
            <summary>
            Defines 0x6c = 108
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x6d">
            <summary>
            Defines 0x6d = 109
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x6e">
            <summary>
            Defines 0x6e = 110
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x6f">
            <summary>
            Defines 0x6f = 111
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x70">
            <summary>
            Defines 0x70 = 112
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x71">
            <summary>
            Defines 0x71 = 113
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x72">
            <summary>
            Defines 0x72 = 114
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x73">
            <summary>
            Defines 0x73 = 115
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x74">
            <summary>
            Defines 0x74 = 116
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x75">
            <summary>
            Defines 0x75 = 117
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x76">
            <summary>
            Defines 0x76 = 118
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x77">
            <summary>
            Defines 0x77 = 119
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x78">
            <summary>
            Defines 0x78 = 120
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x79">
            <summary>
            Defines 0x79 = 121
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x7a">
            <summary>
            Defines 0x7a = 122
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x7b">
            <summary>
            Defines 0x7b = 123
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x7c">
            <summary>
            Defines 0x7c = 124
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x7d">
            <summary>
            Defines 0x7d = 125
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x7e">
            <summary>
            Defines 0x7e = 126
            </summary>
        </member>
        <member name="F:Z0.Hex7Seq.x7f">
            <summary>
            Defines 0x7f = 127
            </summary>
        </member>
        <member name="T:Z0.Hex8Seq">
            <summary>
            Defines identifiers corresponding to each value that can be represented with an 8-bit unsigned integer
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x00">
            <summary>
            Defines 0x00 = 0
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x01">
            <summary>
            Defines 0x01 = 1
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x02">
            <summary>
            Defines 0x02 = 2
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x03">
            <summary>
            Defines 0x03 = 3
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x04">
            <summary>
            Defines 0x04 = 4
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x05">
            <summary>
            Defines 0x05 = 5
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x06">
            <summary>
            Defines 0x06 = 6
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x07">
            <summary>
            Defines 0x07 = 7
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x08">
            <summary>
            Defines 0x08 = 8
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x09">
            <summary>
            Defines 0x09 = 9
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x0a">
            <summary>
            Defines 0x0a = 10
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x0b">
            <summary>
            Defines 0x0b = 11
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x0c">
            <summary>
            Defines 0x0c = 12
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x0d">
            <summary>
            Defines 0x0d = 13
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x0e">
            <summary>
            Defines 0x0e = 14
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x0f">
            <summary>
            Defines 0x0f = 15
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x10">
            <summary>
            Defines 0x10 = 16
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x11">
            <summary>
            Defines 0x11 = 17
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x12">
            <summary>
            Defines 0x12 = 18
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x13">
            <summary>
            Defines 0x13 = 19
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x14">
            <summary>
            Defines 0x14 = 20
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x15">
            <summary>
            Defines 0x15 = 21
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x16">
            <summary>
            Defines 0x16 = 22
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x17">
            <summary>
            Defines 0x17 = 23
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x18">
            <summary>
            Defines 0x18 = 24
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x19">
            <summary>
            Defines 0x19 = 25
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x1a">
            <summary>
            Defines 0x1a = 26
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x1b">
            <summary>
            Defines 0x1b = 27
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x1c">
            <summary>
            Defines 0x1c = 28
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x1d">
            <summary>
            Defines 0x1d = 29
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x1e">
            <summary>
            Defines 0x1e = 30
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x1f">
            <summary>
            Defines 0x1f = 31
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x20">
            <summary>
            Defines 0x20 = 32
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x21">
            <summary>
            Defines 0x21 = 33
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x22">
            <summary>
            Defines 0x22 = 34
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x23">
            <summary>
            Defines 0x23 = 35
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x24">
            <summary>
            Defines 0x24 = 36
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x25">
            <summary>
            Defines 0x25 = 37
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x26">
            <summary>
            Defines 0x26 = 38
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x27">
            <summary>
            Defines 0x27 = 39
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x28">
            <summary>
            Defines 0x28 = 40
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x29">
            <summary>
            Defines 0x29 = 41
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x2a">
            <summary>
            Defines 0x2a = 42
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x2b">
            <summary>
            Defines 0x2b = 43
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x2c">
            <summary>
            Defines 0x2c = 44
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x2d">
            <summary>
            Defines 0x2d = 45
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x2e">
            <summary>
            Defines 0x2e = 46
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x2f">
            <summary>
            Defines 0x2f = 47
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x30">
            <summary>
            Defines 0x30 = 48
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x31">
            <summary>
            Defines 0x31 = 49
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x32">
            <summary>
            Defines 0x32 = 50
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x33">
            <summary>
            Defines 0x33 = 51
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x34">
            <summary>
            Defines 0x34 = 52
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x35">
            <summary>
            Defines 0x35 = 53
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x36">
            <summary>
            Defines 0x36 = 54
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x37">
            <summary>
            Defines 0x37 = 55
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x38">
            <summary>
            Defines 0x38 = 56
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x39">
            <summary>
            Defines 0x39 = 57
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x3a">
            <summary>
            Defines 0x3a = 58
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x3b">
            <summary>
            Defines 0x3b = 59
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x3c">
            <summary>
            Defines 0x3c = 60
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x3d">
            <summary>
            Defines 0x3d = 61
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x3e">
            <summary>
            Defines 0x3e = 62
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x3f">
            <summary>
            Defines 0x3f = 63
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x40">
            <summary>
            Defines 0x40 = 64
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x41">
            <summary>
            Defines 0x41 = 65
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x42">
            <summary>
            Defines 0x42 = 66
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x43">
            <summary>
            Defines 0x43 = 67
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x44">
            <summary>
            Defines 0x44 = 68
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x45">
            <summary>
            Defines 0x45 = 69
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x46">
            <summary>
            Defines 0x46 = 70
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x47">
            <summary>
            Defines 0x47 = 71
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x48">
            <summary>
            Defines 0x48 = 72
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x49">
            <summary>
            Defines 0x49 = 73
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x4a">
            <summary>
            Defines 0x4a = 74
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x4b">
            <summary>
            Defines 0x4b = 75
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x4c">
            <summary>
            Defines 0x4c = 76
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x4d">
            <summary>
            Defines 0x4d = 77
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x4e">
            <summary>
            Defines 0x4e = 78
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x4f">
            <summary>
            Defines 0x4f = 79
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x50">
            <summary>
            Defines 0x50 = 80
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x51">
            <summary>
            Defines 0x51 = 81
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x52">
            <summary>
            Defines 0x52 = 82
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x53">
            <summary>
            Defines 0x53 = 83
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x54">
            <summary>
            Defines 0x54 = 84
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x55">
            <summary>
            Defines 0x55 = 85
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x56">
            <summary>
            Defines 0x56 = 86
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x57">
            <summary>
            Defines 0x57 = 87
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x58">
            <summary>
            Defines 0x58 = 88
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x59">
            <summary>
            Defines 0x59 = 89
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x5a">
            <summary>
            Defines 0x5a = 90
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x5b">
            <summary>
            Defines 0x5b = 91
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x5c">
            <summary>
            Defines 0x5c = 92
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x5d">
            <summary>
            Defines 0x5d = 93
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x5e">
            <summary>
            Defines 0x5e = 94
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x5f">
            <summary>
            Defines 0x5f = 95
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x60">
            <summary>
            Defines 0x60 = 96
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x61">
            <summary>
            Defines 0x61 = 97
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x62">
            <summary>
            Defines 0x62 = 98
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x63">
            <summary>
            Defines 0x63 = 99
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x64">
            <summary>
            Defines 0x64 = 100
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x65">
            <summary>
            Defines 0x65 = 101
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x66">
            <summary>
            Defines 0x66 = 102
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x67">
            <summary>
            Defines 0x67 = 103
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x68">
            <summary>
            Defines 0x68 = 104
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x69">
            <summary>
            Defines 0x69 = 105
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x6a">
            <summary>
            Defines 0x6a = 106
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x6b">
            <summary>
            Defines 0x6b = 107
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x6c">
            <summary>
            Defines 0x6c = 108
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x6d">
            <summary>
            Defines 0x6d = 109
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x6e">
            <summary>
            Defines 0x6e = 110
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x6f">
            <summary>
            Defines 0x6f = 111
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x70">
            <summary>
            Defines 0x70 = 112
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x71">
            <summary>
            Defines 0x71 = 113
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x72">
            <summary>
            Defines 0x72 = 114
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x73">
            <summary>
            Defines 0x73 = 115
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x74">
            <summary>
            Defines 0x74 = 116
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x75">
            <summary>
            Defines 0x75 = 117
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x76">
            <summary>
            Defines 0x76 = 118
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x77">
            <summary>
            Defines 0x77 = 119
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x78">
            <summary>
            Defines 0x78 = 120
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x79">
            <summary>
            Defines 0x79 = 121
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x7a">
            <summary>
            Defines 0x7a = 122
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x7b">
            <summary>
            Defines 0x7b = 123
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x7c">
            <summary>
            Defines 0x7c = 124
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x7d">
            <summary>
            Defines 0x7d = 125
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x7e">
            <summary>
            Defines 0x7e = 126
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x7f">
            <summary>
            Defines 0x7f = 127
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x80">
            <summary>
            Defines 0x80 = 128
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x81">
            <summary>
            Defines 0x81 = 129
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x82">
            <summary>
            Defines 0x82 = 130
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x83">
            <summary>
            Defines 0x83 = 131
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x84">
            <summary>
            Defines 0x84 = 132
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x85">
            <summary>
            Defines 0x85 = 133
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x86">
            <summary>
            Defines 0x86 = 134
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x87">
            <summary>
            Defines 0x87 = 135
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x88">
            <summary>
            Defines 0x88 = 136
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x89">
            <summary>
            Defines 0x89 = 137
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x8a">
            <summary>
            Defines 0x8a = 138
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x8b">
            <summary>
            Defines 0x8b = 139
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x8c">
            <summary>
            Defines 0x8c = 140
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x8d">
            <summary>
            Defines 0x8d = 141
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x8e">
            <summary>
            Defines 0x8e = 142
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x8f">
            <summary>
            Defines 0x8f = 143
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x90">
            <summary>
            Defines 0x90 = 144
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x91">
            <summary>
            Defines 0x91 = 145
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x92">
            <summary>
            Defines 0x92 = 146
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x93">
            <summary>
            Defines 0x93 = 147
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x94">
            <summary>
            Defines 0x94 = 148
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x95">
            <summary>
            Defines 0x95 = 149
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x96">
            <summary>
            Defines 0x96 = 150
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x97">
            <summary>
            Defines 0x97 = 151
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x98">
            <summary>
            Defines 0x98 = 152
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x99">
            <summary>
            Defines 0x99 = 153
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x9a">
            <summary>
            Defines 0x9a = 154
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x9b">
            <summary>
            Defines 0x9b = 155
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x9c">
            <summary>
            Defines 0x9c = 156
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x9d">
            <summary>
            Defines 0x9d = 157
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x9e">
            <summary>
            Defines 0x9e = 158
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.x9f">
            <summary>
            Defines 0x9f = 159
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xa0">
            <summary>
            Defines 0xa0 = 160
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xa1">
            <summary>
            Defines 0xa1 = 161
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xa2">
            <summary>
            Defines 0xa2 = 162
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xa3">
            <summary>
            Defines 0xa3 = 163
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xa4">
            <summary>
            Defines 0xa4 = 164
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xa5">
            <summary>
            Defines 0xa5 = 165
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xa6">
            <summary>
            Defines 0xa6 = 166
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xa7">
            <summary>
            Defines 0xa7 = 167
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xa8">
            <summary>
            Defines 0xa8 = 168
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xa9">
            <summary>
            Defines 0xa9 = 169
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xaa">
            <summary>
            Defines 0xaa = 170
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xab">
            <summary>
            Defines 0xab = 171
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xac">
            <summary>
            Defines 0xac = 172
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xad">
            <summary>
            Defines 0xad = 173
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xae">
            <summary>
            Defines 0xae = 174
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xaf">
            <summary>
            Defines 0xaf = 175
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xb0">
            <summary>
            Defines 0xb0 = 176
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xb1">
            <summary>
            Defines 0xb1 = 177
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xb2">
            <summary>
            Defines 0xb2 = 178
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xb3">
            <summary>
            Defines 0xb3 = 179
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xb4">
            <summary>
            Defines 0xb4 = 180
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xb5">
            <summary>
            Defines 0xb5 = 181
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xb6">
            <summary>
            Defines 0xb6 = 182
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xb7">
            <summary>
            Defines 0xb7 = 183
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xb8">
            <summary>
            Defines 0xb8 = 184
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xb9">
            <summary>
            Defines 0xb9 = 185
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xba">
            <summary>
            Defines 0xba = 186
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xbb">
            <summary>
            Defines 0xbb = 187
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xbc">
            <summary>
            Defines 0xbc = 188
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xbd">
            <summary>
            Defines 0xbd = 189
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xbe">
            <summary>
            Defines 0xbe = 190
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xbf">
            <summary>
            Defines 0xbf = 191
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xc0">
            <summary>
            Defines 0xc0 = 192
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xc1">
            <summary>
            Defines 0xc1 = 193
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xc2">
            <summary>
            Defines 0xc2 = 194
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xc3">
            <summary>
            Defines 0xc3 = 195
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xc4">
            <summary>
            Defines 0xc4 = 196
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xc5">
            <summary>
            Defines 0xc5 = 197
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xc6">
            <summary>
            Defines 0xc6 = 198
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xc7">
            <summary>
            Defines 0xc7 = 199
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xc8">
            <summary>
            Defines 0xc8 = 200
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xc9">
            <summary>
            Defines 0xc9 = 201
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xca">
            <summary>
            Defines 0xca = 202
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xcb">
            <summary>
            Defines 0xcb = 203
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xcc">
            <summary>
            Defines 0xcc = 204
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xcd">
            <summary>
            Defines 0xcd = 205
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xce">
            <summary>
            Defines 0xce = 206
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xcf">
            <summary>
            Defines 0xcf = 207
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xd0">
            <summary>
            Defines 0xd0 = 208
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xd1">
            <summary>
            Defines 0xd1 = 209
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xd2">
            <summary>
            Defines 0xd2 = 210
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xd3">
            <summary>
            Defines 0xd3 = 211
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xd4">
            <summary>
            Defines 0xd4 = 212
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xd5">
            <summary>
            Defines 0xd5 = 213
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xd6">
            <summary>
            Defines 0xd6 = 214
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xd7">
            <summary>
            Defines 0xd7 = 215
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xd8">
            <summary>
            Defines 0xd8 = 216
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xd9">
            <summary>
            Defines 0xd9 = 217
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xda">
            <summary>
            Defines 0xda = 218
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xdb">
            <summary>
            Defines 0xdb = 219
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xdc">
            <summary>
            Defines 0xdc = 220
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xdd">
            <summary>
            Defines 0xdd = 221
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xde">
            <summary>
            Defines 0xde = 222
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xdf">
            <summary>
            Defines 0xdf = 223
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xe0">
            <summary>
            Defines 0xe0 = 224
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xe1">
            <summary>
            Defines 0xe1 = 225
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xe2">
            <summary>
            Defines 0xe2 = 226
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xe3">
            <summary>
            Defines 0xe3 = 227
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xe4">
            <summary>
            Defines 0xe4 = 228
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xe5">
            <summary>
            Defines 0xe5 = 229
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xe6">
            <summary>
            Defines 0xe6 = 230
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xe7">
            <summary>
            Defines 0xe7 = 231
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xe8">
            <summary>
            Defines 0xe8 = 232
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xe9">
            <summary>
            Defines 0xe9 = 233
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xea">
            <summary>
            Defines 0xea = 234
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xeb">
            <summary>
            Defines 0xeb = 235
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xec">
            <summary>
            Defines 0xec = 236
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xed">
            <summary>
            Defines 0xed = 237
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xee">
            <summary>
            Defines 0xee = 238
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xef">
            <summary>
            Defines 0xef = 239
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xf0">
            <summary>
            Defines 0xf0 = 240
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xf1">
            <summary>
            Defines 0xf1 = 241
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xf2">
            <summary>
            Defines 0xf2 = 242
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xf3">
            <summary>
            Defines 0xf3 = 243
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xf4">
            <summary>
            Defines 0xf4 = 244
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xf5">
            <summary>
            Defines 0xf5 = 245
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xf6">
            <summary>
            Defines 0xf6 = 246
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xf7">
            <summary>
            Defines 0xf7 = 247
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xf8">
            <summary>
            Defines 0xf8 = 248
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xf9">
            <summary>
            Defines 0xf9 = 249
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xfa">
            <summary>
            Defines 0xfa = 250
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xfb">
            <summary>
            Defines 0xfb = 251
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xfc">
            <summary>
            Defines 0xfc = 252
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xfd">
            <summary>
            Defines 0xfd = 253
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xfe">
            <summary>
            Defines 0xfe = 254
            </summary>
        </member>
        <member name="F:Z0.Hex8Seq.xff">
            <summary>
            Defines 0xff = 255
            </summary>
        </member>
        <member name="T:Z0.HexLookupEntry`2">
            <summary>
            Defines an association between an integer in the range [0,0xFF] and unmanaged data of parametric type
            </summary>
        </member>
        <member name="T:Z0.HexLookup`2">
            <summary>
            Defines a sequence of unmanaged values indexed by an integer in the range [0,255]
            </summary>
        </member>
        <member name="T:Z0.HexText`1">
            <summary>
            Defines a sequence of K-kinded hex chars
            </summary>
        </member>
        <member name="T:Z0.Imm16`1">
            <summary>
            Defines a refined 16-bit immediate value
            </summary>
        </member>
        <member name="T:Z0.Imm32`1">
            <summary>
            Defines a refined 32-bit immediate value
            </summary>
        </member>
        <member name="T:Z0.Imm64`1">
            <summary>
            Defines a refined 64-bit immediate value
            </summary>
        </member>
        <member name="T:Z0.Imm8`1">
            <summary>
            Defines a refined 8-bit immediate value
            </summary>
        </member>
        <member name="T:Z0.Imm8R">
            <summary>
            Describes an 8-bit immediate that is potentially refined
            </summary>
        </member>
        <member name="T:Z0.IDataFlow`2">
            <summary>
            Characterizes a data flow
            </summary>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="T:Z0.IDataFlow`3">
            <summary>
            Characterizes an executed data flow
            </summary>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="T:Z0.Arrow`3">
            <summary>
            Defines an arrow with kind
            </summary>
        </member>
        <member name="F:Z0.Arrow`3.Kind">
            <summary>
            The kind classifier
            </summary>
        </member>
        <member name="F:Z0.Arrow`3.Source">
            <summary>
            The source
            </summary>
        </member>
        <member name="F:Z0.Arrow`3.Target">
            <summary>
            The target
            </summary>
        </member>
        <member name="T:Z0.FlowType`1">
            <summary>
            Defines the type signature for a node-homogenous arrow
            </summary>
        </member>
        <member name="T:Z0.BoxedValueMap">
            <summary>
            Characterizes a function that projects one structural type onto another
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="T:Z0.BoxedValueMap`1">
            <summary>
            Characterizes a result-parametric value projector
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="T:Z0.Delegates.Projector`2">
            <summary>
            Characterizes a parametric projector
            </summary>
            <param name="src">The source value</param>
            <typeparam name="S">The operand type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="T:Z0.Delegates.StreamReceiver`1">
            <summary>
            Characterizes a receiver that accepts a stream
            </summary>
            <typeparam name="T">The stream element type</typeparam>
        </member>
        <member name="T:Z0.Delegates.SpanReceiver`1">
            <summary>
            Characterizes a receiver that accepts a span
            </summary>
            <typeparam name="T">The stream element type</typeparam>
        </member>
        <member name="M:Z0.Delegates.action(System.Reflection.MethodInfo,System.Object)">
            <summary>
            Creates an action delegate from a method
            </summary>
            <param name="src">The source method</param>
        </member>
        <member name="M:Z0.Delegates.action(System.Reflection.MethodInfo)">
            <summary>
            Creates an action delegate from a method
            </summary>
            <param name="src">The source method</param>
        </member>
        <member name="M:Z0.Delegates.type(System.Reflection.MethodInfo)">
            <summary>
            Infers a delegate type compatible with the signature of a specified method
            </summary>
            <param name="src">The source method</param>
        </member>
        <member name="M:Z0.Delegates.binary``1(System.Reflection.MethodInfo,System.Object)">
            <summary>
            Creates a binary operator from a method
            </summary>
            <param name="src">The source method</param>
            <param name="host">The host instance if not static</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.Delegates.dynamic``1(Z0.OpIdentity,System.Reflection.MethodInfo,System.Reflection.Emit.DynamicMethod)">
            <summary>
            Creates a parameteric dynamic delegate
            </summary>
            <param name="id">The identity to confer on the result</param>
            <param name="src">The source method</param>
            <param name="dst">The dynamic method</param>
            <typeparam name="D">The target delegate type</typeparam>
        </member>
        <member name="M:Z0.Delegates.dynamic(Z0.OpIdentity,System.Reflection.MethodInfo,System.Reflection.Emit.DynamicMethod,System.Type)">
            <summary>
            Creates a non-parameteric dynamic delegate
            </summary>
            <param name="id">The identity to confer on the result</param>
            <param name="src">The source method</param>
            <param name="dst">The dynamic method</param>
            <param name="@delegate">The target delegate type</param>
        </member>
        <member name="M:Z0.Delegates.dynamic(Z0.OpIdentity,System.Reflection.MethodInfo,System.Reflection.Emit.DynamicMethod,System.Delegate)">
            <summary>
            Creates a non-parameteric dynamic delegate
            </summary>
            <param name="id">The identity to confer on the result</param>
            <param name="src">The source method</param>
            <param name="dst">The dynamic method</param>
            <param name="@delegate">The target delegate type</param>
        </member>
        <member name="M:Z0.Delegates.from(System.Reflection.MethodInfo,System.Type,System.Object)">
            <summary>
            Creates an untyped delegate
            </summary>
            <param name="src">The target method</param>
            <param name="tDelegate">The delegate type</param>
            <param name="host">The host instance if not static</param>
        </member>
        <member name="M:Z0.Delegates.from(System.Reflection.MethodInfo,System.Type)">
            <summary>
            Creates an untyped delegate
            </summary>
            <param name="src">The target method</param>
            <param name="tDelegate">The delegate type</param>
            <param name="host">The host instance if not static</param>
        </member>
        <member name="M:Z0.Delegates.from``1(System.Reflection.MethodInfo,System.Object)">
            <summary>
            Creates a generic delegate
            </summary>
            <param name="src">The target method</param>
            <typeparam name="D">The delegate type</typeparam>
        </member>
        <member name="M:Z0.Delegates.from``1(System.Reflection.MethodInfo)">
            <summary>
            Creates a generic delegate
            </summary>
            <param name="src">The target method</param>
            <typeparam name="D">The delegate type</typeparam>
        </member>
        <member name="M:Z0.Delegates.func``1(System.Reflection.MethodInfo,``0)">
            <summary>
            Creates a function delegate of generic arity 1 from a static method
            </summary>
            <param name="src">The source method</param>
            <param name="x0">A representative value for the first argument, used only for type inference</param>
            <typeparam name="X0">The first argument type</typeparam>
        </member>
        <member name="M:Z0.Delegates.func``2(System.Reflection.MethodInfo,``0,``1)">
            <summary>
            Creates a function delegate of generic arity 2 from a static method
            </summary>
            <param name="src">The source method</param>
            <param name="x0">A representative value of the first argument, used only for type inference</param>
            <param name="x1">A representative value of the second argument, used only for type inference</param>
            <typeparam name="X0">The first argument type</typeparam>
            <typeparam name="X1">The second argument type</typeparam>
        </member>
        <member name="M:Z0.Delegates.func``3(System.Reflection.MethodInfo,``0,``1,``2)">
            <summary>
            Creates a function delegate of generic arity 3 from a static method
            </summary>
            <param name="src">The source method</param>
            <param name="x0">A representative value of the first argument, used only for type inference</param>
            <param name="x1">A representative value of the second argument, used only for type inference</param>
            <param name="x2">A representative value of the third argument, used only for type inference</param>
            <typeparam name="X0">The first argument type</typeparam>
            <typeparam name="X1">The second argument type</typeparam>
            <typeparam name="X2">The third argument type</typeparam>
        </member>
        <member name="M:Z0.Delegates.func``4(System.Reflection.MethodInfo,``0,``1,``2,``3)">
            <summary>
            Creates a function delegate of generic arity 4 from a static method
            </summary>
            <param name="src">The source method</param>
            <param name="x0">A representative value of the first argument, used only for type inference</param>
            <param name="x1">A representative value of the second argument, used only for type inference</param>
            <param name="x2">A representative value of the third argument, used only for type inference</param>
            <param name="x3">A representative value of the fourth argument, used only for type inference</param>
            <typeparam name="X0">The first argument type</typeparam>
            <typeparam name="X1">The second argument type</typeparam>
            <typeparam name="X2">The third argument type</typeparam>
            <typeparam name="X3">The fourth argument type</typeparam>
        </member>
        <member name="M:Z0.Delegates.sink``1(System.Reflection.MethodInfo,System.Object)">
            <summary>
            Creates a reception delegate/sink from a method
            </summary>
            <param name="src">The source method</param>
            <param name="host">The host instance if not static</param>
            <typeparam name="T">The reception type</typeparam>
        </member>
        <member name="M:Z0.Delegates.source``1(System.Reflection.MethodInfo,System.Object)">
            <summary>
            Creates an emitter from a method
            </summary>
            <param name="src">The source method</param>
            <param name="host">The host instance if not static</param>
            <typeparam name="T">The emission type</typeparam>
        </member>
        <member name="M:Z0.Delegates.ternary``1(System.Reflection.MethodInfo,System.Object)">
            <summary>
            Creates a ternary operator from a method
            </summary>
            <param name="src">The source method</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.Delegates.unary``1(System.Reflection.MethodInfo,System.Object)">
            <summary>
            Creates a unary operator from a method
            </summary>
            <param name="src">The source method</param>
            <param name="host">The host instance if not static</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="T:Z0.Emitter`1">
            <summary>
            Defines the canonical shape of an emitter
            </summary>
            <typeparam name="T">The production type</typeparam>
        </member>
        <member name="T:Z0.Emitter`2">
            <summary>
            Defines the canonical shape of an emitter
            </summary>
            <typeparam name="T">The production type</typeparam>
            <typeparam name="C">The cell type into which the production type is segmented</typeparam>
        </member>
        <member name="T:Z0.StreamEmitter`1">
            <summary>
            Characterizes a function that produces a stream of values
            </summary>
            <param name="count">If specified, the number of elements to produce</param>
            <typeparam name="T">The emission type</typeparam>
        </member>
        <member name="T:Z0.ValueStreamEmitter`1">
            <summary>
            Characterizes a function that produces a stream of values
            </summary>
            <param name="count">If specified, the number of elements to produce</param>
            <typeparam name="T">The emission type</typeparam>
        </member>
        <member name="T:Z0.UnaryOp`1">
            <summary>
            Defines the canonical shape of a unary operator
            </summary>
            <param name="a">The operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="T:Z0.UnaryOp`2">
            <summary>
            Characterizes a unary operator with known operand width
            </summary>
            <param name="a">The operand</param>
            <typeparam name="W">The width type</typeparam>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="T:Z0.BinaryOp`1">
            <summary>
            Defines the canonical shape of a binary operator
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="T:Z0.BinaryOp`2">
            <summary>
            Characterizes a binary operator with known operand width
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
            <typeparam name="W">The width type</typeparam>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="T:Z0.TernaryOp`1">
            <summary>
            Defines the canonical shape of a terneray operator
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <param name="c">The third operand</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="T:Z0.TernaryOp`2">
            <summary>
            Characterizes a ternary operator with known operand width
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <param name="c">The third operand</param>
            <typeparam name="W">The width type</typeparam>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="T:Z0.Receiver`1">
            <summary>
            Characterizes a function that accepts an input of parametric type
            </summary>
            <typeparam name="T">The input type</typeparam>
        </member>
        <member name="T:Z0.PointedReceiver`1">
            <summary>
            Characterizes a receiver that accepts a pointer
            </summary>
            <typeparam name="T">The stream element type</typeparam>
        </member>
        <member name="T:Z0.SpanPartitioner`2">
            <summary>
            Defines the signature of an operator that accepts a primal value and
            partitions the value, or portion thereof, into segments of common length
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target span of sufficient length to receive the partition segments</param>
            <typeparam name="S">The primal source type</typeparam>
            <typeparam name="T">The primal target type</typeparam>
        </member>
        <member name="T:Z0.SpanEmitter`1">
            <summary>
            Characterizes a function that produces spans values
            </summary>
            <typeparam name="T">The emission type</typeparam>
        </member>
        <member name="T:Z0.ValueMap`2">
            <summary>
            Characterizes a parametric value projector
            </summary>
            <param name="src">The source value</param>
            <typeparam name="S">The operand type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="T:Z0.ValuePredicate`1">
            <summary>
            Characterizes a value predicate f:T -> bool
            </summary>
            <param name="src">The source value</param>
            <typeparam name="S">The operand type</typeparam>
        </member>
        <member name="T:Z0.ValueOperator`1">
            <summary>
            Characterizes a value operator
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The operand/target type</typeparam>
        </member>
        <member name="P:Z0.IEnumLiteral.Position">
            <summary>
            Specifies the declaration order of the enum literal
            </summary>
        </member>
        <member name="P:Z0.IEnumLiteral.Name">
            <summary>
            Specifies the literal identifier
            </summary>
        </member>
        <member name="P:Z0.IEnumLiteral.ScalarValue">
            <summary>
            The literal value in an unfortunate box
            </summary>
        </member>
        <member name="T:Z0.IEnumLiteral`1">
            <summary>
            Characterizes a boxed enum value
            </summary>
        </member>
        <member name="T:Z0.IEnumLiteral`2">
            <summary>
            Characterizes an unboxed enum value
            </summary>
        </member>
        <member name="P:Z0.IEnumLiteral`2.LiteralValue">
            <summary>
            The literal value
            </summary>
        </member>
        <member name="T:Z0.IEnumLiteral`3">
            <summary>
            Characterizes an unboxed enum value, parametric in the enumeration type 
            and the underlying numeric type refined by the enum
            </summary>
        </member>
        <member name="P:Z0.IEnumLiteral`3.PrimalValue">
            <summary>
            The literal value presented as a numeric value
            </summary>
        </member>
        <member name="M:Z0.Enums.typecode``1">
            <summary>
            Determines an enumeration's underlying kind
            </summary>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Enums.literal``2(``1)">
            <summary>
            Reads a generic enum member from a generic value
            </summary>
            <param name="v">The value to reinterpret</param>
            <typeparam name="E">The enum type</typeparam>
            <typeparam name="V">The numeric value type</typeparam>
        </member>
        <member name="M:Z0.Enums.scalar_slow``1(System.Enum)">
            <summary>
            Reads a generic numeric value from a boxed enum
            </summary>
            <param name="e">The enum value to reinterpret</param>
            <typeparam name="V">The numeric value type</typeparam>
        </member>
        <member name="M:Z0.Enums.values``2">
            <summary>
            Gets the literals defined by an enumeration together with their integral values
            </summary>
            <param name="peek">If true, extracts the content, bypassing any caching</param>
            <typeparam name="E">The enum type</typeparam>
            <typeparam name="V">The numeric value type</typeparam>
        </member>
        <member name="M:Z0.Enums.evalue``2(Z0.EnumLiteralDetail{``0},``1)">
            <summary>
            Defines an E-V parametric enum value given an E-parametric literal an a value:V
            </summary>
            <param name="literal">The source literal</param>
            <param name="value">The source value</param>
            <typeparam name="E">The enum source type</typeparam>
            <typeparam name="V">The value type</typeparam>
        </member>
        <member name="M:Z0.Enums.literals``1">
            <summary>
            Gets the literals defined by an enumeration
            </summary>
            <param name="peek">If true, extracts the content directly, bypassing any caching</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Enums.dictionary``2">
            <summary>
            Constructs a arbitrarily deduplicated value-to-member index
            </summary>
            <typeparam name="E">The enum type</typeparam>
            <typeparam name="V">The numeric value type</typeparam>
        </member>
        <member name="M:Z0.Enums.base``1">
            <summary>
            Determines the integral type refined by a parametrically-identified enum type
            </summary>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.Enums.base(System.Enum)" -->
        <member name="M:Z0.Enums.base(System.Type)">
            <summary>
            Determines the integral type refined by a specified enum type
            </summary>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Enums.convert``1(System.Byte,``0)">
            <summary>
            Safely, thus slowly, converts a numeric value to an enum value if and only if the numeric value
            is represented by a declared literal 
            </summary>
            <param name="value">The numeric source value</param>
            <param name="default">The enum value to return if the conversion fails</param>
        </member>
        <member name="M:Z0.Enums.convert``1(System.SByte,``0)">
            <summary>
            Safely, thus slowly, converts a numeric value to an enum value if and only if the numeric value
            is represented by a declared literal 
            </summary>
            <param name="value">The numeric source value</param>
            <param name="default">The enum value to return if the conversion fails</param>
        </member>
        <member name="M:Z0.Enums.convert``1(System.Int16,``0)">
            <summary>
            Safely, thus slowly, converts a numeric value to an enum value if and only if the numeric value
            is represented by a declared literal 
            </summary>
            <param name="value">The numeric source value</param>
            <param name="default">The enum value to return if the conversion fails</param>
        </member>
        <member name="M:Z0.Enums.convert``1(System.UInt16,``0)">
            <summary>
            Safely, thus slowly, converts a numeric value to an enum value if and only if the numeric value
            is represented by a declared literal 
            </summary>
            <param name="value">The numeric source value</param>
            <param name="default">The enum value to return if the conversion fails</param>
        </member>
        <member name="M:Z0.Enums.convert``1(System.Int32,``0)">
            <summary>
            Safely, thus slowly, converts a numeric value to an enum value if and only if the numeric value
            is represented by a declared literal 
            </summary>
            <param name="value">The numeric source value</param>
            <param name="default">The enum value to return if the conversion fails</param>
        </member>
        <member name="M:Z0.Enums.convert``1(System.UInt32,``0)">
            <summary>
            Safely, thus slowly, converts a numeric value to an enum value if and only if the numeric value
            is represented by a declared literal 
            </summary>
            <param name="value">The numeric source value</param>
            <param name="default">The enum value to return if the conversion fails</param>
        </member>
        <member name="M:Z0.Enums.convert``1(System.Int64,``0)">
            <summary>
            Safely, thus slowly, converts a numeric value to an enum value if and only if the numeric value
            is represented by a declared literal 
            </summary>
            <param name="value">The numeric source value</param>
            <param name="default">The enum value to return if the conversion fails</param>
        </member>
        <member name="M:Z0.Enums.convert``1(System.UInt64,``0)">
            <summary>
            Safely, thus slowly, converts a numeric value to an enum value if and only if the numeric value
            is represented by a declared literal 
            </summary>
            <param name="value">The numeric source value</param>
            <param name="default">The enum value to return if the conversion fails</param>
        </member>
        <member name="M:Z0.Enums.dataset``2">
            <summary>
            Creates an enumeration dataset predicated on supplied type parameters
            </summary>
            <typeparam name="E">The enum type</typeparam>
            <typeparam name="T">The refined primitive type</typeparam>
        </member>
        <member name="M:Z0.Enums.defined``1(System.String)">
            <summary>
            Determines whether an enum defines a name-identified literal
            </summary>
            <param name="name">The test name</param>
            <typeparam name="E">The enum source type</typeparam>
        </member>
        <member name="M:Z0.Enums.defined``1(``0)">
            <summary>
            Determines whether an enum value is valid
            </summary>
            <param name="v">The test value</param>
            <typeparam name="E">The enum source type</typeparam>
            <typeparam name="V">The value type</typeparam>
        </member>
        <member name="M:Z0.Enums.defined``2(``1)">
            <summary>
            Determines whether an enum has a specified integral value
            </summary>
            <param name="v">The test value</param>
            <typeparam name="E">The enum source type</typeparam>
            <typeparam name="V">The value type</typeparam>
        </member>
        <member name="M:Z0.Enums.describe``2(Z0.ClrArtifactKey,System.UInt32,System.String,``0,``1)">
            <summary>
            Defines a useful representation of an enumeration literal
            </summary>
            <typeparam name="E">The enum type</typeparam>
            <typeparam name="T">The scalar type refined by the enum</typeparam>
            <typeparam name="A">The asci identifier type</typeparam>
        </member>
        <member name="M:Z0.Enums.e16u``1(``0)">
            <summary>
            Interprets an enum value as an unsigned 16-bit integer
            </summary>
            <param name="e">The enum value</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Enums.e16i``1(``0)">
            <summary>
            Interprets an enum value as a signed 16-bit integer
            </summary>
            <param name="e">The enum value</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Enums.i16``1(``0@,System.UInt64@)">
            <summary>
            Reads an i16 value from an enum of primal i16-kind, writes the value to a u64 target, and returns the extracted i16 value
            </summary>
            <param name="src">The enum value</param>
            <param name="dst">The storage target</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Enums.c16``1(``0@,System.UInt64@)">
            <summary>
            Reads a u16 value from an enum of primal u16-kind, writes the value to a u64 target, and returns the extracted value as c16 value
            </summary>
            <param name="src">The enum value</param>
            <param name="dst">The storage target</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Enums.e32i``1(``0)">
            <summary>
            Interprets an enum value as a signed 32-bit integer
            </summary>
            <param name="e">The enum value</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Enums.e32u``1(``0)">
            <summary>
            Interprets an enum value as an unsigned 32-bit integer
            </summary>
            <param name="e">The enum value</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Enums.i32``1(``0@,System.UInt64@)">
            <summary>
            Reads an i32 value from an enum of primal i32-kind, writes the value to a u64 target, and returns the extracted i32 value
            </summary>
            <param name="src">The enum value</param>
            <param name="dst">The storage target</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Enums.e64i``1(``0)">
            <summary>
            Interprets an enum value as a signed 64-bit integer
            </summary>
            <param name="e">The enum value</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Enums.e64u``1(``0)">
            <summary>
            Interprets an enum value as an unsigned 64-bit integer
            </summary>
            <param name="e">The enum value</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Enums.i64``1(``0@,System.UInt64@)">
            <summary>
            Reads an i64 value from an enum of primal i64-kind, writes the value to a u64 target, and returns the extracted i64 value
            </summary>
            <param name="src">The enum value</param>
            <param name="dst">The storage target</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Enums.e8i``1(``0)">
            <summary>
            Interprets an enum value as a signed byte
            </summary>
            <param name="e">The enum value</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Enums.e8u``1(``0)">
            <summary>
            Interprets an enum value as a byte
            </summary>
            <param name="e">The enum value</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Enums.i8``1(``0@,System.UInt64@)">
            <summary>
            Reads a u8 value from an enum of primal i8-kind, writes the value to a u64 target, and returns the extracted i8 value
            </summary>
            <param name="src">The enum value</param>
            <param name="dst">The storage target</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Enums.index``1">
            <summary>
            Gets the declaration-order indices for each named literal
            </summary>
            <param name="peek">If true, extracts the content directly, bypassing any caching</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Enums.LiteralSequence``2">
            <summary>
            Gets the literals defined by an enumeration together with their integral values
            </summary>
            <typeparam name="E">The enum type</typeparam>
            <typeparam name="T">The value type</typeparam>
        </member>
        <member name="M:Z0.Enums.CreateLiteralArray``1">
            <summary>
            Gets the literals defined by an enumeration
            </summary>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Enums.literal``1(System.Char,``0)">
            <summary>
            Envisions a c16 value as a value of an enum of like u16 kind
            </summary>
            <param name="tVal">The source value</param>
            <param name="eRep">A representative enum value, used only for type inference</param>
            <typeparam name="E">The enum target type of primal u16-kind</typeparam>
        </member>
        <member name="M:Z0.Enums.literal``1(System.Int32,``0)">
            <summary>
            Envisions an i32 value as a value of an enum of like primal kind
            </summary>
            <param name="tVal">The source value</param>
            <param name="eRep">A representative enum value, used only for type inference</param>
            <typeparam name="E">The enum target type of primal i32-kind</typeparam>
        </member>
        <member name="M:Z0.Enums.literal``1(System.UInt32,``0)">
            <summary>
            Envisions a u32 value as a value of an enum of like primal kind
            </summary>
            <param name="tVal">The source value</param>
            <param name="eRep">A representative enum value, used only for type inference</param>
            <typeparam name="E">The enum target type of primal u32-kind</typeparam>
        </member>
        <member name="M:Z0.Enums.literal``1(System.Int64,``0)">
            <summary>
            Envisions an i64 value as a value of an enum of like primal kind
            </summary>
            <param name="tVal">The source value</param>
            <param name="eRep">A representative enum value, used only for type inference</param>
            <typeparam name="E">The enum target type of primal i64-kind</typeparam>
        </member>
        <member name="M:Z0.Enums.literal``1(System.UInt64,``0)">
            <summary>
            Envisions a u64 value as a value of an enum of like primal kind
            </summary>
            <param name="tVal">The source value</param>
            <param name="eRep">A representative enum value, used only for type inference</param>
            <typeparam name="E">The enum target type of primal u64-kind</typeparam>
        </member>
        <member name="M:Z0.Enums.names``1">
            <summary>
            Gets the names of the (unique) enumeration literals
            </summary>
            <param name="e">An enum type representative</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Enums.pair``2(System.String,``0,``1)">
            <summary>
             Defines, but does not verify, a correlation between enum literals
            </summary>
            <param name="name">The correlation axis</param>
            <param name="first">The first literal</param>
            <param name="second">THe second literal</param>
            <typeparam name="E1">The first enum type</typeparam>
            <typeparam name="E2">The second enum type</typeparam>
        </member>
        <member name="M:Z0.Enums.pairs``2">
            <summary>
            Correlates literal values predicated on identifier equality
            </summary>
            <typeparam name="E1">The first enum type</typeparam>
            <typeparam name="E2">The second enum type</typeparam>
        </member>
        <member name="M:Z0.Enums.parse``1(System.String,``0)">
            <summary>
            Attempts to parses an enumeration literal, ignoring case, and returns a default value if parsing failed
            </summary>
            <param name="name">The literal name</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Enums.parse``1(System.String)">
            <summary>
            Attempts o parse an enum literal, ignoring case, and returns a null value if parsing failed
            </summary>
            <param name="name">The literal name</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Enums.scalar``2(``0)">
            <summary>
            Reads a generic numeric value from a generic enum.
            </summary>
            <param name="e">The enum value to reinterpret</param>
            <typeparam name="E">The enum source type</typeparam>
            <typeparam name="V">The value type</typeparam>
        </member>
        <member name="M:Z0.Enums.scalar``2(``0@,``1@)">
            <summary>
            Reads a T-value from an E-enum value of primal T-kind.
            </summary>
            <param name="eVal">The enum value</param>
            <param name="tVal">The primal output value</param>
            <typeparam name="E">The enum type</typeparam>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.Enums.scalar``1(``0@,System.Byte@)">
            <summary>
            Reads a u8-value from an enum of primal u8-kind
            </summary>
            <param name="eVal">The enum value</param>
            <param name="tVal">The primal output value</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Enums.scalar``1(``0@,System.Int16@)">
            <summary>
            Reads an i16-value from an enum of primal i16-kind
            </summary>
            <param name="eVal">The enum value</param>
            <param name="tVal">The primal output value</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Enums.scalar``1(``0@,System.UInt16@)">
            <summary>
            Reads a u16-value from an enum of primal u16-kind
            </summary>
            <param name="eVal">The enum value</param>
            <param name="tVal">The primal output value</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Enums.scalar``1(``0@,System.Int32@)">
            <summary>
            Reads an i32-value from an enum of primal i32-kind
            </summary>
            <param name="eVal">The enum value</param>
            <param name="tVal">The primal output value</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Enums.scalar``1(``0@,System.UInt32@)">
            <summary>
            Reads a u32-value from an enum of primal u32-kind
            </summary>
            <param name="eVal">The enum value</param>
            <param name="tVal">The primal output value</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Enums.scalar``1(``0@,System.SByte@)">
            <summary>
            Reads an i8-value from an enum of primal u8-kind
            </summary>
            <param name="eVal">The enum value</param>
            <param name="tVal">The primal output value</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Enums.scalar``1(``0@,System.Int64@)">
            <summary>
            Reads an i64-value from an enum of primal i64-kind
            </summary>
            <param name="eVal">The enum value</param>
            <param name="tVal">The primal output value</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Enums.scalar``1(``0@,System.UInt64@)">
            <summary>
            Reads a u64-value from an enum of primal u64-kind
            </summary>
            <param name="eVal">The enum value</param>
            <param name="tVal">The primal output value</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Enums.scalar``1(``0@,System.Char@)">
            <summary>
            Reads a c16-value from an enum of primal u16-kind
            </summary>
            <param name="eVal">The enum value</param>
            <param name="cVal">The character output value</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Enums.store``1(``0@,System.UInt64@)">
            <summary>
            Stores an enum value of any primal kind to a u64 target
            </summary>
            <param name="eVal">The enum value</param>
            <param name="dst">The storage target</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.EnumValue.literal``2(``1@,``0)">
            <summary>
            Reads an E-value from an enum of primal T-kind
            </summary>
            <param name="tVal">The integral value</param>
            <param name="eRep">A representative enum value, used only for type inference</param>
            <typeparam name="E">The enum type</typeparam>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.EnumValue.scalar``2(``0@,``1)">
            <summary>
            Reads a T-value from the value of an E-enum of primal T-kind
            </summary>
            <param name="eVal">The enum value</param>
            <param name="tVal">The primal output value</param>
            <typeparam name="E">The enum type</typeparam>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.EnumValue.e8i``1(``0@)">
            <summary>
            Envisions an E-enum value of primal i8-kind as a like-kinded scalar value
            </summary>
            <param name="eVal">The enum source value</param>
            <typeparam name="E">The enum type of primal i8-kind</typeparam>
        </member>
        <member name="M:Z0.EnumValue.e8u``1(``0)">
            <summary>
            Envisions an E-enum value of primal u8-kind as a like-kinded scalar value
            </summary>
            <param name="eVal">The enum source value</param>
            <typeparam name="E">The enum type of primal u8-kind</typeparam>
        </member>
        <member name="M:Z0.EnumValue.e16i``1(``0)">
            <summary>
            Envisions an E-enum value of primal i16-kind as a like-kinded scalar value
            </summary>
            <param name="eVal">The enum source value</param>
            <typeparam name="E">The enum type of primal i16-kind</typeparam>
        </member>
        <member name="M:Z0.EnumValue.e16u``1(``0)">
            <summary>
            Envisions an E-enum value of primal u16-kind as a like-kinded scalar value
            </summary>
            <param name="eVal">The enum source value</param>
            <typeparam name="E">The enum type of primal u16-kind</typeparam>
        </member>
        <member name="M:Z0.EnumValue.e16c``1(``0)">
            <summary>
            Envisions an E-enum value of primal u16-kind as a c16 value
            </summary>
            <param name="eVal">The enum source value</param>
            <typeparam name="E">The enum type of primal u16-kind</typeparam>
        </member>
        <member name="M:Z0.EnumValue.eVal``1(System.Byte,``0)">
            <summary>
            Envisions a u8 value as a value of an enum of like primal kind
            </summary>
            <param name="tVal">The source value</param>
            <param name="eRep">A representative enum value, used only for type inference</param>
            <typeparam name="E">The enum target type of primal u8-kind</typeparam>
        </member>
        <member name="M:Z0.EnumValue.eVal``1(System.SByte,``0)">
            <summary>
            Envisions an i8 value as a value of an enum of like primal kind
            </summary>
            <param name="tVal">The source value</param>
            <param name="eRep">A representative enum value, used only for type inference</param>
            <typeparam name="E">The enum target type of primal i8-kind</typeparam>
        </member>
        <member name="M:Z0.EnumValue.eVal``1(System.Int16,``0)">
            <summary>
            Envisions an i16 value as a value of an enum of like primal kind
            </summary>
            <param name="tVal">The source value</param>
            <param name="eRep">A representative enum value, used only for type inference</param>
            <typeparam name="E">The enum target type of primal i16-kind</typeparam>
        </member>
        <member name="M:Z0.EnumValue.eVal``1(System.UInt16,``0)">
            <summary>
            Envisions a u16 value as a value of an enum of like primal kind
            </summary>
            <param name="tVal">The source value</param>
            <param name="eRep">A representative enum value, used only for type inference</param>
            <typeparam name="E">The enum target type of primal u16-kind</typeparam>
        </member>
        <member name="T:Z0.E8u">
            <summary>
            A <see cref='T:System.Byte'/> refinement that is both vacuous and canonical
            </summary>
        </member>
        <member name="T:Z0.E8i">
            <summary>
            A <see cref='T:System.SByte'/> refinement that is both vacuous and canonical
            </summary>
        </member>
        <member name="T:Z0.E16i">
            <summary>
            A <see cref='T:System.Int16'/> refinement that is both vacuous and canonical
            </summary>
        </member>
        <member name="T:Z0.E16u">
            <summary>
            A <see cref='T:System.UInt16'/> refinement that is both vacuous and canonical
            </summary>
        </member>
        <member name="T:Z0.E32i">
            <summary>
            A <see cref='T:System.Int32'/> refinement that is both vacuous and canonical
            </summary>
        </member>
        <member name="T:Z0.E32u">
            <summary>
            A <see cref='T:System.UInt32'/> refinement that is both vacuous and canonical
            </summary>
        </member>
        <member name="T:Z0.E64i">
            <summary>
            A <see cref='T:System.Int64'/> refinement that is both vacuous and canonical
            </summary>
        </member>
        <member name="T:Z0.E64u">
            <summary>
            A <see cref='T:System.UInt64'/> refinement that is both vacuous and canonical
            </summary>
        </member>
        <member name="T:Z0.EnumDatasetEntries">
            <summary>
            Covers a <see cref='T:Z0.EnumDatasetEntry'/> sequence
            </summary>
        </member>
        <member name="T:Z0.EnumDatasetEntry">
            <summary>
            Defines a nonparametric enum dataset entry
            </summary>
        </member>
        <member name="F:Z0.EnumDatasetEntry.Id">
            <summary>
            The artifact identifier of the defining literal
            </summary>
        </member>
        <member name="F:Z0.EnumDatasetEntry.EnumId">
            <summary>
            The defining <see cref='T:System.Enum'/> id
            </summary>
        </member>
        <member name="F:Z0.EnumDatasetEntry.Index">
            <summary>
            The 0-based declaration order of the defining literal
            </summary>
        </member>
        <member name="F:Z0.EnumDatasetEntry.ScalarValue">
            <summary>
            The refined primitive value
            </summary>
        </member>
        <member name="F:Z0.EnumDatasetEntry.Name">
            <summary>
            The literal name
            </summary>
        </member>
        <member name="F:Z0.EnumDatasetEntry.Description">
            <summary>
            The description, if available
            </summary>
        </member>
        <member name="T:Z0.EnumDatasetEntry`2">
            <summary>
            Defines a <see cref='T:Z0.EnumDataset`2'/> entry
            </summary>
            <typeparam name="E">The enum type</typeparam>
            <typeparam name="T">The refined primitive type</typeparam>
        </member>
        <member name="F:Z0.EnumDatasetEntry`2.Id">
            <summary>
            The artifact identifier of the defining literal
            </summary>
        </member>
        <member name="F:Z0.EnumDatasetEntry`2.EnumId">
            <summary>
            The defining <see cref='T:System.Enum'/> id
            </summary>
        </member>
        <member name="F:Z0.EnumDatasetEntry`2.Index">
            <summary>
            The 0-based declaration order of the defining literal
            </summary>
        </member>
        <member name="F:Z0.EnumDatasetEntry`2.ScalarValue">
            <summary>
            The refined primitive value
            </summary>
        </member>
        <member name="F:Z0.EnumDatasetEntry`2.Name">
            <summary>
            The literal name
            </summary>
        </member>
        <member name="F:Z0.EnumDatasetEntry`2.Description">
            <summary>
            The description, if available
            </summary>
        </member>
        <member name="F:Z0.EnumDatasetEntry`2.EnumValue">
            <summary>
            The enum value
            </summary>
        </member>
        <member name="T:Z0.EnumDataset`2">
            <summary>
            Covers a collection of tables that, together, describe a parametrically-predicated enum
            </summary>
            <typeparam name="E">The enum type</typeparam>
            <typeparam name="T">The refined primitive type</typeparam>
        </member>
        <member name="T:Z0.EnumLiteral.Fields">
            <summary>
            Defines the fields into which a literal table is partitioned
            </summary>
        </member>
        <member name="F:Z0.EnumLiteral.Fields.TypeName">
            <summary>
            The defining type, such as an enum or a type that declares constant fields
            </summary>
        </member>
        <member name="F:Z0.EnumLiteral.Fields.Index">
            <summary>
            The declaration order of the literal relative to other literals in the same dataset
            </summary>
        </member>
        <member name="F:Z0.EnumLiteral.Fields.Name">
            <summary>
            The literal name
            </summary>
        </member>
        <member name="F:Z0.EnumLiteral.Fields.Hex">
            <summary>
            The literal's value in base-16
            </summary>
        </member>
        <member name="F:Z0.EnumLiteral.Fields.BitString">
            <summary>
            The literal's bitstring representation
            </summary>
        </member>
        <member name="F:Z0.EnumLiteral.Fields.Description">
            <summary>
             A description of the literal if it exist
            </summary>
        </member>
        <member name="T:Z0.EnumLiteralDetail`1">
            <summary>
            Defines an enumeration literal as the triple (index,identifier,value)
            </summary>
            <remarks>
            Defining a literal this way attempts to overcome troublesome aspects in which C#/clr enums
            are implemented and preserves all enum information content. It is value-invariant in the sense
            that the numeric content of does of a member not impact the n index/name content.
            Thus, enum value duplication isn't an issue since all data are preserved, the api end-user can decide what
            value duplication means in a given context
            </remarks>
        </member>
        <member name="F:Z0.EnumLiteralDetail`1.BackingField">
            <summary>
            The compiler-emitted field that defines the literal
            </summary>
        </member>
        <member name="F:Z0.EnumLiteralDetail`1.PrimalKind">
            <summary>
            The kind of primitive specialized by the enum
            </summary>
        </member>
        <member name="F:Z0.EnumLiteralDetail`1.Position">
            <summary>
            The literal declaration order, unique within the declaring enum
            </summary>
        </member>
        <member name="F:Z0.EnumLiteralDetail`1.Name">
            <summary>
            The literal identifier, unique within the declaring enum
            </summary>
        </member>
        <member name="F:Z0.EnumLiteralDetail`1.LiteralValue">
            <summary>
            The literal E-value
            </summary>
        </member>
        <member name="F:Z0.EnumLiteralDetail`1.DataType">
            <summary>
            The system data type
            </summary>
        </member>
        <member name="F:Z0.EnumLiteralDetail`1.Description">
            <summary>
            The meaning of the literal, if available
            </summary>
        </member>
        <member name="F:Z0.EnumLiteralDetail`1.UserData">
            <summary>
            User data attached to the literal, if any
            </summary>
        </member>
        <member name="P:Z0.EnumLiteralDetail`1.Id">
            <summary>
            The metadata token that identifies the backing field
            </summary>
        </member>
        <member name="T:Z0.EnumLiteralDetail`2">
            <summary>
            Defines an E-V parametric enum value
            </summary>
        </member>
        <member name="F:Z0.EnumLiteralDetail`2.PrimalValue">
            <summary>
            The literal V-value
            </summary>
        </member>
        <member name="P:Z0.EnumLiteralDetail`2.Position">
            <summary>
            The literal declaration order, unique within the declaring enum
            </summary>
        </member>
        <member name="P:Z0.EnumLiteralDetail`2.Name">
            <summary>
            The literal identifier, unique within the declaring enum
            </summary>
        </member>
        <member name="P:Z0.EnumLiteralDetail`2.LiteralValue">
            <summary>
            The literal E-value
            </summary>
        </member>
        <member name="P:Z0.EnumLiteralDetail`2.PrimalKind">
            <summary>
            The numeric kind refined by the enum
            </summary>
        </member>
        <member name="T:Z0.EnumLiteralDetails`1">
            <summary>
            Defines an E-parametric literal index
            </summary>
        </member>
        <member name="T:Z0.EnumLiteralDetails`2">
            <summary>
            Defines an E-V parametric literal index
            </summary>
        </member>
        <member name="T:Z0.EnumPair`2">
            <summary>
            Captures name-corellated literals values
            </summary>
        </member>
        <member name="F:Z0.EnumPair`2.Name">
            <summary>
            The common name
            </summary>
        </member>
        <member name="F:Z0.EnumPair`2.First">
            <summary>
            The first enum value
            </summary>
        </member>
        <member name="F:Z0.EnumPair`2.Second">
            <summary>
            The second enum value
            </summary>
        </member>
        <member name="T:Z0.Refinement`2">
            <summary>
            Let's pretend we can make refinement types in .Net
            </summary>
        </member>
        <member name="F:Z0.Refinement`2.Value">
            <summary>
            The numeric content covered by the refining enumeration
            </summary>
        </member>
        <member name="P:Z0.Refinement`2.Numeric">
            <summary>
            The numeric content
            </summary>
        </member>
        <member name="T:Z0.BinaryEvaluations`1">
            <summary>
            Captures the operands and outcome of binary operator evaluation
            </summary>
            <typeparam name="T">The evaluation result type</typeparam>
        </member>
        <member name="T:Z0.EvalResult">
            <summary>
            Describes the outcome of a test case
            </summary>
        </member>
        <member name="T:Z0.PairEvalResults`1">
            <summary>
            Captures paired evaluations
            </summary>
            <typeparam name="T">The evaluation result type</typeparam>
        </member>
        <member name="T:Z0.UnaryEvaluations`1">
            <summary>
            Captures the operands and outcome unary pair evaluation
            </summary>
            <typeparam name="T">The evaluation result type</typeparam>
        </member>
        <member name="F:Z0.UnaryEvaluations`1.Source">
            <summary>
            The source operand data
            </summary>
        </member>
        <member name="F:Z0.UnaryEvaluations`1.Target">
            <summary>
            The evaluation data
            </summary>
        </member>
        <member name="P:Z0.UnaryEvaluations`1.Count">
            <summary>
            The evaluated pair count
            </summary>
        </member>
        <member name="P:Z0.UnaryEvaluations`1.LeftLabel">
            <summary>
            Designates the left operator
            </summary>
        </member>
        <member name="P:Z0.UnaryEvaluations`1.RightLabel">
            <summary>
            Designates the right operator
            </summary>
        </member>
        <member name="P:Z0.IPartFileExtensions.Extract">
            <summary>
            Extract log extension
            </summary>
        </member>
        <member name="P:Z0.IPartFileExtensions.Parsed">
            <summary>
            Parse log extension
            </summary>
        </member>
        <member name="P:Z0.IPartFileExtensions.Unparsed">
            <summary>
            Parse failure log extension
            </summary>
        </member>
        <member name="P:Z0.IPartFileExtensions.HexLine">
            <summary>
            Extension for hex files
            </summary>
        </member>
        <member name="P:Z0.IPartFileExtensions.Asm">
            <summary>
            Extension for formatted asm files
            </summary>
        </member>
        <member name="P:Z0.IPartFileExtensions.Il">
            <summary>
            Extension for Cil files
            </summary>
        </member>
        <member name="P:Z0.IPartFileExtensions.IlData">
            <summary>
            Extension for Cil data files
            </summary>
        </member>
        <member name="P:Z0.IPartFileExtensions.Config">
            <summary>
            Extension for part configuration files
            </summary>
        </member>
        <member name="P:Z0.IPartFileExtensions.StatusLog">
            <summary>
            Extension for application status logs
            </summary>
        </member>
        <member name="P:Z0.IPartFileExtensions.ErrorLog">
            <summary>
            Extension for error output capture logs
            </summary>
        </member>
        <member name="P:Z0.IPartFilePaths.ArchiveRoot">
            <summary>
            The path to which all archive path arithmetic is relative
            </summary>
        </member>
        <member name="T:Z0.IPartFolderNames">
            <summary>
            Defines common part path components
            </summary>
        </member>
        <member name="P:Z0.IPartFolderNames.TestFolder">
            <summary>
            An archive partition for files emitted during test execution
            </summary>
        </member>
        <member name="P:Z0.IPartFolderNames.ImmFolderName">
            <summary>
            The imm root folder name
            </summary>
        </member>
        <member name="M:Z0.IPartFolderNames.PartFolderName(PartId)">
            <summary>
            Defines a part-specific folder name {part}
            </summary>
            <param name="part">The source part</param>
        </member>
        <member name="P:Z0.IPartImmPaths.ImmRoot">
            <summary>
            The imm root directory path
            </summary>
        </member>
        <member name="M:Z0.IPartImmPaths.ImmDirs(PartId)">
            <summary>
            Nonrecursively enumerates directory paths owned by a specified part
            </summary>
            <param name="part">The owning part</param>
            <param name="ext">The extension to match</param>
        </member>
        <member name="F:Z0.ArchiveFileKindNames.txt">
            <summary>
            Defines the 'txt' literal
            </summary>
        </member>
        <member name="F:Z0.ArchiveFileKindNames.il">
            <summary>
            Defines the 'il' literal
            </summary>
        </member>
        <member name="F:Z0.ArchiveFileKindNames.asm">
            <summary>
            Defines the 'asm' literal
            </summary>
        </member>
        <member name="F:Z0.ArchiveFileKindNames.csv">
            <summary>
            Defines the 'csv' literal
            </summary>
        </member>
        <member name="F:Z0.ArchiveFileKindNames.cs">
            <summary>
            Defines the 'cs' literal
            </summary>
        </member>
        <member name="F:Z0.ArchiveFileKindNames.cil">
            <summary>
            Defines the 'cil' literal
            </summary>
        </member>
        <member name="F:Z0.ArchiveFileKindNames.cpp">
            <summary>
            Defines the 'cpp' literal
            </summary>
        </member>
        <member name="F:Z0.ArchiveFileKindNames.dll">
            <summary>
            Defines the 'dll' literal
            </summary>
        </member>
        <member name="F:Z0.ArchiveFileKindNames.json">
            <summary>
            Defines the 'json' literal
            </summary>
        </member>
        <member name="F:Z0.ArchiveFileKindNames.pdb">
            <summary>
            Defines the 'pdb' literal
            </summary>
        </member>
        <member name="F:Z0.ArchiveFileKindNames.xml">
            <summary>
            Defines the 'xml' literal
            </summary>
        </member>
        <member name="F:Z0.ArchiveFileKindNames.exe">
            <summary>
            Defines the 'exe' literal
            </summary>
        </member>
        <member name="F:Z0.ArchiveFileKindNames.hex">
            <summary>
            Defines the 'hex' literal
            </summary>
        </member>
        <member name="F:Z0.ArchiveFileKindNames.log">
            <summary>
            Defines the 'log' literal
            </summary>
        </member>
        <member name="F:Z0.ArchiveFileKindNames.obj">
            <summary>
            Defines the 'obj' literal
            </summary>
        </member>
        <member name="F:Z0.ArchiveFileKindNames.status">
            <summary>
            Defines the 'status' literal
            </summary>
        </member>
        <member name="F:Z0.ArchiveFileKindNames.error">
            <summary>
            Defines the 'errors' literal
            </summary>
        </member>
        <member name="F:Z0.ArchiveFileKindNames.lib">
            <summary>
            Defines the 'lib' literal
            </summary>
        </member>
        <member name="F:Z0.ArchiveFileKindNames.cmd">
            <summary>
            Defines the 'cmd' literal
            </summary>
        </member>
        <member name="F:Z0.ArchiveFileKindNames.xcsv">
            <summary>
            Defines the 'x.csv' literal
            </summary>
        </member>
        <member name="F:Z0.ArchiveFileKindNames.pcsv">
            <summary>
            Defines the 'p.csv' literal
            </summary>
        </member>
        <member name="F:Z0.ArchiveFileKindNames.idx">
            <summary>
            Defines the 'idx' literal
            </summary>
        </member>
        <member name="F:Z0.ArchiveFileKindNames.deps">
            <summary>
            Defines the 'deps' literal
            </summary>
        </member>
        <member name="T:Z0.FileKinds">
            <summary>
            Defines a rooted archive over files with specified extensions
            </summary>
        </member>
        <member name="T:Z0.FileCatalogEntry">
            <summary>
            Defines a file catalog entry that specifies a path to a file
            </summary>
        </member>
        <member name="F:Z0.CoreFileKind.Hex">
            <summary>
            Text-formatted x86-encoded assembly
            </summary>
        </member>
        <member name="F:Z0.CoreFileKind.Asm">
            <summary>
            Formatted assembly
            </summary>
        </member>
        <member name="F:Z0.CoreFileKind.Cil">
            <summary>
            Text-formatted CIL instructions
            </summary>
        </member>
        <member name="F:Z0.CoreFileKind.Csv">
            <summary>
             Delimited data rows
            </summary>
        </member>
        <member name="F:Z0.CoreFileKind.Dll">
            <summary>
             A library module, managed or otherwise
            </summary>
        </member>
        <member name="F:Z0.CoreFileKind.Exe">
            <summary>
             An executable module
            </summary>
        </member>
        <member name="F:Z0.CoreFileKind.Txt">
            <summary>
            Text data
            </summary>
        </member>
        <member name="F:Z0.CoreFileKind.Xml">
            <summary>
             Xml data
            </summary>
        </member>
        <member name="F:Z0.CoreFileKind.Json">
            <summary>
            Json data
            </summary>
        </member>
        <member name="F:Z0.CoreFileKind.Extract">
            <summary>
            Unprocessed x86-encoded data
            </summary>
        </member>
        <member name="F:Z0.CoreFileKind.Parsed">
            <summary>
            Text-formatted x86-encoded/executable data
            </summary>
        </member>
        <member name="F:Z0.CoreFileKind.StdLog">
            <summary>
            Application message/diagnostic log
            </summary>
        </member>
        <member name="F:Z0.CoreFileKind.ErrLog">
            <summary>
            Application error log
            </summary>
        </member>
        <member name="F:Z0.CoreFileKind.Dat">
            <summary>
            Line-oriented hex data where each line is prefixed with an absolute/relative offset
            </summary>
        </member>
        <member name="F:Z0.CoreFileKind.Doc">
            <summary>
            A text document of some sort
            </summary>
        </member>
        <member name="F:Z0.CoreFileKind.Tool">
            <summary>
            A file produced by some sort of tool
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Z0.FileModuleKind" -->
        <member name="F:Z0.FileModuleKind.Dll">
            <summary>
            Classifies a file as a module that lacks an entry point
            </summary>
        </member>
        <member name="F:Z0.FileModuleKind.Exe">
            <summary>
            Classifies a file as a module that has an entry point
            </summary>
        </member>
        <member name="F:Z0.FileModuleKind.Lib">
            <summary>
            Classifies a file as static module that exports routines for inclusion in other modules
            </summary>
        </member>
        <member name="F:Z0.FileModuleKind.Native">
            <summary>
            Classifies a file as a module that does not require a managed execution context for use
            </summary>
        </member>
        <member name="F:Z0.FileModuleKind.Managed">
            <summary>
            Classifies a file as a module that requires a managed execution context for use
            </summary>
        </member>
        <member name="F:Z0.FileModuleKind.Hybrid">
            <summary>
            Classifies a file as a hybrid module that contains both IL and managed code
            </summary>
        </member>
        <member name="F:Z0.FileModuleKind.NativeDll">
            <summary>
            Classifies a file as a <see cref='F:Z0.FileModuleKind.Native'/> <see cref='F:Z0.FileModuleKind.Dll' />
            </summary>
        </member>
        <member name="F:Z0.FileModuleKind.NativeExe">
            <summary>
            Classifies a file as a <see cref='F:Z0.FileModuleKind.Native'/> <see cref='F:Z0.FileModuleKind.Exe' />
            </summary>
        </member>
        <member name="F:Z0.FileModuleKind.NativeLib">
            <summary>
            Classifies a file as a <see cref='F:Z0.FileModuleKind.Native'/> <see cref='F:Z0.FileModuleKind.Lib' />
            </summary>
        </member>
        <member name="F:Z0.FileModuleKind.ManagedDll">
            <summary>
            Classifies a file as a <see cref='F:Z0.FileModuleKind.Managed'/> <see cref='F:Z0.FileModuleKind.Dll' />
            </summary>
        </member>
        <member name="F:Z0.FileModuleKind.ManagedExe">
            <summary>
            Classifies a file as a <see cref='F:Z0.FileModuleKind.Managed'/> <see cref='F:Z0.FileModuleKind.Exe' />
            </summary>
        </member>
        <member name="T:Z0.ManagedDllFile">
            <summary>
            Identifies and represents and managaged module that lacks an entry point
            </summary>
        </member>
        <member name="P:Z0.ManagedDllFile.Path">
            <summary>
            The file's path
            </summary>
        </member>
        <member name="P:Z0.ManagedDllFile.Name">
            <summary>
            The assembly name
            </summary>
        </member>
        <member name="T:Z0.ManagedExeFile">
            <summary>
            Represents a managed executable
            </summary>
        </member>
        <member name="P:Z0.ManagedExeFile.Path">
            <summary>
            The path to the represented file
            </summary>
        </member>
        <member name="P:Z0.ManagedExeFile.Name">
            <summary>
            The assembly name
            </summary>
        </member>
        <member name="T:Z0.NativeDllFile">
            <summary>
            Represents a native dll
            </summary>
        </member>
        <member name="T:Z0.NativeExeFile">
            <summary>
            Represents a native executable
            </summary>
        </member>
        <member name="T:Z0.NativeLibFile">
            <summary>
            Identifies and represents a native static library
            </summary>
        </member>
        <member name="T:Z0.PdbFile">
            <summary>
            Represents a pdb file
            </summary>
        </member>
        <member name="T:Z0.PeFile">
            <summary>
            Represents a file that conforms to the portable executable format
            </summary>
        </member>
        <member name="P:Z0.FS.FileName.Owner">
            <summary>
            Specifies the file's owning part, if any
            </summary>
        </member>
        <member name="M:Z0.FS.FileName.IsOwner(PartId)">
            <summary>
            Determines whether the name of a file is of the form {owner}.{*}
            </summary>
            <param name="host">The owner to test</param>
        </member>
        <member name="M:Z0.FS.FileName.IsHost(Z0.ApiHostUri)">
            <summary>
            Determines whether the name of a file is of the form {owner}.{host}.{*}
            </summary>
            <param name="host">The owner to test</param>
        </member>
        <member name="M:Z0.FS.FileName.EndsWith(System.String)">
            <summary>
            Determines whether the filename, including the extension, ends with a specified substring
            </summary>
            <param name="substring">The substring to match</param>
        </member>
        <member name="P:Z0.FS.FilePath.Owner">
            <summary>
            Specifies the file's owning part, if any
            </summary>
        </member>
        <member name="M:Z0.FS.FilePath.IsHost(Z0.ApiHostUri)">
            <summary>
            Determines whether the filename is of the form {owner}.{host}.{*}
            </summary>
            <param name="owner">The owner to test</param>
        </member>
        <member name="M:Z0.FS.FilePath.IsOwner(PartId)">
            <summary>
            Determines whether the filename is of the form {owner}.{.}.{*}
            </summary>
            <param name="owner">The owner to test</param>
        </member>
        <member name="M:Z0.FS.FilePath.EndsWith(System.String)">
            <summary>
            Determines whether the filename, including the extension, ends with a specified substring
            </summary>
            <param name="substring">The substring to match</param>
        </member>
        <member name="P:Z0.FS.FolderPath.AllFiles">
            <summary>
            Nonrecursively enumerates all files in the folder
            </summary>
        </member>
        <member name="M:Z0.FS.FolderPath.Files(PartId,Z0.FS.FileExt)">
            <summary>
            Nonrecursively enumerates part-owned folder files
            </summary>
            <param name="part">The owning part</param>
            <param name="ext">The extension to match</param>
        </member>
        <member name="M:Z0.FS.FolderPath.Files(Z0.ApiHostUri,Z0.FS.FileExt)">
            <summary>
            Nonrecursively enumerates host-owned folder files
            </summary>
            <param name="part">The owning part</param>
            <param name="ext">The extension to match</param>
        </member>
        <member name="P:Z0.FS.FolderPath.One">
            <summary>
            Just the one
            </summary>
        </member>
        <member name="M:Z0.FS.FolderPath.Create">
            <summary>
            Creates the represented directory in the file system if it doesn't exist
            </summary>
            <param name="dst">The target path</param>
        </member>
        <member name="P:Z0.FS.FolderPath.Exists">
            <summary>
            Specifies whether the represented directory actually exists within the file system
            </summary>
        </member>
        <member name="F:Z0.FS.PartFolderNames.test">
            <summary>
            An archive partition for files emitted during test execution
            </summary>
        </member>
        <member name="F:Z0.FS.PartFolderNames.data">
            <summary>
            An archive partition for reference data
            </summary>
        </member>
        <member name="F:Z0.FS.PartFolderNames.apps">
            <summary>
            An archive partition for application-specific data
            </summary>
        </member>
        <member name="F:Z0.FS.PartFolderNames.logs">
            <summary>
            An archive partition for application logs
            </summary>
        </member>
        <member name="F:Z0.FS.PartFolderNames.extracted">
            <summary>
            Raw/unparsed binary extracts
            </summary>
        </member>
        <member name="F:Z0.FS.PartFolderNames.parsed">
            <summary>
            Parsed binary extracts
            </summary>
        </member>
        <member name="F:Z0.FS.PartFolderNames.asm">
            <summary>
            Formatted x86 assembly
            </summary>
        </member>
        <member name="F:Z0.FS.PartFolderNames.hex">
            <summary>
            Hex formatted encoded x86 assembly
            </summary>
        </member>
        <member name="T:Z0.FS.PathPart">
            <summary>
            Defines the content of file path component
            </summary>
        </member>
        <member name="M:Z0.FS.PathPart.EndsWith(System.String)">
            <summary>
            Determines whether the filename, including the extension, ends with a specified substring
            </summary>
            <param name="substring">The substring to match</param>
        </member>
        <member name="M:Z0.FS.PathPart.EndsWith(System.Char)">
            <summary>
            Determines whether the filename, including the extension, ends with a specified substring
            </summary>
            <param name="substring">The substring to match</param>
        </member>
        <member name="T:Z0.FS.PathPartKind">
            <summary>
            Classifies <see cref='!:FilePathPart'/> components
            </summary>
        </member>
        <member name="F:Z0.FS.PathPartKind.FileName">
            <summary>
            The filename without the extension
            </summary>
        </member>
        <member name="F:Z0.FS.PathPartKind.ExtSep">
            <summary>
            The '.' delimiter between the filename and the extension
            </summary>
        </member>
        <member name="F:Z0.FS.PathPartKind.Ext">
            <summary>
            The file extension as determined by the character sequence that follows the <see cref='F:Z0.FS.PathPartKind.ExtSep'/>
            </summary>
        </member>
        <member name="F:Z0.FS.PathPartKind.FolderName">
            <summary>
            A folder name
            </summary>
        </member>
        <member name="F:Z0.FS.PathPartKind.Drive">
            <summary>
            A drive letter
            </summary>
        </member>
        <member name="M:Z0.FS.create(Z0.FS.FolderPath)">
            <summary>
            Creates the specified folder if it does not exist; if it already exists, the file system is unmodified.
            </summary>
            <param name="dst">The source path</param>
            <remarks>The operation is idempotent</remarks>
        </member>
        <member name="M:Z0.FS.delete(Z0.FS.FilePath)">
            <summary>
            Deletes the file if it exists
            </summary>
            <param name="src">The path to the file</param>
        </member>
        <member name="M:Z0.FS.delete(Z0.FS.FilePath,System.Action{System.Exception})">
            <summary>
            Deletes the file if it exists
            </summary>
            <param name="src">The path to the file</param>
        </member>
        <member name="M:Z0.FS.file(PartId,System.String,Z0.FS.FileExt)">
            <summary>
            Defines a host-specialized filename
            </summary>
            <param name="part">The owning part</param>
            <param name="hostname">The host api name</param>
            <param name="ext">The file extension</param>
        </member>
        <member name="M:Z0.FS.managed(Z0.FS.FilePath)">
            <summary>
            Returns true if a path-identified file is a managed module of some sort; otherwise, false
            </summary>
            <param name="src">The source path</param>
        </member>
        <member name="M:Z0.FS.managed(Z0.FS.FilePath,System.Reflection.AssemblyName@)">
            <summary>
            Returns true if a path-identified file is a managed module of some sort; otherwise, false
            </summary>
            <param name="src">The source path</param>
        </member>
        <member name="M:Z0.FS.managed(Z0.FS.FolderPath,System.Boolean)">
            <summary>
            Searches the source for managed modules
            </summary>
            <param name="src">The directory to search to search</param>
            <param name="dst">The buffer to populate</param>
            <param name="recurse">Specifies whether subdirectories should be searched</param>
        </member>
        <member name="M:Z0.FS.name(Z0.FS.FilePath,System.Reflection.AssemblyName@)">
            <summary>
            For a managed module, retrieves its name and returns true; otherwise, returns false
            </summary>
            <param name="src">The source path</param>
        </member>
        <member name="M:Z0.FS.native(Z0.FS.FilePath)">
            <summary>
            Determines whether a module is native (vs. managed)
            </summary>
            <param name="src"></param>
            <returns></returns>
        </member>
        <member name="M:Z0.FS.reader(Z0.FS.FilePath)">
            <summary>
            Creates a reader initialized with the source file; caller-disposal required
            </summary>
            <param name="src">The file path</param>
        </member>
        <member name="M:Z0.FS.stream(Z0.FS.FilePath,System.IO.FileMode,System.IO.FileAccess,System.IO.FileShare)">
            <summary>
            Opens a <see cref='T:System.IO.FileStream'/>
            </summary>
            <param name="path">The file path</param>
            <param name="mode">The stream mode</param>
            <param name="access">The stream access spec</param>
            <param name="share">Sharing options</param>
        </member>
        <member name="M:Z0.FS.write(System.String,System.IO.FileStream,System.Text.Encoding)">
            <summary>
            Writes text data to the target
            </summary>
            <param name="src">The source content</param>
            <param name="dst">The target stream</param>
            <param name="encoding">The encoding to use, which defaults to <see cref='P:System.Text.Encoding.UTF8'/> if unspecified</param>
        </member>
        <member name="M:Z0.FS.writer(Z0.FS.FilePath)">
            <summary>
            Creates an overwriting and caller-disposed stream writer that targets a specified path
            </summary>
            <param name="dst">The file path</param>
        </member>
        <member name="T:Z0.FileExtension">
            <summary>
            Defines a file extension
            </summary>
        </member>
        <member name="P:Z0.FileExtension.Description">
            <summary>
            Describes the sort of file identified by the extension
            </summary>
        </member>
        <member name="T:Z0.FileName">
            <summary>
            Defines a file name along with the extension in isolation
            and without ascribing additional path content
            </summary>
        </member>
        <member name="P:Z0.FileName.HasExtension">
            <summary>
            Does the file have an extension?
            </summary>
        </member>
        <member name="P:Z0.FileName.WithoutExtension">
            <summary>
            The name of the file sans extension
            </summary>
        </member>
        <member name="P:Z0.FileName.Ext">
            <summary>
            The file's extension, if any
            </summary>
        </member>
        <member name="M:Z0.FileName.WithNewName(System.String)">
            <summary>
            Renames the file (in the model, not on disk)
            </summary>
            <param name="name">The new file name</param>
        </member>
        <member name="M:Z0.FileName.Contains(System.String)">
            <summary>
            Determines whether the filename, including the extension, contains a specified substring
            </summary>
            <param name="substring">The substring to match</param>
        </member>
        <member name="M:Z0.FileName.EndsWith(System.String)">
            <summary>
            Determines whether the filename, including the extension, ends with a specified substring
            </summary>
            <param name="substring">The substring to match</param>
        </member>
        <member name="M:Z0.FileName.StartsWith(System.String)">
            <summary>
            Determines whether the filename, begins with a specified substring
            </summary>
            <param name="substring">The substring to match</param>
        </member>
        <member name="M:Z0.FileName.OwnedBy(PartId)">
            <summary>
            Dtermines whether the name of a file is of the form {owner}.{.}.{*}
            </summary>
            <param name="owner">The owner to test</param>
        </member>
        <member name="P:Z0.FileName.Owner">
            <summary>
            Specifies the file's owning part, if any
            </summary>
        </member>
        <member name="M:Z0.FileName.HostedBy(Z0.ApiHostUri)">
            <summary>
            Determines whether the name of a file is of the form {owner}.{host}.{*}
            </summary>
            <param name="host">The owner to test</param>
        </member>
        <member name="M:Z0.FileOps.CreateParent(Z0.FilePath)">
            <summary>
            Creates the containing folder if it does not exist
            </summary>
            <param name="src">The file path</param>
            <remarks>The operation is idempotent</remarks>
        </member>
        <member name="M:Z0.FileOps.create(Z0.FolderPath)">
            <summary>
            Creates the specified folder if it does not exist; if it already exists, the file system is unmodified.
            </summary>
            <param name="dst">The source path</param>
            <remarks>The operation is idempotent</remarks>
        </member>
        <member name="M:Z0.FileOps.delete(Z0.FilePath)">
            <summary>
            Deletes the file if it exists
            </summary>
            <param name="src">The path to the file</param>
        </member>
        <member name="M:Z0.FileOps.ReadBytes(Z0.FilePath)">
            <summary>
            Reads the full content of a file into a byte array
            </summary>
            <param name="src">The file path</param>
        </member>
        <member name="M:Z0.FileOps.ReadLines(Z0.FilePath)">
            <summary>
            Reads the line-partitioned content of a text file
            </summary>
            <param name="src">The file path</param>
        </member>
        <member name="M:Z0.FileOps.ReadText(Z0.FilePath)">
            <summary>
            Reads the full content of a text file
            </summary>
            <param name="src">The file path</param>
        </member>
        <member name="T:Z0.FilePath">
            <summary>
            Represents a fully-qualified path to a file on the local machine
            </summary>
        </member>
        <member name="P:Z0.FilePath.None">
            <summary>
            Lonely, so
            </summary>
        </member>
        <member name="P:Z0.FilePath.Exists">
            <summary>
            Determines whether the modeled file exists on disk
            </summary>
        </member>
        <member name="M:Z0.FilePath.OwnedBy(PartId)">
            <summary>
            Determines whether the filename is of the form {owner}.{.}.{*}
            </summary>
            <param name="owner">The owner to test</param>
        </member>
        <member name="M:Z0.FilePath.HostedBy(Z0.ApiHostUri)">
            <summary>
            Determines whether the filename is of the form {owner}.{host}.{*}
            </summary>
            <param name="owner">The owner to test</param>
        </member>
        <member name="P:Z0.FilePath.Owner">
            <summary>
            Specifies the file's owning part, if any
            </summary>
        </member>
        <member name="M:Z0.FilePath.Contains(System.String)">
            <summary>
            Determines whether the path contains a specified substring
            </summary>
            <param name="substring">The substring to match</param>
        </member>
        <member name="M:Z0.FilePath.StartsWith(System.String)">
            <summary>
            Determines whether the path begins with a specified substring
            </summary>
            <param name="substring">The substring to match</param>
        </member>
        <member name="M:Z0.FilePath.EndsWith(System.String)">
            <summary>
            Determines whether the path ends with a specified substring
            </summary>
            <param name="substring">The substring to match</param>
        </member>
        <member name="T:Z0.FileWriteMode">
            <summary>
            Defines the available stream-writer modes
            </summary>
        </member>
        <member name="T:Z0.FolderName">
            <summary>
            Defines a folder name in isolation without ascribing additional path content
            </summary>
        </member>
        <member name="P:Z0.FolderName.Description">
            <summary>
            Describes the sort of file contained by the folder
            </summary>
        </member>
        <member name="M:Z0.FolderName.Define(PartId)">
            <summary>
            Defines the name of a part-owned folder
            </summary>
            <param name="part">The owning part</param>
        </member>
        <member name="M:Z0.FolderName.Define(Z0.ApiHostUri)">
            <summary>
            Defines the name of an api host-owned folder
            </summary>
            <param name="part">The owning host</param>
        </member>
        <member name="T:Z0.FolderPath">
            <summary>
            Represents a fully-qualified path to a folder on the local machine
            </summary>
        </member>
        <member name="P:Z0.FolderPath.Name">
            <summary>
            The full path name
            </summary>
        </member>
        <member name="P:Z0.FolderPath.One">
            <summary>
            Just the one
            </summary>
        </member>
        <member name="P:Z0.FolderPath.FolderName">
            <summary>
            The name of the folder sans path
            </summary>
        </member>
        <member name="M:Z0.FolderPath.Define(System.String)">
            <summary>
            Creates a folder path directly from text, with no intervening manipulation
            </summary>
            <param name="name">The source path</param>
        </member>
        <member name="M:Z0.FolderPath.op_Addition(Z0.FolderPath,Z0.FolderName)">
            <summary>
            Combines a folder path with a subfolder name to form a new folder path
            </summary>
            <param name="path">The source path</param>
            <param name="folder">The subfolder to append</param>
        </member>
        <member name="M:Z0.FolderPath.op_Addition(Z0.FolderPath,Z0.FileName)">
            <summary>
            Combines a folder path with a filename to form a file path
            </summary>
            <param name="path">The source path</param>
            <param name="file">The file name</param>
        </member>
        <member name="P:Z0.FolderPath.Exists">
            <summary>
            Specifies whether the represented directory actually exists within the file system
            </summary>
        </member>
        <member name="P:Z0.FolderPath.SubDirs">
            <summary>
            Nonrecursively enumerates the folder's subfolders
            </summary>
        </member>
        <member name="P:Z0.FolderPath.AllFiles">
            <summary>
            Nonrecursively enumerates all files in the folder
            </summary>
        </member>
        <member name="P:Z0.FolderPath.WithoutSeparatorSuffix">
            <summary>
            The folder path sans trailing separator
            </summary>
        </member>
        <member name="M:Z0.FolderPath.Files(Z0.FileExtension)">
            <summary>
            Nonrecursively enumerates files in the directory, if it exists, that match a specified extension
            </summary>
            <param name="ext">The extension to match</param>
        </member>
        <member name="M:Z0.FolderPath.Files(PartId,Z0.FileExtension)">
            <summary>
            Nonrecursively enumerates part-owned folder files
            </summary>
            <param name="part">The owning part</param>
            <param name="ext">The extension to match</param>
        </member>
        <member name="M:Z0.FolderPath.Files(Z0.ApiHostUri,Z0.FileExtension)">
            <summary>
            Nonrecursively enumerates host-owned folder files
            </summary>
            <param name="part">The owning part</param>
            <param name="ext">The extension to match</param>
        </member>
        <member name="M:Z0.FolderPath.Files(Z0.FileExtension,System.Boolean)">
            <summary>
            Enumerates files in the folder, with optional recursion, that match a specified extension
            </summary>
            <param name="ext">The extension to match</param>
            <param name="recursive">Whether to enumerate recursively</param>
        </member>
        <member name="M:Z0.FolderPath.Files(Z0.FileName,System.Boolean)">
            <summary>
            Enumerates files in the folder, with optional recursion, that match a specified extension
            </summary>
            <param name="ext">The extension to match</param>
            <param name="recursive">Whether to enumerate recursively</param>
        </member>
        <member name="M:Z0.FolderPath.Files(PartId)">
            <summary>
            Nonrecursively enumerates folder files owned by a specified part
            </summary>
            <param name="part">The owning part</param>
        </member>
        <member name="M:Z0.FolderPath.Files(Z0.FileExtension,System.String)">
            <summary>
            Nonrecursively Enumerates folder files that match a specified extension and with names that contain a specified substring
            </summary>
            <param name="substring">The substring to match</param>
        </member>
        <member name="M:Z0.FolderPath.Files(PartId,Z0.FileExtension,System.Boolean)">
            <summary>
            Enumerates the files in the folder, with optional recursion, owned by a specified parth and which match a specified extension
            </summary>
            <param name="part">The owning part</param>
            <param name="ext">The extension to match</param>
            <param name="recursive">Whether to enumerate recursively</param>
        </member>
        <member name="M:Z0.FolderPath.Delete(System.Boolean)">
            <summary>
            Consigns the folder and its contents to oblivion
            </summary>
            <param name="recursive">How sure are you?</param>
        </member>
        <member name="M:Z0.FolderPath.Create">
            <summary>
            Creates the represented directory in the file system if it doesn't exist
            </summary>
            <param name="dst">The target path</param>
        </member>
        <member name="M:Z0.FolderPath.Clear(PartId[])">
            <summary>
            Deletes all files in the directory, but neither does it recurse nor delete folders
            </summary>
            <param name="owners">If nonempty, restricts the deletion operation to only files owned by a specified owner</param>
        </member>
        <member name="T:Z0.RelativeLocation">
            <summary>
            Represents a relative folder name
            </summary>
        </member>
        <member name="T:Z0.DriveLetter">
            <summary>
            Defines symbols for file system drive letters
            </summary>
        </member>
        <member name="T:Z0.ListedFile">
            <summary>
            Defines an entry in list of files
            </summary>
        </member>
        <member name="T:Z0.ListedFileField">
            <summary>
            Defines the fields in a <see  cref='T:Z0.ListedFile'/> table
            </summary>
        </member>
        <member name="M:Z0.XFs.Contains(Z0.FS.FilePath,System.String,System.UInt32@)">
            <summary>
            Determines whether some line of a text file contains a specified substring
            </summary>
            <param name="file">The source file</param>
            <param name="match">The substring to match</param>
            <param name="lineNumber">The line number of the first match, if found</param>
        </member>
        <member name="M:Z0.XFs.Contains(Z0.FS.FilePath,System.Func{System.String,System.Boolean},System.UInt32@)">
            <summary>
            Determines whether some line of a text file satisfies a specified predicate
            </summary>
            <param name="file">The source file</param>
            <param name="predicate">The adjudicating predicate</param>
            <param name="lineNumber">The line number of the first match, if found</param>
        </member>
        <member name="M:Z0.XFs.Delete(Z0.FS.FilePath)">
            <summary>
            Deletes the file if it exists
            </summary>
            <param name="src">The path to the file</param>
        </member>
        <member name="M:Z0.XFs.ReadText(Z0.FS.FilePath)">
            <summary>
            Reads the full content of a text file
            </summary>
            <param name="src">The file path</param>
        </member>
        <member name="M:Z0.XFs.ReadLines(Z0.FS.FilePath)">
            <summary>
            Reads the line-partitioned content of a text file
            </summary>
            <param name="src">The file path</param>
        </member>
        <member name="M:Z0.XFs.ReadBytes(Z0.FS.FilePath)">
            <summary>
            Reads the full content of a file into a byte array
            </summary>
            <param name="src">The file path</param>
        </member>
        <member name="M:Z0.XFs.Reader(Z0.FS.FilePath)">
            <summary>
            Creates a reader initialized with the source file; caller-disposal required
            </summary>
            <param name="src">The file path</param>
        </member>
        <member name="M:Z0.XFs.Writer(Z0.FS.FilePath)">
            <summary>
            Creates an overwriting and caller-disposed stream writer that targets a specified path
            </summary>
            <param name="dst">The file path</param>
        </member>
        <member name="M:Z0.GridCells.aligned(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Computes the minimum number of w-cells required to evenly cover a grid of bit-dimensions mxn
            </summary>
            <param name="w">The cellwidth</param>
            <param name="rows">The number of grid rows</param>
            <param name="cols">The number of grid columns</param>
        </member>
        <member name="M:Z0.GridCells.bytes``1(System.Int32)">
            <summary>
            Computes the number of bytes that can be covered by a specified number of cells of parametric type
            </summary>
            <param name="cells">The number of cells</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.GridCells.bytes(System.Int32,System.Int32)">
            <summary>
            Computes the number of bytes required to cover a grid, predicated on row/col counts
            </summary>
            <param name="rows">The number of grid rows</param>
            <param name="cols">The number of grid columns</param>
        </member>
        <member name="M:Z0.GridCells.bytes(System.UInt64,System.UInt64)">
            <summary>
            Computes the number of bytes required to cover a grid, predicated on row/col counts
            </summary>
            <param name="rows">The number of grid rows</param>
            <param name="cols">The number of grid columns</param>
        </member>
        <member name="M:Z0.GridCells.count(System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Computes the number of packed cells required to cover a rectangular area
            </summary>
            <param name="rows">The grid row count</param>
            <param name="cols">The grid col count</param>
            <param name="w">The storage cell width</param>
        </member>
        <member name="M:Z0.GridCells.count``1(System.UInt32,System.UInt32)">
            <summary>
            Computes the number of cells required to cover a rectangular region predicated on the
            parametric cell type and supplied row/col dimensions
            </summary>
            <param name="rows">The number of rows in the grid</param>
            <param name="cols">The number of columns in the grid</param>
            <typeparam name="T">The storage cell type</typeparam>
        </member>
        <member name="M:Z0.GridCells.count``3(``0,``1,``2)">
            <summary>
            Computes the number of segments required cover a grid as characterized by parametric type information
            </summary>
            <param name="m">The row count representative</param>
            <param name="n">The col count representative</param>
            <param name="t">The segment type zero representative</param>
            <typeparam name="M">The row type</typeparam>
            <typeparam name="N">The col type</typeparam>
            <typeparam name="T">The storage segment type</typeparam>
        </member>
        <member name="M:Z0.GridCells.dim``3(``0,``1,``2)">
            <summary>
            Computes dimension information for a grid predicated on parametric types
            </summary>
            <param name="m">The row count representative</param>
            <param name="n">The col count representative</param>
            <param name="t">The cell type representative</param>
            <typeparam name="M">The row type</typeparam>
            <typeparam name="N">The col type</typeparam>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.GridCells.grid(System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Defines a grid specification predicated on specified row count, col count and bit width
            </summary>
            <param name="rows">The number of rows in the grid</param>
            <param name="cols">The number of columns in the grid</param>
            <param name="segwidth">The width of a grid cell</param>
        </member>
        <member name="M:Z0.GridCells.grid``1(System.UInt16,System.UInt16)">
            <summary>
            Defines a grid specification predicated on specified row count, col count and bit width of a parametric type
            </summary>
            <param name="rows">The number of rows in the grid</param>
            <param name="cols">The number of columns in the grid</param>
        </member>
        <member name="M:Z0.GridCells.linear(System.Int32,System.Int32,System.Int32)">
            <summary>
            Computes the 0-based linear index determined by column width and a row/col coordinate
            </summary>
            <param name="colwidth">The bit-width of a grid column</param>
            <param name="row">The 0-based row index</param>
            <param name="col">The 0-based col index</param>
        </member>
        <member name="M:Z0.GridCells.linear``1(System.Int32,System.Int32,``0)">
            <summary>
            Computes the 0-based linear index determined by a row/col coordinate and natural column width
            </summary>
            <param name="row">The grid row</param>
            <param name="col">The grid columns</param>
            <typeparam name="N">The grid column type</typeparam>
        </member>
        <member name="M:Z0.GridCells.linear``1(System.UInt32,System.UInt32,``0)">
            <summary>
            Computes the 0-based linear index determined by a row/col coordinate and natural column width
            </summary>
            <param name="row">The grid row</param>
            <param name="col">The grid columns</param>
            <typeparam name="N">The grid column type</typeparam>
        </member>
        <member name="M:Z0.GridCells.metrics(System.Int32,System.Int32,System.Int32)">
            <summary>
            Calculates memory block statistics for specified parameters
            </summary>
            <param name="bc">The block count</param>
            <param name="bw">The block width</param>
            <param name="cw">The cell width</param>
        </member>
        <member name="M:Z0.GridCells.metrics``1(System.Int32,System.Int32)">
            <summary>
            Calculates memory block statistics for specified function and type parameters
            </summary>
            <param name="bc">The block count</param>
            <param name="bw">The block width</param>
            <typeparam name="T">The type that determines cell width</typeparam>
        </member>
        <member name="M:Z0.GridCells.metrics(Z0.GridSpec@)">
            <summary>
            Calculates a grid layout from a specification
            </summary>
            <param name="spec">The grid specification that characterizes the layout</param>
        </member>
        <member name="M:Z0.GridCells.metrics(System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Defines a grid map predicated row count, col count and storage segment bit width width
            </summary>
            <param name="rows">The number of rows in the grid</param>
            <param name="cols">The number of columns in the grid</param>
            <param name="segwidth">The width of a grid cell</param>
        </member>
        <member name="M:Z0.GridCells.metrics``1(System.UInt16,System.UInt16)">
            <summary>
            Defines a grid map predicated row count, col count and the bit width of parametric type
            </summary>
            <param name="rows">The number of rows in the grid</param>
            <param name="cols">The number of columns in the grid</param>
        </member>
        <member name="M:Z0.GridCells.metrics``2(System.Int32,``0,``1)">
            <summary>
            Calculates memory block statistics for specified function and type parameters
            </summary>
            <param name="bc">The block count</param>
            <param name="bw">The block width representative</param>
            <param name="t">The block cell type representative</param>
            <typeparam name="N">The type that dermines block width</typeparam>
            <typeparam name="T">The type that determines cell width</typeparam>
        </member>
        <member name="M:Z0.GridCells.metrics``3(``0,``1,``2)">
            <summary>
            Defines a grid map predicated on type parameters
            </summary>
            <param name="RowCount">The number of rows in the grid</param>
            <param name="ColCount">The number of columns in the grid</param>
            <param name="CellWidth">The width of a grid cell</param>
            <typeparam name="T">The storage segment type</typeparam>
        </member>
        <member name="M:Z0.GridCells.minbytes(System.Int32)">
            <summary>
            Computes the minimum number of bytes required to cover a specified number of bits
            </summary>
            <param name="bits">The number of bits for which storage is required</param>
        </member>
        <member name="M:Z0.GridCells.mincells(System.UInt64,System.UInt64)">
            <summary>
            Computes the minimum number of cells required to store a specified number of bits
            </summary>
            <param name="w">The cell width</param>
            <param name="n">The bit count/number of matrix columns</param>
        </member>
        <member name="M:Z0.GridCells.mincells``1(System.UInt64)">
            <summary>
            Computes the minimum number of cells required to store data of a given bit width
            </summary>
            <param name="bc">The number of bits for which storage is required</param>
            <typeparam name="T">The storage cell type</typeparam>
        </member>
        <member name="M:Z0.GridCells.minimum``2(``0,``1)">
            <summary>
            Computes the minimum number of T-cells required to store N bits
            </summary>
            <param name="n">The bit count representative</param>
            <param name="t">A cell type representative</param>
            <typeparam name="N">The bit count type</typeparam>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.GridCells.tablesize(System.Int32,System.Int32)">
            <summary>
            Computes the number of bytes required to cover a grid, predicated on row/col counts
            </summary>
            <param name="rows">The number of grid rows</param>
            <param name="cols">The number of grid columns</param>
        </member>
        <member name="M:Z0.GridCells.tablesize``2(``0,``1)">
            <summary>
            Computes the number of bytes required to cover a rectangular area, predicated on natural row/col counts
            </summary>
            <param name="m">The row count representative</param>
            <param name="n">The col count representative</param>
            <typeparam name="M">The row type</typeparam>
            <typeparam name="N">The col type</typeparam>
        </member>
        <member name="M:Z0.GridCells.tablebits``2(``0,``1)">
            <summary>
            Computes the number of bits covered by a rectangular region and predicated on natural dimensions
            </summary>
            <param name="rows">The grid row count</param>
            <param name="cols">The grid col count</param>
        </member>
        <member name="M:Z0.GridMetrics.aligned``1(Z0.GridMetrics@,``0)">
            <summary>
            Determines whether grid storage is N-bit aligned
            </summary>
            <param name="src">The source specifier</param>
            <param name="w">A width-type representative</param>
            <typeparam name="N">The bit type</typeparam>
        </member>
        <member name="M:Z0.GridMetrics.aligned(Z0.GridMetrics@,Z0.DataWidth)">
            <summary>
            Determines whether grid storage is data width-aligned
            </summary>
            <param name="src">The source specifier</param>
            <param name="w">A width-type representative</param>
        </member>
        <member name="M:Z0.GridMetrics.aligned(Z0.GridMetrics@,Z0.NumericKind)">
            <summary>
            Determines whether grid storage is aligned with that of a specified numeric kind
            </summary>
            <param name="src">The source specifier</param>
            <param name="w">A width-type representative</param>
            <typeparam name="W">The bit-width type</typeparam>
        </member>
        <member name="M:Z0.GridMetrics.linear(Z0.GridMetrics@,System.Int32,System.Int32)">
            <summary>
            Computes the 0-based linear index determined by a row/col coordinate
            </summary>
            <param name="row">The 0-based row index</param>
            <param name="col">The 0-based col index</param>
        </member>
        <member name="M:Z0.GridMetrics.offset(Z0.GridMetrics@,System.Int32,System.Int32)">
            <summary>
            Computes the storage segment offset for a row/col coordinate
            </summary>
            <param name="row">The 0-based row index</param>
            <param name="col">The 0-based col index</param>
        </member>
        <member name="M:Z0.GridMetrics.seg(Z0.GridMetrics@,System.Int32,System.Int32)">
            <summary>
            Computes the storage segment that covers a specifed row/col coordinate
            </summary>
            <param name="row">The 0-based row index</param>
            <param name="col">The 0-based col index</param>
        </member>
        <member name="F:Z0.GridMetrics.RowCount">
            <summary>
            The number of rows in the layout
            </summary>
        </member>
        <member name="F:Z0.GridMetrics.ColCount">
            <summary>
            The number of columns in the layout
            </summary>
        </member>
        <member name="F:Z0.GridMetrics.CellWidth">
            <summary>
            The number of bits in a segment
            </summary>
        </member>
        <member name="F:Z0.GridMetrics.CellCount">
            <summary>
            The number of segment-aligned storage segments
            </summary>
        </member>
        <member name="F:Z0.GridMetrics.StoreWidth">
            <summary>
            The number of segment-aligned bits required for storage
            </summary>
        </member>
        <member name="F:Z0.GridMetrics.StoreSize">
            <summary>
            The number of segment-aligned bytes bits required for storage
            </summary>
        </member>
        <member name="M:Z0.GridMetrics.Position(System.Int32,System.Int32)">
            <summary>
            Computes the 0-based linear index determined by a row/col coordinate
            </summary>
            <param name="row">The 0-based row index</param>
            <param name="col">The 0-based col index</param>
        </member>
        <member name="P:Z0.GridMetrics.Item(System.Int32,System.Int32)">
            <summary>
            Computes the 0-based linear index determined by a row/col coordinate
            </summary>
            <param name="row">The 0-based row index</param>
            <param name="col">The 0-based col index</param>
        </member>
        <member name="T:Z0.GridCell`2">
            <summary>
            Defines a K-indexed T-cell
            </summary>
        </member>
        <member name="T:Z0.GridCell`3">
            <summary>
            Defines an MxN indexed T-cell
            </summary>
        </member>
        <member name="T:Z0.GridCellMetrics">
            <summary>
            Captures memory block statistics
            </summary>
        </member>
        <member name="F:Z0.GridCellMetrics.BlockCount">
            <summary>
            The number of blocks being described
            </summary>
        </member>
        <member name="F:Z0.GridCellMetrics.BlockWidth">
            <summary>
            The bit-width of a block
            </summary>
        </member>
        <member name="F:Z0.GridCellMetrics.CellWidth">
            <summary>
            The bit-width of a cell
            </summary>
        </member>
        <member name="F:Z0.GridCellMetrics.BlockLength">
            <summary>
            The number of cells in a block
            </summary>
        </member>
        <member name="F:Z0.GridCellMetrics.CellCount">
            <summary>
            The total number of covered cells
            </summary>
        </member>
        <member name="P:Z0.GridCellMetrics.BitCount">
            <summary>
            The total number of covered bits
            </summary>
        </member>
        <member name="T:Z0.GridCellMetrics`2">
            <summary>
            Captures memory block statistics for blocks of natural width N over generic T-cells
            </summary>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="F:Z0.GridCellMetrics`2.BlockCount">
            <summary>
            The number of blocks being described
            </summary>
        </member>
        <member name="F:Z0.GridCellMetrics`2.BlockWidth">
            <summary>
            The bit-width of a block
            </summary>
        </member>
        <member name="F:Z0.GridCellMetrics`2.CellWidth">
            <summary>
            The bit-width of a cell
            </summary>
        </member>
        <member name="F:Z0.GridCellMetrics`2.BlockLength">
            <summary>
            The number of cells in a block
            </summary>
        </member>
        <member name="F:Z0.GridCellMetrics`2.CellCount">
            <summary>
            The total number of covered cells
            </summary>
        </member>
        <member name="P:Z0.GridCellMetrics`2.BitCount">
            <summary>
            The total number of covered bits
            </summary>
        </member>
        <member name="T:Z0.GridCellMetrics`1">
            <summary>
            Captures statistics for memory blocks over generic T-cells
            </summary>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="F:Z0.GridCellMetrics`1.BlockCount">
            <summary>
            The number of blocks being described
            </summary>
        </member>
        <member name="F:Z0.GridCellMetrics`1.BlockWidth">
            <summary>
            The bit-width of a block
            </summary>
        </member>
        <member name="F:Z0.GridCellMetrics`1.CellWidth">
            <summary>
            The bit-width of a cell
            </summary>
        </member>
        <member name="F:Z0.GridCellMetrics`1.BlockLength">
            <summary>
            The number of cells in a block
            </summary>
        </member>
        <member name="F:Z0.GridCellMetrics`1.CellCount">
            <summary>
            The total number of covered cells
            </summary>
        </member>
        <member name="P:Z0.GridCellMetrics`1.BitCount">
            <summary>
            The total number of covered bits
            </summary>
        </member>
        <member name="T:Z0.GridDim">
            <summary>
            Defines grid dimensions based on specification without parametrization
            </summary>
        </member>
        <member name="F:Z0.GridDim.RowCount">
            <summary>
            The number of grid rows
            </summary>
        </member>
        <member name="F:Z0.GridDim.ColCount">
            <summary>
            The number of grid columns
            </summary>
        </member>
        <member name="M:Z0.GridDim.Format">
            <summary>
            Formats the dimension in canonical form
            </summary>
        </member>
        <member name="T:Z0.GridDim`3">
            <summary>
            Encapsulates metrics that characterize a grid of natural rectangular dimensions
            </summary>
        </member>
        <member name="P:Z0.GridDim`3.BitCount">
            <summary>
            The total number gb of grid bits determined by gb := MxN
            </summary>
        </member>
        <member name="P:Z0.GridDim`3.RowCount">
            <summary>
            The number of grid rows
            </summary>
        </member>
        <member name="P:Z0.GridDim`3.ColCount">
            <summary>
            The number of grid columns
            </summary>
        </member>
        <member name="P:Z0.GridDim`3.CellWidth">
            <summary>
            The bit width of a storage cell
            </summary>
        </member>
        <member name="P:Z0.GridDim`3.BlockWidth">
            <summary>
            The bit width of a storage block
            </summary>
        </member>
        <member name="P:Z0.GridDim`3.CellCount">
            <summary>
            The number of cells required cover a grid
            </summary>
        </member>
        <member name="P:Z0.GridDim`3.ByteCount">
            <summary>
            The number of bytes required to cover a grid
            </summary>
        </member>
        <member name="M:Z0.GridDim`3.Format">
            <summary>
            Returns a dimension expression of the form RxCxWw where
            R := row count
            C := column count
            W := cell width
            </summary>
        </member>
        <member name="F:Z0.GridSegment`1.RowCount">
            <summary>
            The number of rows in the grid
            </summary>
        </member>
        <member name="F:Z0.GridSegment`1.ColCount">
            <summary>
            The number of columns in the grid
            </summary>
        </member>
        <member name="F:Z0.GridSegment`1.CellWidth">
            <summary>
            The bit-width of a grid cell
            </summary>
        </member>
        <member name="F:Z0.GridSegment`1.SegWidth">
            <summary>
            The bit-width of a segment that covers one or more cells
            </summary>
        </member>
        <member name="M:Z0.GridSegment`1.Format">
            <summary>
            Returns a dimension expression of the form RxCxWw where
            R := row count
            C := column count
            W := cell width
            </summary>
        </member>
        <member name="T:Z0.GridSpec">
            <summary>
            Characterizes the memory layout of a 2-d grid
            </summary>
        </member>
        <member name="F:Z0.GridSpec.RowCount">
            <summary>
            The number of grid rows
            </summary>
        </member>
        <member name="F:Z0.GridSpec.ColCount">
            <summary>
            The number of grid columns
            </summary>
        </member>
        <member name="F:Z0.GridSpec.CellWidth">
            <summary>
            The number of bits in a storage cell
            </summary>
        </member>
        <member name="F:Z0.GridSpec.CellCount">
            <summary>
            The the total number of allocated storage cells
            </summary>
        </member>
        <member name="F:Z0.GridSpec.StoreWidth">
            <summary>
            The the total number of segment-aligned bits allocated for storage
            </summary>
        </member>
        <member name="F:Z0.GridSpec.StoreSize">
            <summary>
            The the total number of segment-aligned bytes allocated for storage
            </summary>
        </member>
        <member name="F:Z0.GridStorage.Bits">
            <summary>
            The the total number of segment-aligned bits allocated for storage
            </summary>
        </member>
        <member name="F:Z0.GridStorage.Segments">
            <summary>
            The the total number of segments allocated for storage
            </summary>
        </member>
        <member name="P:Z0.GridStorage.Bytes">
            <summary>
            The the total number of segment-aligned bytes allocated for storage
            </summary>
        </member>
        <member name="P:Z0.IInterval.LeftClosed">
            <summary>
             Specifies whether the interval contains its left endpoint
            </summary>
        </member>
        <member name="P:Z0.IInterval.RightClosed">
            <summary>
             Specifies whether the interval contains its right endpoint
            </summary>
        </member>
        <member name="P:Z0.IInterval.Kind">
            <summary>
            The interval classification
            </summary>
        </member>
        <member name="P:Z0.IInterval.Width">
            <summary>
            The interval width
            </summary>
        </member>
        <member name="P:Z0.IInterval.Closed">
            <summary>
             Specifies whether the interval is closed
            </summary>
        </member>
        <member name="P:Z0.IInterval.Open">
            <summary>
             Specifies whether the interval is open
            </summary>
        </member>
        <member name="P:Z0.IInterval.RightOpen">
            <summary>
            Specifies whether the interval is open on the right and closed on the left, denoted by [Left,Right)
            </summary>
        </member>
        <member name="P:Z0.IInterval.LeftOpen">
            <summary>
            Specifies whether the interval is open on the left and closed on the right, denoted by (Left,Right]
            </summary>
        </member>
        <member name="M:Z0.IInterval`2.ToOpen">
            <summary>
            Creates an open interval with endpoints from the existing interval
            </summary>
        </member>
        <member name="M:Z0.IInterval`2.ToLeftOpen">
            <summary>
            Creates a left-open/right-closed interval with endpoints from the existing interval
            </summary>
        </member>
        <member name="M:Z0.IInterval`2.ToRightClosed">
            <summary>
            Creates a left-open/right-closed interval with endpoints from the existing interval
            </summary>
        </member>
        <member name="M:Z0.IInterval`2.ToRightOpen">
            <summary>
            Creates a left-open/right-closed interval with endpoints from the existing interval
            </summary>
        </member>
        <member name="M:Z0.IInterval`2.ToLeftClosed">
            <summary>
            Creates a left-closed interval with endpoints from the existing interval
            </summary>
        </member>
        <member name="M:Z0.IInterval`2.ToClosed">
            <summary>
            Creates a closed interval with endpoints from the existing interval
            </summary>
        </member>
        <member name="T:Z0.IInterval`1">
            <summary>
            Characterizes a contiguous segment of homogenous values that lie within
            left and right boundaries 
            </summary>
            <remarks>
            Note that extended real numbers may also serve as endpoints,enabling representations such as (-,3] and (-3, ).
            </remarks>
        </member>
        <member name="P:Z0.IInterval`1.Left">
            <summary>
             The left endpoint
            </summary>
        </member>
        <member name="P:Z0.IInterval`1.Right">
            <summary>
             The right endpoint
            </summary>
        </member>
        <member name="T:Z0.Interval">
            <summary>
            Defines interval manipulation api
            </summary>
        </member>
        <member name="M:Z0.Interval.open``1(``0,``0)">
            <summary>
            Defines an open interval (min,max)
            </summary>
            <param name="min">The exclusive left endpoint</param>
            <param name="max">The exclusive right endpoint</param>
            <typeparam name="T">The numeric type over which the interval is defined</typeparam>
        </member>
        <member name="M:Z0.Interval.closed``1(``0,``0)">
            <summary>
            Defines a closed interval [min,max]
            </summary>
            <param name="min">The inclusive left endpoint</param>
            <param name="max">The inclusive right endpoint</param>
            <typeparam name="T">The numeric type over which the interval is defined</typeparam>
        </member>
        <member name="M:Z0.Interval.closedL``1(``0,``0)">
            <summary>
            Constructs the (left-closed | right-open) interval [min,max)
            </summary>
            <param name="min">The inclusive left endpoint</param>
            <param name="max">The exclusive right endpoint</param>
            <typeparam name="T">The underlying type</typeparam>
        </member>
        <member name="M:Z0.Interval.closedR``1(``0,``0)">
            <summary>
            Constructs the (left-closed | right-open) interval [min,max)
            </summary>
            <param name="min">The inclusive left endpoint</param>
            <param name="max">The exclusive right endpoint</param>
            <typeparam name="T">The underlying type</typeparam>
        </member>
        <member name="M:Z0.Interval.define``1(``0,``0,Z0.IntervalKind)">
            <summary>
            Defines an interval of specified sort
            </summary>
            <param name="min">The left endpoint</param>
            <param name="max">The right endpoint</param>
            <param name="kind">The interval kind</param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Z0.Intervals.partition(Z0.ClosedInterval{System.UInt64}@,System.UInt64)">
            <summary>
            Computes the points that determine a partitioning predicated on partition width
            </summary>
            <param name="src">The source interval</param>
            <param name="width">The partition width</param>
        </member>
        <member name="M:Z0.Intervals.partition(System.UInt64,System.UInt64,System.UInt64,System.UInt64[])">
            <summary>
            Computes a sequence of points that partitions an integral range
            </summary>
            <param name="min">The lower bound</param>
            <param name="min">The upper bound</param>
            <param name="width">The partition width</param>
            <param name="dst">The target buffer</param>
        </member>
        <member name="M:Z0.Intervals.bin``1(Z0.ClosedInterval{``0}@,System.UInt32)">
            <summary>
            Creates a bin over a closed interval partitioned into a specified number of segments
            </summary>
            <param name="src">The source interval</param>
            <param name="count">The partition count</param>
            <typeparam name="T">The interval domain</typeparam>
        </member>
        <member name="M:Z0.Intervals.bounds``1(Z0.Histogram{``0}@)">
            <summary>
            Computes the smallest/greatest bin counts
            </summary>
        </member>
        <member name="M:Z0.Intervals.bucket``1(Z0.Histogram{``0}@,``0)">
            <summary>
            Searches for the bucket containing the point; if found, returns the bucket index; otherwise returns a failure code
            </summary>
            <param name="src">The histogram to search</param>
            <param name="point">A point contained in some bucket, hopefully </param>
            <typeparam name="T">The point domain</typeparam>
        </member>
        <member name="M:Z0.Intervals.buckets``1(Z0.Histogram{``0}@)">
            <summary>
            Presents the histogram state as a sequence of buckets
            </summary>
            <param name="src">The histogram to query</param>
            <typeparam name="T">The point domain</typeparam>
        </member>
        <member name="M:Z0.Intervals.closed``1(``0,``0)">
            <summary>
            Defines a closed interval
            </summary>
            <param name="min">The inclusive lower bound</param>
            <param name="max">The inclusive upper bound</param>
            <typeparam name="T">The interval domain</typeparam>
        </member>
        <member name="M:Z0.Intervals.contains``1(Z0.ClosedInterval{``0}@,``0)">
            <summary>
            Determines whether the source interval contains a specified test point
            </summary>
            <param name="src">The source interval</param>
            <param name="x">The point to test</param>
            <typeparam name="T">The interval domain</typeparam>
        </member>
        <member name="M:Z0.Intervals.count``1(Z0.Histogram{``0}@,System.UInt32)">
            <summary>
            Findes the number of items in an index-identified bucket
            </summary>
            <param name="src">The histogram to query</param>
            <param name="index">THe bucket index</param>
            <typeparam name="T">The point domain</typeparam>
        </member>
        <member name="M:Z0.Intervals.deposit``1(System.ReadOnlySpan{``0},Z0.Histogram{``0}@)">
            <summary>
            Deposits each source point, when possible, into some histogram bucket
            </summary>
            <param name="src">The point source</param>
            <param name="dst">The target histogram</param>
            <typeparam name="T">The point domain</typeparam>
        </member>
        <member name="M:Z0.Intervals.deposit``1(``0[],Z0.Histogram{``0}@)">
            <summary>
            Distribute an index of values to the histogram
            </summary>
            <param name="value">The source value</param>
        </member>
        <member name="M:Z0.Intervals.deposit``1(``0,Z0.Histogram{``0}@,System.Action{``0})">
            <summary>
            Deposits a point, if possible, into a histogram bucket
            </summary>
            <param name="src">The point one would like to deposit</param>
            <param name="dst">The target histogram</param>
            <param name="undeposited">If specified, invoked whenever a bucket can't be found</param>
            <typeparam name="T">The point domain</typeparam>
        </member>
        <member name="M:Z0.Intervals.partition``1(Z0.ClosedInterval{``0}@,``0)">
            <summary>
            Cleaves a closed interval over an intergral domain into manageable disjoint pieces
            </summary>
            <param name="src">The source interval</param>
            <param name="width">The partition width</param>
            <typeparam name="T">The integer type, at most 64-bits wide</typeparam>
        </member>
        <member name="M:Z0.Intervals.segment``1(Z0.Histogram{``0}@,System.UInt32)">
            <summary>
            Presents an index-identifeid histogram bucket as an interval
            </summary>
            <param name="src">The histogram to search</param>
            <param name="index">THe bucket index</param>
            <typeparam name="T">The point domain</typeparam>
        </member>
        <member name="M:Z0.Intervals.unit``1(``0)">
            <summary>
            Defines the unit interval over a parametric domain
            </summary>
            <param name="t">A representative used only for type inference</param>
            <typeparam name="T">The interval domain</typeparam>
        </member>
        <member name="T:Z0.Bin`1">
            <summary>
            Represents one or more occurrence of a value within an interval
            </summary>
            <typeparam name="T">The value domain</typeparam>
        </member>
        <member name="T:Z0.ClosedInterval`1">
            <summary>
            Defines a closed T-interval  where an ordering on T is assumed to exist and be well-defined
            </summary>
        </member>
        <member name="F:Z0.ClosedInterval`1.Min">
            <summary>
            The left endpoint
            </summary>
        </member>
        <member name="F:Z0.ClosedInterval`1.Max">
            <summary>
            The right endpoint
            </summary>
        </member>
        <member name="P:Z0.ClosedInterval`1.Degenerate">
            <summary>
            Specifies whether the left and right endpoints are the same
            </summary>
        </member>
        <member name="P:Z0.ClosedInterval`1.IsEmpty">
            <summary>
            Specifies whether the interval is the zero interval
            </summary>
        </member>
        <member name="M:Z0.ClosedInterval`1.Convert``1">
            <summary>
            Converts the left and right underlying values
            </summary>
            <typeparam name="U">The target type</typeparam>
        </member>
        <member name="M:Z0.ClosedInterval`1.As``1">
            <summary>
            Creates a view of the data in the interval as seen through the
            lens of another type, but performs no conversion
            </summary>
            <typeparam name="U">The target type</typeparam>
        </member>
        <member name="P:Z0.ClosedInterval`1.Z0#IInterval#Kind">
            <summary>
            The interval classification
            </summary>
        </member>
        <member name="P:Z0.ClosedInterval`1.Empty">
            <summary>
            The interval of nothingness
            </summary>
        </member>
        <member name="T:Z0.Interval`1">
            <summary>
            Defines a contiguous segment of homogenous values that lie within left and right boundaries
            </summary>
            <remarks>
            Note that models of extended real numbers may also serve as endpoints, enabling representations such as (-,3] and (-3, ).
            </remarks>
        </member>
        <member name="F:Z0.Interval`1.Left">
            <summary>
            The left endpoint
            </summary>
        </member>
        <member name="F:Z0.Interval`1.Right">
            <summary>
            The right endpoint
            </summary>
        </member>
        <member name="P:Z0.Interval`1.Kind">
            <summary>
            The interval classification
            </summary>
        </member>
        <member name="P:Z0.Interval`1.U01">
            <summary>
            Specifies the canonical closed unit interval over the underlying primitive
            </summary>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="P:Z0.Interval`1.Full">
            <summary>
            Defines a closed interval that subsumes all points representable by the primal type
            </summary>
        </member>
        <member name="P:Z0.Interval`1.Unbound">
            <summary>
            Defines an open interval that subsumes all points representable by the primal type and all points represented
            by increasing the size of the primal type without altering other characteristics
            </summary>
        </member>
        <member name="P:Z0.Interval`1.LeftClosed">
            <summary>
            Specifies whether the interval is left-closed, or equivalently right-open, denoted by [Left,Right),
            </summary>
        </member>
        <member name="P:Z0.Interval`1.RightClosed">
            <summary>
            Specifies whether the interval is right-closed, or equivalently left-open, denoted by (Left,Right],
            </summary>
        </member>
        <member name="P:Z0.Interval`1.Open">
            <summary>
            Specifies whether the interval is open, denoted by (Left,Right)
            </summary>
        </member>
        <member name="P:Z0.Interval`1.Closed">
            <summary>
            Specifies whether the interval is closed, denoted by [Left,Right]
            </summary>
        </member>
        <member name="P:Z0.Interval`1.RightOpen">
            <summary>
            Specifies whether the interval is open on the right and closed on the left, denoted by [Left,Right)
            </summary>
        </member>
        <member name="P:Z0.Interval`1.LeftOpen">
            <summary>
            Specifies whether the interval is open on the left and closed on the right, denoted by (Left,Right]
            </summary>
        </member>
        <member name="P:Z0.Interval`1.LeftUnbounded">
            <summary>
            Specifies whether the interval is unbounded on the left, denoted by (-, right).
            </summary>
        </member>
        <member name="P:Z0.Interval`1.RightUnbounded">
            <summary>
            Specifies whether the interval is unbounded on the left, denoted by (left, ).
            </summary>
        </member>
        <member name="P:Z0.Interval`1.Unbounded">
            <summary>
            Specifies whether the interval is unbounded on the left and right, denoted by (-, ).
            </summary>
        </member>
        <member name="P:Z0.Interval`1.Degenerate">
            <summary>
            Specifies whether the left and right enpoints are the same
            </summary>
        </member>
        <member name="P:Z0.Interval`1.IsEmpty">
            <summary>
            Specifies whether the interval is the zero interval
            </summary>
        </member>
        <member name="P:Z0.Interval`1.Zero">
            <summary>
            Specifies the zero interval
            </summary>
        </member>
        <member name="M:Z0.Interval`1.ToOpen">
            <summary>
            Creates an open interval with endpoints from the existing interval
            </summary>
        </member>
        <member name="M:Z0.Interval`1.ToLeftOpen">
            <summary>
            Creates a left-open/right-closed interval with endpoints from the existing interval
            </summary>
        </member>
        <member name="M:Z0.Interval`1.ToRightClosed">
            <summary>
            Creates a left-open/right-closed interval with endpoints from the existing interval
            </summary>
        </member>
        <member name="M:Z0.Interval`1.ToRightOpen">
            <summary>
            Creates a left-open/right-closed interval with endpoints from the existing interval
            </summary>
        </member>
        <member name="M:Z0.Interval`1.ToLeftClosed">
            <summary>
            Creates a left-closed interval with endpoints from the existing interval
            </summary>
        </member>
        <member name="M:Z0.Interval`1.ToClosed">
            <summary>
            Creates a closed interval with endpoints from the existing interval
            </summary>
        </member>
        <member name="M:Z0.Interval`1.Convert``1">
            <summary>
            Converts the left and right underlying values
            </summary>
            <typeparam name="U">The target type</typeparam>
        </member>
        <member name="M:Z0.Interval`1.As``1">
            <summary>
            Creates a view of the data in the inverval as seen through the
            lens of another type, but performs no conversion
            </summary>
            <typeparam name="U">The target type</typeparam>
        </member>
        <member name="P:Z0.Interval`1.Empty">
            <summary>
            The interval of nothingness
            </summary>
        </member>
        <member name="T:Z0.IntervalKind">
            <summary>
            Defines interval classifications predicated on endpoint containment
            </summary>
        </member>
        <member name="T:Z0.Ratio`1">
            <summary>
            Defines a ratio between two values, a measure that indicates how many times the first number contains the second
            </summary>
            <remarks>See https://en.wikipedia.org/wiki/Ratio</remarks>
        </member>
        <member name="F:Z0.Ratio`1.A">
            <summary>
            The left value
            </summary>
        </member>
        <member name="F:Z0.Ratio`1.B">
            <summary>
            The right value
            </summary>
        </member>
        <member name="T:Z0.U01`1">
            <summary>
            Defines a unit interval
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit0">
            <summary>
            Identifies term 0 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit1">
            <summary>
            Identifies term 1 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit2">
            <summary>
            Identifies term 2 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit3">
            <summary>
            Identifies term 3 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit4">
            <summary>
            Identifies term 4 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit5">
            <summary>
            Identifies term 6 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit6">
            <summary>
            Identifies term 6 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit7">
            <summary>
            Identifies term 7 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit8">
            <summary>
            Identifies term 8 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit9">
            <summary>
            Identifies term 9 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit10">
            <summary>
            Identifies term 10 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit11">
            <summary>
            Identifies term 11 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit12">
            <summary>
            Identifies term 12 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit13">
            <summary>
            Identifies term 13 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit14">
            <summary>
            Identifies term 14 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit15">
            <summary>
            Identifies term 15 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit16">
            <summary>
            Identifies term 16 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit17">
            <summary>
            Identifies term 17 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit18">
            <summary>
            Identifies term 18 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit19">
            <summary>
            Identifies term 19 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit20">
            <summary>
            Identifies term 20 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit21">
            <summary>
            Identifies term 21 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit22">
            <summary>
            Identifies term 22 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit23">
            <summary>
            Identifies term 23 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit24">
            <summary>
            Identifies term 24 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit25">
            <summary>
            Identifies term 25 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit26">
            <summary>
            Identifies term 26 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit27">
            <summary>
            Identifies term 27 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit28">
            <summary>
            Identifies term 28 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit29">
            <summary>
            Identifies term 29 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit30">
            <summary>
            Identifies term 30 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit31">
            <summary>
            Identifies term 31 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit32">
            <summary>
            Identifies term 33 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit33">
            <summary>
            Identifies term 33 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit34">
            <summary>
            Identifies term 34 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit35">
            <summary>
            Identifies term 35 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit36">
            <summary>
            Identifies term 36 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit37">
            <summary>
            Identifies term 37 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit38">
            <summary>
            Identifies term 38 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit39">
            <summary>
            Identifies term 39 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit40">
            <summary>
            Identifies term 40 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit41">
            <summary>
            Identifies term 41 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit42">
            <summary>
            Identifies term 44 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit43">
            <summary>
            Identifies term 44 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit44">
            <summary>
            Identifies term 44 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit45">
            <summary>
            Identifies term 45 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit46">
            <summary>
            Identifies term 46 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit47">
            <summary>
            Identifies term 47 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit48">
            <summary>
            Identifies term 48 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Bit49">
            <summary>
            Identifies term 49 of a bit sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.StdCall">
            <summary>
            Specifies the <see cref='F:System.Runtime.InteropServices.CallingConvention.StdCall'/> calling convention where the
            callee is responsible for stack management
            </summary>
            <remarks>
            This is the default PInvoke convention
            </remarks>
        </member>
        <member name="F:Z0.Konst.Cdecl">
            <summary>
            Specifies the <see cref='F:System.Runtime.InteropServices.CallingConvention.Cdecl'/> calling convention where the caller
            is responsible for stack management
            </summary>
            <remarks>
            According to the runtime documentation, "This enables calling functions with varargs, which
            makes it appropriate to use for methods that accept a variable number of parameters,
            such as Printf".
            </remarks>
        </member>
        <member name="F:Z0.Konst.ThisCall">
            <summary>
            Specifies the <see cref='F:System.Runtime.InteropServices.CallingConvention.ThisCall'/> calling convention where first argument is <see cref='!:this'/>
            and is placed in ECX/RCX
            </summary>
        </member>
        <member name="F:Z0.Konst.ItemDelimiter">
            <summary>
            The default item list delimiter
            </summary>
        </member>
        <member name="F:Z0.Konst.LabelDelimiter">
            <summary>
            The default label delimiter
            </summary>
        </member>
        <member name="F:Z0.Konst.HexDelimiter">
            <summary>
            The default hex value delimiter
            </summary>
        </member>
        <member name="P:Z0.Konst.EmptyType">
            <summary>
            A type considered to be empty
            </summary>
        </member>
        <member name="P:Z0.Konst.UpperCase">
            <summary>
            Uppercase letter classifier accessor
            </summary>
        </member>
        <member name="P:Z0.Konst.LowerCase">
            <summary>
            Lowercase letter classifier accessor
            </summary>
        </member>
        <member name="P:Z0.Konst.Letter">
            <summary>
            Letter classifier accessor
            </summary>
        </member>
        <member name="P:Z0.Konst.Number">
            <summary>
            Number classifier accessor
            </summary>
        </member>
        <member name="F:Z0.Konst.NoCase">
            <summary>
            An abbreviation for the ridiculously long "StringComparison.InvariantCultureIgnoreCase"
            </summary>
        </member>
        <member name="F:Z0.Konst.Cased">
            <summary>
            An abbreviation for the somewhat verbose "StringComparison.InvariantCulture"
            </summary>
        </member>
        <member name="F:Z0.Konst.WidthOffset">
            <summary>
            The number of bits to shift a field specifier left/right to reveal/specify the width of an identified field
            </summary>
        </member>
        <member name="F:Z0.Konst.FieldDelimiter">
            <summary>
            The default delimiter to use when formatting structured text
            </summary>
        </member>
        <member name="F:Z0.Konst.NestedLeftFence">
            <summary>
            The default left subfield delimiter
            </summary>
        </member>
        <member name="F:Z0.Konst.NestedRightFence">
            <summary>
            The default right subfield delimiter
            </summary>
        </member>
        <member name="F:Z0.Konst.EmptyString">
            <summary>
            What else could this be?
            </summary>
        </member>
        <member name="F:Z0.Konst.Space">
            <summary>
            What else could this be?
            </summary>
        </member>
        <member name="F:Z0.Konst.Eol">
            <summary>
            The end-of-line escape sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.RBrace">
            <summary>
            The '{' character
            </summary>
        </member>
        <member name="F:Z0.Konst.LBrace">
            <summary>
            The '}' character
            </summary>
        </member>
        <member name="F:Z0.Konst.Colon">
            <summary>
            The ':' character
            </summary>
        </member>
        <member name="F:Z0.Konst.Semicolon">
            <summary>
            The ':' character
            </summary>
        </member>
        <member name="F:Z0.Konst.Overwrite">
            <summary>
            Indicates that emitted content should overwrite whatever file content may exist
            </summary>
        </member>
        <member name="F:Z0.Konst.Append">
            <summary>
            Indicates that emitted content should be appended to a file, rather than replacing a file
            </summary>
        </member>
        <member name="F:Z0.Konst.NotFound">
            <summary>
            Canonical return value for search operation that returns a nonnegative value upon success
            </summary>
        </member>
        <member name="F:Z0.Konst.AsciArrow">
            <summary>
            The "->" character sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Define">
            <summary>
            The ":=" character sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.SpacePipe">
            <summary>
            The " | " character sequence
            </summary>
        </member>
        <member name="P:Z0.Konst.base2">
            <summary>
            Species the base2 singleton representative
            </summary>
        </member>
        <member name="P:Z0.Konst.base3">
            <summary>
            Species the base8 singleton representative
            </summary>
        </member>
        <member name="P:Z0.Konst.base8">
            <summary>
            Species the base8 singleton representative
            </summary>
        </member>
        <member name="P:Z0.Konst.base10">
            <summary>
            Species the base10 singleton representative
            </summary>
        </member>
        <member name="P:Z0.Konst.base16">
            <summary>
            Species the base16 singleton representative
            </summary>
        </member>
        <member name="M:Z0.Konst.no``1">
            <summary>
            Populates a <see cref="T:System.NotSupportedException"/> complaining that a
            parametrically-identified type is not supported
            </summary>
            <typeparam name="T">The unsupported type</typeparam>
        </member>
        <member name="F:Z0.Konst.Max8i">
            <summary>
            The maximum representable <see cref='T:System.SByte'/> value
            </summary>
        </member>
        <member name="F:Z0.Konst.Max8u">
            <summary>
            The maximum representable <see cref='T:System.Byte'/> value
            </summary>
        </member>
        <member name="F:Z0.Konst.Max16i">
            <summary>
            The maximum representable <see cref='T:System.Int16'/> value
            </summary>
        </member>
        <member name="F:Z0.Konst.Max16u">
            <summary>
            The maximum representable <see cref='T:System.UInt16'/> value
            </summary>
        </member>
        <member name="F:Z0.Konst.Max24u">
            <summary>
            The largest representable uint64 value
            </summary>
        </member>
        <member name="F:Z0.Konst.Max32u">
            <summary>
            The largest representable uint32 value
            </summary>
        </member>
        <member name="F:Z0.Konst.Max40u">
            <summary>
            The largest representable value v where v:uint40
            </summary>
        </member>
        <member name="F:Z0.Konst.Max48u">
            <summary>
            The largest representable value v where v:uint48
            </summary>
        </member>
        <member name="F:Z0.Konst.Max56u">
            <summary>
            The largest representable value v where v:uint56
            </summary>
        </member>
        <member name="F:Z0.Konst.Max64u">
            <summary>
            The maximum representable <see cref='T:System.UInt64'/> value
            </summary>
        </member>
        <member name="F:Z0.Konst.Max32i">
            <summary>
            The minimum representable <see cref='T:System.Int64'/> value
            </summary>
        </member>
        <member name="F:Z0.Konst.Max64i">
            <summary>
            The maximum representable <see cref='T:System.Int64'/> value
            </summary>
        </member>
        <member name="F:Z0.Konst.Max32f">
            <summary>
            The maximum representable <see cref='T:System.Single'/> value
            </summary>
        </member>
        <member name="F:Z0.Konst.Max64f">
            <summary>
            The maximum representable <see cref='T:System.Double'/> value
            </summary>
        </member>
        <member name="F:Z0.Konst.Mak128f">
            <summary>
            The maximum representable <see cref='T:System.Decimal'/> value
            </summary>
        </member>
        <member name="F:Z0.Konst.Min8u">
            <summary>
            The smallest representable uint8 value
            </summary>
        </member>
        <member name="F:Z0.Konst.Min8i">
            <summary>
            The smallest representable int8 value
            </summary>
        </member>
        <member name="F:Z0.Konst.Min16u">
            <summary>
            The smallest representable uint16 value
            </summary>
        </member>
        <member name="F:Z0.Konst.Min16i">
            <summary>
            The smallest representable int16 value
            </summary>
        </member>
        <member name="F:Z0.Konst.Min32u">
            <summary>
            The smallest representable uint16 value
            </summary>
        </member>
        <member name="F:Z0.Konst.Min32i">
            <summary>
            The minimum representable <see cref='T:System.Int32'/> value
            </summary>
        </member>
        <member name="F:Z0.Konst.Min64i">
            <summary>
            The minimum representable <see cref='T:System.Int64'/> value
            </summary>
        </member>
        <member name="F:Z0.Konst.Min64u">
            <summary>
            The minimum representable <see cref='T:System.UInt64'/> value
            </summary>
        </member>
        <member name="F:Z0.Konst.Min32f">
            <summary>
            The minimum representable <see cref='T:System.Single'/> value
            </summary>
        </member>
        <member name="F:Z0.Konst.Min64f">
            <summary>
            The minimum representable <see cref='T:System.Double'/> value
            </summary>
        </member>
        <member name="F:Z0.Konst.Min128f">
            <summary>
            The minimum representable <see cref='T:System.Decimal'/> value
            </summary>
        </member>
        <member name="F:Z0.Konst.NumericWidths">
            <summary>
            Specifies the widths of system-supported primal numeric data types
            </summary>
        </member>
        <member name="F:Z0.Konst.UnsignedInts">
            <summary>
            Specifies unsigned integral types of widths <see cref='F:Z0.Konst.NumericWidths'/>
            </summary>
        </member>
        <member name="F:Z0.Konst.SignedInts">
            <summary>
            Specifies signed integral types of widths <see cref='F:Z0.Konst.NumericWidths'/>
            </summary>
        </member>
        <member name="F:Z0.Konst.Integers">
            <summary>
            Specifies signed and unsigned integral types of widths <see cref='F:Z0.Konst.NumericWidths'/>
            </summary>
        </member>
        <member name="F:Z0.Konst.Numeric8k">
            <summary>
            Specifies numeric types of width <see cref='T:Z0.W8'/>
            </summary>
        </member>
        <member name="F:Z0.Konst.Numeric16k">
            <summary>
            Specifies numeric types of width <see cref='T:Z0.W16'/>
            </summary>
        </member>
        <member name="F:Z0.Konst.Numeric32k">
            <summary>
            Specifies numeric types of width <see cref='T:Z0.W32'/>
            </summary>
        </member>
        <member name="F:Z0.Konst.Numeric64k">
            <summary>
            Specifies numeric types of width <see cref='T:Z0.W64'/>
            </summary>
        </member>
        <member name="F:Z0.Konst.Numeric8x16x32k">
            <summary>
            Specifies numeric types of width <see cref='T:Z0.W8'/>, <see cref='T:Z0.W16'/> and <see cref='T:Z0.W32'/>
            </summary>
        </member>
        <member name="F:Z0.Konst.Numeric16x32x64k">
            <summary>
            Specifies numeric types of width <see cref='T:Z0.W16'/>, <see cref='T:Z0.W32'/>, and <see cref='T:Z0.W64'/>
            </summary>
        </member>
        <member name="F:Z0.Konst.Numeric32x64k">
            <summary>
            Specifies numeric types of width <see cref='T:Z0.W32'/>, and <see cref='T:Z0.W64'/>
            </summary>
        </member>
        <member name="F:Z0.Konst.Int8k">
            <summary>
            Specifies signed and unsigned integral type of width <see cref='T:Z0.W8'/>
            </summary>
        </member>
        <member name="F:Z0.Konst.Int16k">
            <summary>
            Specifies signed and unsigned integral type of width <see cref='T:Z0.W16'/>
            </summary>
        </member>
        <member name="F:Z0.Konst.Int32k">
            <summary>
            Specifies signed and unsigned integral type of width <see cref='T:Z0.W32'/>
            </summary>
        </member>
        <member name="F:Z0.Konst.Int64k">
            <summary>
            Specifies signed and unsigned integral type of width <see cref='T:Z0.W64'/>
            </summary>
        </member>
        <member name="F:Z0.Konst.Int8x16k">
            <summary>
            Specifies signed and unsigned integral types of width <see cref='T:Z0.W8'/> and <see cref='T:Z0.W16'/>
            </summary>
        </member>
        <member name="F:Z0.Konst.Int8x16x32k">
            <summary>
            Specifies signed and unsigned integral types of width <see cref='T:Z0.W8'/>, <see cref='T:Z0.W16'/>, and <see cref='T:Z0.W32'/>
            </summary>
        </member>
        <member name="F:Z0.Konst.Int16x32x64k">
            <summary>
            Specifies signed and unsigned integral types of width <see cref='T:Z0.W16'/>, <see cref='T:Z0.W32'/>, and <see cref='T:Z0.W64'/>
            </summary>
        </member>
        <member name="F:Z0.Konst.Int8x64k">
            <summary>
            Specifies signed and unsigned integral types of width <see cref='T:Z0.W8'/> and <see cref='T:Z0.W64'/>
            </summary>
        </member>
        <member name="P:Z0.Konst.t8u">
            <summary>
            Defines a <see cref='T:Z0.U8'/> representative
            </summary>
        </member>
        <member name="P:Z0.Konst.t8i">
            <summary>
            Defines a global <see cref='T:Z0.I8'/> representative
            </summary>
        </member>
        <member name="P:Z0.Konst.t16u">
            <summary>
            Defines a global <see cref='T:Z0.U16'/> representative
            </summary>
        </member>
        <member name="P:Z0.Konst.t16i">
            <summary>
            Defines a global <see cref='T:Z0.I16'/> representative
            </summary>
        </member>
        <member name="P:Z0.Konst.t32u">
            <summary>
            Defines a global <see cref='T:Z0.U32'/> representative
            </summary>
        </member>
        <member name="P:Z0.Konst.t32i">
            <summary>
            Defines a global <see cref='T:Z0.I32'/> representative
            </summary>
        </member>
        <member name="P:Z0.Konst.t64u">
            <summary>
            Defines a global <see cref='T:Z0.U64'/> representative
            </summary>
        </member>
        <member name="P:Z0.Konst.t64i">
            <summary>
            Defines a global <see cref='T:Z0.I64'/> representative
            </summary>
        </member>
        <member name="F:Z0.Konst.One8i">
            <summary>
            One, presented as an 8-bit signed integer
            </summary>
        </member>
        <member name="F:Z0.Konst.One8u">
            <summary>
            One, presented as an 8-bit unsigned integer
            </summary>
        </member>
        <member name="F:Z0.Konst.One16i">
            <summary>
            One, presented as a 16-bit signed integer
            </summary>
        </member>
        <member name="F:Z0.Konst.One16u">
            <summary>
            One, presented as a 16-bit unsigned integer
            </summary>
        </member>
        <member name="F:Z0.Konst.One32i">
            <summary>
            One, presented as a 32-bit signed integer
            </summary>
        </member>
        <member name="F:Z0.Konst.One32u">
            <summary>
            One, presented as a 32-bit unsigned integer
            </summary>
        </member>
        <member name="F:Z0.Konst.One64i">
            <summary>
            One, presented as a 64-bit signed integer
            </summary>
        </member>
        <member name="F:Z0.Konst.One64u">
            <summary>
            One, presented as a 64-bit unsigned integer
            </summary>
        </member>
        <member name="F:Z0.Konst.One32f">
            <summary>
            One, presented as a 32-bit floating-point number
            </summary>
        </member>
        <member name="F:Z0.Konst.One64f">
            <summary>
            One, presented as a 64-bit floating-point number
            </summary>
        </member>
        <member name="F:Z0.Konst.One128f">
            <summary>
            One, presented as a 128-bit floating-point number
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos0">
            <summary>
            Identifies term 0 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos1">
            <summary>
            Identifies term 1 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos2">
            <summary>
            Identifies term 2 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos3">
            <summary>
            Identifies term 3 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos4">
            <summary>
            Identifies term 4 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos5">
            <summary>
            Identifies term 6 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos6">
            <summary>
            Identifies term 6 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos7">
            <summary>
            Identifies term 7 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos8">
            <summary>
            Identifies term 8 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos9">
            <summary>
            Identifies term 9 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos10">
            <summary>
            Identifies term 10 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos11">
            <summary>
            Identifies term 11 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos12">
            <summary>
            Identifies term 12 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos13">
            <summary>
            Identifies term 13 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos14">
            <summary>
            Identifies term 14 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos15">
            <summary>
            Identifies term 15 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos16">
            <summary>
            Identifies term 16 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos17">
            <summary>
            Identifies term 17 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos18">
            <summary>
            Identifies term 18 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos19">
            <summary>
            Identifies term 19 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos20">
            <summary>
            Identifies term 20 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos21">
            <summary>
            Identifies term 21 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos22">
            <summary>
            Identifies term 22 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos23">
            <summary>
            Identifies term 23 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos24">
            <summary>
            Identifies term 24 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos25">
            <summary>
            Identifies term 25 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos26">
            <summary>
            Identifies term 26 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos27">
            <summary>
            Identifies term 27 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos28">
            <summary>
            Identifies term 28 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos29">
            <summary>
            Identifies term 29 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos30">
            <summary>
            Identifies term 30 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos31">
            <summary>
            Identifies term 31 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos32">
            <summary>
            Identifies term 33 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos33">
            <summary>
            Identifies term 33 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos34">
            <summary>
            Identifies term 34 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos35">
            <summary>
            Identifies term 35 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos36">
            <summary>
            Identifies term 36 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos37">
            <summary>
            Identifies term 37 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos38">
            <summary>
            Identifies term 38 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos39">
            <summary>
            Identifies term 39 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos40">
            <summary>
            Identifies term 40 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos41">
            <summary>
            Identifies term 41 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos42">
            <summary>
            Identifies term 44 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos43">
            <summary>
            Identifies term 44 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos44">
            <summary>
            Identifies term 44 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos45">
            <summary>
            Identifies term 45 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos46">
            <summary>
            Identifies term 46 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos47">
            <summary>
            Identifies term 47 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos48">
            <summary>
            Identifies term 48 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Pos49">
            <summary>
            Identifies term 49 of a sequence
            </summary>
        </member>
        <member name="F:Z0.Konst.Zero8i">
            <summary>
            Zero, presented as an 8-bit signed integer
            </summary>
        </member>
        <member name="F:Z0.Konst.Zero8u">
            <summary>
            Zero, presented as an 8-bit unsigned integer
            </summary>
        </member>
        <member name="F:Z0.Konst.Zero16i">
            <summary>
            Zero, presented as a 16-bit signed integer
            </summary>
        </member>
        <member name="F:Z0.Konst.Zero16u">
            <summary>
            Zero, presented as a 16-bit unsigned integer
            </summary>
        </member>
        <member name="F:Z0.Konst.Zero32i">
            <summary>
            Zero, presented as a 32-bit signed integer
            </summary>
        </member>
        <member name="F:Z0.Konst.Zero32u">
            <summary>
            Zero, presented as a 32-bit unsigned integer
            </summary>
        </member>
        <member name="F:Z0.Konst.Zero64i">
            <summary>
            Zero, presented as a 64-bit signed integer
            </summary>
        </member>
        <member name="F:Z0.Konst.Zero64u">
            <summary>
            Zero, presented as a 64-bit unsigned integer
            </summary>
        </member>
        <member name="F:Z0.Konst.Zero32f">
            <summary>
            Zero, presented as a 32-bit floating-point number
            </summary>
        </member>
        <member name="F:Z0.Konst.Zero64f">
            <summary>
            Zero, presented as a 64-bit floating-point number
            </summary>
        </member>
        <member name="F:Z0.Konst.Zero128f">
            <summary>
            Zero, presented as a 128-bit floating-point number
            </summary>
        </member>
        <member name="F:Z0.Konst.Zero16c">
            <summary>
            Zero, presented as a character
            </summary>
        </member>
        <member name="F:Z0.Konst.Zero8b">
            <summary>
            Zero, presented as a boolean
            </summary>
        </member>
        <member name="F:Z0.Konst.z8i">
            <summary>
            The zero-value for an 8-bit signed integer
            </summary>
        </member>
        <member name="F:Z0.Konst.z8">
            <summary>
            The zero-value for an 8-bit usigned integer
            </summary>
        </member>
        <member name="F:Z0.Konst.z16i">
            <summary>
            The zero-value for a 16-bit signed integer
            </summary>
        </member>
        <member name="F:Z0.Konst.z16">
            <summary>
            The zero-value for a 16-bit unsigned integer
            </summary>
        </member>
        <member name="F:Z0.Konst.z32i">
            <summary>
            The zero-value for a 32-bit signed integer
            </summary>
        </member>
        <member name="F:Z0.Konst.z32">
            <summary>
            The zero-value for a 32-bit usigned integer
            </summary>
        </member>
        <member name="F:Z0.Konst.z64i">
            <summary>
            The zero-value for a 64-bit signed integer
            </summary>
        </member>
        <member name="F:Z0.Konst.z64">
            <summary>
            The zero-value for a 64-bit usigned integer
            </summary>
        </member>
        <member name="F:Z0.Konst.z16c">
            <summary>
            Zero, presented as a character
            </summary>
        </member>
        <member name="F:Z0.Konst.z32f">
            <summary>
            The zero-value for a 32-bit float
            </summary>
        </member>
        <member name="F:Z0.Konst.z64f">
            <summary>
            The zero-value for a 64-bit float
            </summary>
        </member>
        <member name="F:Z0.Konst.z128f">
            <summary>
            The zero-value for a 128-bit float
            </summary>
        </member>
        <member name="F:Z0.Konst.z8b">
            <summary>
            The zero-value for a bool
            </summary>
        </member>
        <member name="F:Z0.Konst.zS">
            <summary>
            The zero-value for a string
            </summary>
        </member>
        <member name="P:Z0.KonstBytes.BlendSpec_Even_256x8">
            <summary>
            Defines a mask for an even 256x8-bit blend
            </summary>
        </member>
        <member name="P:Z0.KonstBytes.BlendSpec_Odd_256x8">
            <summary>
            Defines a mask for an even 256x8-bit blend
            </summary>
        </member>
        <member name="P:Z0.KonstBytes.BlendSpec_Even_256x16">
            <summary>
            Defines a mask for an even 256x8-bit blend
            </summary>
        </member>
        <member name="P:Z0.KonstBytes.BlendSpec_Odd_256x16">
            <summary>
            Defines a mask for an odd 256x32-bit blend
            </summary>
        </member>
        <member name="P:Z0.KonstBytes.BlendSpec_Even_256x32">
            <summary>
            Defines a mask for an even 256x32-bit blend
            </summary>
        </member>
        <member name="P:Z0.KonstBytes.BlendSpec_Odd_256x32">
            <summary>
            Defines a mask for an odd 256x32-bit blend
            </summary>
        </member>
        <member name="P:Z0.KonstBytes.BlendSpec_Even_256x64">
            <summary>
            Defines a mask for an even 256x64-bit blend
            </summary>
        </member>
        <member name="P:Z0.KonstBytes.BlendSpec_Odd_256x64">
            <summary>
            Defines a mask for an odd 256x64-bit blend
            </summary>
        </member>
        <member name="P:Z0.KonstBytes.ByteSwap128x16u">
            <summary>
            Shuffle pattern that, when applied, swaps the byte-level representation of 16-bit unsigned integers
            </summary>
        </member>
        <member name="P:Z0.KonstBytes.ByteSwap128x32u">
            <summary>
            Shuffle pattern that, when applied, swaps the byte-level representation of 32-bit unsigned integers
            </summary>
        </member>
        <member name="P:Z0.KonstBytes.ByteSwap128x64u">
            <summary>
            Shuffle pattern that, when applied, swaps the byte-level representation of 64-bit unsigned integers
            </summary>
        </member>
        <member name="P:Z0.KonstBytes.ByteSwap256x16u">
            <summary>
            Shuffle pattern that, when applied, swaps the byte-level representation of 16-bit unsigned integers
            </summary>
        </member>
        <member name="P:Z0.KonstBytes.ByteSwap256x32u">
            <summary>
            Shuffle pattern that, when applied, swaps the byte-level representation of 32-bit unsigned integers
            </summary>
        </member>
        <member name="P:Z0.KonstBytes.ByteSwap256x64u">
            <summary>
            Shuffle pattern that, when applied, swaps the byte-level representation of 64-bit unsigned integers
            </summary>
        </member>
        <member name="P:Z0.KonstBytes.RotR48_128x8u">
            <summary>
            Shuffle pattern that, when applied, rotates 128 bits of content rightward by 48 bits
            </summary>
        </member>
        <member name="P:Z0.KonstBytes.RotR8_128x8u">
            <summary>
            Shuffle pattern that, when applied, rotates 128 bits of content rightward by 8 bits
            </summary>
        </member>
        <member name="P:Z0.KonstBytes.RotR16_128x8u">
            <summary>
            Shuffle pattern that, when applied, rotates 128 bits of content rightward by 16 bits
            </summary>
        </member>
        <member name="P:Z0.KonstBytes.RotR24_128x8u">
            <summary>
            Shuffle pattern that, when applied, rotates 128 bits of content rightward by 24 bits
            </summary>
        </member>
        <member name="P:Z0.KonstBytes.RotR32_128x8u">
            <summary>
            Shuffle pattern that, when applied, rotates 128 bits of content rightward by 32 bits
            </summary>
        </member>
        <member name="P:Z0.KonstBytes.RotR40_128x8u">
            <summary>
            Shuffle pattern that, when applied, rotates 128 bits of content rightward by 40 bits
            </summary>
        </member>
        <member name="F:Z0.Zero.z8i">
            <summary>
            The zero-value for an 8-bit signed integer
            </summary>
        </member>
        <member name="F:Z0.Zero.z8">
            <summary>
            The zero-value for an 8-bit unsigned integer
            </summary>
        </member>
        <member name="F:Z0.Zero.z16i">
            <summary>
            The zero-value for a 16-bit signed integer
            </summary>
        </member>
        <member name="F:Z0.Zero.z16">
            <summary>
            The zero-value for a 16-bit unsigned integer
            </summary>
        </member>
        <member name="F:Z0.Zero.z32i">
            <summary>
            The zero-value for a 32-bit signed integer
            </summary>
        </member>
        <member name="F:Z0.Zero.z32">
            <summary>
            The zero-value for a 32-bit unsigned integer
            </summary>
        </member>
        <member name="F:Z0.Zero.z64i">
            <summary>
            The zero-value for a 64-bit signed integer
            </summary>
        </member>
        <member name="F:Z0.Zero.z64">
            <summary>
            The zero-value for a 64-bit unsigned integer
            </summary>
        </member>
        <member name="F:Z0.Zero.z32f">
            <summary>
            The zero-value for a 32-bit float
            </summary>
        </member>
        <member name="F:Z0.Zero.z64f">
            <summary>
            The zero-value for a 64-bit float
            </summary>
        </member>
        <member name="F:Z0.Zero.z128f">
            <summary>
            The zero-value for a 128-bit float
            </summary>
        </member>
        <member name="F:Z0.Zero.z16c">
            <summary>
            Zero, presented as a character, expressed with an impressively-short identifier
            </summary>
        </member>
        <member name="F:Z0.Zero.z8b">
            <summary>
            The zero-value for a bool
            </summary>
        </member>
        <member name="F:Z0.Zero.zS">
            <summary>
            The zero-value for a string
            </summary>
        </member>
        <member name="M:Z0.Zero.zed``1(``0)">
            <summary>
            Computes the zero-value for any unmanaged type
            </summary>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="T:Z0.TypedLiteral`2">
            <summary>
            A numeric-parametric typed literal
            </summary>
            <typeparam name="E">An enumeration type that refines the parametric numeric type</typeparam>
            <typeparam name="T">The numeric type refined by the enum</typeparam>
        </member>
        <member name="T:Z0.TypedLiteralType`1">
            <summary>
            Covers a value that can be interpreted as a compile-time literal constant
            </summary>
        </member>
        <member name="M:Z0.TypedLiterals.define``1(``0)">
            <summary>
            Creates a <see cref='T:Z0.TypedLiteral`1'/>
            </summary>
            <param name="e">The enum literal value</param>
            <typeparam name="E">The enumeration type</typeparam>
        </member>
        <member name="M:Z0.TypedLiterals.define``2(``1)">
            <summary>
            Creates a <see cref='T:Z0.TypedLiteral`2'/>
            </summary>
            <param name="value">The numeric value</param>
            <param name="t">The primitive value</param>
            <typeparam name="E">The enum type</typeparam>
            <typeparam name="T">The refined primitive type</typeparam>
        </member>
        <member name="M:Z0.TypedLiterals.define``2(``0)">
            <summary>
            Creates a <see cref='T:Z0.TypedLiteral`2'/>
            </summary>
            <param name="e">The enum literal value</param>
            <typeparam name="E">The enum type</typeparam>
            <typeparam name="T">The refined primitive type</typeparam>
        </member>
        <member name="M:Z0.TypedLiterals.define``2(``0,``1)">
            <summary>
            Creates a <see cref='T:Z0.TypedLiteral`2'/>
            </summary>
            <param name="e">The enum literal value</param>
            <param name="t">The corresponding primitive value</param>
            <typeparam name="E">The enum type</typeparam>
            <typeparam name="T">The refined primitive type</typeparam>
        </member>
        <member name="M:Z0.LiteralFields.values``1(System.Type)">
            <summary>
            Collects unmanaged fields defined by a type
            </summary>
            <param name="src"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Z0.Literals.kind(Z0.BinaryLiteral)">
            <summary>
            Discerns the numeric kind of a specified binary literal
            </summary>
            <param name="src">The source literal</param>
        </member>
        <member name="M:Z0.Literals.kind``1(Z0.BinaryLiteral{``0})">
            <summary>
            Discerns the numeric kind of a specified binary literal
            </summary>
            <param name="src">The source literal</param>
        </member>
        <member name="M:Z0.Literals.pair``2(``0,``1,``1)">
            <summary>
            Defines an homogenous pair of key-correlated literals
            </summary>
            <param name="key">The correlation key</param>
            <param name="first">The fist member</param>
            <param name="second">The second member</param>
            <typeparam name="K">The key type</typeparam>
            <typeparam name="P">The literal type</typeparam>
        </member>
        <member name="M:Z0.Literals.pair``3(``0,``1,``2)">
            <summary>
            Defines a heterogenous pair of key-correlated literals
            </summary>
            <param name="key">The correlation key</param>
            <param name="first">The fist literal</param>
            <param name="second">The second literal</param>
            <typeparam name="K">The key type</typeparam>
            <typeparam name="P">The first literal type</typeparam>
            <typeparam name="Q">The second literal type</typeparam>
        </member>
        <member name="M:Z0.Literals.tagged``1(Z0.Base2,System.Type)">
            <summary>
            Selects the binary literals declared by a type that are of a specified parametric primal type
            </summary>
            <param name="src">The source type</param>
            <typeparam name="T">The primal literal type</typeparam>
        </member>
        <member name="M:Z0.Literals.tagged(Z0.Base2,System.Type)">
            <summary>
            Selects the binary literals declared by a type
            </summary>
            <param name="src">The source type</param>
        </member>
        <member name="M:Z0.Literals.typed``1(``0)">
            <summary>
            Creates a <see cref='T:Z0.TypedLiteral`1'/>
            </summary>
            <param name="e">The enum literal value</param>
            <typeparam name="E">The enumeration type</typeparam>
        </member>
        <member name="M:Z0.Literals.typed``2(``1)">
            <summary>
            Creates a <see cref='T:Z0.TypedLiteral`2'/>
            </summary>
            <param name="value">The numeric value</param>
            <param name="t">The primitive value</param>
            <typeparam name="E">The enum type</typeparam>
            <typeparam name="T">The refined primitive type</typeparam>
        </member>
        <member name="M:Z0.Literals.values``1(Z0.Base2,System.Type)">
            <summary>
            Selects the binary literals declared by a specified type that are of a specified primal type
            </summary>
            <param name="src">The source type</param>
            <typeparam name="T">The primal literal type</typeparam>
        </member>
        <member name="T:Z0.BinaryLiteral">
            <summary>
            Defines a base2 literal via text and a boxed value; for the literal to be valid,
            the text, when parsed, must yield a value equivalent to the boxed value
            </summary>
        </member>
        <member name="F:Z0.BinaryLiteral.Name">
            <summary>
            The literal name
            </summary>
        </member>
        <member name="F:Z0.BinaryLiteral.Data">
            <summary>
            The literal value
            </summary>
        </member>
        <member name="F:Z0.BinaryLiteral.Text">
            <summary>
            Text that represents the boxed value
            </summary>
        </member>
        <member name="T:Z0.LiteralInfo">
            <summary>
            Covers a value that can be interpreted as a compile-time literal constant
            </summary>
        </member>
        <member name="T:Z0.LiteralPair`2">
            <summary>
            Defines an identifiable association between two homogenous literal values
            </summary>
            <typeparam name="K">The key type</typeparam>
            <typeparam name="P">The first literal type</typeparam>
        </member>
        <member name="F:Z0.LiteralPair`2.Key">
            <summary>
            The identifying key
            </summary>
        </member>
        <member name="F:Z0.LiteralPair`2.First">
            <summary>
            The first literal value
            </summary>
        </member>
        <member name="F:Z0.LiteralPair`2.Second">
            <summary>
            The second literal value
            </summary>
        </member>
        <member name="T:Z0.LiteralPair`3">
            <summary>
            Defines an identifiable association between two heterogenous literal values
            </summary>
            <typeparam name="K">The key type</typeparam>
            <typeparam name="P">The first literal type</typeparam>
            <typeparam name="Q">The second literal type</typeparam>
        </member>
        <member name="F:Z0.LiteralPair`3.Key">
            <summary>
            The identifying key
            </summary>
        </member>
        <member name="F:Z0.LiteralPair`3.First">
            <summary>
            The first literal value
            </summary>
        </member>
        <member name="F:Z0.LiteralPair`3.Second">
            <summary>
            The second literal value
            </summary>
        </member>
        <member name="M:Z0.Lookups.lookup``2(Z0.LookupEntry{``0,``1}[])">
            <summary>
            Creates a lookup table
            </summary>
            <param name="src">The table entries</param>
            <typeparam name="K">The key type</typeparam>
            <typeparam name="V">The value type</typeparam>
        </member>
        <member name="T:Z0.Lookups.Lu8`1">
            <summary>
            Defines an 8-bit lookup table predicated on an explicit lookup function
            </summary>
        </member>
        <member name="T:Z0.Lookups.Lu16`1">
            <summary>
            Defines a 16-bit lookup tablee
            </summary>
        </member>
        <member name="T:Z0.Lookups.Lu32`1">
            <summary>
            Defines a 32-bit lookup tablee
            </summary>
        </member>
        <member name="T:Z0.Lookups.Lu64`1">
            <summary>
            Defines a 64-bit lookup tablee
            </summary>
        </member>
        <member name="T:Z0.KeyFunction`2">
            <summary>
            Signature for a key function, also called in index function, that computes a K-value for any V-value
            </summary>
            <param name="src"></param>
            <typeparam name="K">The key type</typeparam>
            <typeparam name="V">The value type</typeparam>
        </member>
        <member name="T:Z0.KeyInjection`2">
            <summary>
            Signature for an injective key function that satisfied kf(v1) = kf(v2) => v1 = v2
            </summary>
            <param name="src"></param>
            <typeparam name="K">The key type</typeparam>
            <typeparam name="V">The value type</typeparam>
        </member>
        <member name="T:Z0.KeyedValue`2">
            <summary>
            Correlates a value with a key that uniquely identifies the value within some context
            </summary>
        </member>
        <member name="F:Z0.KeyedValue`2.Key">
            <summary>
            The key that identifies the value
            </summary>
        </member>
        <member name="F:Z0.KeyedValue`2.Value">
            <summary>
            The value identified by the key
            </summary>
        </member>
        <member name="T:Z0.KeyedValues`2">
            <summary>
            Defines a T-value index together with a comanion K-index ,
            where each K-value i is either obtained directly from the caller or by
            invoking a caller-supplied index function f:T -> K that computes a unique K-value for each T-value
            </summary>
        </member>
        <member name="T:Z0.Key`2">
            <summary>
            Defines a <typeparamref name='K'/> discriminated key for an identifier <typeparamref name='T'/>
            </summary>
            <remarks>
             The key is denoted symbolically by <see cref='F:Z0.Key`2.Identifier'/>: <see cref='F:Z0.Key`2.Kind'/>
            </remarks>
        </member>
        <member name="F:Z0.Key`2.Kind">
            <summary>
            The key discriminator
            </summary>
        </member>
        <member name="F:Z0.Key`2.Identifier">
            <summary>
            The item identifier relative to the discriminated context defined by <see cref='F:Z0.Key`2.Kind'/>
            </summary>
        </member>
        <member name="T:Z0.KeyValuePairs`2">
            <summary>
            Reifies a K-V parametric hashtable, along with extras
            </summary>
            <typeparam name="K">The key type</typeparam>
            <typeparam name="V">The value type</typeparam>
        </member>
        <member name="P:Z0.KeyValuePairs`2.Empty">
            <summary>
            A hashtable that hashes nothing
            </summary>
        </member>
        <member name="T:Z0.LookupEntry`2">
            <summary>
            Defines an entry in a <see cref='T:Z0.LookupTable`2'/>
            </summary>
        </member>
        <member name="T:Z0.LookupTable`2">
            <summary>
            Defines a K-V lookup table
            </summary>
        </member>
        <member name="T:Z0.IMeaning">
            <summary>
            Characterizes type that defines a Description facet
            </summary>
        </member>
        <member name="T:Z0.IMeaning`1">
            <summary>
            Characterizes type that defines a Description facet
            </summary>
        </member>
        <member name="P:Z0.MemoryOffset.OffsetAddress">
            <summary>
            The offset magnitude presented as an address
            </summary>
        </member>
        <member name="P:Z0.MemoryOffset.Absolute">
            <summary>
            The absolute address
            </summary>
        </member>
        <member name="T:Z0.IAddressable">
            <summary>
            Characterizes an object that advertises its memory location
            </summary>
        </member>
        <member name="T:Z0.IAddressable`1">
            <summary>
            Characterizes an object that advertises a parametric memory location
            </summary>
            <typeparam name="T">The parametric address type</typeparam>
        </member>
        <member name="T:Z0.IAddressable`2">
            <summary>
            Characterizes a reified addressable object
            </summary>
            <typeparam name="F">The reification type</typeparam>
            <typeparam name="T">The address type</typeparam>
        </member>
        <member name="T:Z0.ISegRef">
            <summary>
            Characterizes a segment reference
            </summary>
        </member>
        <member name="T:Z0.ISegRef`1">
            <summary>
            Characterizes a content-parametric segment reference
            </summary>
            <typeparam name="T">The content type</typeparam>
        </member>
        <member name="T:Z0.ISegRef`2">
            <summary>
            Characterizes a reified content-parameteric segment reference
            </summary>
            <typeparam name="F">The reifying type</typeparam>
            <typeparam name="T">The content type</typeparam>
        </member>
        <member name="M:Z0.MemCopy.concat(System.Byte[][],System.Byte[])">
            <summary>
            Concatenates an array sequence
            </summary>
            <param name="src">The source arrays</param>
        </member>
        <member name="M:Z0.MemCopy.concat(System.Byte[][])">
            <summary>
            Concatenates an array sequence
            </summary>
            <param name="src">The source arrays</param>
        </member>
        <member name="M:Z0.MemCopy.copy(Z0.W8,System.Byte@,System.Byte@)">
            <summary>
            Copies 8 bits from the source to the target
            </summary>
            <param name="src">The data source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.MemCopy.copy(Z0.W16,System.Byte@,System.Byte@)">
            <summary>
            Copies 16 bits from the source to the target
            </summary>
            <param name="src">The data source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.MemCopy.copy(Z0.W32,System.Byte@,System.Byte@)">
            <summary>
            Copies 32 bits from the source to the target
            </summary>
            <param name="src">The data source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.MemCopy.copy(Z0.W64,System.Byte@,System.Byte@)">
            <summary>
            Copies 64 bits from the source to the target
            </summary>
            <param name="src">The data source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.MemCopy.copy(Z0.W128,System.Byte@,System.Byte@)">
            <summary>
            Copies 128 bits from the source to the target
            </summary>
            <param name="src">The data source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.MemCopy.copy(Z0.W256,System.Byte@,System.Byte@)">
            <summary>
            Copies 256 bits from the source to the target
            </summary>
            <param name="src">The data source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.MemCopy.copy(Z0.W512,System.Byte@,System.Byte@)">
            <summary>
            Copies 512 bits from the source to the target
            </summary>
            <param name="src">The data source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.MemCopy.copy(Z0.W1024,System.Byte@,System.Byte@)">
            <summary>
            Copies 512 bits from the source to the target
            </summary>
            <param name="src">The data source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.MemCopy.copy(Z0.W16,System.UInt16@,System.Byte@)">
            <summary>
            Copies 16 bits from the source to the target
            </summary>
            <param name="src">The data source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.MemCopy.copy(Z0.W32,System.UInt16@,System.UInt32@)">
            <summary>
            Copies 32 bits from the source to the target
            </summary>
            <param name="src">The bit source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.MemCopy.copy(Z0.W64,System.Byte@,System.UInt64@)">
            <summary>
            Copies 64 bits from the source to the target
            </summary>
            <param name="src">The source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.MemCopy.copy(Z0.W64,System.UInt16@,System.UInt64@)">
            <summary>
            Copies 64 bits from the source to the target
            </summary>
            <param name="src">The data source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.MemCopy.copy(Z0.W16,System.Byte@,System.UInt16@)">
            <summary>
            Copies 16 bits from the source to the target
            </summary>
            <param name="src">The data source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.MemCopy.copy(Z0.W32,System.Byte@,System.UInt32@)">
            <summary>
            Copies 32 bits from the source to the target
            </summary>
            <param name="src">The data source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.MemCopy.copy(Z0.W64,System.UInt32@,System.UInt64@)">
            <summary>
            Copies 64 bits from the source to the target
            </summary>
            <param name="src">The data source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.MemCopy.copy(Z0.W32,System.UInt32@,System.Byte@)">
            <summary>
            Copies 64 bits from the source to the target
            </summary>
            <param name="src">The data source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.MemCopy.copy(Z0.W32,System.UInt32@,System.UInt16@)">
            <summary>
            Copies 64 bits from the source to the target
            </summary>
            <param name="src">The data source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.MemCopy.copy(Z0.W64,System.UInt64@,System.Byte@)">
            <summary>
            Copies 64 bits from the source to the target
            </summary>
            <param name="src">The data source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.MemCopy.copy(Z0.W64,System.UInt64@,System.UInt16@)">
            <summary>
            Copies 64 bits from the source to the target
            </summary>
            <param name="src">The data source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.MemCopy.copy(Z0.W64,System.UInt64@,System.UInt32@)">
            <summary>
            Copies 64 bits from the source to the target
            </summary>
            <param name="src">The data source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.MemCopy.copy``2(``0@,``1@,System.Int32,System.Int32)">
            <summary>
            Copies a specified number of source values to the target and returns the count of copied bytes
            </summary>
            <param name="src">The source reference</param>
            <param name="count">The number of source cells to copy</param>
            <param name="dst">The target reference</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.MemCopy.vcopy``1(Z0.W128,System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>
            Copies the source to the target using 128-bit intrinsic operations
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The source</param>
            <param name="dst">The target</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.MemCopy.vcopy``1(Z0.W256,System.ReadOnlySpan{``0},System.Span{``0})">
            <summary>
            Copies the source to the target using 256-bit intrinsic operations
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The source</param>
            <param name="dst">The target</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.MemCopy.copy(System.Byte*,System.Byte*,System.UInt32)">
            <summary>
            Copies a contiguous segments of bytes from one location to another
            </summary>
            <param name="pSrc">The location of the source bytes</param>
            <param name="pDst">The location of the target</param>
            <param name="srcCount">The number of values to copy</param>
        </member>
        <member name="M:Z0.MemCopy.copy``1(``0*,``0*,System.UInt32)">
            <summary>
            Copies a contiguous segments of values from one location to another
            </summary>
            <param name="pSrc">The location of the source bytes</param>
            <param name="pDst">The location of the target</param>
            <param name="srcCount">The number of values to copy</param>
        </member>
        <member name="M:Z0.MemCopy.copy``1(``0*,System.Span{``0},System.Int32,System.UInt32)">
            <summary>
            Copies a contiguous segments of values to a span
            </summary>
            <param name="pSrc">The location of the source bytes</param>
            <param name="pDst">The location of the target</param>
            <param name="srcCount">The number of values to copy</param>
        </member>
        <member name="M:Z0.MemCopy.copy(System.Byte*,System.Span{System.Byte},System.Int32,System.UInt32)">
            <summary>
            Copies a contiguous segments of bytes from a source location to a target span
            </summary>
            <param name="pSrc">The location of the source bytes</param>
            <param name="dst">The location of the target</param>
            <param name="srcCount">The number of values to copy</param>
        </member>
        <member name="M:Z0.MemCopy.copy``2(System.ReadOnlySpan{``0},System.Int32,System.Int32,System.Span{``1},System.Int32)">
            <summary>
            Copies a specified number source cells to the target and returns the count of copied bytes
            </summary>
            <param name="src">The data source</param>
            <param name="start">The source start index</param>
            <param name="count">The source cell count</param>
            <param name="dst">The data target</param>
            <param name="offset">The target offset</param>
            <typeparam name="S">The source cell type</typeparam>
            <typeparam name="T">The target cell type</typeparam>
        </member>
        <member name="M:Z0.MemCopy.copy``2(System.Span{``0},System.Int32,System.Int32,System.Span{``1},System.Int32)">
            <summary>
            Copies a specified number source cells to the target and returns the count of copied bytes
            </summary>
            <param name="src">The data source</param>
            <param name="start">The source start index</param>
            <param name="count">The source cell count</param>
            <param name="dst">The data target</param>
            <param name="offset">The target offset</param>
            <typeparam name="S">The source cell type</typeparam>
            <typeparam name="T">The target cell type</typeparam>
        </member>
        <member name="M:Z0.MemRefs.format(Z0.StringRef@,Z0.StringRef@)">
            <summary>
            Formats the source argument according to a specified format pattern
            </summary>
            <param name="pattern">The format pattern</param>
            <param name="arg0">The pattern argument</param>
        </member>
        <member name="M:Z0.MemRefs.format(Z0.StringRef@,Z0.StringRef@,Z0.StringRef@)">
            <summary>
            Formats the source arguments according to a specified format pattern
            </summary>
            <param name="pattern">The format pattern</param>
            <param name="arg0">The first pattern argument</param>
            <param name="arg0">The second pattern argument</param>
        </member>
        <member name="M:Z0.MemRefs.format(System.String,Z0.StringRef@,Z0.StringRef@)">
            <summary>
            Formats the source arguments according to a specified format pattern
            </summary>
            <param name="pattern">The format pattern</param>
            <param name="arg0">The first pattern argument</param>
            <param name="arg0">The second pattern argument</param>
        </member>
        <member name="M:Z0.MemRefs.format(System.String,System.String@,Z0.StringRef@)">
            <summary>
            Formats the source arguments according to a specified format pattern
            </summary>
            <param name="pattern">The format pattern</param>
            <param name="arg0">The first pattern argument</param>
            <param name="arg0">The second pattern argument</param>
        </member>
        <member name="M:Z0.MemRefs.format(Z0.StringRef@,Z0.StringRef@,Z0.StringRef@,Z0.StringRef@)">
            <summary>
            Formats the source arguments according to a specified format pattern
            </summary>
            <param name="pattern">The format pattern</param>
            <param name="arg0">The first pattern argument</param>
            <param name="arg1">The second pattern argument</param>
            <param name="arg2">The third pattern argument</param>
        </member>
        <member name="P:Z0.MemoryAddress.MinWidth">
            <summary>
            Computes the bit-width of the smallest numeric type that can represent the address
            </summary>
        </member>
        <member name="T:Z0.MemoryRange">
            <summary>
            Defines an inclusive address range
            </summary>
        </member>
        <member name="T:Z0.Ptr">
            <summary>
            Captures and represents a void pointer
            </summary>
        </member>
        <member name="T:Z0.Ptr16">
            <summary>
            Captures and represents <see cref='T:System.UInt16'/> pointer
            </summary>
        </member>
        <member name="T:Z0.Ptr32">
            <summary>
            Captures and represents <see cref='T:System.UInt32'/> pointer
            </summary>
        </member>
        <member name="T:Z0.Ptr64">
            <summary>
            Captures and represents <see cref='T:System.UInt64'/> pointer
            </summary>
        </member>
        <member name="T:Z0.Ptr8">
            <summary>
            Captures and represents <see cref='T:System.Byte'/> pointer
            </summary>
        </member>
        <member name="T:Z0.Ptr`1">
            <summary>
            Captures and represents an <see cref='!:unmanaged'/> generic pointer
            </summary>
        </member>
        <member name="T:Z0.ConstRef`1">
            <summary>
            Defines a content-parametric view over a memory reference
            </summary>
        </member>
        <member name="M:Z0.ConstRef`1.op_LogicalNot(Z0.ConstRef{`0})">
            <summary>
            Dereferences the reference
            </summary>
            <param name="src">The source reference</param>
        </member>
        <member name="T:Z0.FieldRef">
            <summary>
            Deefines a reference to a <see cref='T:System.Reflection.FieldInfo'/>
            </summary>
        </member>
        <member name="P:Z0.FieldRef.DataSize">
            <summary>
            Specifies the size, in bytes of the fields data
            </summary>
        </member>
        <member name="P:Z0.FieldRef.Width">
            <summary>
            Specifies the size, in bits of the fields data
            </summary>
        </member>
        <member name="P:Z0.FieldRef.I8">
            <summary>
            Presents the leading source cell as an int8 reference
            </summary>
        </member>
        <member name="P:Z0.FieldRef.U8">
            <summary>
            Presents the leading source cell as a uint8 reference
            </summary>
        </member>
        <member name="P:Z0.FieldRef.U16">
            <summary>
            Presents the leading source cell as a uint16 reference
            </summary>
        </member>
        <member name="P:Z0.FieldRef.I32">
            <summary>
            Presents the leading source cell as a uint32 reference
            </summary>
        </member>
        <member name="P:Z0.FieldRef.U32">
            <summary>
            Presents the leading source cell as a uint32 reference
            </summary>
        </member>
        <member name="P:Z0.FieldRef.I64">
            <summary>
            Presents the leading source cell as na int64 reference
            </summary>
        </member>
        <member name="P:Z0.FieldRef.U64">
            <summary>
            Presents the leading source cell as a uint64 reference
            </summary>
        </member>
        <member name="P:Z0.FieldRef.F32">
            <summary>
            Presents the leading source cell as a float32 reference
            </summary>
        </member>
        <member name="P:Z0.FieldRef.F64">
            <summary>
            Presents the leading source cell as a float128 reference
            </summary>
        </member>
        <member name="P:Z0.FieldRef.F128">
            <summary>
            Presents the leading source cell as a float128 reference
            </summary>
        </member>
        <member name="P:Z0.FieldRef.U1">
            <summary>
            Presents the leading source cell as a bool reference
            </summary>
        </member>
        <member name="P:Z0.FieldRef.C16">
            <summary>
            Presents the leading source cell as a character reference
            </summary>
        </member>
        <member name="M:Z0.FieldRef.Enum``1">
            <summary>
            Presents the leading source cell as a reference to an enum value of parametric kind
            </summary>
        </member>
        <member name="M:Z0.FieldRef.Struct``1">
            <summary>
            Presents the leading source cell as a reference to a structural value of pararametric kind
            </summary>
        </member>
        <member name="P:Z0.FieldRef.KindId">
            <summary>
            Specifies the field's primal kind, if applicable; otherwise, none
            </summary>
        </member>
        <member name="M:Z0.Ref.op_LogicalNot(Z0.Ref)">
            <summary>
            Dereferences the reference
            </summary>
            <param name="src">The source reference</param>
        </member>
        <member name="T:Z0.Ref`1">
            <summary>
            Defines a content-parametric memory reference
            </summary>
        </member>
        <member name="F:Z0.Ref`1.Segment">
            <summary>
            The source reference
            </summary>
        </member>
        <member name="M:Z0.Ref`1.op_LogicalNot(Z0.Ref{`0})">
            <summary>
            Dereferences the reference
            </summary>
            <param name="src">The source reference</param>
        </member>
        <member name="T:Z0.Segments">
            <summary>
            Indexes a sequence of memory references
            </summary>
        </member>
        <member name="M:Z0.Segments.Load(System.UInt64)">
            <summary>
            Loads the data tracked by an index-identified memory reference
            </summary>
            <param name="index">The ref index</param>
        </member>
        <member name="T:Z0.SegRef">
            <summary>
            Defines a reference to a memory segment
            </summary>
        </member>
        <member name="P:Z0.SegRef.DataSize">
            <summary>
            Specifies the segment byte count
            </summary>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.SegRef.Count``1">
            <summary>
            Computes the whole number of T-cells covered by segment
            </summary>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="T:Z0.StringRef">
            <summary>
            A string?
            </summary>
        </member>
        <member name="P:Z0.StringRef.Length">
            <summary>
            The length of the represented string
            </summary>
        </member>
        <member name="P:Z0.StringRef.View">
            <summary>
            The string content presented as a readonly span
            </summary>
        </member>
        <member name="P:Z0.StringRef.Edit">
            <summary>
            The string content presented as a mutable span
            </summary>
        </member>
        <member name="P:Z0.StringRef.Z0#IConstSpan{Z0#StringRef,System#Char}#Data">
            <summary>
            The string content presented as a span
            </summary>
        </member>
        <member name="T:Z0.MemorySlots`1">
            <summary>
            Defines a key-parametric indexed view over <see cref='T:Z0.SegRef'/> values
            </summary>
        </member>
        <member name="M:Z0.Pointers.address``1(Z0.Ptr{``0}@)">
            <summary>
            Reveals the memory location to which the represented pointer points
            </summary>
            <param name="src">The source pointer</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.Pointers.address(Z0.Ptr8@)">
            <summary>
            Reveals the memory location to which the represented pointer points
            </summary>
            <param name="src">The source pointer</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.Pointers.address(Z0.Ptr16@)">
            <summary>
            Reveals the memory location to which the represented pointer points
            </summary>
            <param name="src">The source pointer</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.Pointers.address(Z0.Ptr32@)">
            <summary>
            Reveals the memory location to which the represented pointer points
            </summary>
            <param name="src">The source pointer</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.Pointers.address(Z0.Ptr64@)">
            <summary>
            Reveals the memory location to which the represented pointer points
            </summary>
            <param name="src">The source pointer</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.Pointers.next(Z0.Ptr8@)">
            <summary>
            Advances the source by a uint
            </summary>
            <param name="src">The source pointer</param>
        </member>
        <member name="M:Z0.Pointers.next(Z0.Ptr16@)">
            <summary>
            Advances the source by a uint
            </summary>
            <param name="src">The source pointer</param>
        </member>
        <member name="M:Z0.Pointers.next(Z0.Ptr32@)">
            <summary>
            Advances the source by a uint
            </summary>
            <param name="src">The source pointer</param>
        </member>
        <member name="M:Z0.Pointers.next(Z0.Ptr64@)">
            <summary>
            Advances the source by a uint
            </summary>
            <param name="src">The source pointer</param>
        </member>
        <member name="M:Z0.Pointers.p16(System.UInt16*)">
            <summary>
            Creates a representation over a specified pointer
            </summary>
            <param name="pSrc">The source pointer</param>
        </member>
        <member name="M:Z0.Pointers.p16(System.Void*)">
            <summary>
            Creates a representation over a specified pointer
            </summary>
            <param name="pSrc">The source pointer</param>
        </member>
        <member name="M:Z0.Pointers.p32(System.UInt32*)">
            <summary>
            Creates a representation over a specified pointer
            </summary>
            <param name="pSrc">The source pointer</param>
        </member>
        <member name="M:Z0.Pointers.p32(System.Void*)">
            <summary>
            Creates a representation over a specified pointer
            </summary>
            <param name="pSrc">The source pointer</param>
        </member>
        <member name="M:Z0.Pointers.p64(System.UInt64*)">
            <summary>
            Creates a representation over a specified pointer
            </summary>
            <param name="pSrc">The source pointer</param>
        </member>
        <member name="M:Z0.Pointers.p64(System.Void*)">
            <summary>
            Creates a representation over a specified pointer
            </summary>
            <param name="pSrc">The source pointer</param>
        </member>
        <member name="M:Z0.Pointers.p8(System.Byte*)">
            <summary>
            Creates a <see cref='T:Z0.Ptr8'/> representation over a specified source
            </summary>
            <param name="pSrc">The source pointer</param>
        </member>
        <member name="M:Z0.Pointers.p8(System.Void*)">
            <summary>
            Creates a <see cref='T:Z0.Ptr8'/> representation over a specified source
            </summary>
            <param name="pSrc">The source pointer</param>
        </member>
        <member name="M:Z0.Pointers.p8(System.UInt16*)">
            <summary>
            Creates a <see cref='T:Z0.Ptr8'/> representation over a specified source
            </summary>
            <param name="pSrc">The source pointer</param>
        </member>
        <member name="M:Z0.Pointers.p8(System.UInt32*)">
            <summary>
            Creates a <see cref='T:Z0.Ptr8'/> representation over a specified source
            </summary>
            <param name="pSrc">The source pointer</param>
        </member>
        <member name="M:Z0.Pointers.p8(System.UInt64*)">
            <summary>
            Creates a <see cref='T:Z0.Ptr8'/> representation over a specified source
            </summary>
            <param name="pSrc">The source pointer</param>
        </member>
        <member name="M:Z0.Pointers.p8(Z0.Ptr16@)">
            <summary>
            Presents a <see cref='T:Z0.Ptr16'/> representation as a <see cref='T:Z0.Ptr8'/> representation 
            </summary>
            <param name="source">The source representation</param>
        </member>
        <member name="M:Z0.Pointers.p8(Z0.Ptr32@)">
            <summary>
            Presents a <see cref='T:Z0.Ptr32'/> representation as a <see cref='T:Z0.Ptr8'/> representation 
            </summary>
            <param name="source">The source representation</param>
        </member>
        <member name="M:Z0.Pointers.p8(Z0.Ptr64@)">
            <summary>
            Presents a <see cref='T:Z0.Ptr64'/> representation as a <see cref='T:Z0.Ptr8'/> representation 
            </summary>
            <param name="source">The source representation</param>
        </member>
        <member name="M:Z0.Pointers.prior(Z0.Ptr8@)">
            <summary>
            Advances the source by a uint
            </summary>
            <param name="src">The source pointer</param>
        </member>
        <member name="M:Z0.Pointers.prior(Z0.Ptr16@)">
            <summary>
            Advances the source by a uint
            </summary>
            <param name="src">The source pointer</param>
        </member>
        <member name="M:Z0.Pointers.prior(Z0.Ptr32@)">
            <summary>
            Advances the source by a uint
            </summary>
            <param name="src">The source pointer</param>
        </member>
        <member name="M:Z0.Pointers.prior(Z0.Ptr64@)">
            <summary>
            Advances the source by a uint
            </summary>
            <param name="src">The source pointer</param>
        </member>
        <member name="M:Z0.Pointers.ptr``1(``0*)">
            <summary>
            Creates a representation over a specified generic pointer
            </summary>
            <param name="pSrc">The source pointer</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.Pointers.pvoid(System.Void*)">
            <summary>
            Creates a void pointer representation
            </summary>
            <param name="pSrc">The pointer to represent</param>
        </member>
        <member name="M:Z0.Pointers.pvoid``1(Z0.Ptr{``0}@)">
            <summary>
            Creates a void pointer representation
            </summary>
            <param name="pSrc">The pointer to represent</param>
        </member>
        <member name="M:Z0.Pointers.pvoid(Z0.Ptr8@)">
            <summary>
            Transforms the source representation to a void representation
            </summary>
            <param name="src">The source</param>
        </member>
        <member name="M:Z0.Pointers.pvoid(System.Byte*)">
            <summary>
            Creates a void pointer representation
            </summary>
            <param name="pSrc">The pointer to represent</param>
        </member>
        <member name="M:Z0.Pointers.pvoid(System.UInt16*)">
            <summary>
            Creates a void pointer representation
            </summary>
            <param name="pSrc">The pointer to represent</param>
        </member>
        <member name="M:Z0.Pointers.pvoid(System.UInt32*)">
            <summary>
            Creates a void pointer representation
            </summary>
            <param name="pSrc">The pointer to represent</param>
        </member>
        <member name="M:Z0.Pointers.pvoid(System.UInt64*)">
            <summary>
            Creates a void pointer representation
            </summary>
            <param name="pSrc">The pointer to represent</param>
        </member>
        <member name="M:Z0.Pointers.seek``1(Z0.Ptr{``0}@,System.UInt32)">
            <summary>
            Advances the source by a T-measured offset
            </summary>
            <param name="src">The source pointer</param>
            <param name="count">The number of T-elements to advance</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.Pointers.seek(Z0.Ptr8@,System.UInt32)">
            <summary>
            Advances the source by a specified count
            </summary>
            <param name="src">The source pointer</param>
            <param name="count">The number of elements to skip</param>
        </member>
        <member name="M:Z0.Pointers.seek(Z0.Ptr16@,System.UInt32)">
            <summary>
            Advances the source by a uint
            </summary>
            <param name="src">The source pointer</param>
        </member>
        <member name="M:Z0.Pointers.seek(Z0.Ptr32@,System.UInt32)">
            <summary>
            Advances the source by a uint
            </summary>
            <param name="src">The source pointer</param>
        </member>
        <member name="M:Z0.Pointers.seek(Z0.Ptr64@,System.UInt32)">
            <summary>
            Advances the source by a uint
            </summary>
            <param name="src">The source pointer</param>
        </member>
        <member name="M:Z0.MemoryRangeParser.Parse(System.String)">
            <summary>
            Attempts to parse an address segment in standard form, [start,end]
            </summary>
            <param name="src">The source text</param>
        </member>
        <member name="M:Z0.MemoryRangeParser.ParseOption(System.String)">
            <summary>
            Attempts to parse an address segment in standard form, [start,end]
            </summary>
            <param name="src">The source text</param>
        </member>
        <member name="P:Z0.MemoryReader.HasNext">
            <summary>
            Specifies whether the reader can advance to and read the next cell
            </summary>
        </member>
        <member name="P:Z0.MemoryReader.Length">
            <summary>
            Specifies the length of the data source
            </summary>
        </member>
        <member name="P:Z0.MemoryReader.Remaining">
            <summary>
            Specifies the number of elements that remain to be read
            </summary>
        </member>
        <member name="T:Z0.MemoryReader`1">
            <summary>
            Defines a stream reader (of sorts) over a sequence of pointer-identified unmanaged values
            This ought to be fast, but if your looking for safe, many other choices would be better
            </summary>
        </member>
        <member name="M:Z0.MemoryReader`1.Read(`0@)">
            <summary>
            Deposits the next byte in a caller-supplied target and returns true if there are yet more bytes to read
            </summary>
            <param name="dst">The value of the next byte</param>
        </member>
        <member name="M:Z0.MemoryReader`1.Read(System.Int32,System.Int32,System.Span{`0})">
            <summary>
            Reads a specified number of elements if they exist or fewer if not and deposits the values in a caller-suppled target
            Returns the actual number of elements read
            </summary>
            <param name="offset">The offset at which to begin reading</param>
            <param name="wantedCount">The number of desired</param>
            <param name="dst">The target buffer</param>
        </member>
        <member name="M:Z0.MemoryReader`1.Read(System.Int32,System.Int32,`0@)">
            <summary>
            Reads a specified number of elements if they exist or fewer if not and deposits the values in a caller-suppled target
            Returns the actual number of elements read
            </summary>
            <param name="offset">The offset at which to begin reading</param>
            <param name="wantedCount">The number of desired</param>
            <param name="dst">The target buffer</param>
        </member>
        <member name="M:Z0.MemoryReader`1.Seek(System.UInt32)">
            <summary>
            If source value pos is within the range [0,Length), assigns Current = pos;
            otherwise, assigns Current = -1 and returns true if the former and false if the latter
            </summary>
            <param name="pos">The desired reader position</param>
        </member>
        <member name="P:Z0.MemoryReader`1.Position">
            <summary>
            The current position of the stream
            </summary>
        </member>
        <member name="P:Z0.MemoryReader`1.HasNext">
            <summary>
            Specifies whether the reader can advance to and read the next cell
            </summary>
        </member>
        <member name="P:Z0.MemoryReader`1.Length">
            <summary>
            Specifies the length of the data source
            </summary>
        </member>
        <member name="P:Z0.MemoryReader`1.Remaining">
            <summary>
            Specifies the number of elements that remain to be read
            </summary>
        </member>
        <member name="M:Z0.MemReaderState.Advance">
            <summary>
            Advances the stream to the next position, if any
            </summary>
        </member>
        <member name="M:Z0.MemReaderState.Advance(System.UInt32)">
            <summary>
            Advances the stream a specified number if elements, if possible
            </summary>
            <param name="count">The number of elements to advance</param>
        </member>
        <member name="M:Z0.MemReaderState.Seek(System.UInt32)">
            <summary>
            If source value pos is within the range [0,Length), assigns Current = pos;
            otherwise, assigns Current = -1 and returns true if the former and false if the latter
            </summary>
            <param name="pos">The desired reader position</param>
        </member>
        <member name="P:Z0.MemReaderState.HasNext">
            <summary>
            Specifies whether the reader can advance to and read the next cell
            </summary>
        </member>
        <member name="M:Z0.StringRefs.string(System.String,System.UInt32)">
            <summary>
            Creates a <see cref='T:Z0.StringRef'/> from a specified <see cref='T:System.String'/> and optional user data
            </summary>
            <param name="src">The source string</param>
            <param name="user">The user data, if any</param>
        </member>
        <member name="M:Z0.StringRefs.define(Z0.MemoryAddress,System.UInt32)">
            <summary>
            Creates a <see cref='T:Z0.StringRef'/> from a specified <see cref='T:Z0.MemoryAddress'/> and memory size
            </summary>
            <param name="address">The reference address</param>
            <param name="length">The size, in bytes, of the segment</param>
        </member>
        <member name="M:Z0.StringRefs.string(Z0.SegRef)">
            <summary>
            Creates a <see cref='T:Z0.StringRef'/> from a specified <see cref='T:Z0.SegRef'/>
            </summary>
            <param name="src">The source reference</param>
        </member>
        <member name="M:Z0.StringRefs.string(Z0.Ref)">
            <summary>
            Creates a <see cref='T:Z0.StringRef'/> from a specified <see cref='T:Z0.Ref'/>
            </summary>
            <param name="src">The source reference</param>
        </member>
        <member name="M:Z0.StringRefs.length(Z0.StringRef)">
            <summary>
            Computes the number of characters represented by a <see cref='T:Z0.StringRef'/>
            </summary>
            <param name="src">The source reference</param>
        </member>
        <member name="T:Z0.INamed">
            <summary>
            Characterizes something with a name
            </summary>
        </member>
        <member name="T:Z0.NamedValue`1">
            <summary>
            Names a value
            </summary>
        </member>
        <member name="F:Z0.NamedValue`1.Name">
            <summary>
            The name of the value
            </summary>
        </member>
        <member name="F:Z0.NamedValue`1.Value">
            <summary>
            The named value
            </summary>
        </member>
        <member name="T:Z0.Dependency`2">
            <summary>
            Captures a directed relation
            </summary>
        </member>
        <member name="F:Z0.Dependency`2.Source">
            <summary>
            The client in the relation that that depends on the <see cref='F:Z0.Dependency`2.Target'/>
            </summary>
        </member>
        <member name="F:Z0.Dependency`2.Target">
            <summary>
            The client-agnostic relation supplier
            </summary>
        </member>
        <member name="T:Z0.Relation`2">
            <summary>
            Defines a directed association from a source to a target
            </summary>
        </member>
        <member name="T:Z0.ComplexF32">
            <summary>
            Represents a 32-bit floating point complex number
            </summary>
        </member>
        <member name="M:Z0.ComplexF32.Load(System.Span{System.Single})">
            <summary>
            Loads a span of span of complext values from a source span where adjacent 
            entries (i,i+j) are interpreted respectively as real and imaginary components
            </summary>
            <param name="src">The source span, which must contain an even number of elements</param>
        </member>
        <member name="M:Z0.ComplexF32.op_Implicit(Z0.Complex{System.Single})~Z0.ComplexF32">
            <summary>
            Implicitly constructs a <see cref='T:Z0.ComplexF32'/> value from its equivalent generic representation
            </summary>
            <param name="src">The source value</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.ComplexF32.op_Implicit(Z0.ComplexF32)~Z0.Complex{System.Single}" -->
        <member name="M:Z0.ComplexF32.op_Equality(Z0.ComplexF32@,Z0.ComplexF32@)">
            <summary>
            Tests the operands for exact equality
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
        </member>
        <member name="M:Z0.ComplexF32.op_Inequality(Z0.ComplexF32@,Z0.ComplexF32@)">
            <summary>
            Tests the operands for inequality
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
        </member>
        <member name="M:Z0.ComplexF32.op_Subtraction(Z0.ComplexF32@,Z0.ComplexF32@)">
            <summary>
            Subtracts the second operand from the first
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
        </member>
        <member name="M:Z0.ComplexF32.op_Addition(Z0.ComplexF32@,Z0.ComplexF32@)">
            <summary>
            Adds the second operand to the first
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
        </member>
        <member name="M:Z0.ComplexF32.op_Implicit(System.ValueTuple{System.Single,System.Single}@)~Z0.ComplexF32">
            <summary>
            Implcitly converts a 2-tuple to a complex value
            </summary>
            <param name="x">The source value</param>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexF32.op_Implicit(Z0.ComplexF32@)~System.ValueTuple{System.Single,System.Single}">
            <summary>
            Implcitly converts a complex value to a 2-tuple
            </summary>
            <param name="x">The source value</param>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="F:Z0.ComplexF32.re">
            <summary>
            specifies the real component
            </summary>
        </member>
        <member name="F:Z0.ComplexF32.im">
            <summary>
            Specifies the imaginary component
            </summary>
        </member>
        <member name="M:Z0.ComplexF32.#ctor(System.ValueTuple{System.Single,System.Single}@)">
            <summary>
            Constructs the complex number from a tuple with real and imaginary parts
            </summary>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexF32.#ctor(System.Single,System.Single)">
            <summary>
            Constructs the complex number from real and imaginary components
            </summary>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexF32.Format(System.Boolean)">
            <summary>
            Formats the real and imaginar parts of a complex number in one of two canonical forms
            </summary>
            <param name="tupelize">Whether the value should be represented as a tuple (re,im) or in canonical form re +imi</param>
        </member>
        <member name="M:Z0.ComplexF32.Deconstruct(System.Single@,System.Single@)">
            <summary>
            Partitions the complex number into real and imanginary components
            </summary>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="T:Z0.ComplexF64">
            <summary>
            Represents a 32-bit floating point complex number
            </summary>
        </member>
        <member name="F:Z0.ComplexF64.re">
            <summary>
            Specifies the real component
            </summary>
        </member>
        <member name="F:Z0.ComplexF64.im">
            <summary>
            Specifies the imaginary component
            </summary>
        </member>
        <member name="M:Z0.ComplexF64.Load(System.Span{System.Double})">
            <summary>
            Loads a span of span of complext values from a source span where adjacent 
            entries (i,i+j) are interpreted respectively as real and imaginary components
            </summary>
            <param name="src">The source span, which must contain an even number of elements</param>
        </member>
        <member name="M:Z0.ComplexF64.op_Implicit(Z0.ComplexF64@)~System.ValueTuple{System.Double,System.Double}">
            <summary>
            Implcitly converts a complex value to a 2-tuple
            </summary>
            <param name="x">The source value</param>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.ComplexF64.op_Implicit(Z0.ComplexF64)~Z0.Complex{System.Double}" -->
        <member name="M:Z0.ComplexF64.op_Implicit(Z0.Complex{System.Double})~Z0.ComplexF64">
            <summary>
            Implicitly constructs a <see cref='T:Z0.ComplexF32'/> value from its equivalent generic representation
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.ComplexF64.op_Equality(Z0.ComplexF64@,Z0.ComplexF64@)">
            <summary>
            Tests the operands for exact equality
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
        </member>
        <member name="M:Z0.ComplexF64.op_Inequality(Z0.ComplexF64@,Z0.ComplexF64@)">
            <summary>
            Tests the operands for inequality
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
        </member>
        <member name="M:Z0.ComplexF64.op_Subtraction(Z0.ComplexF64@,Z0.ComplexF64@)">
            <summary>
            Subtracts the second operand from the first
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
        </member>
        <member name="M:Z0.ComplexF64.op_Addition(Z0.ComplexF64@,Z0.ComplexF64@)">
            <summary>
            Adds the second operand to the first
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
        </member>
        <member name="M:Z0.ComplexF64.op_Implicit(System.ValueTuple{System.Double,System.Double}@)~Z0.ComplexF64">
            <summary>
            Implcitly converts a 2-tuple to a complex value
            </summary>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexF64.#ctor(System.ValueTuple{System.Double,System.Double}@)">
            <summary>
            Constructs the complex number from a tuple with real and imaginary parts
            </summary>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexF64.#ctor(System.Double,System.Double)">
            <summary>
            Constructs the complex number from real and imaginary components
            </summary>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexF64.Deconstruct(System.Double@,System.Double@)">
            <summary>
            Partitions the complex number into real and imanginary components
            </summary>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexF64.Format(System.Boolean)">
            <summary>
            Formats the real and imaginar parts of a complex number in one of two canonical forms
            </summary>
            <param name="tupelize">Whether the value should be represented as a tuple (re,im) or in canonical form re +imi</param>
        </member>
        <member name="T:Z0.ComplexI16">
            <summary>
            Represents a complex value with signed 16-bit integer components
            </summary>
        </member>
        <member name="M:Z0.ComplexI16.Load(System.Span{System.Int16})">
            <summary>
            Loads a span of span of complext values from a source span where adjacent 
            entries (i,i+j) are shorterpreted respectively as real and imaginary components
            </summary>
            <param name="src">The source span, which must contain an even number of elements</param>
        </member>
        <member name="M:Z0.ComplexI16.op_Subtraction(Z0.ComplexI16@,Z0.ComplexI16@)">
            <summary>
            Subtracts the second operand from the first
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
        </member>
        <member name="M:Z0.ComplexI16.op_Addition(Z0.ComplexI16@,Z0.ComplexI16@)">
            <summary>
            Adds the second operand to the first
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
        </member>
        <member name="M:Z0.ComplexI16.op_Equality(Z0.ComplexI16@,Z0.ComplexI16@)">
            <summary>
            Tests the operands for equality
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
        </member>
        <member name="M:Z0.ComplexI16.op_Inequality(Z0.ComplexI16@,Z0.ComplexI16@)">
            <summary>
            Tests the operands for inequality
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
        </member>
        <member name="M:Z0.ComplexI16.op_Implicit(System.ValueTuple{System.Int16,System.Int16})~Z0.ComplexI16">
            <summary>
            Implcitly converts a 2-tuple to a complex value
            </summary>
            <param name="x">The source value</param>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexI16.op_Implicit(Z0.ComplexI16)~System.ValueTuple{System.Int16,System.Int16}">
            <summary>
            Implcitly converts a complex value to a 2-tuple
            </summary>
            <param name="x">The source value</param>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="F:Z0.ComplexI16.re">
            <summary>
            Specifies the real component
            </summary>
        </member>
        <member name="F:Z0.ComplexI16.im">
            <summary>
            Specifies the imaginary component
            </summary>
        </member>
        <member name="M:Z0.ComplexI16.#ctor(System.ValueTuple{System.Int16,System.Int16})">
            <summary>
            Constructs the complex number from a tuple with real and imaginary parts
            </summary>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexI16.#ctor(System.Int16,System.Int16)">
            <summary>
            Constructs the complex number from real and imaginary components
            </summary>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexI16.Deconstruct(System.Int16@,System.Int16@)">
            <summary>
            Partitions the complex number shorto real and imanginary components
            </summary>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexI16.Format(System.Boolean)">
            <summary>
            Formats the real and imaginar parts of a complex number in one of two canonical forms
            </summary>
            <param name="tupelize">Whether the value should be represented as a tuple (re,im) or in canonical form re +imi</param>
        </member>
        <member name="T:Z0.ComplexI32">
            <summary>
            Represents a complex value with signed 32-bit integer components
            </summary>
        </member>
        <member name="M:Z0.ComplexI32.Load(System.Span{System.Int32})">
            <summary>
            Loads a span of span of complext values from a source span where adjacent 
            entries (i,i+j) are interpreted respectively as real and imaginary components
            </summary>
            <param name="src">The source span, which must contain an even number of elements</param>
        </member>
        <member name="M:Z0.ComplexI32.op_Subtraction(Z0.ComplexI32@,Z0.ComplexI32@)">
            <summary>
            Subtracts the second operand from the first
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
        </member>
        <member name="M:Z0.ComplexI32.op_Addition(Z0.ComplexI32@,Z0.ComplexI32@)">
            <summary>
            Adds the second operand to the first
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
        </member>
        <member name="M:Z0.ComplexI32.op_Equality(Z0.ComplexI32@,Z0.ComplexI32@)">
            <summary>
            Tests the operands for equality
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
        </member>
        <member name="M:Z0.ComplexI32.op_Inequality(Z0.ComplexI32@,Z0.ComplexI32@)">
            <summary>
            Tests the operands for inequality
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
        </member>
        <member name="M:Z0.ComplexI32.op_Implicit(System.ValueTuple{System.Int32,System.Int32})~Z0.ComplexI32">
            <summary>
            Implcitly converts a 2-tuple to a complex value
            </summary>
            <param name="x">The source value</param>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexI32.op_Implicit(Z0.ComplexI32)~System.ValueTuple{System.Int32,System.Int32}">
            <summary>
            Implcitly converts a complex value to a 2-tuple
            </summary>
            <param name="x">The source value</param>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="F:Z0.ComplexI32.re">
            <summary>
            Specifies the real component
            </summary>
        </member>
        <member name="F:Z0.ComplexI32.im">
            <summary>
            Specifies the imaginary component
            </summary>
        </member>
        <member name="M:Z0.ComplexI32.#ctor(System.ValueTuple{System.Int32,System.Int32})">
            <summary>
            Constructs the complex number from a tuple with real and imaginary parts
            </summary>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexI32.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructs the complex number from real and imaginary components
            </summary>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexI32.Deconstruct(System.Int32@,System.Int32@)">
            <summary>
            Partitions the complex number into real and imanginary components
            </summary>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexI32.Format(System.Boolean)">
            <summary>
            Formats the real and imaginar parts of a complex number in one of two canonical forms
            </summary>
            <param name="tupelize">Whether the value should be represented as a tuple (re,im) or in canonical form re +imi</param>
        </member>
        <member name="T:Z0.ComplexI64">
            <summary>
            Represents a complex value with signed 64-bit integer components
            </summary>
        </member>
        <member name="M:Z0.ComplexI64.Load(System.Span{System.Int64})">
            <summary>
            Loads a span of span of complext values from a source span where adjacent 
            entries (i,i+j) are interpreted respectively as real and imaginary components
            </summary>
            <param name="src">The source span, which must contain an even number of elements</param>
        </member>
        <member name="M:Z0.ComplexI64.op_Equality(Z0.ComplexI64@,Z0.ComplexI64@)">
            <summary>
            Tests the operands for equality
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
        </member>
        <member name="M:Z0.ComplexI64.op_Inequality(Z0.ComplexI64@,Z0.ComplexI64@)">
            <summary>
            Tests the operands for inequality
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
        </member>
        <member name="M:Z0.ComplexI64.op_Implicit(System.ValueTuple{System.Int64,System.Int64}@)~Z0.ComplexI64">
            <summary>
            Implcitly converts a 2-tuple to a complex value
            </summary>
            <param name="x">The source value</param>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexI64.op_Implicit(Z0.ComplexI64@)~System.ValueTuple{System.Int64,System.Int64}">
            <summary>
            Implcitly converts a complex value to a 2-tuple
            </summary>
            <param name="x">The source value</param>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="F:Z0.ComplexI64.re">
            <summary>
            Specifies the real component
            </summary>
        </member>
        <member name="F:Z0.ComplexI64.im">
            <summary>
            Specifies the imaginary component
            </summary>
        </member>
        <member name="M:Z0.ComplexI64.#ctor(System.ValueTuple{System.Int64,System.Int64})">
            <summary>
            Constructs the complex number from a tuple with real and imaginary parts
            </summary>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexI64.#ctor(System.Int64,System.Int64)">
            <summary>
            Constructs the complex number from real and imaginary components
            </summary>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexI64.Deconstruct(System.Int64@,System.Int64@)">
            <summary>
            Partitions the complex number into real and imanginary components
            </summary>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexI64.Format(System.Boolean)">
            <summary>
            Renders the value as a string per supplied options
            </summary>
            <param name="tupelize">Whether the value should be represented as a tuple (re,im) or in canonical form re +imi</param>
        </member>
        <member name="T:Z0.ComplexI8">
            <summary>
            Represents a complex value with signed 8-bit integer components
            </summary>
        </member>
        <member name="M:Z0.ComplexI8.Load(System.Span{System.SByte})">
            <summary>
            Loads a span of span of complext values from a source span where adjacent 
            entries (i,i+j) are interpreted respectively as real and imaginary components
            </summary>
            <param name="src">The source span, which must contain an even number of elements</param>
        </member>
        <member name="M:Z0.ComplexI8.op_Subtraction(Z0.ComplexI8@,Z0.ComplexI8@)">
            <summary>
            Subtracts the second operand from the first
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
        </member>
        <member name="M:Z0.ComplexI8.op_Addition(Z0.ComplexI8@,Z0.ComplexI8@)">
            <summary>
            Adds the second operand to the first
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
        </member>
        <member name="M:Z0.ComplexI8.op_Equality(Z0.ComplexI8@,Z0.ComplexI8@)">
            <summary>
            Tests the operands for equality
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
        </member>
        <member name="M:Z0.ComplexI8.op_Inequality(Z0.ComplexI8@,Z0.ComplexI8@)">
            <summary>
            Tests the operands for inequality
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
        </member>
        <member name="M:Z0.ComplexI8.op_Implicit(System.ValueTuple{System.SByte,System.SByte})~Z0.ComplexI8">
            <summary>
            Implcitly converts a 2-tuple to a complex value
            </summary>
            <param name="x">The source value</param>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexI8.op_Implicit(Z0.ComplexI8)~System.ValueTuple{System.SByte,System.SByte}">
            <summary>
            Implcitly converts a complex value to a 2-tuple
            </summary>
            <param name="x">The source value</param>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="F:Z0.ComplexI8.re">
            <summary>
            Specifies the real component
            </summary>
        </member>
        <member name="F:Z0.ComplexI8.im">
            <summary>
            Specifies the imaginary component
            </summary>
        </member>
        <member name="M:Z0.ComplexI8.#ctor(System.ValueTuple{System.SByte,System.SByte})">
            <summary>
            Constructs the complex number from a tuple with real and imaginary parts
            </summary>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexI8.#ctor(System.SByte,System.SByte)">
            <summary>
            Constructs the complex number from real and imaginary components
            </summary>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexI8.Deconstruct(System.SByte@,System.SByte@)">
            <summary>
            Partitions the complex number into real and imanginary components
            </summary>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexI8.Format(System.Boolean)">
            <summary>
            Formats the real and imaginar parts of a complex number in one of two canonical forms
            </summary>
            <param name="tupelize">Whether the value should be represented as a tuple (re,im) or in canonical form re +imi</param>
        </member>
        <member name="T:Z0.Complex`1">
            <summary>
            Defines a complex number parameterized over the primal types
            </summary>
        </member>
        <member name="M:Z0.Complex`1.Format(`0,`0,System.Boolean)">
            <summary>
            Formats the real and imaginar parts of a complex number in one of two canonical forms
            </summary>
            <param name="re">The real part</param>
            <param name="im">The imaginary part</param>
            <param name="tupelize">Whether the value should be represented as a tuple (re,im) or in canonical form re +imi</param>
        </member>
        <member name="M:Z0.Complex`1.Hash(`0,`0)">
            <summary>
            Creates a combined hash code for the real and imaginary parts of a complex number
            </summary>
            <param name="re">The real part</param>
            <param name="im">The imaginary part</param>
        </member>
        <member name="M:Z0.Complex`1.op_Implicit(System.ValueTuple{`0,`0})~Z0.Complex{`0}">
            <summary>
            Implicitly constructs a generic complex value from an ordered pair
            interpreted as the real/imaginary parts, respectively, of a 
            complex number
            </summary>
            <param name="re">The real part</param>
            <param name="im">The imaginary part</param>
            <typeparam name="T">The underlying primal type</typeparam>
        </member>
        <member name="M:Z0.Complex`1.op_Implicit(Z0.Complex{`0})~System.ValueTuple{`0,`0}">
            <summary>
            Implictly constructes an ordered pair consisting respectively of
            the real an imaginary parts of the source value
            </summary>
            <param name="re">The real part</param>
            <param name="im">The imaginary part</param>
        </member>
        <member name="M:Z0.Complex`1.op_Equality(Z0.Complex{`0}@,Z0.Complex{`0}@)">
            <summary>
            Tests the operands for exact equality
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
        </member>
        <member name="M:Z0.Complex`1.op_Inequality(Z0.Complex{`0}@,Z0.Complex{`0}@)">
            <summary>
            Tests the operands for inequality
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
        </member>
        <member name="M:Z0.Complex`1.Deconstruct(`0@,`0@)">
            <summary>
            Partitions the complex number into real and imanginary components
            </summary>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="T:Z0.ComplexU16">
            <summary>
            Represents a complex value with unsigned 16-bit integer components
            </summary>
        </member>
        <member name="M:Z0.ComplexU16.Load(System.Span{System.UInt16})">
            <summary>
            Loads a span of span of complext values from a source span where adjacent 
            entries (i,i+j) are interpreted respectively as real and imaginary components
            </summary>
            <param name="src">The source span, which must contain an even number of elements</param>
        </member>
        <member name="M:Z0.ComplexU16.op_Equality(Z0.ComplexU16@,Z0.ComplexU16@)">
            <summary>
            Tests the operands for equality
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
        </member>
        <member name="M:Z0.ComplexU16.op_Inequality(Z0.ComplexU16@,Z0.ComplexU16@)">
            <summary>
            Tests the operands for inequality
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
        </member>
        <member name="M:Z0.ComplexU16.op_Implicit(System.ValueTuple{System.UInt16,System.UInt16}@)~Z0.ComplexU16">
            <summary>
            Implcitly converts a 2-tuple to a complex value
            </summary>
            <param name="x">The source value</param>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexU16.op_Implicit(Z0.ComplexU16@)~System.ValueTuple{System.UInt16,System.UInt16}">
            <summary>
            Implcitly converts a complex value to a 2-tuple
            </summary>
            <param name="x">The source value</param>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="F:Z0.ComplexU16.re">
            <summary>
            Specifies the real component
            </summary>
        </member>
        <member name="F:Z0.ComplexU16.im">
            <summary>
            Specifies the imaginary component
            </summary>
        </member>
        <member name="M:Z0.ComplexU16.#ctor(System.ValueTuple{System.UInt16,System.UInt16})">
            <summary>
            Constructs the complex number from a tuple with real and imaginary parts
            </summary>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexU16.#ctor(System.UInt16,System.UInt16)">
            <summary>
            Constructs the complex number from real and imaginary components
            </summary>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexU16.Deconstruct(System.UInt16@,System.UInt16@)">
            <summary>
            Partitions the complex number into real and imanginary components
            </summary>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexU16.Format(System.Boolean)">
            <summary>
            Renders the value as a string per supplied options
            </summary>
            <param name="tupelize">Whether the value should be represented as a tuple (re,im) or in canonical form re +imi</param>
        </member>
        <member name="T:Z0.ComplexU32">
            <summary>
            Represents a complex value with unsigned 32-bit integer components
            </summary>
        </member>
        <member name="M:Z0.ComplexU32.Load(System.Span{System.UInt32})">
            <summary>
            Loads a span of span of complext values from a source span where adjacent 
            entries (i,i+j) are interpreted respectively as real and imaginary components
            </summary>
            <param name="src">The source span, which must contain an even number of elements</param>
        </member>
        <member name="M:Z0.ComplexU32.op_Equality(Z0.ComplexU32@,Z0.ComplexU32@)">
            <summary>
            Tests the operands for equality
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
        </member>
        <member name="M:Z0.ComplexU32.op_Inequality(Z0.ComplexU32@,Z0.ComplexU32@)">
            <summary>
            Tests the operands for inequality
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
        </member>
        <member name="M:Z0.ComplexU32.op_Implicit(System.ValueTuple{System.UInt32,System.UInt32}@)~Z0.ComplexU32">
            <summary>
            Implcitly converts a 2-tuple to a complex value
            </summary>
            <param name="x">The source value</param>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexU32.op_Implicit(Z0.ComplexU32@)~System.ValueTuple{System.UInt32,System.UInt32}">
            <summary>
            Implcitly converts a complex value to a 2-tuple
            </summary>
            <param name="x">The source value</param>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="F:Z0.ComplexU32.re">
            <summary>
            Specifies the real component
            </summary>
        </member>
        <member name="F:Z0.ComplexU32.im">
            <summary>
            Specifies the imaginary component
            </summary>
        </member>
        <member name="M:Z0.ComplexU32.#ctor(System.ValueTuple{System.UInt32,System.UInt32})">
            <summary>
            Constructs the complex number from a tuple with real and imaginary parts
            </summary>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexU32.#ctor(System.UInt32,System.UInt32)">
            <summary>
            Constructs the complex number from real and imaginary components
            </summary>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexU32.Deconstruct(System.UInt32@,System.UInt32@)">
            <summary>
            Partitions the complex number into real and imanginary components
            </summary>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexU32.Format(System.Boolean)">
            <summary>
            Renders the value as a string per supplied options
            </summary>
            <param name="tupelize">Whether the value should be represented as a tuple (re,im) or in canonical form re +imi</param>
        </member>
        <member name="T:Z0.ComplexU64">
            <summary>
            Represents a complex value with unsigned 64-bit integer components
            </summary>
        </member>
        <member name="M:Z0.ComplexU64.Load(System.Span{System.UInt64})">
            <summary>
            Loads a span of span of complext values from a source span where adjacent 
            entries (i,i+j) are interpreted respectively as real and imaginary components
            </summary>
            <param name="src">The source span, which must contain an even number of elements</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.ComplexU64.op_Implicit(Z0.ComplexU64)~Z0.Complex{System.UInt64}" -->
        <member name="M:Z0.ComplexU64.op_Implicit(Z0.Complex{System.UInt64})~Z0.ComplexU64">
            <summary>
            Implicitly constructs a <see cref='T:Z0.ComplexF32'/> value from its equivalent generic representation
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.ComplexU64.op_Equality(Z0.ComplexU64@,Z0.ComplexU64@)">
            <summary>
            Tests the operands for equality
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
        </member>
        <member name="M:Z0.ComplexU64.op_Inequality(Z0.ComplexU64@,Z0.ComplexU64@)">
            <summary>
            Tests the operands for inequality
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
        </member>
        <member name="M:Z0.ComplexU64.op_Implicit(System.ValueTuple{System.UInt64,System.UInt64}@)~Z0.ComplexU64">
            <summary>
            Implcitly converts a 2-tuple to a complex value
            </summary>
            <param name="x">The source value</param>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexU64.op_Implicit(Z0.ComplexU64@)~System.ValueTuple{System.UInt64,System.UInt64}">
            <summary>
            Implcitly converts a complex value to a 2-tuple
            </summary>
            <param name="x">The source value</param>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="F:Z0.ComplexU64.re">
            <summary>
            Specifies the real component
            </summary>
        </member>
        <member name="F:Z0.ComplexU64.im">
            <summary>
            Specifies the imaginary component
            </summary>
        </member>
        <member name="M:Z0.ComplexU64.#ctor(System.ValueTuple{System.UInt64,System.UInt64})">
            <summary>
            Constructs the complex number from a tuple with real and imaginary parts
            </summary>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexU64.#ctor(System.UInt64,System.UInt64)">
            <summary>
            Constructs the complex number from real and imaginary components
            </summary>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexU64.Deconstruct(System.UInt64@,System.UInt64@)">
            <summary>
            Partitions the complex number into real and imanginary components
            </summary>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexU64.Format(System.Boolean)">
            <summary>
            Formats the real and imaginar parts of a complex number in one of two canonical forms
            </summary>
            <param name="tupelize">Whether the value should be represented as a tuple (re,im) or in canonical form re +imi</param>
        </member>
        <member name="T:Z0.ComplexU8">
            <summary>
            Represents a complex value with unsigned 8-bit integer components
            </summary>
        </member>
        <member name="F:Z0.ComplexU8.re">
            <summary>
            Specifies the real component
            </summary>
        </member>
        <member name="F:Z0.ComplexU8.im">
            <summary>
            Specifies the imaginary component
            </summary>
        </member>
        <member name="M:Z0.ComplexU8.Load(System.Span{System.Byte})">
            <summary>
            Loads a span of span of complext values from a source span where adjacent 
            entries (i,i+j) are interpreted respectively as real and imaginary components
            </summary>
            <param name="src">The source span, which must contain an even number of elements</param>
        </member>
        <member name="M:Z0.ComplexU8.op_Equality(Z0.ComplexU8@,Z0.ComplexU8@)">
            <summary>
            Tests the operands for equality
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
        </member>
        <member name="M:Z0.ComplexU8.op_Inequality(Z0.ComplexU8@,Z0.ComplexU8@)">
            <summary>
            Tests the operands for inequality
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
        </member>
        <member name="M:Z0.ComplexU8.op_Implicit(System.ValueTuple{System.Byte,System.Byte})~Z0.ComplexU8">
            <summary>
            Implcitly converts a 2-tuple to a complex value
            </summary>
            <param name="x">The source value</param>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexU8.op_Implicit(Z0.ComplexU8)~System.ValueTuple{System.Byte,System.Byte}">
            <summary>
            Implcitly converts a complex value to a 2-tuple
            </summary>
            <param name="x">The source value</param>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexU8.#ctor(System.ValueTuple{System.Byte,System.Byte})">
            <summary>
            Constructs the complex number from a tuple with real and imaginary parts
            </summary>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexU8.#ctor(System.Byte,System.Byte)">
            <summary>
            Constructs the complex number from real and imaginary components
            </summary>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexU8.Deconstruct(System.Byte@,System.Byte@)">
            <summary>
            Partitions the complex number into real and imanginary components
            </summary>
            <param name="re">The real component</param>
            <param name="im">The imaginary component</param>
        </member>
        <member name="M:Z0.ComplexU8.Format(System.Boolean)">
            <summary>
            Renders the value as a string per supplied options
            </summary>
            <param name="tupelize">Whether the value should be represented as a tuple (re,im) or in canonical form re +imi</param>
        </member>
        <member name="M:Z0.NumericKinds.contains(Z0.NumericKind,Z0.NumericApiClass)">
            <summary>
            Tests whether an identified type is of specified numeric kind
            </summary>
            <param name="kind">The source kind</param>
            <param name="id">The kind to match</param>
        </member>
        <member name="M:Z0.NumericKinds.floating(Z0.NumericKind)">
            <summary>
            Determines whether a numeric kind designates a floating-point type
            </summary>
            <param name="T">The type to test</param>
        </member>
        <member name="M:Z0.NumericKinds.floating``1">
            <summary>
            Returns true if a parametric type is of floating-point numeric type, false otherwise
            </summary>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.NumericKinds.floating(System.Type)">
            <summary>
            Returns true if the source type is a primal floating point type, false otherwise
            </summary>
        </member>
        <member name="M:Z0.NumericKinds.floating(System.Object)">
            <summary>
            Returns true if a value is of floating-point numeric type, false otherwise
            </summary>
        </member>
        <member name="M:Z0.NumericKinds.FloatingTypes">
            <summary>
            recognized floating-point types
            </summary>
        </member>
        <member name="M:Z0.NumericKinds.FloatingKindSeq">
            <summary>
            Recognized floating-point kinds
            </summary>
        </member>
        <member name="M:Z0.NumericKinds.char(Z0.NumericIndicator)">
            <summary>
            Converts a numeric indicator to a character
            </summary>
            <param name="src">The source kind</param>
        </member>
        <member name="M:Z0.NumericKinds.format(Z0.NumericIndicator)">
            <summary>
            Produces text in the form {'i' | 'u' | 'f'}
            </summary>
            <param name="src">The source kind</param>
        </member>
        <member name="M:Z0.NumericKinds.format(Z0.NumericKind)">
            <summary>
            Produces text in the form {width}{indicator}
            </summary>
            <param name="k">The source kind</param>
        </member>
        <member name="M:Z0.NumericKinds.indicator(Z0.NumericKind)">
            <summary>
            Determines the indicator of a numeric kind
            </summary>
            <param name="src">The source kind</param>
        </member>
        <member name="M:Z0.NumericKinds.keyword(Z0.NumericKind)">
            <summary>
            Specifies the C# keyword used to designate a kind-identified primal type
            </summary>
        </member>
        <member name="M:Z0.NumericKinds.nonkeyword(Z0.NumericKind)">
            <summary>
            Specifies the keyword not used in C# to designate a kind-identified primal type
            </summary>
        </member>
        <member name="M:Z0.NumericKinds.kind(System.Type)">
            <summary>
            Determines the numeric kind of a system type
            </summary>
            <param name="src">The source type</param>
        </member>
        <member name="M:Z0.NumericKinds.kind(System.TypeCode)">
            <summary>
            Determines the numeric kind identified by a type code, if any
            </summary>
            <param name="tc">The type code to evaluate</param>
        </member>
        <member name="M:Z0.NumericKinds.kind(Z0.NumericWidth,Z0.NumericIndicator)">
            <summary>
            Computes the numeric kind determined by a bit-width and numeric indicator
            </summary>
            <param name="nw">The type width, in bits</param>
            <param name="ni">The numeric indicator</param>
        </member>
        <member name="M:Z0.NumericKinds.kind``1">
            <summary>
            Determines the numeric kind of a parametrically-identified type
            </summary>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="P:Z0.NumericKinds.i8">
            <summary>
            Specifies the int8 kind
            </summary>
        </member>
        <member name="P:Z0.NumericKinds.u8">
            <summary>
            Specifies the uint8 kind
            </summary>
        </member>
        <member name="P:Z0.NumericKinds.i16">
            <summary>
            Specifies the int16 kind
            </summary>
        </member>
        <member name="P:Z0.NumericKinds.u16">
            <summary>
            Specifies the uint16 kind
            </summary>
        </member>
        <member name="P:Z0.NumericKinds.i32">
            <summary>
            Specifies the int32 kind
            </summary>
        </member>
        <member name="P:Z0.NumericKinds.u32">
            <summary>
            Specifies the uint32 kind
            </summary>
        </member>
        <member name="P:Z0.NumericKinds.i64">
            <summary>
            Specifies the int64 kind
            </summary>
        </member>
        <member name="P:Z0.NumericKinds.u64">
            <summary>
            Specifies the uint64 kind
            </summary>
        </member>
        <member name="P:Z0.NumericKinds.f32">
            <summary>
            Specifies the float32 kind
            </summary>
        </member>
        <member name="P:Z0.NumericKinds.f64">
            <summary>
            Specifies the float64 kind
            </summary>
        </member>
        <member name="M:Z0.NumericKinds.IntegralTypes">
            <summary>
            Recognized integral types
            </summary>
        </member>
        <member name="M:Z0.NumericKinds.IntegralKindSeq">
            <summary>
            Recognized integral kinds
            </summary>
        </member>
        <member name="M:Z0.NumericKinds.NumericTypes">
            <summary>
            Recognized numeric types
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.NumericKinds.signed(Z0.NumericKind)" -->
        <member name="M:Z0.NumericKinds.signed``1">
            <summary>
            Returns true if a parametric type is of signed numeric type, false otherwise
            </summary>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.NumericKinds.signed(System.Type)">
            <summary>
            Returns true if the source type is a primal signed type, false otherwise
            </summary>
            <param name="src">The source type</param>
        </member>
        <member name="M:Z0.NumericKinds.signed(System.Object)">
            <summary>
            Returns true if a value is of signed numeric type, false otherwise
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.NumericKinds.SignedTypes">
            <summary>
            Recognized signed integral kinds
            </summary>
        </member>
        <member name="M:Z0.NumericKinds.SignedKindSeq">
            <summary>
            Recognized signed integral kinds
            </summary>
        </member>
        <member name="M:Z0.NumericKinds.test(System.Type)">
            <summary>
            Returns true if a type is a numeric type, false otherwise
            </summary>
            <param name="src">The source type</param>
        </member>
        <member name="M:Z0.NumericKinds.type(Z0.NumericKind)">
            <summary>
            Returns a kind-identified system type if possible; throws an exception otherwise
            </summary>
            <param name="k">The identifying kind</param>
        </member>
        <member name="M:Z0.NumericKinds.unsigned(Z0.NumericKind)">
            <summary>
            Determines whether a numeric kind designates an unsigned integral type
            </summary>
            <typeparam name="T">The type to test</typeparam>
        </member>
        <member name="M:Z0.NumericKinds.unsigned``1">
            <summary>
            Returns true if a parametric type is of unsigned numeric type, false otherwise
            </summary>
            <typeparam name="T">The type to evaluate</typeparam>
        </member>
        <member name="M:Z0.NumericKinds.unsigned(System.Type)">
            <summary>
            Returns true if a type is of unsigned numeric type, false otherwise
            </summary>
        </member>
        <member name="M:Z0.NumericKinds.unsigned(System.Object)">
            <summary>
            Returns true if a value is of unsigned numeric type, false otherwise
            </summary>
        </member>
        <member name="M:Z0.NumericKinds.UnsignedTypes">
            <summary>
            Recognized unsigned integral types
            </summary>
        </member>
        <member name="M:Z0.NumericKinds.UnsignedKindSeq">
            <summary>
            Recognized unsigned integral kinds
            </summary>
        </member>
        <member name="M:Z0.NumericKinds.width(Z0.NumericKind)">
            <summary>
            Determines the width of the identified numeric type
            </summary>
            <param name="kind">The source kind</param>
        </member>
        <member name="M:Z0.XNumericKinds.IsFloat(Z0.NumericKind)">
            <summary>
            Determines whether a numeric kind designates a floating-point type
            </summary>
            <param name="T">The type to test</param>
        </member>
        <member name="M:Z0.XNumericKinds.IsSome(Z0.NumericKind)">
            <summary>
            Determines whether a numeric kind is nonempty
            </summary>
            <param name="k">The kind to examine</param>
        </member>
        <member name="M:Z0.XNumericKinds.IsUnsigned(Z0.NumericKind)">
            <summary>
            Determines whether a numeric kind designates an unsigned integral type
            </summary>
        </member>
        <member name="M:Z0.XNumericKinds.NumericId(Z0.NumericKind)">
            <summary>
            Determines the type identifer of a numeric kind
            </summary>
            <param name="kind">The source kind</param>
        </member>
        <member name="M:Z0.XNumericKinds.ToChar(Z0.NumericIndicator)">
            <summary>
            Converts a numeric indicator to a character
            </summary>
            <param name="src">The source kind</param>
        </member>
        <member name="M:Z0.XNumericKinds.Format(Z0.NumericIndicator)">
            <summary>
            Produces text in the form {'i' | 'u' | 'f'}
            </summary>
            <param name="src">The source kind</param>
        </member>
        <member name="M:Z0.XNumericKinds.Format(Z0.NumericKind)">
            <summary>
            Produces text in the form {width}{indicator}
            </summary>
            <param name="k">The source kind</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.XNumericKinds.IsSigned(Z0.NumericKind)" -->
        <member name="M:Z0.XNumericKinds.Indicator(Z0.NumericKind)">
            <summary>
            Determines the indicator of a numeric kind
            </summary>
            <param name="src">The source kind</param>
        </member>
        <member name="M:Z0.XNumericKinds.Keyword(Z0.NumericKind)">
            <summary>
            Specifies the C# keyword used to designate a kind-identified numeric type
            </summary>
        </member>
        <member name="M:Z0.XNumericKinds.KeywordNot(Z0.NumericKind)">
            <summary>
            Specifies the keyword not used in C# to designate a kind-identified primal type
            </summary>
        </member>
        <member name="M:Z0.XNumericKinds.NumericKeyword(System.Type)">
            <summary>
            Specifies the C# keyword used to designate a primal numeric type
            </summary>
            <param name="src">The type to examine</param>
        </member>
        <member name="M:Z0.XNumericKinds.NumericKeywordNot(System.Type)">
            <summary>
            Specifies the keyword not used in C# to designate a primal numeric type
            </summary>
            <param name="src">The type to examine</param>
        </member>
        <member name="M:Z0.XNumericKinds.TypeWidth(Z0.NumericKind)">
            <summary>
            Determines the width of a numeric kind
            </summary>
            <param name="kind">The source kind</param>
        </member>
        <member name="M:Z0.XNumericKinds.Width(Z0.NumericKind)">
            <summary>
            Determines the width of the represented kind in bits
            </summary>
            <param name="k">The kind to examine</param>
        </member>
        <member name="M:Z0.XNumericKinds.Size(Z0.NumericKind)">
            <summary>
            Determines the width of the represented kind in bytes
            </summary>
            <param name="k">The kind to examine</param>
        </member>
        <member name="M:Z0.XNumericKinds.SystemType(Z0.NumericKind)">
            <summary>
            Determines the system type represented by a numeric kind
            </summary>
            <param name="src">The source kind</param>
        </member>
        <member name="M:Z0.XNumericKinds.NumericKind(System.Type)">
            <summary>
            Determines the numeric kind of a type
            </summary>
            <param name="src">The type to examine</param>
        </member>
        <member name="M:Z0.XNumericKinds.NumericKind(System.TypeCode)">
            <summary>
            Determines the numeric kind of a type-code identified type
            </summary>
            <param name="tc">The type code to evaluate</param>
        </member>
        <member name="T:Z0.NumericLiteral">
            <summary>
            Defines a (boxed) numeric literal relative to a specified base
            </summary>
        </member>
        <member name="T:Z0.NumericLiteral`1">
            <summary>
            Defines a numeric literal relative to a specified base
            </summary>
        </member>
        <member name="T:Z0.NumericBaseIndicator">
            <summary>
            Defines common numeric base indicators that prefix or suffix a numeric literal
            to designate the literal's numeric base
            </summary>
        </member>
        <member name="F:Z0.NumericBaseIndicator.Base2">
            <summary>
            Identifies base 2, binary
            </summary>
        </member>
        <member name="F:Z0.NumericBaseIndicator.Base3">
            <summary>
            Identifies base 3, ternary
            </summary>
        </member>
        <member name="F:Z0.NumericBaseIndicator.Base8">
            <summary>
            Identifies base 8, octal
            </summary>
        </member>
        <member name="F:Z0.NumericBaseIndicator.Base10">
            <summary>
            Identifies base 10, decimal
            </summary>
        </member>
        <member name="F:Z0.NumericBaseIndicator.Base16">
            <summary>
            Identifies base 16, hex
            </summary>
        </member>
        <member name="F:Z0.NumericLiterals.z8i">
            <summary>
            The zero-value for an 8-bit signed integer
            </summary>
        </member>
        <member name="F:Z0.NumericLiterals.z8">
            <summary>
            The zero-value for an 8-bit unsigned integer
            </summary>
        </member>
        <member name="F:Z0.NumericLiterals.z16i">
            <summary>
            The zero-value for a 16-bit signed integer
            </summary>
        </member>
        <member name="F:Z0.NumericLiterals.z16">
            <summary>
            The zero-value for a 16-bit unsigned integer
            </summary>
        </member>
        <member name="F:Z0.NumericLiterals.z32i">
            <summary>
            The zero-value for a 32-bit signed integer
            </summary>
        </member>
        <member name="F:Z0.NumericLiterals.z32">
            <summary>
            The zero-value for a 32-bit unsigned integer
            </summary>
        </member>
        <member name="F:Z0.NumericLiterals.z64i">
            <summary>
            The zero-value for a 64-bit signed integer
            </summary>
        </member>
        <member name="F:Z0.NumericLiterals.z64">
            <summary>
            The zero-value for a 64-bit unsigned integer
            </summary>
        </member>
        <member name="F:Z0.NumericLiterals.z32f">
            <summary>
            The zero-value for a 32-bit float
            </summary>
        </member>
        <member name="F:Z0.NumericLiterals.z64f">
            <summary>
            The zero-value for a 64-bit float
            </summary>
        </member>
        <member name="F:Z0.NumericLiterals.i8max">
            <summary>
            The maximum value for an 8-bit signed integer
            </summary>
        </member>
        <member name="F:Z0.NumericLiterals.u8max">
            <summary>
            The maximum value for an 8-bit unsigned integer
            </summary>
        </member>
        <member name="F:Z0.NumericLiterals.i16max">
            <summary>
            The maximum value for a 16-bit signed integer
            </summary>
        </member>
        <member name="F:Z0.NumericLiterals.u16max">
            <summary>
            The maximum value for a 16-bit unsigned integer
            </summary>
        </member>
        <member name="F:Z0.NumericLiterals.i32max">
            <summary>
            The maximum value for a 32-bit signed integer
            </summary>
        </member>
        <member name="F:Z0.NumericLiterals.u32max">
            <summary>
            The maximum value for a 32-bit unsigned integer
            </summary>
        </member>
        <member name="F:Z0.NumericLiterals.i64max">
            <summary>
            The maximum value for a 64-bit signed integer
            </summary>
        </member>
        <member name="F:Z0.NumericLiterals.u64max">
            <summary>
            The maximum value for a 64-bit unsigned integer
            </summary>
        </member>
        <member name="F:Z0.NumericLiterals.f32max">
            <summary>
            The maximum value for a 32-bit float
            </summary>
        </member>
        <member name="F:Z0.NumericLiterals.f64max">
            <summary>
            The maximum value for a 64-bit float
            </summary>
        </member>
        <member name="F:Z0.NumericLiterals.i8min">
            <summary>
            The minimum value for an 8-bit signed integer
            </summary>
        </member>
        <member name="F:Z0.NumericLiterals.i16min">
            <summary>
            The minimum value for a 16-bit signed integer
            </summary>
        </member>
        <member name="F:Z0.NumericLiterals.i32min">
            <summary>
            The minimum value for a 32-bit signed integer
            </summary>
        </member>
        <member name="F:Z0.NumericLiterals.i64min">
            <summary>
            The minimum value for a 64-bit signed integer
            </summary>
        </member>
        <member name="M:Z0.NumericLiterals.zero``1(``0)">
            <summary>
            Returns generic 0 for a primal source type
            </summary>
            <param name="t">A primal type representative</param>
            <typeparam name="T">The primal source type</typeparam>
        </member>
        <member name="M:Z0.NumericLiterals.one``1(``0)">
            <summary>
            Returns generic 1 for a primal source type
            </summary>
            <param name="t">A primal type representative</param>
            <typeparam name="T">The primal source type</typeparam>
        </member>
        <member name="M:Z0.NumericLiterals.ones``1(``0)">
            <summary>
            Ones all bits each and every ... one
            </summary>
            <param name="t">A primal type representative</param>
            <typeparam name="T">The primal source type</typeparam>
        </member>
        <member name="M:Z0.NumericLiterals.minval``1(``0)">
            <summary>
            Returns the minimum value supported by a parametrically-identified primal type
            </summary>
            <typeparam name="T">The primal source type</typeparam>
        </member>
        <member name="M:Z0.NumericLiterals.maxval``1(``0)">
            <summary>
            Returns the maximim value supported by a parametrically-identified primal type
            </summary>
            <typeparam name="T">The primal source type</typeparam>
        </member>
        <member name="M:Z0.NumericParser.transposition``1(System.String)">
            <summary>
            Parses a transposition in canonical form (i j), if possible; otherwise returns the empty transposition
            </summary>
            <param name="src">The source text</param>
        </member>
        <member name="M:Z0.NumericParser.infallible``1">
            <summary>
            Creates an infallible numeric parser
            </summary>
            <typeparam name="T">The numeric type to parse</typeparam>
        </member>
        <member name="M:Z0.NumericParser.parse``1(System.String)">
            <summary>
            Attempts to parse the source text as a parametrically-identified type
            </summary>
            <param name="src">The source text</param>
        </member>
        <member name="M:Z0.Cast.to``2(``0)">
            <summary>
            Unconditionally casts from one numeric kind to another
            </summary>
            <param name="src">The source value</param>
            <typeparam name="S">The source numeric kind</typeparam>
            <typeparam name="T">The target numeric kind</typeparam>
        </member>
        <member name="M:Z0.NumericCast.force``1(System.Single,``0)">
            <summary>
            If possible, applies the conversion float -> T
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.NumericCast.force``1(System.Double,``0)">
            <summary>
            If possible, applies the conversion double -> T
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.NumericCast.force``1(System.Int16,``0)">
            <summary>
            If possible, applies the conversion short -> T
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.NumericCast.force``1(System.Int32,``0)">
            <summary>
            If possible, applies the conversion int -> T
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.NumericCast.force``1(System.Int64,``0)">
            <summary>
            If possible, applies the conversion long -> T
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.NumericCast.force``1(System.SByte,``0)">
            <summary>
            If possible, applies the conversion sbyte -> T
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.NumericCast.force``2(``0)">
            <summary>
            If possible, applies the conversion S -> T
            </summary>
            <param name="src">The source value</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.NumericCast.force``1(System.UInt16,``0)">
            <summary>
            If possible, applies the conversion ushort -> T
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.NumericCast.force``1(System.UInt32,``0)">
            <summary>
            If possible, applies the conversion uint -> T
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.NumericCast.force``1(System.UInt64,``0)">
            <summary>
            If possible, applies the conversion ulong -> T
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.NumericCast.force``1(System.Byte,``0)">
            <summary>
            If possible, applies the conversion byte -> T
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="T:Z0.INumeric">
            <summary>
            Characterizes a numeric thing
            </summary>
        </member>
        <member name="P:Z0.IRational`1.Over">
            <summary>
            The dividend
            </summary>
        </member>
        <member name="P:Z0.IRational`1.Under">
            <summary>
            The divisor
            </summary>
        </member>
        <member name="T:Z0.Count">
            <summary>
            Defines a data structure that measures a nonnegative count (I mean, really, is there any other kind?) of 32-bit capacity
            </summary>
        </member>
        <member name="T:Z0.Percent">
            <summary>
            Defines a datatype that represents a discrete percentage
            </summary>
        </member>
        <member name="T:Z0.Percent`1">
            <summary>
            Defines a datatype that represents a discrete percentage
            </summary>
        </member>
        <member name="T:Z0.Rational`1">
            <summary>
            Defines a datatype that represents a rational number
            </summary>
        </member>
        <member name="M:Z0.NumericArrays.force``2(``0[],``1[])">
            <summary>
            Unconditionally converts the source values to values of parametric numeric type
            </summary>
            <param name="src">The source values</param>
            <typeparam name="T">The numeric type</typeparam>
        </member>
        <member name="M:Z0.NumericArrays.force``2(``0[])">
            <summary>
            Unconditionally converts the source values to values of parametric numeric type
            </summary>
            <param name="src">The source values</param>
            <typeparam name="T">The numeric type</typeparam>
        </member>
        <member name="T:Z0.Outcome`2">
            <summary>
            Describes an operation result
            </summary>
        </member>
        <member name="T:Z0.Outcome`1">
            <summary>
            Describes an operation result
            </summary>
        </member>
        <member name="M:Z0.Parsers.from``2(Z0.Parse{``0,``1})">
            <summary>
            Defines a parser predicated on a parse function
            </summary>
            <param name="f">The parse function</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="T:Z0.Perm16">
            <summary>
            Defines a 16-symbol permutation 
            </summary>
        </member>
        <member name="T:Z0.Perm32">
            <summary>
            Defines a 32-symbol permutation
            </summary>
        </member>
        <member name="T:Z0.PermCycle">
            <summary>
            Describes cycle in a perutation
            </summary>
        </member>
        <member name="F:Z0.PermCycle.Terms">
            <summary>
            The terms that define the cycle
            </summary>
        </member>
        <member name="T:Z0.PermTerm">
            <summary>
            Describes an individual term of a permutation p, i.e. the point
            of evaluation i and its image p(i)
            </summary>
        </member>
        <member name="F:Z0.PermTerm.Source">
            <summary>
            The point at which the permutation is evaluated
            </summary>
        </member>
        <member name="F:Z0.PermTerm.Target">
            <summary>
            The result of evaluating the permutation over the source
            </summary>
        </member>
        <member name="T:Z0.Swap">
            <summary>
            Defines a transposition, i.e. a specification for a two-element position exchange
            Typically denoted by an ordered pair of space-delimited indices (i j)
            </summary>
        </member>
        <member name="F:Z0.Swap.i">
            <summary>
            The first index
            </summary>
        </member>
        <member name="F:Z0.Swap.j">
            <summary>
            The second index
            </summary>
        </member>
        <member name="M:Z0.Swap.Format">
            <summary>
            Renders the tranposition as text in canonical form
            </summary>
        </member>
        <member name="M:Z0.Swap.Equals(Z0.Swap)">
            <summary>
            Determines whether this transposition is identical to another.
            Note that the order of indices is immaterial
            </summary>
            <param name="rhs">The right transposition</param>
        </member>
        <member name="M:Z0.Swap.Replicate">
            <summary>
            Creates a copy
            </summary>
        </member>
        <member name="P:Z0.Swap.Zero">
            <summary>
            The monodial zero
            </summary>
        </member>
        <member name="P:Z0.Swap.Empty">
            <summary>
            The empty element, which is not Zero
            </summary>
        </member>
        <member name="M:Z0.PermSymbolic.apply``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{Z0.Swap},System.Span{``0})">
            <summary>
            Applies a transposition sequence to an input sequence
            </summary>
            <param name="src">The input sequence</param>
            <param name="swaps">The transposition sequence</param>
            <param name="dst">The output sequence</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.PermSymbolic.literal(Z0.Perm4L,System.Int32,Z0.Perm4L@)">
            <summary>
            Attempts to extract an index-identified permutation symbol
            </summary>
            <param name="src">The permutation spec</param>
            <param name="index">The symbol index</param>
            <param name="dst">The symbol, if successful</param>
            <returns>True if symbol was successfully extracted, false otherwise</returns>
        </member>
        <member name="M:Z0.PermSymbolic.literal(Z0.Perm8L,System.Int32,Z0.Perm8L@)">
            <summary>
            Attempts to extract an index-identified permutation symbol
            </summary>
            <param name="src">The permutation spec</param>
            <param name="index">The symbol index</param>
            <param name="dst">The symbol, if successful</param>
            <returns>True if symbol was successfully extracted, false otherwise</returns>
        </member>
        <member name="M:Z0.PermSymbolic.literal(Z0.Perm16L,System.Int32,Z0.Perm16L@)">
            <summary>
            Attempts to extract an index-identified permutation symbol
            </summary>
            <param name="src">The permutation spec</param>
            <param name="index">The symbol index</param>
            <param name="dst">The symbol, if successful</param>
            <returns>True if symbol was successfully extracted, false otherwise</returns>
        </member>
        <member name="M:Z0.PermSymbolic.literals(Z0.Perm16L,System.Span{Z0.Perm16L})">
            <summary>
            Extracts the ordered sequence of symbolic literals that define a 16-symbol permutation to a caller-supplied target
            </summary>
            <param name="src">The canonical literal representation</param>
            <param name="dst">The literal receiver</param>
        </member>
        <member name="M:Z0.PermSymbolic.literals(Z0.Perm16L)">
            <summary>
            Extracts the ordered sequence of symbolic literals that define a 16-symbol permutation to a caller-supplied target
            </summary>
            <param name="src">The canonical literal representation</param>
        </member>
        <member name="M:Z0.PermSymbolic.literals(Z0.Perm4L)">
            <summary>
            Extracts the ordered sequence of symbolic literals that define a 4-symbol permutation
            </summary>
            <param name="src">The canonical literal representation</param>
        </member>
        <member name="M:Z0.PermSymbolic.literals(Z0.Perm8L,System.Span{Z0.Perm8L})">
            <summary>
            Extracts the ordered sequence of symbolic literals that define an 8-symbol permutation to a caller-supplied target
            </summary>
            <param name="src">The canonical literal representation</param>
            <param name="dst">The literal receiver</param>
        </member>
        <member name="M:Z0.PermSymbolic.literals(Z0.Perm8L)">
            <summary>
            Extracts the ordered sequence of symbolic literals that define an 8-symbol permutation
            </summary>
            <param name="src">The canonical literal representation</param>
        </member>
        <member name="M:Z0.PermSymbolic.test(Z0.Perm4L)">
            <summary>
            Determines whether a permutation literal is a symbol
            </summary>
            <param name="src">The value to inspect</param>
        </member>
        <member name="M:Z0.PermSymbolic.test(Z0.Perm8L)">
            <summary>
            Determines whether a permutation literal is a symbol
            </summary>
            <param name="src">The value to inspect</param>
        </member>
        <member name="M:Z0.PermSymbolic.test(Z0.Perm16L)">
            <summary>
            Determines whether a permutation literal is a symbol
            </summary>
            <param name="src">The value to inspect</param>
        </member>
        <member name="M:Z0.PermSymbolic.digits(Z0.Perm16)">
            <summary>
            Computes the digits corresponding to each 4-bit segment of the permutation spec as
            </summary>
            <param name="src">The perm spec</param>
        </member>
        <member name="M:Z0.PermSymbolic.digits(Z0.Perm32)">
            <summary>
            Computes the digits corresponding to each 5-bit segment of the permutation spec
            </summary>
            <param name="src">The perm spec</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.PermSymbolic.assemble(Z0.Perm4L,Z0.Perm4L,Z0.Perm4L,Z0.Perm4L)" -->
        <member name="M:Z0.PermSymbolic.assemble(Z0.Perm8L,Z0.Perm8L,Z0.Perm8L,Z0.Perm8L,Z0.Perm8L,Z0.Perm8L,Z0.Perm8L,Z0.Perm8L)">
            <summary>
            Constructs a permutation of length 8 from 8 ordered symbols
            </summary>
        </member>
        <member name="M:Z0.PermSymbolic.assemble(Z0.Perm16L,Z0.Perm16L,Z0.Perm16L,Z0.Perm16L,Z0.Perm16L,Z0.Perm16L,Z0.Perm16L,Z0.Perm16L,Z0.Perm16L,Z0.Perm16L,Z0.Perm16L,Z0.Perm16L,Z0.Perm16L,Z0.Perm16L,Z0.Perm16L,Z0.Perm16L)">
            <summary>
            Constructs a permutation of length 16 from 16 ordered symbols
            </summary>
        </member>
        <member name="M:Z0.PermSymbolic.identity(Z0.N4)">
            <summary>
            Defines the identity permutation on 4 symbols
            </summary>
            <param name="n">The symbol count selector</param>
        </member>
        <member name="M:Z0.PermSymbolic.identity(Z0.N8)">
            <summary>
            Defines the identity permutation on 8 symbols
            </summary>
            <param name="n">The symbol count selector</param>
        </member>
        <member name="M:Z0.PermSymbolic.identity(Z0.N16)">
            <summary>
            Defines the identity permutation on 16 symbols
            </summary>
            <param name="n">The symbol count selector</param>
        </member>
        <member name="M:Z0.PermSymbolic.identity(Z0.W128)">
            <summary>
            Creates the identity permutation
            </summary>
        </member>
        <member name="M:Z0.PermSymbolic.identity(Z0.W256)">
            <summary>
            Creates the identity permutation
            </summary>
        </member>
        <member name="M:Z0.PermSymbolic.reversed(Z0.N4)">
            <summary>
            Defines the canonical literal representation of the reversal of the identity permutation on 4 symbols
            </summary>
            <param name="n">The symbol count selector</param>
        </member>
        <member name="M:Z0.PermSymbolic.reversed(Z0.N8)">
            <summary>
            Defines the canonical literal representation of the reversal of the identity permutation on 8 symbols
            </summary>
            <param name="n">The symbol count selector</param>
        </member>
        <member name="M:Z0.PermSymbolic.reversed(Z0.N16)">
            <summary>
            Returns the canonical literal representation of the reversal of the identity permutation on 16 symbols
            </summary>
            <param name="n">The symbol count selector</param>
        </member>
        <member name="M:Z0.PermSymbolic.reversed(Z0.W128)">
            <summary>
            Creates the reversal of the identity permutation
            </summary>
        </member>
        <member name="M:Z0.PermSymbolic.reversed(Z0.W256)">
            <summary>
            Creates the reversal of the identity permutation
            </summary>
        </member>
        <member name="T:Z0.Symbolic">
            <summary>
            Defines an api surface for <see cref='T:Z0.ISymbol'/> manipulation
            </summary>
        </member>
        <member name="M:Z0.Symbolic.index``2">
            <summary>
            Creates value-to-symbol index
            </summary>
            <typeparam name="E">The enumeration type that defines the symbols</typeparam>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.Symbolic.indices(System.ReadOnlySpan{System.Char},System.Char,System.Span{System.Int32})">
            <summary>
            Finds indices of the source cells that contain a specified character and returns the number of matches found
            </summary>
            <param name="src">The data source</param>
            <param name="match">The character to match</param>
            <param name="dst">The index target</param>
        </member>
        <member name="M:Z0.Symbolic.indices(System.ReadOnlySpan{System.Byte},System.Byte,System.Span{System.Int32})">
            <summary>
            Finds indices of the source cells that contain a specified value 
            and returns the number of matches found
            </summary>
            <param name="src">The data source</param>
            <param name="match">The value to match</param>
            <param name="dst">The index target</param>
        </member>
        <member name="M:Z0.Symbolic.name``1(``0,System.String)">
            <summary>
            Assigns a name to a symbol
            </summary>
            <param name="symbol">The target symbol</param>
            <param name="name">The name to assign</param>
            <typeparam name="S">The symbol type</typeparam>
        </member>
        <member name="M:Z0.Symbolic.spec``3(``0[])">
            <summary>
            Defines a symbol spec
            </summary>
            <param name="symbols"></param>
            <typeparam name="S">The symbol data type</typeparam>
            <typeparam name="T">The symbol domain type</typeparam>
            <typeparam name="N">The symbol bit-width type</typeparam>
        </member>
        <member name="M:Z0.Symbolic.symbol``3(``0,``1,``2)">
            <summary>
            Defines an <typeparamref name='S'/>-valued symbol of representation bit-width <typeparamref name='N'/>  covered by a <see cref='!:T'/> storage cell
            </summary>
            <param name="value">The symbol value</param>
            <param name="t">A storage cell represetnative</param>
            <param name="n">A bitwith value representative</param>
            <typeparam name="S">The symbol type</typeparam>
            <typeparam name="T">The storage type</typeparam>
            <typeparam name="N">The symbol representation bit-width</typeparam>
        </member>
        <member name="M:Z0.Swaps.format(Z0.Swap)">
            <summary>
            Renders the tranposition as text in canonical form
            </summary>
        </member>
        <member name="M:Z0.Swaps.violation``1(``0@,``0@)">
            <summary>
            The canonical swap function defined over readonly parametric references
            </summary>
            <param name="lhs">The left value</param>
            <param name="rhs">The right value</param>
            <typeparam name="T">The value type</typeparam>
        </member>
        <member name="M:Z0.Swaps.swap``1(``0@,``0@)">
            <summary>
            The canonical swap function defines over parametric references
            </summary>
            <param name="lhs">The left value</param>
            <param name="rhs">The right value</param>
            <typeparam name="T">The value type</typeparam>
        </member>
        <member name="M:Z0.Swaps.swap``1(``0*,``0*)">
            <summary>
            Exchanges operand targets
            </summary>
            <param name="pLhs"></param>
            <param name="pRhs"></param>
            <typeparam name="T"></typeparam>
            <remarks>
            T:uint32: mov eax,[rdx] => mov [rcx],eax => mov eax,[rcx] => mov [rdx],eax
            T:uint32: *rdx -> eax => eax -> *rcx => *rcx -> eax -> eax -> *rdx
            T:uint64: mov rax,[rdx] => mov [rcx],rax => mov rax,[rcx] => mov [rdx],rax
            </remarks>
        </member>
        <member name="M:Z0.Swaps.swap``1(System.Span{``0},System.UInt32,System.UInt32)">
            <summary>
            Interchanges span elements i and j
            </summary>
            <param name="src">The source span</param>
            <param name="i">An index of a span element</param>
            <param name="j">An index of a span element</param>
            <typeparam name="T">The span element type</typeparam>
        </member>
        <member name="M:Z0.Swaps.inc(Z0.Swap@)">
            <summary>
            Effects (i j) -> ((i + 1) (j+ 1))
            </summary>
        </member>
        <member name="M:Z0.Swaps.dec(Z0.Swap@)">
            <summary>
            Effects (i j) -> ((i - 1) (j - 1)) where decremented indices are clamped to 0
            </summary>
        </member>
        <member name="M:Z0.Swaps.chain(Z0.Swap,System.Int32)">
            <summary>
            Creates a sequence of transpositions
            </summary>
            <param name="s0">The leading transposition</param>
            <param name="len">The length of the chain</param>
        </member>
        <member name="M:Z0.Swaps.parse(System.String)">
            <summary>
            Parses a transposition in canonical form (i j), if possible; otherwise
            returns the empty transposition
            </summary>
            <param name="src">The source text</param>
        </member>
        <member name="M:Z0.XPermSymbolic.IsSymbol(Z0.Perm4L)">
            <summary>
            Determines whether a permutation literal is a symbol
            </summary>
            <param name="src">The value to inspect</param>
        </member>
        <member name="M:Z0.XPermSymbolic.IsSymbol(Z0.Perm8L)">
            <summary>
            Determines whether a permutation literal is a symbol
            </summary>
            <param name="src">The value to inspect</param>
        </member>
        <member name="M:Z0.XPermSymbolic.IsSymbol(Z0.Perm16L)">
            <summary>
            Determines whether a permutation literal is a symbol
            </summary>
            <param name="src">The value to inspect</param>
        </member>
        <member name="M:Z0.XPermSymbolic.Literals(Z0.Perm4L)">
            <summary>
            Constructs the sequence of permutation symbols corresponding to the canonical literal representation
            </summary>
            <param name="src">The canonical literal representation of a 4-symbol permutation</param>
        </member>
        <member name="M:Z0.XPermSymbolic.Literals(Z0.Perm8L)">
            <summary>
            Constructs the sequence of permutation symbols corresponding to the canonical literal representation
            </summary>
            <param name="src">The canonical literal representation of a 8-symbol permutation</param>
        </member>
        <member name="M:Z0.XPermSymbolic.Literals(Z0.Perm16L)">
            <summary>
            Constructs the sequence of permutation symbols corresponding to the canonical literal representation
            </summary>
            <param name="src">The canonical literal representation of a 16-symbol permutation</param>
        </member>
        <member name="M:Z0.PrimalKinds.kind(System.TypeCode)">
            <summary>
            Returns the type-code identified primal kind
            </summary>
            <param name="src">The type code</param>
        </member>
        <member name="M:Z0.PrimalKinds.ecode``1(``0)">
            <summary>
            Determines an enumeration's underlying kind
            </summary>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.PrimalKinds.ecode(System.Type)">
            <summary>
            Determines an enumeration's underlying kind
            </summary>
        </member>
        <member name="M:Z0.PrimalKinds.eq``1(``0,``0)">
            <summary>
            Determines equality for unmanaged primitive values
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <typeparam name="T">The numeric type</typeparam>
        </member>
        <member name="M:Z0.Scalars.scalar``2(``0@)">
            <summary>
            Interprets a scalar value of one sort as a scalar value of another
            </summary>
            <param name="src">The source value</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.Scalars.scalar``2(``0@,``1@)">
            <summary>
            Reads a T-value from an E-enum value of primal T-kind.
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target output value</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.Scalars.scalar``1(``0@,System.Byte@)">
            <summary>
            Reads a u8-value from an enum of primal u8-kind
            </summary>
            <param name="src">The enum value</param>
            <param name="dst">The primal output value</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Scalars.scalar``1(``0@,System.SByte@)">
            <summary>
            Reads an i8-value from an enum of primal u8-kind
            </summary>
            <param name="src">The enum value</param>
            <param name="dst">The primal output value</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Scalars.scalar``1(``0@,System.Int16@)">
            <summary>
            Reads an i16-value from an enum of primal i16-kind
            </summary>
            <param name="src">The enum value</param>
            <param name="dst">The primal output value</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Scalars.scalar``1(``0@,System.UInt16@)">
            <summary>
            Reads a u16-value from an enum of primal u16-kind
            </summary>
            <param name="src">The enum value</param>
            <param name="dst">The primal output value</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Scalars.scalar``1(``0@,System.Int32@)">
            <summary>
            Reads an i32-value from an enum of primal i32-kind
            </summary>
            <param name="eVal">The enum value</param>
            <param name="tVal">The primal output value</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Scalars.scalar``1(``0@,System.UInt32@)">
            <summary>
            Reads a u32-value from an enum of primal u32-kind
            </summary>
            <param name="eVal">The enum value</param>
            <param name="tVal">The primal output value</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Scalars.scalar``1(``0@,System.Int64@)">
            <summary>
            Reads an i64-value from an enum of primal i64-kind
            </summary>
            <param name="eVal">The enum value</param>
            <param name="tVal">The primal output value</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Scalars.scalar``1(``0@,System.UInt64@)">
            <summary>
            Reads a u64-value from an enum of primal u64-kind
            </summary>
            <param name="eVal">The enum value</param>
            <param name="tVal">The primal output value</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.Scalars.scalar``1(``0@,System.Char@)">
            <summary>
            Reads a c16-value from an enum of primal u16-kind
            </summary>
            <param name="eVal">The enum value</param>
            <param name="cVal">The character output value</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="T:Z0.Bijection`2">
            <summary>
            Represents an iterable K-indexed bijection
            </summary>
        </member>
        <member name="T:Z0.Dependency`1">
            <summary>
            Captures a node-homogenous directed relation
            </summary>
        </member>
        <member name="F:Z0.Dependency`1.Source">
            <summary>
            The client in the relation that that depends on the <see cref='F:Z0.Dependency`1.Target'/>
            </summary>
        </member>
        <member name="F:Z0.Dependency`1.Target">
            <summary>
            The client-agnostic relation supplier
            </summary>
        </member>
        <member name="T:Z0.RelationFacet`1">
            <summary>
            Captures an attribute relation value
            </summary>
        </member>
        <member name="T:Z0.BinaryResource">
            <summary>
            Describes an embedded data resource
            </summary>
        </member>
        <member name="T:Z0.BinaryResourceSpec">
            <summary>
            Defines the content of a binary resource
            </summary>
        </member>
        <member name="T:Z0.HostResources">
            <summary>
            Defines the content of a set of binary resources for an api host
            </summary>
        </member>
        <member name="T:Z0.ResIdentity">
            <summary>
            Identifies a resource, its data type, and specifies the memory segment it occupies
            </summary>
        </member>
        <member name="P:Z0.ResIdentity.Name">
            <summary>
            The resource name, relative to the enclosing type
            </summary>
        </member>
        <member name="P:Z0.ResIdentity.Reference">
            <summary>
            The memory segment occupied by the resource
            </summary>
        </member>
        <member name="P:Z0.ResIdentity.DataType">
            <summary>
            The resource data type
            </summary>
        </member>
        <member name="T:Z0.ResIdentity`1">
            <summary>
            Identifies a resource of parametric type along with a reference to the memory segment it occupies
            </summary>
        </member>
        <member name="T:Z0.ResMember">
            <summary>
            Describes a member that defines a resource
            </summary>
        </member>
        <member name="T:Z0.StringResource">
            <summary>
            Describes/models a literal text resource
            </summary>
        </member>
        <member name="F:Z0.StringResource.Source">
            <summary>
            The resource identifier
            </summary>
        </member>
        <member name="F:Z0.StringResource.Address">
            <summary>
            The resource address
            </summary>
        </member>
        <member name="F:Z0.StringResource.Value">
            <summary>
            The resource value extracted from the accompanying location
            </summary>
        </member>
        <member name="T:Z0.StringResource`1">
            <summary>
            Represents an identified string resource
            </summary>
        </member>
        <member name="P:Z0.StringResource`1.Identifier">
            <summary>
            The resource identifier
            </summary>
        </member>
        <member name="P:Z0.StringResource`1.Address">
            <summary>
            The resource address
            </summary>
        </member>
        <member name="P:Z0.StringResource`1.Length">
            <summary>
            The resource value extracted from the accompanying location
            </summary>
        </member>
        <member name="M:Z0.Resources.BinaryProviders``1">
            <summary>
            Returns the properties declared by a type that define binary resource content
            </summary>
            <typeparam name="T">The defining type</typeparam>
        </member>
        <member name="M:Z0.Resources.data(Z0.ResourceDescriptor@)">
            <summary>
            Reveals the data represented by a <see cref='T:Z0.ResourceDescriptor'/>
            </summary>
            <param name="src">The source descriptor</param>
        </member>
        <member name="M:Z0.Resources.api(System.Type)">
            <summary>
            Queries the source type for ByteSpan property getters
            </summary>
            <param name="src">The type to query</param>
        </member>
        <member name="M:Z0.Resources.accessors(System.Reflection.Assembly[])">
            <summary>
            Queries the source assemblies for ByteSpan property getters
            </summary>
            <param name="src">The assemblies to query</param>
        </member>
        <member name="M:Z0.Resources.accessors(System.Reflection.Assembly)">
            <summary>
            Queries the source assembly for ByteSpan property getters
            </summary>
            <param name="src">The assembly to query</param>
        </member>
        <member name="M:Z0.Resources.accessors(System.Type[])">
            <summary>
            Queries the source types for ByteSpan property getters
            </summary>
            <param name="src">The types to query</param>
        </member>
        <member name="M:Z0.Resources.declarations(System.Reflection.Assembly)">
            <summary>
            Collects all resource accessors defined by a specified assembly
            </summary>
            <param name="src">The source assembly</param>
        </member>
        <member name="M:Z0.Resources.from(System.Reflection.Assembly,Z0.ApiResource[])">
            <summary>
            Collects all resource accessors defined by a specified assembly
            </summary>
            <param name="src">The source assembly</param>
        </member>
        <member name="F:Z0.SegmentKind.None">
            <summary>
            Classifier that classifies nothing
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg16x8u">
            <summary>
            A 16-bit linear memory segment covering 2 unsigned 8-bit segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg16x8i">
            <summary>
            A 16-bit linear memory segment covering 2 signed 8-bit segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg16x16u">
            <summary>
            A 16-bit linear memory segment covering an unsigned 16-bit segment
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg16x16i">
            <summary>
            A 16-bit linear memory segment covering an unsigned 16-bit segment
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg32x8u">
            <summary>
            A 32-bit linear memory segment covering 4 unsigned 8-bit segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg32x8i">
            <summary>
            A 32-bit linear memory segment covering 4 unsigned 8-bit segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg32x16u">
            <summary>
            A 32-bit linear memory segment covering 2 unsigned 16-bit segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg32x16i">
            <summary>
            A 32-bit linear memory segment covering 2 signed 16-bit segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg32x32u">
            <summary>
            A 32-bit linear memory segment covering an unsigned 32-bit segment
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg32x32i">
            <summary>
            A 32-bit linear memory segment covering a signed 32-bit segment
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg32x32f">
            <summary>
            A 32-bit linear memory segment covering a floating-point 32-bit segment
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg64x8u">
            <summary>
            A 64-bit linear memory segment covering 8 unsigned 8-bit segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg64x8i">
            <summary>
            A 64-bit linear memory segment covering 8 signed 8-bit segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg64x16u">
            <summary>
            A 64-bit linear memory segment covering 4 unsigned 16-bit segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg64x16i">
            <summary>
            A 64-bit linear memory segment covering 4 signed 16-bit segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg64x32u">
            <summary>
            A 64-bit linear memory segment covering 2 unsigned 32-bit segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg64x32i">
            <summary>
            A 64-bit linear memory segment covering 2 signed 32-bit segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg64x64u">
            <summary>
            A 64-bit linear memory segment covering an unsigned 64-bit segment
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg64x64i">
            <summary>
            A 64-bit linear memory segment covering a signed 64-bit segment
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg64x32f">
            <summary>
            A 64-bit linear memory segment covering 2 32-bit floating-point segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg64x64f">
            <summary>
            A 64-bit linear memory segment covering a 64-bit floating-point segment
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg128x8u">
            <summary>
            A 128-bit linear memory segment covering 16 8-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg128x8i">
            <summary>
            A 128-bit linear memory segment covering 16 8-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg128x16u">
            <summary>
            A 128-bit linear memory segment covering 8 16-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg128x16i">
            <summary>
            A 128-bit linear memory segment covering 8 16-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg128x32u">
            <summary>
            A 128-bit linear memory segment covering 4 32-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg128x32i">
            <summary>
            A 128-bit linear memory segment covering 4 32-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg128x64u">
            <summary>
            A 128-bit linear memory segment covering 2 64-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg128x64i">
            <summary>
            A 128-bit linear memory segment covering 2 64-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg128x32f">
            <summary>
            A 128-bit linear memory segment covering 4 32-bit floating-point segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg128x64f">
            <summary>
            A 128-bit linear memory segment covering 2 64-bit floating-point segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg256x8u">
            <summary>
            A 256-bit linear memory segment covering 32 8-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg256x8i">
            <summary>
            A 256-bit linear memory segment covering 32 8-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg256x16u">
            <summary>
            A 256-bit linear memory segment covering 16 16-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg256x16i">
            <summary>
            A 256-bit linear memory segment covering 16 16-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg256x32u">
            <summary>
            A 256-bit linear memory segment covering 8 32-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg256x32i">
            <summary>
            A 256-bit linear memory segment covering 8 32-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg256x64u">
            <summary>
            A 256-bit linear memory segment covering 4 64-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg256x64i">
            <summary>
            A 256-bit linear memory segment covering 4 64-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg256x32f">
            <summary>
            A 256-bit linear memory segment covering 8 32-bit floating-point segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg256x64f">
            <summary>
            A 256-bit linear memory segment covering 4 64-bit floating-point segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg512x8u">
            <summary>
            A 512-bit linear memory segment covering 32 8-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg512x8i">
            <summary>
            A 512-bit linear memory segment covering 32 8-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg512x16u">
            <summary>
            A 512-bit linear memory segment covering 16 16-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg512x16i">
            <summary>
            A 512-bit linear memory segment covering 16 16-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg512x32u">
            <summary>
            A 512-bit linear memory segment covering 8 32-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg512x32i">
            <summary>
            A 512-bit linear memory segment covering 8 32-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg512x64u">
            <summary>
            A 512-bit linear memory segment covering 4 64-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg512x64i">
            <summary>
            A 512-bit linear memory segment covering 4 64-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg512x32f">
            <summary>
            A 512-bit linear memory segment covering 8 32-bit floating-point segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg512x64f">
            <summary>
            A 512-bit linear memory segment covering 4 64-bit floating-point segments
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Signed">
            <summary>
            Classifies signed integral types; if sign bit is not enabled and float bit
            is not enabled, the number is considered unsigned
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Float">
            <summary>
            Classifies floating-point types
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg8u">
            <summary>
            Classifies the 8-bit unsigned integer type
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg16u">
            <summary>
            Classifies the 16-bit unsigned integer type
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg32u">
            <summary>
            Classifies the 32-bit unsigned integer type
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg64u">
            <summary>
            Classifies the 64-bit unsigned integer type
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg8i">
            <summary>
            Classifies the 8-bit signed integer type
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg16i">
            <summary>
            Classifies the 16-bit signed integer type
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg32i">
            <summary>
            Classifies the 32-bit signed integer type
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg64i">
            <summary>
            Classifies the 64-bit signed integer type
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg32f">
            <summary>
            Classifies the 32-bit floating-point type type
            </summary>
        </member>
        <member name="F:Z0.SegmentKind.Seg64f">
            <summary>
            Classifies the 64-bit floating-point type type
            </summary>
        </member>
        <member name="M:Z0.SeqMap.i8``1(System.Span{``0})">
            <summary>
            Projects a sequence of <typeparamref name='T'/> cells onto a sequence of <see cref='T:System.SByte'/> cells
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.SeqMap.i8``1(System.ReadOnlySpan{``0})">
            <summary>
            Projects a readonly sequence of <typeparamref name='T'/> cells onto a sequence of readonly <see cref='T:System.SByte'/> cells
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.SeqMap.u8``1(System.Span{``0})">
            <summary>
            Projects a sequence of <typeparamref name='T'/> cells onto a sequence of <see cref='T:System.Byte'/> cells
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.SeqMap.u8``1(System.ReadOnlySpan{``0})">
            <summary>
            Projects a readonly sequence of <typeparamref name='T'/> cells onto a sequence of readonly <see cref='T:System.Byte'/> cells
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.SeqMap.i16``1(System.Span{``0})">
            <summary>
            Projects a sequence of <typeparamref name='T'/> cells onto a sequence of <see cref='T:System.Int16'/> cells
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.SeqMap.i16``1(System.ReadOnlySpan{``0})">
            <summary>
            Projects a readonly sequence of <typeparamref name='T'/> cells onto a sequence of readonly <see cref='T:System.Int16'/> cells
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.SeqMap.u16``1(System.Span{``0})">
            <summary>
            Projects a sequence of <typeparamref name='T'/> cells onto a sequence of <see cref='T:System.UInt16'/> cells
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.SeqMap.u16``1(System.ReadOnlySpan{``0})">
            <summary>
            Projects a readonly sequence of <typeparamref name='T'/> cells onto a readonly sequence of <see cref='T:System.UInt16'/> cells
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.SeqMap.i32``1(System.Span{``0})">
            <summary>
            Projects a sequence of <typeparamref name='T'/> cells onto a sequence of <see cref='T:System.Int32'/> cells
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.SeqMap.i32``1(System.ReadOnlySpan{``0})">
            <summary>
            Projects a readonly sequence of <typeparamref name='T'/> cells onto a sequence of readonly <see cref='T:System.Int32'/> cells
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.SeqMap.u32``1(System.Span{``0})">
            <summary>
            Projects a sequence of <typeparamref name='T'/> cells onto a sequence of <see cref='T:System.UInt32'/> cells
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.SeqMap.u32``1(System.ReadOnlySpan{``0})">
            <summary>
            Projects a readonly sequence of <typeparamref name='T'/> cells onto a readonly sequence of <see cref='T:System.UInt32'/> cells
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.SeqMap.i64``1(System.Span{``0})">
            <summary>
            Projects a sequence of <typeparamref name='T'/> cells onto a sequence of <see cref='T:System.Int64'/> cells
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.SeqMap.i64``1(System.ReadOnlySpan{``0})">
            <summary>
            Projects a readonly sequence of <typeparamref name='T'/> cells onto a sequence of readonly <see cref='T:System.Int64'/> cells
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.SeqMap.u64``1(System.Span{``0})">
            <summary>
            Projects a sequence of <typeparamref name='T'/> cells onto a sequence of <see cref='T:System.UInt64'/> cells
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.SeqMap.u64``1(System.ReadOnlySpan{``0})">
            <summary>
            Projects a readonly sequence of <typeparamref name='T'/> cells onto a readonly sequence of <see cref='T:System.UInt64'/> cells
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="T:Z0.IJsonSettings">
            <summary>
            Characterizes an app settings collection
            </summary>
        </member>
        <member name="T:Z0.ISetting">
            <summary>
            Characterizes a nonparametric application setting
            </summary>
        </member>
        <member name="P:Z0.ISetting.Name">
            <summary>
            The setting name
            </summary>
        </member>
        <member name="P:Z0.ISetting.Value">
            <summary>
            The setting value
            </summary>
        </member>
        <member name="T:Z0.ISettingSource">
            <summary>
            Characterizes an application settings provider that supports settings persistence
            </summary>
        </member>
        <member name="P:Z0.ISettingSource.Settings">
            <summary>
            The provided settings
            </summary>
        </member>
        <member name="M:Z0.ISettingSource.Save(Z0.FilePath)">
            <summary>
            Saves the settings to a file
            </summary>
            <param name="dst">The target path</param>
        </member>
        <member name="T:Z0.ISettingSource`1">
            <summary>
            Characterizes an F-bound polymorphic app setting set reification
            </summary>
            <typeparam name="F">The reification type</typeparam>
        </member>
        <member name="T:Z0.JsonSettings">
            <summary>
            Defines the canonical <see cref='T:Z0.IJsonSettings'/> reification
            </summary>
        </member>
        <member name="T:Z0.SettingFormat">
            <summary>
            Defines an application setting format configuration
            </summary>
        </member>
        <member name="P:Z0.SettingFormat.FormatAsJson">
            <summary>
            Specifies whether to render application settings as JSON text
            </summary>
        </member>
        <member name="T:Z0.SettingValue">
            <summary>
            Defines a nonparametric kvp application setting
            </summary>
        </member>
        <member name="P:Z0.SettingValue.Name">
            <summary>
            The setting name
            </summary>
        </member>
        <member name="P:Z0.SettingValue.Value">
            <summary>
            The setting value
            </summary>
        </member>
        <member name="T:Z0.SettingValue`1">
            <summary>
            Defines a value-parametric application setting
            </summary>
        </member>
        <member name="F:Z0.SettingValue`1.Name">
            <summary>
            The setting name
            </summary>
        </member>
        <member name="F:Z0.SettingValue`1.Value">
            <summary>
            The setting value
            </summary>
        </member>
        <member name="M:Z0.SFx.apply``2(``1,``1,``0)">
            <summary>
            Computes z := y |> f x := f(x,y) for a binary operator f
            </summary>
            <param name="x">The left domain value</param>
            <param name="y">The right domain value</param>
            <param name="f">The binary operator</param>
            <typeparam name="F">The binary operator type</typeparam>
            <typeparam name="T">The operator domain type</typeparam>
        </member>
        <member name="M:Z0.SFx.compose``3(``2,``0,``1)">
            <summary>
            Computes y := f(x,g(x)) for a unary operator g, and binary operator f
            </summary>
            <param name="x">The input value</param>
            <param name="f">A binary operator</param>
            <param name="g">A unary operator</param>
            <typeparam name="F">The binary operator type</typeparam>
            <typeparam name="G">The unary operator type</typeparam>
            <typeparam name="T">The type over which the operators are defined</typeparam>
        </member>
        <member name="M:Z0.SFx.compose``3(``2,``2,``0,``1)">
            <summary>
            Computes y := f(g(x),g(y)) for a unary operator g, and binary operator f
            </summary>
            <param name="x">The input value</param>
            <param name="f">A binary operator</param>
            <param name="g">A unary operator</param>
            <typeparam name="F">The binary operator type</typeparam>
            <typeparam name="G">The unary operator type</typeparam>
            <typeparam name="T">The type over which the operators are defined</typeparam>
        </member>
        <member name="M:Z0.SFx.if``1(``0@,Z0.ValuePredicate{``0},Z0.ValueOperator{``0},Z0.ValueOperator{``0})">
            <summary>
            Branches an operator according to predicate evaluation outcome
            </summary>
            <param name="src">The source value</param>
            <param name="test">The branch predicate</param>
            <param name="true">The operator to apply when the test is true</param>
            <param name="false">The operator to apply when the test is false</param>
            <typeparam name="S">The operand type</typeparam>
        </member>
        <member name="M:Z0.SFx.if``1(``0@,Z0.ValuePredicate{``0},Z0.ValueMap{``0,``0},Z0.ValueMap{``0,``0})">
            <summary>
            Branches an operator according to predicate evaluation outcome
            </summary>
            <param name="src">The source value</param>
            <param name="test">The branch predicate</param>
            <param name="true">The operator to apply when the test is true</param>
            <param name="false">The operator to apply when the test is false</param>
            <typeparam name="S">The operand type</typeparam>
        </member>
        <member name="M:Z0.SFx.if``2(``0@,Z0.ValuePredicate{``0},Z0.ValueMap{``0,``1},Z0.ValueMap{``0,``1})">
            <summary>
            Branches a projection as determined by a predicate
            </summary>
            <param name="src">The source value</param>
            <param name="test">The branch predicate</param>
            <param name="true">The projection to apply when the test is true</param>
            <param name="false">The projection to apply when the test is false</param>
            <typeparam name="S">The source domain type</typeparam>
            <typeparam name="T">The target domain type</typeparam>
        </member>
        <member name="M:Z0.SFx.pipe``2(``1,``0)">
            <summary>
            Computes y := x |> f = f(x) for a unary operator f
            </summary>
            <param name="x">The left domain value</param>
            <param name="y">The right domain value</param>
            <param name="f">The binary operator</param>
            <typeparam name="F">The binary operator type</typeparam>
            <typeparam name="T">The operator domain type</typeparam>
        </member>
        <member name="M:Z0.SFx.pipe``3(``2,``0,``1)">
            <summary>
            Computes y := x |> f |> g := g(f(x)) for unary operators f and g
            </summary>
            <param name="x">The input value</param>
            <param name="f">A unary operator</param>
            <param name="g">A unary operator</param>
            <typeparam name="F">The type of the first unary operator</typeparam>
            <typeparam name="G">The type of the second unary operator</typeparam>
            <typeparam name="T">The operator domain type</typeparam>
        </member>
        <member name="M:Z0.SFx.pipe``4(``3,``0,``1)">
            <summary>
            Computes y := x |> f |> g |> h := h(g(f(x))) for unary operators f, g and h
            </summary>
            <param name="x">The input value</param>
            <param name="f">A unary operator</param>
            <param name="g">A unary operator</param>
            <typeparam name="F">The type of the first unary operator</typeparam>
            <typeparam name="G">The type of the second unary operator</typeparam>
            <typeparam name="T">The operator domain type</typeparam>
        </member>
        <member name="M:Z0.SFx.reduce``2(Z0.ValueProjector{``0,``1})">
            <summary>
            Removes a layer of parametricity from a projector
            </summary>
            <param name="src">The source projector</param>
            <typeparam name="S">The source domain</typeparam>
            <typeparam name="T">The target domain</typeparam>
        </member>
        <member name="M:Z0.SFx.reduce``2(Z0.ValueProjector{``0,``1},``1[])">
            <summary>
            Removes a layer of parametricity from a projector
            </summary>
            <param name="src">The source projector</param>
            <typeparam name="S">The source domain</typeparam>
            <typeparam name="T">The target domain</typeparam>
        </member>
        <member name="T:Z0.SFx.IBinaryImm8Op128`1">
            <summary>
            Characterizes a vectorized binary operator over 128-bit operands that accepts an 8-bit immediate
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.SFx.IBinaryImm8Op256`1">
            <summary>
            Characterizes a vectorized binary operator over 256-bit operands that accepts an 8-bit immediate
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.SFx.IBinaryImm8Op512`1">
            <summary>
            Characterizes a vectorized binary operator over 256-bit operands that accepts an 8-bit immediate
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.SFx.boxed``1(System.Func{System.Object,``0})">
            <summary>
            Creates a <see cref='T:Z0.BoxedValueMap`1'/> from a function
            </summary>
            <param name="f">The source function</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="T:Z0.SFxShape.IReducer256`1">
            <summary>
            Characterizes a function that produces a 128-bit vector from a 256-bit vector
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IBinaryOp`1">
            <summary>
            Characterizes a structural binary operator
            </summary>
            <typeparam name="A">The operand type</typeparam>
        </member>
        <member name="T:Z0.IBinaryPred`1">
            <summary>
            Defines trait for a vectorized binary predicate that supports componentwise decomposition/evaluation
            </summary>
            <typeparam name="T">The component type</typeparam>
        </member>
        <member name="T:Z0.IBinaryPred`2">
            <summary>
            Characterizes a natural binary predicate over non-primal operands
            </summary>
            <typeparam name="W">The natural type</typeparam>
            <typeparam name="V">The non-primal operand type</typeparam>
        </member>
        <member name="T:Z0.IBinaryPred`3">
            <summary>
            Characterizes a natural binary predicate over non-primal operands that support scalar application
            </summary>
            <typeparam name="W">The natural type</typeparam>
            <typeparam name="V">The non-primal type</typeparam>
            <typeparam name="T">The scalar type</typeparam>
        </member>
        <member name="T:Z0.IBinaryPred128`1">
            <summary>
            Characterizes a vectorized binary predicate over 128-bit operands
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IBinaryPred256`1">
            <summary>
            Characterizes a vectorized binary predicate over 256-bit operands
            </summary>
            <typeparam name="T">The component type</typeparam>
        </member>
        <member name="T:Z0.IBinaryPred128D`1">
            <summary>
            Characterizes a vectorized binary predicate over 128-bit operands that
            also supports componentwise decomposition/evaluation
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IBinaryPred256D`1">
            <summary>
            Characterizes a vectorized binary predicate over 128-bit operands that
            also supports componentwise decomposition/evaluation
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IBlockedFunc">
            <summary>
            Characterizes structured blocked functions
            </summary>
        </member>
        <member name="T:Z0.IBlockedFunc`1">
            <summary>
            Characterizes identified SBF operations that are width-parametric
            </summary>
            <typeparam name="W">The width type</typeparam>
        </member>
        <member name="T:Z0.IBlockedFunc`2">
            <summary>
            Characterizes identified SBF operations that are cell and width-parametric
            </summary>
            <typeparam name="W">The width type</typeparam>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="T:Z0.IEmitter`1">
            <summary>
            Characterizes an operation that produces a value that does not depend on arguments
            </summary>
            <typeparam name="A">The production type</typeparam>
        </member>
        <member name="T:Z0.IFactory`4">
            <summary>
            Characterizes a function that produces a vector predicated on a source value
            </summary>
            <typeparam name="W">The vector width</typeparam>
            <typeparam name="S">The source value type</typeparam>
            <typeparam name="V">The target vector type</typeparam>
            <typeparam name="T">The target vector component type</typeparam>
        </member>
        <member name="T:Z0.IFactory128`2">
            <summary>
            Characterizes an operator that produces a 128-bit target vector predicated on a source value
            </summary>
            <typeparam name="S">The source value type</typeparam>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IFactory256`2">
            <summary>
            Characterizes an operator that produces a 256-bit target vector predicated on a source value
            </summary>
            <typeparam name="S">The source value type</typeparam>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IFunc">
            <summary>
            Characterizes a function reified as a (structural) type, referred to as a structural function
            </summary>
        </member>
        <member name="P:Z0.IFunc.Id">
            <summary>
            The operation identity
            </summary>
        </member>
        <member name="T:Z0.IFunc`1">
            <summary>
            Characterizes a structural emitter; that is, the contract characterizes a type that implements an emitter
            </summary>
            <typeparam name="A">The emission type</typeparam>
        </member>
        <member name="T:Z0.IFunc`2">
            <summary>
            Characterizes an identified structural unary function
            </summary>
            <typeparam name="A">The first operand type</typeparam>
            <typeparam name="B">The result type</typeparam>
        </member>
        <member name="T:Z0.IFunc`3">
            <summary>
            Characterizes an identified structural binary function
            </summary>
            <typeparam name="A">The first operand type</typeparam>
            <typeparam name="B">The second operand type</typeparam>
            <typeparam name="C">The third result type</typeparam>
        </member>
        <member name="M:Z0.IFunc`3.Invoke(`0,`1)">
            <summary>
            Invokes the reified function over supplied operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <param name="c">The third operand</param>
        </member>
        <member name="T:Z0.IFunc`4">
            <summary>
            Characterizes an identified structural ternary function
            </summary>
            <typeparam name="A">The first operand type</typeparam>
            <typeparam name="B">The second operand type</typeparam>
            <typeparam name="C">The third operand type</typeparam>
            <typeparam name="D">The result type</typeparam>
        </member>
        <member name="M:Z0.IFunc`4.Invoke(`0,`1,`2)">
            <summary>
            Invokes the reified function over supplied operands
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <param name="c">The third operand</param>
        </member>
        <member name="T:Z0.IFuncW`1">
            <summary>
            Characterizes a structural function that is width-parametric
            </summary>
            <typeparam name="W">The width type</typeparam>
        </member>
        <member name="T:Z0.IFuncWT`2">
            <summary>
            Characterizes a width-parametric and T-parameteric structural function
            </summary>
            <typeparam name="W">The width type</typeparam>
            <typeparam name="T">Unconstrained</typeparam>
        </member>
        <member name="T:Z0.IProjector`2">
            <summary>
            Characterizes a structural transformation function
            </summary>
            <typeparam name="A">The source domain type</typeparam>
            <typeparam name="B">The target domain type</typeparam>
        </member>
        <member name="T:Z0.ISFParser`1">
            <summary>
            Characterizes an operator that materializes a primal value from a string
            </summary>
            <typeparam name="T">The primal value type</typeparam>
        </member>
        <member name="T:Z0.IMap`6">
            <summary>
            Characterizes a vectorized transformation parameterized by operand source/target bit widths and source/target component types
            </summary>
            <typeparam name="W1">The bit-width type of the source operand</typeparam>
            <typeparam name="W2">The bit-width type of the target operand</typeparam>
            <typeparam name="V1">The source operand type</typeparam>
            <typeparam name="V2">The target operand type</typeparam>
            <typeparam name="T1">The source component type</typeparam>
            <typeparam name="T2">The target component type</typeparam>
        </member>
        <member name="T:Z0.IMap128`2">
            <summary>
            Characterizes a 128-bit vectorized transformation parameterized by source/target component types
            </summary>
            <typeparam name="S">The source component type</typeparam>
            <typeparam name="T">The target component type</typeparam>
        </member>
        <member name="T:Z0.IMap256`2">
            <summary>
            Characterizes a 256-bit vectorized transformation parameterized by source/target component types
            </summary>
            <typeparam name="S">The source component type</typeparam>
            <typeparam name="T">The target component type</typeparam>
        </member>
        <member name="T:Z0.IMerge2x128x256`2">
            <summary>
            Characterizes an operand-homogenous vectorized merge operator that carries 2 128-bit operands to a 256-bit target
            </summary>
            <typeparam name="S">The operand component type</typeparam>
            <typeparam name="T">The target component type</typeparam>
        </member>
        <member name="T:Z0.ISFxHost">
            <summary>
            Characterizes a service that exposes serviced api operations
            </summary>
        </member>
        <member name="P:Z0.ISFxHost.HostTypes">
            <summary>
            The known types that reify contracted operation services, potentially generic
            </summary>
        </member>
        <member name="P:Z0.ISFxHost.FactoryMethods">
            <summary>
            The methods that instantiate services reified by the hosts
            </summary>
        </member>
        <member name="P:Z0.ISFxHost.HostCount">
            <summary>
            Specifies the number of service hosts described by the catalog
            </summary>
        </member>
        <member name="P:Z0.ISFxHost.IsNonEmpty">
            <summary>
            Specifies whether the catalog describes any service hosts
            </summary>
        </member>
        <member name="T:Z0.ISFxHost`1">
            <summary>
            Characterizes an F-bound polymorphic functional service factory that also encloses service host types
            </summary>
            <typeparam name="F">The factory type</typeparam>
        </member>
        <member name="T:Z0.ISFxRoot`2">
            <summary>
            Characterizes an F-bound polymorphic functional service factory with an H-parametric enclosure
            </summary>
            <typeparam name="R">The factory type</typeparam>
            <typeparam name="H">The host enclosure type</typeparam>
        </member>
        <member name="T:Z0.IShiftOp128`1">
            <summary>
            Characterizes a vectorized shift operator over 128-bit operands
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IShiftOp256`1">
            <summary>
            Characterizes a vectorized shift operator over 256-bit operands
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IShiftOp128D`1">
            <summary>
            Characterizes a vectorized shift operator over 128-bit operands that also supports componentwise decomposition/evaluation
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IShiftOp256D`1">
            <summary>
            Characterizes a vectorized shift operator over 256-bit operands that also supports componentwise decomposition/evaluation
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.ISpanEmitter`1">
            <summary>
            Characterizes an emitter that shoots out spans
            </summary>
            <typeparam name="T">The span element type</typeparam>
        </member>
        <member name="T:Z0.ISpanLoader`2">
            <summary>
            Characterizes an operation that accepts a source span and produces a derived target vector
            </summary>
            <typeparam name="W">The target vector width</typeparam>
            <typeparam name="S">The span source cell type</typeparam>
            <typeparam name="V">The target vector type</typeparam>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.ISpanMap`2">
            <summary>
            Characterizes a structural transformation function defined over parametric spans
            </summary>
            <typeparam name="A">The source span cell type</typeparam>
            <typeparam name="B">The target span cell type</typeparam>
        </member>
        <member name="T:Z0.IUnarySpanOp`1">
            <summary>
            Characterizes a structural function that accepts source span and
            target spans defined over cells of common type
            </summary>
            <typeparam name="W">The cell width</typeparam>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="T:Z0.IBinarySpanOp`1">
            <summary>
            Characterizes a function that accepts two source spans and a target span over a common element type
            </summary>
            <typeparam name="T">The span element type</typeparam>
        </member>
        <member name="T:Z0.ITernarySpanOp`1">
            <summary>
            Characterizes a structural function that accepts two source spans and a
            target span defined over cells of common type
            </summary>
            <typeparam name="T">The span element type</typeparam>
        </member>
        <member name="T:Z0.IUnarySpanPred`1">
            <summary>
            Characterizes a function that accepts two source spans and a target span of bits
            </summary>
            <typeparam name="T">The span element type</typeparam>
        </member>
        <member name="T:Z0.IBinarySpanPred`1">
            <summary>
            Characterizes a function that accepts two source spans and a target span of bits
            </summary>
            <typeparam name="T">The span element type</typeparam>
        </member>
        <member name="T:Z0.IBinarySpanPred`2">
            <summary>
            Characterizes a function that accepts two source spans and a target span of parametric type
            </summary>
            <typeparam name="T">The span element type</typeparam>
        </member>
        <member name="T:Z0.ITernarySpanPred`1">
            <summary>
            Characterizes a function that accepts three source spans and a target span of bits
            </summary>
            <typeparam name="T">The span element type</typeparam>
        </member>
        <member name="T:Z0.ISpanShift">
            <summary>
            Characterizes an operator that applies a bitwise shift or rotation to elements in a source span
            </summary>
        </member>
        <member name="T:Z0.ISpanShift`1">
            <summary>
            Characterizes a span operator that shifts each source element by the same amount
            </summary>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="T:Z0.IVarSpanShift`1">
            <summary>
            Characterizes a span operator that shifts each source element by an amount specified in a corresponding count span
            </summary>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="T:Z0.ITernaryOp`1">
            <summary>
            Characterizes a structural ternary operator
            </summary>
            <typeparam name="A">The operand type</typeparam>
        </member>
        <member name="T:Z0.ITernaryOp128`1">
            <summary>
            Characterizes a vectorized 128-bit ternary operator
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.ITernaryOp256`1">
            <summary>
            Characterizes a vectorized 256-bit ternary operator
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.ITernaryOp128D`1">
            <summary>
            Characterizes a vectorized 128-bit ternary operator that also supports evaluation via scalar decomposition
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.ITernaryOp256D`1">
            <summary>
            Characterizes a vectorized 256-bit ternary operator that also supports evaluation via scalar decomposition
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IUnaryImm8Op`1">
            <summary>
            Characterizes a binary function F:A -> byte -> A that accepts an 8-bit immediate value in the second parameter.
            </summary>
            <typeparam name="A">The operand type</typeparam>
            <remarks>
            Immediates are constant values, embedded directly in an instruction. So, given such a function
            when closed over a constant value, it effectively becomes a unary operator. This observation
            justifies the contract name
            </remarks>
        </member>
        <member name="T:Z0.IUnaryImm8x2Op`1">
            <summary>
            Characterizes a ternary function F:A -> byte -> byte -> A that accepts 8-bit
            immediate values in the second and third parameters.
            </summary>
            <typeparam name="A">The operand type</typeparam>
        </member>
        <member name="T:Z0.IUnaryImm8Op`3">
            <summary>
            Characterizes a unary vectorized operator that accepts an 8-bit immediate
            </summary>
            <typeparam name="W">The bit-width type</typeparam>
            <typeparam name="V">The operand type</typeparam>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IUnaryImm8Op128`1">
            <summary>
            Characterizes a vectorized unary operator over 128-bit operands that acepts an 8-bit immediate
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IUnaryImm8Op256`1">
            <summary>
            Characterizes a vectorized unary operator over 256-bit operands that acepts an 8-bit immediate
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IUnaryScalarImm8Op128`2">
            <summary>
            Characterizes a unary function that accepts a 128-bit vector and an 8-bit immediate and returns a scalar value
            </summary>
            <typeparam name="T">The vector component type</typeparam>
            <typeparam name="K">The scalar result type</typeparam>
        </member>
        <member name="T:Z0.IUnaryScalarImm8Op256`2">
            <summary>
            Characterizes a unary function that accepts a 256-bit vector argument along with an 8-bit immediate and returns a scalar value
            </summary>
            <typeparam name="T">The vector component type</typeparam>
            <typeparam name="K">The scalar result type</typeparam>
        </member>
        <member name="T:Z0.IUnaryImm8x2Op`3">
            <summary>
            Characterizes a unary vectorized operator that accepts two 8-bit immediates
            </summary>
            <typeparam name="W">The bit-width type</typeparam>
            <typeparam name="V">The operand type</typeparam>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IUnaryImm8x2Op128`1">
            <summary>
            Characterizes a vectorized unary operator over 128-bit operands that acepts two 8-bit immediates
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IUnaryImm8x2Op256`1">
            <summary>
            Characterizes a vectorized unary operator over 256-bit operands that acepts two 8-bit immediates
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IUnaryImm8x2Op128D`1">
            <summary>
            Characterizes a vectorized unary operator over 128-bit operands that acepts two 8-bit immediates
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IUnaryImm8x2Op256D`1">
            <summary>
            Characterizes a vectorized unary operator over 256-bit operands that acepts an 8-bit immediate
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IUnaryOp`1">
            <summary>
            Characterizes a unary operator
            </summary>
            <typeparam name="A">The operand type</typeparam>
        </member>
        <member name="T:Z0.IUnaryOp128`1">
            <summary>
            Characterizes a vectorized unary operator over 128-bit operands
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IUnaryOp256`1">
            <summary>
            Characterizes a vectorized unary operator over 256-bit operands
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IUnaryOp128D`1">
            <summary>
            Characterizes a vectorized unary operator over 128-bit operands that also supports componentwise decomposition/evaluation
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IUnaryOp256D`1">
            <summary>
            Characterizes a vectorized unary operator over 256-bit operands also supports componentwise decomposition/evaluation
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IUnaryPred`1">
            <summary>
            Defines trait for a vectorized unary predicate that supports componentwise decomposition/evaluation
            </summary>
            <typeparam name="T">The component type</typeparam>
        </member>
        <member name="T:Z0.IUnaryPred128`1">
            <summary>
            Characterizes a vectorized unary predicate over 128-bit operands
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IUnaryPred256`1">
            <summary>
            Characterizes a vectorized unary predicate over 256-bit operands
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IUnaryPred128D`1">
            <summary>
            Characterizes a vectorized unary predicate over 128-bit operands that also supports componentwise decomposition/evaluation
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IUnaryPred256D`1">
            <summary>
            Characterizes a vectorized unary predicate over 128-bit operands that also supports componentwise decomposition/evaluation
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IBinaryOp128`1">
            <summary>
            Characterizes a vectorized binary operator over 128-bit operands
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IBinaryOp256`1">
            <summary>
            Characterizes a vectorized binary operator over 256-bit operands
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IBinaryOp512`1">
            <summary>
            Characterizes a vectorized binary operator over 256-bit operands
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IBinaryOp128D`1">
            <summary>
            Characterizes a vectorized binary operator over 128-bit operands that is accompanied by componentwise decomposition/evaluation
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IBinaryOp256D`1">
            <summary>
            Characterizes a vectorized binary operator over 256-bit operands that is accompanied by componentwise decomposition/evaluation
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IBinaryOp512D`1">
            <summary>
            Characterizes a vectorized binary operator over 256-bit operands that is accompanied by componentwise decomposition/evaluation
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IVUnaryScalarFunc`2">
            <summary>
            Defines trait for a vectorized unary scalar function that supports componentwise decomposition/evaluation
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IVBinaryScalarFunc`2">
            <summary>
            Defines trait for a vectorized binary scalar function that supports componentwise decomposition/evaluation
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IVTernaryScalarFunc`2">
            <summary>
            Defines trait for a vectorized binary scalar function that supports componentwise decomposition/evaluation
            </summary>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="T:Z0.IVScalarFunc`4">
            <summary>
            Characterizes a unary function that accepts a vector argument and returns a scalar value
            </summary>
            <typeparam name="W">The bit width type</typeparam>
            <typeparam name="V">The vector type</typeparam>
            <typeparam name="T">The vector component type</typeparam>
            <typeparam name="K">The scalar result type</typeparam>
        </member>
        <member name="T:Z0.IVScalarFunc`7">
            <summary>
            Characterizes a binary function that accepts two vector arguments and returns a scalar value
            </summary>
            <typeparam name="W1">The bit width type of the first vector</typeparam>
            <typeparam name="W2">The bit width type of the second vector</typeparam>
            <typeparam name="V1">The type of the first vector</typeparam>
            <typeparam name="V2">The type of the second vector</typeparam>
            <typeparam name="T1">The component type of the first vector</typeparam>
            <typeparam name="T2">The component type of the second vector</typeparam>
            <typeparam name="K">The scalar result type</typeparam>
        </member>
        <member name="T:Z0.IVScalarFunc`10">
            <summary>
            Characterizes a ternary function that accepts three vector arguments and returns a scalar value
            </summary>
            <typeparam name="W1">The bit width type of the first vector</typeparam>
            <typeparam name="W2">The bit width type of the second vector</typeparam>
            <typeparam name="W3">The bit width type of the second vector</typeparam>
            <typeparam name="V1">The type of the first vector</typeparam>
            <typeparam name="V2">The type of the second vector</typeparam>
            <typeparam name="V3">The type of the third vector</typeparam>
            <typeparam name="T1">The component type of the first vector</typeparam>
            <typeparam name="T2">The component type of the second vector</typeparam>
            <typeparam name="T3">The component type of the third vector</typeparam>
            <typeparam name="K">The scalar result type</typeparam>
        </member>
        <member name="T:Z0.IVUnaryScalarFunc128`2">
            <summary>
            Characterizes a unary function that accepts a 128-bit vector argument and returns a scalar value
            </summary>
            <typeparam name="T">The vector component type</typeparam>
            <typeparam name="K">The scalar result type</typeparam>
        </member>
        <member name="T:Z0.ISVBinaryScalar128D`2">
            <summary>
            Characterizes a binary function that accepts homogenous 128-bit vector arguments and returns a scalar value
            that supports scalar decomposition
            </summary>
            <typeparam name="T">The vector component type</typeparam>
            <typeparam name="K">The scalar result type</typeparam>
        </member>
        <member name="T:Z0.ISVTernaryScalar128D`2">
            <summary>
            Characterizes a ternary function that accepts homogenous 128-bit vector arguments and returns a scalar value
            that supports scalar decomposition
            </summary>
            <typeparam name="T">The vector component type</typeparam>
            <typeparam name="K">The scalar result type</typeparam>
        </member>
        <member name="T:Z0.ISVUnaryScalarFunc256`2">
            <summary>
            Characterizes a unary function that accepts a 256-bit vector argument and returns a scalar value
            </summary>
            <typeparam name="T">The vector component type</typeparam>
            <typeparam name="K">The scalar result type</typeparam>
        </member>
        <member name="T:Z0.ISVUnaryScalarFunc256D`2">
            <summary>
            Characterizes a unary function that accepts a 256-bit vector argument and returns a scalar value
            that supports scalar decomposition
            </summary>
            <typeparam name="T">The vector component type</typeparam>
            <typeparam name="K">The scalar result type</typeparam>
        </member>
        <member name="T:Z0.ISVBinaryScalarFunc256D`2">
            <summary>
            Characterizes a binary function that accepts homogenous 256-bit vector arguments and returns a scalar value
            that supports scalar decomposition
            </summary>
            <typeparam name="T">The vector component type</typeparam>
            <typeparam name="K">The scalar result type</typeparam>
        </member>
        <member name="T:Z0.ISVTernaryScalarFunc256D`2">
            <summary>
            Characterizes a ternary function that accepts homogenous 256-bit vector arguments that returns a scalar value
            that supports scalar decomposition
            </summary>
            <typeparam name="T">The vector component type</typeparam>
            <typeparam name="K">The scalar result type</typeparam>
        </member>
        <member name="F:Z0.ProjectorProxy`2.Dst">
            <summary>
            Captures a projected value
            </summary>
        </member>
        <member name="F:Z0.ProjectorProxy`1.Delegate">
            <summary>
            The proxy subject
            </summary>
        </member>
        <member name="F:Z0.ProjectorProxy`1.Target">
            <summary>
            Captures a projected value
            </summary>
        </member>
        <member name="M:Z0.SFxFactories.fx(System.Type)">
            <summary>
            Instantiates a service operation host
            </summary>
            <param name="host">The hosting type</param>
        </member>
        <member name="M:Z0.SFxFactories.host(System.Type)">
            <summary>
            Creates a service provider reified by a specified type
            </summary>
            <param name="provider">The provider type</param>
        </member>
        <member name="M:Z0.SFxFactories.host(System.Type,System.Type)">
            <summary>
            Creates a provider from the service factory that defines operations to instantiate
            services and an enclosing type within which the service implementations are defined
            </summary>
            <param name="factory">The service factor</param>
            <param name="enclosure">The outer host type</param>
        </member>
        <member name="T:Z0.SFxHost">
            <summary>
            Defines service provider implementation predicated on service factory and enclosure types
            </summary>
        </member>
        <member name="F:Z0.SFxHost.HostTypes">
            <summary>
            The types declared within the enclosure that define serviced api operations
            </summary>
        </member>
        <member name="F:Z0.SFxHost.FactoryMethods">
            <summary>
            The methods defined by the factory host that intantiate services reified by the host types
            </summary>
        </member>
        <member name="P:Z0.SFxHost.FactoryHost">
            <summary>
            The type that defines the service factory operations
            </summary>
        </member>
        <member name="P:Z0.SFxHost.HostEnclosure">
            <summary>
            The type into which api service reifications are nested
            </summary>
        </member>
        <member name="P:Z0.SFxHost.Z0#ISFxHost#HostTypes">
            <summary>
            The types declared within the enclosure that define serviced api operations
            </summary>
        </member>
        <member name="P:Z0.SFxHost.Z0#ISFxHost#FactoryMethods">
            <summary>
            The methods defined by the factory host that intantiate services reified by the host types
            </summary>
        </member>
        <member name="T:Z0.Surrogates">
            <summary>
            Defines surrogate api - a facility for defining structural functions over delegates
            </summary>
        </member>
        <member name="M:Z0.Surrogates.emitter``1(Z0.Emitter{``0},System.String,``0)">
            <summary>
            Defines a delegate-predicated structural emitter
            </summary>
            <param name="f">The source delegate</param>
            <param name="t">An operand type representative to aid type inference</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.Surrogates.unary``1(Z0.UnaryOp{``0},System.String,``0)">
            <summary>
            Defines a delegate-predicated structural operator
            </summary>
            <param name="f">The source delegate</param>
            <param name="t">An operand type representative to aid type inference</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.Surrogates.binary``1(Z0.BinaryOp{``0},System.String,``0)">
            <summary>
            Defines a delegate-predicated structural operator
            </summary>
            <param name="f">The source delegate</param>
            <param name="t">An operand type representative to aid type inference</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.Surrogates.ternary``1(Z0.TernaryOp{``0},System.String,``0)">
            <summary>
            Defines a delegate-predicated structural operator
            </summary>
            <param name="f">The source delegate</param>
            <param name="t">An operand type representative to aid type inference</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.Surrogates.predicate``1(Z0.UnaryPredicate{``0},System.String,``0)">
            <summary>
            Defines a delegate-predicated structural predicate
            </summary>
            <param name="f">The source delegate</param>
            <param name="t">An operand type representative to aid type inference</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.Surrogates.predicate``1(Z0.BinaryPredicate{``0},System.String,``0)">
            <summary>
            Defines a delegate-predicated structural predicate
            </summary>
            <param name="f">The source delegate</param>
            <param name="t">An operand type representative to aid type inference</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.Surrogates.emitter``1(Z0.Emitter{``0},Z0.OpIdentity,``0)">
            <summary>
            Defines an identified structural emitter predicated on a delegate
            </summary>
            <param name="f">The source delegate</param>
            <param name="id">The sfunc identity</param>
            <param name="t">An operand type representative to aid type inference</param>
            <typeparam name="T">The emission type</typeparam>
        </member>
        <member name="M:Z0.Surrogates.unary``1(Z0.UnaryOp{``0},Z0.OpIdentity,``0)">
            <summary>
            Defines a delegate-predicated structural operator with identity
            </summary>
            <param name="f">The source delegate</param>
            <param name="id">The sfunc identity</param>
            <param name="t">An operand type representative to aid type inference</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.Surrogates.binary``1(Z0.BinaryOp{``0},Z0.OpIdentity,``0)">
            <summary>
            Defines a delegate-predicated structural operator with identity
            </summary>
            <param name="f">The source delegate</param>
            <param name="id">The sfunc identity</param>
            <param name="t">An operand type representative to aid type inference</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.Surrogates.ternary``1(Z0.TernaryOp{``0},Z0.OpIdentity,``0)">
            <summary>
            Defines a delegate-predicated structural operator with identity
            </summary>
            <param name="f">The source delegate</param>
            <param name="id">The sfunc identity</param>
            <param name="t">An operand type representative to aid type inference</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.Surrogates.predicate``1(Z0.UnaryPredicate{``0},Z0.OpIdentity,``0)">
            <summary>
            Defines a delegate-predicated structural predicate with identity
            </summary>
            <param name="f">The source delegate</param>
            <param name="id">The sfunc identity</param>
            <param name="t">An operand type representative to aid type inference</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.Surrogates.predicate``1(Z0.BinaryPredicate{``0},Z0.OpIdentity,``0)">
            <summary>
            Defines a delegate-predicated structural predicate with identity
            </summary>
            <param name="f">The source delegate</param>
            <param name="id">The sfunc identity</param>
            <param name="t">An operand type representative to aid type inference</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="T:Z0.Surrogates.Emitter`1">
            <summary>
            Captures a delegate that is exposed as an emitter
            </summary>
        </member>
        <member name="T:Z0.Surrogates.SpanEmitter`1">
            <summary>
            Captures a delegate that is exposed as an emitter
            </summary>
        </member>
        <member name="M:Z0.Spans.all``1(System.ReadOnlySpan{``0},System.Func{``0,System.Boolean})">
            <summary>
            Determines whether all of the elements of a source span satisfy a supplied predicate
            </summary>
            <param name="src">The source span</param>
            <param name="f">The predicate</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.Spans.alloc``1(System.UInt64)">
            <summary>
            Allocates a span
            </summary>
            <param name="length">The number cells to allocate</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.Spans.alloc``1(System.Int32)">
            <summary>
            Allocates a span
            </summary>
            <param name="length">The number cells to allocate</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.Spans.count``1(System.ReadOnlySpan{``0},System.Func{``0,System.Boolean})">
            <summary>
            Counts the number of values in the source that satisfy the predicate
            </summary>
            <param name="src">The source span</param>
            <param name="f">The predicate to evaluate over each element</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.Spans.first``2(Z0.NatSpan{``0,``1})">
            <summary>
            Returns a reference to the location of the first span element
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.Spans.s8u``1(System.Span{``0})">
            <summary>
            Presents a span of generic values as a span of bytes
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.Spans.s8i``1(System.Span{``0})">
            <summary>
            Presents a readonly span of generic values as a span of signed bytes
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.Spans.s16i``1(System.Span{``0})">
            <summary>
            Presents a span of generic values as a span of signed 16-bit integers
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.Spans.s16u``1(System.Span{``0})">
            <summary>
            Presents a span of generic values as a span of unsigned 16-bit integers
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.Spans.s32i``1(System.Span{``0})">
            <summary>
            Presents a span of generic values as a span of signed 32-bit integers
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.Spans.s32u``1(System.Span{``0})">
            <summary>
            Presents a span of generic values as a span of unsigned 32-bit integers
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.Spans.s64i``1(System.Span{``0})">
            <summary>
            Presents a span of generic values as a span of 64-bit signed integers
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.Spans.s64u``1(System.Span{``0})">
            <summary>
            Presents a span of generic values as a span of 64-bit unsigned integers
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.Spans.s32f``1(System.Span{``0})">
            <summary>
            Presents a span of generic values as a span of 32-bit floats
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.Spans.s64f``1(System.Span{``0})">
            <summary>
            Presents a span of generic values as a span of 64-bit floats
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.Spans.s8i``1(System.ReadOnlySpan{``0})">
            <summary>
            Presents a readonly span of generic values as a readonly span of signed bytes
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.Spans.s8u``1(System.ReadOnlySpan{``0})">
            <summary>
            Presents a readonly span of generic values as a readonly span of bytes
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.Spans.s16i``1(System.ReadOnlySpan{``0})">
            <summary>
            Presents a readonly span of generic values as a readonly span of signed 16-bit integers
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.Spans.s16u``1(System.ReadOnlySpan{``0})">
            <summary>
            Presents a readonly span of generic values as a readonly span of unsigned 16-bit integers
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.Spans.s32i``1(System.ReadOnlySpan{``0})">
            <summary>
            Presents a readonly span of generic values as a readonly span of signed 32-bit integers
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.Spans.s32u``1(System.ReadOnlySpan{``0})">
            <summary>
            Presents a readonly span of generic values as a readonly span of unsigned 32-bit integers
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.Spans.s64i``1(System.ReadOnlySpan{``0})">
            <summary>
            Presents a readonly span of generic values as a readonly span of 64-bit signed integers
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.Spans.s64u``1(System.ReadOnlySpan{``0})">
            <summary>
            Presents a readonly span of generic values as a readonly span of 64-bit unsigned integers
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.Spans.s32f``1(System.ReadOnlySpan{``0})">
            <summary>
            Presents a readonly span of generic values as a readonly span of 32-bit floats
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.Spans.s64f``1(System.ReadOnlySpan{``0})">
            <summary>
            Presents a readonly readonly span of generic values as a readonly readonly span of 64-bit floats
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.Spans.partial``1(System.Span{System.Byte})">
            <summary>
            Reads a partial value if there aren't a sufficient number of bytes to comprise a target value
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.XSpan.Any``1(System.ReadOnlySpan{``0},System.Func{``0,System.Boolean})">
            <summary>
            Determines whether any elements of a span satisfy a supplied predicate
            </summary>
            <param name="src">The source span</param>
            <param name="f">The predicate</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XSpan.Any``1(System.Span{``0},System.Func{``0,System.Boolean})">
            <summary>
            Determines whether any elements of a span satisfy a supplied predicate
            </summary>
            <param name="src">The source span</param>
            <param name="f">The predicate</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XSpan.AsInt8``1(System.Span{``0})">
            <summary>
            Presents a span of generic values as a span of signed 8-bit integers
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.XSpan.AsUInt8``1(System.Span{``0})">
            <summary>
            Presents a span of generic values as a span of unsigned 8-bit integers
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.XSpan.AsInt16``1(System.Span{``0})">
            <summary>
            Presents a span of generic values as a span of signed 16-bit integers
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.XSpan.AsUInt16``1(System.Span{``0})">
            <summary>
            Presents a span of generic values as a span of unsigned 16-bit integers
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.XSpan.AsInt32``1(System.Span{``0})">
            <summary>
            Presents a span of generic values as a span of signed 32-bit integers
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.XSpan.AsUInt32``1(System.Span{``0})">
            <summary>
            Presents a span of generic values as a span of unsigned 32-bit integers
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.XSpan.AsInt64``1(System.Span{``0})">
            <summary>
            Presents a span of generic values as a span of 64-bit signed integers
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.XSpan.AsUInt64``1(System.Span{``0})">
            <summary>
            Presents a span of generic values as a span of 64-bit unsigned integers
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.XSpan.AsFloat32``1(System.Span{``0})">
            <summary>
            Presents a span of generic values as a span of 32-bit floats
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.XSpan.AsFloat64``1(System.Span{``0})">
            <summary>
            Presents a span of generic values as a span of 64-bit floats
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.XSpan.AsFloat128``1(System.Span{``0})">
            <summary>
            Presents a span of generic values as a span of 64-bit floats
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.XSpan.AsBool``1(System.Span{``0})">
            <summary>
            Presents a span of generic values as a span of bool
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.XSpan.AsBit8u``1(System.Span{``0})">
            <summary>
            Presents a span of generic values as a span of <see cref='T:Z0.bit'/>
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.XSpan.AsChar``1(System.Span{``0})">
            <summary>
            Presents a span of generic values as a span of 64-bit floats
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.XSpan.AsEnum``2(System.Span{``0},``1)">
            <summary>
            Presents a span of generic values as a span of chars
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.XSpan.AsInt8``1(System.ReadOnlySpan{``0})">
            <summary>
            Presents a readonly span of generic values as a span of signed bytes
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source span element type</typeparam>
        </member>
        <member name="M:Z0.XSpan.AsInt16``1(System.ReadOnlySpan{``0})">
            <summary>
            Presents a span of generic values as a span of signed 16-bit integers
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.XSpan.AsUInt16``1(System.ReadOnlySpan{``0})">
            <summary>
            Presents a span of generic values as a span of unsigned 16-bit integers
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.XSpan.AsInt32``1(System.ReadOnlySpan{``0})">
            <summary>
            Presents a span of generic values as a span of signed 32-bit integers
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.XSpan.AsUInt32``1(System.ReadOnlySpan{``0})">
            <summary>
            Presents a span of generic values as a span of unsigned 32-bit integers
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.XSpan.AsInt64``1(System.ReadOnlySpan{``0})">
            <summary>
            Presents a span of generic values as a span of 64-bit signed integers
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.XSpan.AsUInt64``1(System.ReadOnlySpan{``0})">
            <summary>
            Presents a span of generic values as a span of 64-bit unsigned integers
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.XSpan.AsFloat32``1(System.ReadOnlySpan{``0})">
            <summary>
            Presents a span of generic values as a span of 32-bit floats
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.XSpan.AsFloat64``1(System.ReadOnlySpan{``0})">
            <summary>
            Presents a span of generic values as a span of 64-bit floats
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.XSpan.AsFloat128``1(System.ReadOnlySpan{``0})">
            <summary>
            Presents a span of generic values as a span of 64-bit floats
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.XSpan.AsBool``1(System.ReadOnlySpan{``0})">
            <summary>
            Presents a span of generic values as a span of bool
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.XSpan.AsChar``1(System.ReadOnlySpan{``0})">
            <summary>
            Presents a span of generic values as a span of chars
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.XSpan.count``1(System.ReadOnlySpan{``0},System.Func{``0,System.Boolean})">
            <summary>
            Counts the number of values in the source that satisfy the predicate
            </summary>
            <param name="src">The source span</param>
            <param name="f">The predicate to evaluate over each element</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XSpan.Count``1(System.ReadOnlySpan{``0},System.Func{``0,System.Boolean})">
            <summary>
            Counts the number of values in the source that satisfy the predicate
            </summary>
            <param name="src">The source span</param>
            <param name="f">The predicate to evaluate over each element</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XSpan.Count``1(System.Span{``0},System.Func{``0,System.Boolean})">
            <summary>
            Counts the number of values in the source that satisfy the predicate
            </summary>
            <param name="src">The source span</param>
            <param name="f">The predicate to evaluate over each element</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XSpan.First``1(System.Span{``0})">
            <summary>
            Returns a reference to the first element of a nonempty span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XSpan.Last``1(System.Span{``0})">
            <summary>
            Returns a reference to the last element of a nonempty span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XSpan.FormatTable``1(System.Span{``0},System.Int32,System.Int32,System.Nullable{System.Int32},System.Nullable{System.Char},System.Nullable{System.Char},System.Nullable{System.Char})">
            <summary>
            Formats a span as a table
            </summary>
            <param name="src">The source data to be formatted</param>
            <param name="rowcount">The number of rows in the output table</param>
            <param name="colcount">The number of columns in the output table</param>
            <param name="cellsep">The character that intersperses the cells of each row</param>
            <param name="rowsep">The character that intersperses the rows </param>
            <param name="padlen">The optional padding for each cell; if less than zero the calls are left-padded; if greater than zero, the cells are right-padded</param>
            <param name="padchar">The optional pad character; if unspecified and padlen is specified it defaults to a space</param>
            <typeparam name="T">The span element type</typeparam>
        </member>
        <member name="M:Z0.XSpan.Intersperse``1(System.ReadOnlySpan{``0},``0)">
            <summary>
            Creates a new span by interposing a specified element between each element of an existing span
            </summary>
            <param name="src">The source span</param>
            <param name="x">The value to place between each element in the new span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XSpan.Intersperse``1(System.Span{``0},``0)">
            <summary>
            Creates a new span by interposing a specified element between each element of an existing span
            </summary>
            <param name="src">The source span</param>
            <param name="x">The value to place between each element in the new span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XSpan.Map``2(System.ReadOnlySpan{``0},System.Func{``0,``1})">
            <summary>
            Projects a source span to target span via a supplied transformation
            </summary>
            <param name="src">The source</param>
            <param name="f">The transformation</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.XSpan.Map``2(System.Span{``0},System.Func{``0,``1})">
            <summary>
            Projects a source span to target span
            </summary>
            <param name="src">The source span</param>
            <param name="f">The projector</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.XSpan.MapRange``2(System.ReadOnlySpan{``0},System.Int32,System.Int32,System.Func{``0,``1})">
            <summary>
            Projects a range of elements from a source span to a target span
            </summary>
            <param name="src">The source span</param>
            <param name="offset">The source offset</param>
            <param name="length">The length of the segment to project</param>
            <param name="f">The projector</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.XSpan.MapRange``2(System.Span{``0},System.Int32,System.Int32,System.Func{``0,``1})">
            <summary>
            Projects a range of elements from a source span to a target span
            </summary>
            <param name="src">The source span</param>
            <param name="offset">The source offset</param>
            <param name="length">The length of the segment to project</param>
            <param name="f">The projector</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.XSpan.MapArray``2(System.ReadOnlySpan{``0},System.Func{``0,``1})">
            <summary>
            Projects a source span to target span via a supplied transformation
            </summary>
            <param name="src">The source</param>
            <param name="f">The transformation</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.XSpan.Replicate``1(System.ReadOnlySpan{``0})">
            <summary>
            Clones the source span into a new span
            </summary>
            <param name="src">The span to replicate</param>
            <typeparam name="T">The element type</typeparam>
            <returns>Returns the replicated span</returns>
        </member>
        <member name="M:Z0.XSpan.Replicate``1(System.Span{``0})">
            <summary>
            Clones the source span into a new span
            </summary>
            <param name="src">The span to replicate</param>
            <typeparam name="T">The element type</typeparam>
            <returns>Returns the replicated span</returns>
        </member>
        <member name="M:Z0.XSpan.Reverse``1(System.ReadOnlySpan{``0})">
            <summary>
            Produces a reversed span from a readonly span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XSpan.Bytes``1(System.Span{``0},System.Int32,System.Nullable{System.Int32})">
            <summary>
            Presents selected span content as a span of bytes
            </summary>
            <param name="src">The source span</param>
            <param name="offset">The source offset</param>
            <param name="length">The source length</param>
            <typeparam name="T">The source element type</typeparam>
        </member>
        <member name="M:Z0.XSpan.Bytes``1(System.Span{``0})">
            <summary>
            Presents a span of generic values as a span of bytes
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.XSpan.Bytes``1(System.ReadOnlySpan{``0})">
            <summary>
            Presents a readonly span of generic values as a span of readonly bytes
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source span element type</typeparam>
        </member>
        <member name="M:Z0.XSpan.Cast``1(System.Span{System.Byte})">
            <summary>
            Presents a u8 span as a T-span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The Target type</typeparam>
        </member>
        <member name="M:Z0.XSpan.Cast``1(System.Span{System.UInt16})">
            <summary>
            Presents a u16 span as a T-span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The Target type</typeparam>
        </member>
        <member name="M:Z0.XSpan.Cast``1(System.Span{System.UInt32})">
            <summary>
            Presents a u32 span as a T-span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The Target type</typeparam>
        </member>
        <member name="M:Z0.XSpan.Cast``1(System.Span{System.UInt64})">
            <summary>
            Presents a u64 span as a T-span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The Target type</typeparam>
        </member>
        <member name="M:Z0.XSpan.Cast``1(System.Span{System.Char})">
            <summary>
            Presents a c16 span as a T-span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The Target type</typeparam>
        </member>
        <member name="M:Z0.XSpan.Cast``1(System.ReadOnlySpan{System.Byte})">
            <summary>
            Presents a u8 span as a T-span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The Target type</typeparam>
        </member>
        <member name="M:Z0.XSpan.Cast``1(System.ReadOnlySpan{System.UInt16})">
            <summary>
            Presents a u16 span as a T-span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The Target type</typeparam>
        </member>
        <member name="M:Z0.XSpan.Cast``1(System.ReadOnlySpan{System.UInt32})">
            <summary>
            Presents a u32 span as a T-span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The Target type</typeparam>
        </member>
        <member name="M:Z0.XSpan.Cast``1(System.ReadOnlySpan{System.UInt64})">
            <summary>
            Presents a u64 span as a T-span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The Target type</typeparam>
        </member>
        <member name="M:Z0.XSpan.Cast``1(System.ReadOnlySpan{System.Char})">
            <summary>
            Presents a c16 span as a T-span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The Target type</typeparam>
        </member>
        <member name="M:Z0.XSpan.Cast``2(System.Span{``0})">
            <summary>
            Presents a span of one value-type as a span of another value-type
            </summary>
            <param name="src">The source span</param>
            <typeparam name="S">The source cell type</typeparam>
            <typeparam name="T">The target cell type</typeparam>
        </member>
        <member name="M:Z0.XSpan.Cast``2(System.ReadOnlySpan{``0})">
            <summary>
            Presents a readonly span of one value-type as a span of another value-type
            </summary>
            <param name="src">The source span</param>
            <typeparam name="S">The source cell type</typeparam>
            <typeparam name="T">The target cell type</typeparam>
        </member>
        <member name="M:Z0.XSpan.Concat``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Forms a new span via concatenation [head,tail]
            </summary>
            <param name="head">The first span</param>
            <param name="tail">The second span</param>
            <typeparam name="T">The span element type</typeparam>
        </member>
        <member name="M:Z0.XSpan.Concat``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Forms a new span via concatenation [head,tail]
            </summary>
            <param name="head">The first span</param>
            <param name="tail">The second span</param>
            <typeparam name="T">The span element type</typeparam>
        </member>
        <member name="M:Z0.XSpan.CopyTo``1(System.Span{``0},System.Span{``0},System.Int32)">
            <summary>
            Copies the source span to a target span begininning at a specified target offset
            </summary>
            <param name="src">The source span</param>
            <param name="dst">The target span</param>
            <param name="offset">The target offset</param>
            <typeparam name="T">The span cell type</typeparam>
        </member>
        <member name="M:Z0.XSpan.CopyTo``1(System.ReadOnlySpan{``0},System.Span{``0},System.Int32)">
            <summary>
            Copies the source span to a target span begininning at a specified target offset
            </summary>
            <param name="src">The source span</param>
            <param name="dst">The target span</param>
            <param name="offset">The target offset</param>
            <typeparam name="T">The span cell type</typeparam>
        </member>
        <member name="M:Z0.XSpan.Singleton``2(System.Span{``0},System.Int32,System.Nullable{System.Int32})">
            <summary>
            Renders a non-allocating mutable view over a source span segment that is presented as an individual target value
            </summary>
            <param name="src">The source span</param>
            <param name="offset">The index of the first source element</param>
            <param name="length">The number of source elements required to constitute a target type</param>
            <typeparam name="S">The source element type</typeparam>
            <typeparam name="T">The target element type</typeparam>
        </member>
        <member name="M:Z0.XSpan.Take``1(System.Span{System.Byte})">
            <summary>
            Reads a partial value if there aren't a sufficient number of bytes to comprise a target value
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.XSpan.TakeBytes(System.ReadOnlySpan{System.Byte},System.Span{System.Byte})">
            <summary>
            Copies at most n bytes from the source span to the target span where n is the length of the target span
            </summary>
            <param name="src">The source span</param>
            <param name="dst">The target span</param>
        </member>
        <member name="M:Z0.XSpan.TakeUInt24``1(System.Span{``0})">
            <summary>
            Converts the leading elements of a primal source span to a 24-bit unsigned integer
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The primal source type</typeparam>
        </member>
        <member name="M:Z0.XSpan.TrimEnd(System.Span{System.Byte})">
            <summary>
            Eliminates trailing zeros in the source span
            </summary>
            <param name="src">The source span</param>
        </member>
        <member name="M:Z0.XSpan.Swap``1(System.Span{``0},System.UInt32,System.UInt32)">
            <summary>
            Interchanges span elements i and j
            </summary>
            <param name="src">The source span</param>
            <param name="i">An index of a span element</param>
            <param name="j">An index of a span element</param>
            <typeparam name="T">The span element type</typeparam>
        </member>
        <member name="M:Z0.XSpan.ToDictionary``1(System.ReadOnlySpan{``0})">
            <summary>
            Creates a dictionary from a span using the element indices as keys
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XSpan.ToDictionary``1(System.Span{``0})">
            <summary>
            Creates a dictionary from a span using the element indices as keys
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XSpan.ToEnumerable``1(System.ReadOnlySpan{``0})">
            <summary>
            Lifts span content into the LINQ monad
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XSpan.ToEnumerable``1(System.Span{``0})">
            <summary>
            Lifts span content into the LINQ monad
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XSpan.ToMemory``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
             Constructs a memory segment from the content of the (hopefully finite) stream (allocating)
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.XSpan.ToReadOnlyMemory``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
             Constructs a memory segment from the content of the (hopefully finite) stream (allocating)
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.XSpan.ToSet``1(System.Span{``0})">
            <summary>
            Constructs a hash set from span content
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The item type</typeparam>
        </member>
        <member name="M:Z0.XSpan.ToSet``1(System.ReadOnlySpan{``0})">
            <summary>
            Constructs a hash set from span content
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The item type</typeparam>
        </member>
        <member name="M:Z0.XSpan.ToSet``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Constructs a hash set from span content
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The item type</typeparam>
        </member>
        <member name="M:Z0.XSpan.ToSet``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Constructs a hash set from span content
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The item type</typeparam>
        </member>
        <member name="M:Z0.XSpan.ValuesEqual``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0})">
            <summary>
            Evaluates whether two spans have identical content
            </summary>
            <param name="lhs">The left span</param>
            <param name="rhs">The right span</param>
            <typeparam name="T">The value type</typeparam>
        </member>
        <member name="M:Z0.XSpan.ValuesEqual``1(System.Span{``0},System.ReadOnlySpan{``0})">
            <summary>
            Evaluates whether two spans have identical content
            </summary>
            <param name="lhs">The left span</param>
            <param name="rhs">The right span</param>
            <typeparam name="T">The value type</typeparam>
        </member>
        <member name="T:Z0.IDomainValues`1">
            <summary>
            Characterizes a value emitter that supports placing upper and/or lower bounds on
            the values produced
            </summary>
            <typeparam name="T">The production value type</typeparam>
        </member>
        <member name="M:Z0.IDomainValues`1.Next(`0)">
            <summary>
            Retrieves the next point from the source, constrained by an upper bound
            </summary>
            <param name="max">The exclusive upper bound</param>
            <typeparam name="T">The point type</typeparam>
        </member>
        <member name="M:Z0.IDomainValues`1.Next(`0,`0)">
            <summary>
            Retrieves the next point from the source, constrained by upper and lower bounds
            </summary>
            <param name="min">The inclusive lower bound</param>
            <param name="max">The exclusive max value</param>
        </member>
        <member name="M:Z0.IDomainValues.Next``1(``0)">
            <summary>
            Retrieves the next point from the source, constrained by an upper bounds
            </summary>
            <param name="max">The exclusive max value</param>
            <typeparam name="T">The point type</typeparam>
        </member>
        <member name="M:Z0.IDomainValues.Next``1(``0,``0)">
            <summary>
            Retrieves the next point from the source, constrained by upper and lower bounds
            </summary>
            <param name="min">The inclusive min value</param>
            <param name="max">The exclusive max value</param>
            <typeparam name="T">The point type</typeparam>
        </member>
        <member name="M:Z0.IDomainValues.Next``1(Z0.Interval{``0})">
            <summary>
            Retrieves the next point from the source, bound within a specified interval
            </summary>
            <param name="src">The random source</param>
            <param name="domain">The domain of the random variable</param>
            <typeparam name="T">The point type</typeparam>
        </member>
        <member name="M:Z0.IDomainValues.Next``1(Z0.ClosedInterval{``0})">
            <summary>
            Retrieves the next point from the source, bound within a specified interval
            </summary>
            <param name="src">The random source</param>
            <param name="domain">The domain of the random variable</param>
            <typeparam name="T">The point type</typeparam>
        </member>
        <member name="T:Z0.ILimitedSource`1">
            <summary>
            Characterizes an emission service that may run out of values to emit
            </summary>
            <typeparam name="T">The emission value type</typeparam>
        </member>
        <member name="M:Z0.ILimitedSource`1.Next(`0@)">
            <summary>
            Populates the target with the next value if it exists
            </summary>
        </member>
        <member name="T:Z0.IPolySource">
            <summary>
            Characterizes a fountain of generic points
            </summary>
        </member>
        <member name="M:Z0.IPolySource.Domain``1">
            <summary>
            Returns the default domain used when producing random points for a parametrically-identified type
            </summary>
            <typeparam name="T">The point type</typeparam>
        </member>
        <member name="P:Z0.IStreamProvider`1.Stream">
            <summary>
            In infinite T-stream
            </summary>
        </member>
        <member name="M:Z0.IValueSource.Next``1">
            <summary>
            Retrieves the next point from the source, bound only by the domain of the type
            </summary>
            <typeparam name="T">The point type</typeparam>
        </member>
        <member name="T:Z0.IValueSource`1">
            <summary>
            Characterizes an unlimited value emitter that produces one value at a time
            </summary>
            <typeparam name="T">The production value type</typeparam>
        </member>
        <member name="T:Z0.IDistributionSpec">
            <summary>
            Characterizes a distribution specifier
            </summary>
        </member>
        <member name="T:Z0.IDistributionSpec`1">
            <summary>
            Characterizes a T-parametric distribution specifier
            </summary>
            <typeparam name="T">The sample value type</typeparam>
        </member>
        <member name="T:Z0.IDistributionSpec`2">
            <summary>
            Characterizes a T-parametric distribution specifier reification
            </summary>
            <typeparam name="F">The reification type</typeparam>
            <typeparam name="T">The sample value type</typeparam>
        </member>
        <member name="T:Z0.IPolyrand">
            <summary>
            Characterizes source capable of producing an interminable sequence of pseudorandom bounded points
            of any numeric type among: sbyte, byte, short, ushort, int, uint, long, ulong, float, double
            </summary>
        </member>
        <member name="P:Z0.IPolyrand.Navigator">
            <summary>
            Retrieves the random stream navigator, if supported
            </summary>
        </member>
        <member name="T:Z0.IPolyrandProvider">
            <summary>
            Characterizes a type that provides access to a stateful and parametric-polymorphic
            pseudorandom number generator
            </summary>
        </member>
        <member name="T:Z0.IRngBoundPointSource`1">
            <summary>
            Characterizes a random source that can produce points bounded by a range
            </summary>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="T:Z0.IRngNav">
            <summary>
            Characterizes a random stream navigator
            </summary>
        </member>
        <member name="M:Z0.IRngNav.Advance(System.UInt64)">
            <summary>
            Moves the stream a specified number of steps forward
            </summary>
            <param name="steps">The step count</param>
        </member>
        <member name="M:Z0.IRngNav.Retreat(System.UInt64)">
            <summary>
            Moves the stream a specified number of steps backward
            </summary>
            <param name="steps">The step count</param>
        </member>
        <member name="T:Z0.IRngNav`1">
            <summary>
            Characterizes a random source that can be navigated
            </summary>
            <typeparam name="T">The primal element type</typeparam>
        </member>
        <member name="P:Z0.IRngSampler`1.BufferLength">
            <summary>
            The length of the sampler's internal buffer
            </summary>
        </member>
        <member name="P:Z0.IRngSampler`1.DistKind">
            <summary>
            The type of distribution being sampled
            </summary>
        </member>
        <member name="T:Z0.IRngSource">
            <summary>
            Identifies a source of random data
            </summary>
        </member>
        <member name="P:Z0.IRngSource.RngKind">
            <summary>
            Identifies the rng that drives the source
            </summary>
        </member>
        <member name="T:Z0.IRngStream`1">
            <summary>
            Characterizes a stream of random values of parametric type
            </summary>
            <typeparam name="T">The random value type</typeparam>
        </member>
        <member name="P:Z0.ISampleDefaults`1.SampleDomain">
            <summary>
            The domain of potential values
            </summary>
        </member>
        <member name="T:Z0.RngKind">
            <summary>
            Defines rng classifiers
            </summary>
        </member>
        <member name="F:Z0.RngKind.EntropicCrypto">
            <summary>
            A crypto-sourced nondeterministic generator
            </summary>
        </member>
        <member name="F:Z0.RngKind.Pcg32">
            <summary>
            A 32-bit PCG generator
            </summary>
        </member>
        <member name="F:Z0.RngKind.Pcg32Suite">
            <summary>
            A suite of 32-bit PCG generators
            </summary>
        </member>
        <member name="F:Z0.RngKind.Pcg64">
            <summary>
            A 64-bit PCG generator
            </summary>
        </member>
        <member name="F:Z0.RngKind.Pcg64Suite">
            <summary>
            A suite of 64-bit PCG generators
            </summary>
        </member>
        <member name="F:Z0.RngKind.SplitMix64">
            <summary>
            A 64-bit SplitMix generator
            </summary>
        </member>
        <member name="F:Z0.RngKind.WyHash16">
            <summary>
            A 16-bit WyHash generator
            </summary>
        </member>
        <member name="F:Z0.RngKind.WyHash64">
            <summary>
            A 64-bit WyHash generator
            </summary>
        </member>
        <member name="F:Z0.RngKind.WyHash64Suite">
            <summary>
            A suite of 64-bit WyHash generators
            </summary>
        </member>
        <member name="F:Z0.RngKind.XOrShift128">
            <summary>
            An xorshift generator with 128 bits of state
            </summary>
        </member>
        <member name="F:Z0.RngKind.XOrShift256">
            <summary>
            An xorshift generator with 256 bits of state
            </summary>
        </member>
        <member name="F:Z0.RngKind.XOrShift1024">
            <summary>
            An xorshift generator with 1024 bits of state
            </summary>
        </member>
        <member name="F:Z0.RngKind.Mrg32K3Au">
            <summary>
            LEcuyer's combined multiple recursive generator (CMRG) with 32-bit unsigned integers
            </summary>
        </member>
        <member name="F:Z0.RngKind.MRG32K3Ad">
            <summary>
            LEcuyer's combined multiple recursive generator (CMRG) with 64-bit floating-point arithmetic.
            </summary>
        </member>
        <member name="F:Z0.RngKind.MklEntropic">
            <summary>
            Identifies a hardware level entropic source driven by the RDRAND instruction
            </summary>
        </member>
        <member name="F:Z0.RngKind.MklMcg31">
            <summary>
            A 31-bit multiplicative congruential generator provided by MKL
            </summary>
        </member>
        <member name="F:Z0.RngKind.MklR250">
            <summary>
            A generalized feedback shift register generator provided by MKL
            </summary>
        </member>
        <member name="F:Z0.RngKind.MklMrg32K3A">
            <summary>
            A combined multiple recursive generator with two components of order 3 provided by MKL
            </summary>
        </member>
        <member name="F:Z0.RngKind.MklMcg59">
            <summary>
            A 59-bit multiplicative congruential generator provided by MKL
            </summary>
        </member>
        <member name="F:Z0.RngKind.MklWH">
            <summary>
            A set of 273 Wichmann-Hill combined multiplicative congruential generators provided by MKL
            </summary>
        </member>
        <member name="F:Z0.RngKind.MklSobol">
            <summary>
            A 32-bit Gray code-based generator producing low-discrepancy sequences for dimensions 1  s  40 provided by MKL
            </summary>
        </member>
        <member name="F:Z0.RngKind.MklNiederr">
            <summary>
            A 32-bit Gray code-based generator producing low-discrepancy sequences for dimensions 1  s  318 provided by MKL
            </summary>
        </member>
        <member name="F:Z0.RngKind.MklMt19937">
            <summary>
            A SIMD-oriented Fast Mersenne Twister pseudorandom number generator provided by MKL
            </summary>
        </member>
        <member name="F:Z0.RngKind.MklMt2203">
            <summary>
            A set of 6024 Mersenne Twister pseudorandom number generators provided by MKL
            </summary>
        </member>
        <member name="F:Z0.RngKind.MklSfmt19937">
            <summary>
            A SIMD-oriented Fast Mersenne Twister pseudorandom number generator provided by MKL
            </summary>
        </member>
        <member name="F:Z0.RngKind.MklARS5">
            <summary>
            An ARS-5 counter-based pseudorandom number generator that uses instructions from the AES-NI set
            </summary>
        </member>
        <member name="F:Z0.RngKind.MklPhilox4X32X10">
            <summary>
            A Philox4x32-10 counter-based pseudorandom number generator.
            </summary>
        </member>
        <member name="M:Z0.Sourced.bytes(Z0.IValueSource)">
            <summary>
            Produces stream of bytes
            </summary>
            <param name="source">The random source</param>
        </member>
        <member name="M:Z0.PolyBits.BitStream32(Z0.IValueSource)">
            <summary>
            Produces an interminable stream of random bits
            </summary>
            <param name="random">The random source</param>
        </member>
        <member name="M:Z0.PolyBits.BitStream``1(Z0.IValueSource)">
            <summary>
            Produces an interminable stream of random bits from a value sequence of parametric type
            </summary>
            <param name="random">The random source</param>
        </member>
        <member name="M:Z0.PolyBytes.Bytes(Z0.IPolySourced)">
            <summary>
            Produces an interminable stream of random bytes
            </summary>
            <param name="random">The random source</param>
        </member>
        <member name="M:Z0.PolyBytes.Bytes(Z0.IPolySourced,System.Int32)">
            <summary>
            Produces a limited stream of random bytes
            </summary>
            <param name="random">The random source</param>
            <param name="count">The maximum number of bytes to produce</param>
        </member>
        <member name="M:Z0.Streams.sink``1(Z0.Receiver{``0})">
            <summary>
            Creates a <see cref='T:Z0.Sink`1'/> from a <see cref='T:Z0.Receiver`1'/>
            </summary>
            <param name="dst">The target receiver</param>
            <typeparam name="T">The reception type</typeparam>
        </member>
        <member name="M:Z0.Streams.sink``1(System.IO.StreamWriter)">
            <summary>
            Creates a <see cref='T:Z0.Sink`1'/> from a <see cref='T:System.IO.StreamWriter'/>
            </summary>
            <param name="dst">The target writer</param>
            <typeparam name="T">The reception type</typeparam>
        </member>
        <member name="M:Z0.Streams.sink``1(System.IO.FileStream)">
            <summary>
            Creates a <see cref='T:Z0.Sink`1'/> from a <see cref='T:System.IO.StreamWriter'/>
            </summary>
            <param name="dst">The target writer</param>
            <typeparam name="T">The reception type</typeparam>
        </member>
        <member name="M:Z0.asci.byte(Z0.AsciCharCode@)">
            <summary>
            Presents the input  as a byte
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.asci.byte(Z0.asci2@)">
            <summary>
            Presents the leading source cell as a byte reference
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.asci.byte(Z0.asci4@)">
            <summary>
            Presents the leading source cell as a byte reference
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.asci.byte(Z0.asci8@)">
            <summary>
            Presents the leading source cell as a byte reference
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.asci.byte(Z0.asci16@)">
            <summary>
            Presents the leading source cell as a byte reference
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.asci.byte(Z0.asci32@)">
            <summary>
            Presents the leading source cell as a byte reference
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.asci.byte(Z0.asci64@)">
            <summary>
            Presents the leading source cell as a byte reference
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.asci.bytes(System.Span{Z0.AsciCharCode})">
            <summary>
            Presents a span of character codes as a bytespan
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.asci.bytes(System.Span{Z0.AsciSymbol})">
            <summary>
            Presents a span of asci symbols as a bytespan
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.asci.bytes(System.Byte,System.Byte)">
            <summary>
            Selects a contiguous asci character sequence encoded as as bytespan
            </summary>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:Z0.asci.bytes(Z0.asci2@)">
            <summary>
            Presents the source content as a bytespan
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.asci.bytes(Z0.asci4@)">
            <summary>
            Presents the source content as a bytespan
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.asci.bytes(Z0.asci8@)">
            <summary>
            Presents the source content as a bytespan
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.asci.bytes(Z0.asci16@)">
            <summary>
            Presents the source content as a bytespan
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.asci.bytes(Z0.asci32@)">
            <summary>
            Presents the source content as a bytespan
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.asci.bytes(Z0.asci64@)">
            <summary>
            Presents the source content as a bytespan
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.asci.code(Z0.UpperCased,Z0.HexDigit)">
            <summary>
            Returns the upper-case hex code for a specified digit
            </summary>
            <param name="case">The case selector</param>
            <param name="index">The digit value</param>
            <remarks>movzx eax,dl -> movsxd rax,eax -> mov rdx,28b57e0aca9h -> movzx eax,byte ptr [rax+rdx] </remarks>
        </member>
        <member name="M:Z0.asci.code(Z0.LowerCased,Z0.HexDigit)">
            <summary>
            Returns the lower-case hex code for a specified digit
            </summary>
            <param name="case">The case selector</param>
            <param name="index">The digit value</param>
            <remarks>movzx eax,dl -> movsxd rax,eax -> mov rdx,28b57e0aed9h -> movzx eax,byte ptr [rax+rdx]</remarks>
        </member>
        <member name="M:Z0.asci.codes(System.ReadOnlySpan{System.Byte},Z0.UpperCased,System.Span{Z0.HexCode})">
            <summary>
            Projects a bytespan into a codespan
            </summary>
            <param name="src">The data source</param>
            <param name="dst">The hexcode target</param>
        </member>
        <member name="M:Z0.asci.codes(System.ReadOnlySpan{System.Byte},System.Span{Z0.HexCode})">
            <summary>
            Projects a bytespan into a codespan
            </summary>
            <param name="src">The data source</param>
            <param name="dst">The hexcode target</param>
        </member>
        <member name="M:Z0.asci.digit(System.Char)">
            <summary>
            Tests whether a character symbol is one of '0'..'9'
            </summary>
            <param name="src">The symbol to test</param>
        </member>
        <member name="M:Z0.asci.digit(Z0.Base16,Z0.LowerCased,System.Char)">
            <summary>
            Computes the numeric value in in the range [0,..F] identified by a lowercase hex symbol
            </summary>
            <param name="src">The source symbol</param>
        </member>
        <member name="M:Z0.asci.digit(Z0.Base16,Z0.UpperCased,System.Char)">
            <summary>
            Computes the numeric value in in the range [0,..F] identified by a lowercase hex symbol
            </summary>
            <param name="src">The source symbol</param>
        </member>
        <member name="M:Z0.asci.digit(Z0.HexSymLo)">
            <summary>
            Computes the numeric value in in the range [0,..F] identified by a lowercase hex symbol
            </summary>
            <param name="src">The source symbol</param>
        </member>
        <member name="M:Z0.asci.digit(Z0.HexSymUp)">
            <summary>
            Computes the numeric value in in the range [0,..F] identified by an uppercase hex symbol
            </summary>
            <param name="src">The source symbol</param>
        </member>
        <member name="M:Z0.asci.digit(Z0.Base10,System.UInt16,System.Byte)">
            <summary>
            Extracts an index-identified encoded digit
            </summary>
            <param name="base">The base selector</param>
            <param name="src">The digit source</param>
            <param name="index">An integer in the inclusive range [0, 1] that identifies the digit to extract</param>
        </member>
        <member name="M:Z0.asci.digit(Z0.Base10,System.UInt32,System.Byte)">
            <summary>
            Extracts an index-identified encoded digit
            </summary>
            <param name="base">The base selector</param>
            <param name="src">The digit source</param>
            <param name="index">An integer in the inclusive range [0, 3] that identifies the digit to extract</param>
        </member>
        <member name="M:Z0.asci.digit(Z0.Base10,System.UInt64,System.Byte)">
            <summary>
            Extracts an index-identified encoded digit
            </summary>
            <param name="base">The base selector</param>
            <param name="src">The digit source</param>
            <param name="index">An integer in the inclusive range [0, 7] that identifies the digit to extract</param>
        </member>
        <member name="M:Z0.asci.digits(Z0.Perm4L,System.Span{System.Byte})">
            <summary>
            Computes the digigs corresponding to each 2-bit segment of the permutation spec
            </summary>
            <param name="src">The perm spec</param>
        </member>
        <member name="M:Z0.asci.digits(Z0.Perm4L,Z0.NatSpan{Z0.N4,System.Byte}@)">
            <summary>
            Computes the digigs corresponding to each 2-bit segment of the permutation spec
            </summary>
            <param name="src">The perm spec</param>
        </member>
        <member name="M:Z0.asci.digits(Z0.Perm4L)">
            <summary>
            Computes the digigs corresponding to each 2-bit segment of the permutation spec
            </summary>
            <param name="src">The perm spec</param>
        </member>
        <member name="M:Z0.asci.digits(Z0.Perm8L,System.Span{Z0.OctalDigit})">
            <summary>
            Computes the digits corresponding to each 3-bit segment of the permutation spec
            </summary>
            <param name="src">The perm spec</param>
        </member>
        <member name="M:Z0.asci.digits(Z0.Perm8L,Z0.NatSpan{Z0.N8,Z0.OctalDigit}@)">
            <summary>
            Computes the digits corresponding to each 3-bit segment of the permutation spec
            </summary>
            <param name="src">The perm spec</param>
        </member>
        <member name="M:Z0.asci.digits(Z0.Perm8L)">
            <summary>
            Computes the digits corresponding to each 3-bit segment of the permutation spec
            </summary>
            <param name="src">The perm spec</param>
        </member>
        <member name="M:Z0.asci.digits(Z0.Perm16L,System.Span{Z0.HexDigit})">
            <summary>
            Computes the digits corresponding to each 4-bit segment of the permutation spec
            </summary>
            <param name="src">The perm spec</param>
        </member>
        <member name="M:Z0.asci.digits(Z0.Perm16L,Z0.NatSpan{Z0.N16,Z0.HexDigit}@)">
            <summary>
            Computes the digits corresponding to each 4-bit segment of the permutation spec
            </summary>
            <param name="src">The perm spec</param>
        </member>
        <member name="M:Z0.asci.digits(Z0.Perm16L)">
            <summary>
            Computes the digits corresponding to each 4-bit segment of the permutation spec
            </summary>
            <param name="src">The perm spec</param>
        </member>
        <member name="M:Z0.asci.encode(System.Char@,System.UInt32,Z0.N16,Z0.AsciCharCode@)">
            <summary>
            Converts 16 source characters to 16 asci codes
            </summary>
            <param name="src">The source data</param>
            <param name="offset">The source offset</param>
            <param name="count">The number of source characters to convert</param>
            <param name="dst">The receiving buffer</param>
        </member>
        <member name="M:Z0.asci.encode``1(System.ReadOnlySpan{System.Char},System.Span{``0})">
            <summary>
            Encodes a sequence of source characters and stores a result in a caller-supplied
            T-parametric target with cells assumed to be at least 16 bits wide
            </summary>
            <param name="src">The data source</param>
            <param name="dst">The target</param>
            <typeparam name="T">The target cell type</typeparam>
        </member>
        <member name="M:Z0.asci.encode(System.Char)">
            <summary>
            Encodes a single character
            </summary>
            <param name="src">The character to encode</param>
        </member>
        <member name="M:Z0.asci.encode(System.ReadOnlySpan{System.String},System.Span{System.Byte})">
            <summary>
            Encodes each source string and packs the result into the target
            </summary>
            <param name="src">The encoding source</param>
            <param name="dst">The encoding target</param>
        </member>
        <member name="M:Z0.asci.encode(System.ReadOnlySpan{System.String},System.Span{System.Byte},System.Byte)">
            <summary>
            Encodes each source string and packs the result into the target, interspersed by a supplied delimiter
            </summary>
            <param name="src">The encoding source</param>
            <param name="dst">The encoding target</param>
        </member>
        <member name="M:Z0.asci.encode(System.Char@,Z0.Hex1Seq,Z0.asci2@)">
            <summary>
            Populates an asci target with a specified number of source characters
            </summary>
            <param name="src">The data source</param>
            <param name="count">The number of characters to encode</param>
            <param name="dst">The receiver</param>
        </member>
        <member name="M:Z0.asci.encode(System.Char@,Z0.Hex2Seq,Z0.asci4@)">
            <summary>
            Populates an asci target with a specified number of source characters
            </summary>
            <param name="src">The data source</param>
            <param name="count">The number of characters to encode</param>
            <param name="dst">The receiver</param>
        </member>
        <member name="M:Z0.asci.encode(System.Char@,Z0.Hex3Seq,Z0.asci8@)">
            <summary>
            Populates an asci target with a specified number of source characters
            </summary>
            <param name="src">The data source</param>
            <param name="count">The number of characters to encode</param>
            <param name="dst">The receiver</param>
        </member>
        <member name="M:Z0.asci.encode(System.Char@,Z0.Hex4Seq,Z0.asci16@)">
            <summary>
            Populates an asci target with a specified number of source characters
            </summary>
            <param name="src">The data source</param>
            <param name="count">The number of characters to encode</param>
            <param name="dst">The receiver</param>
        </member>
        <member name="M:Z0.asci.encode(System.Char@,Z0.Hex5Seq,Z0.asci32@)">
            <summary>
            Populates an asci target with a specified number of source characters
            </summary>
            <param name="src">The data source</param>
            <param name="count">The number of characters to encode</param>
            <param name="dst">The receiver</param>
        </member>
        <member name="M:Z0.asci.encode(System.Char@,Z0.Hex6Seq,Z0.asci64@)">
            <summary>
            Populates an asci target with a specified number of source characters
            </summary>
            <param name="src">The data source</param>
            <param name="count">The number of characters to encode</param>
            <param name="dst">The receiver</param>
        </member>
        <member name="M:Z0.asci.encode(System.ReadOnlySpan{System.Char},System.Span{Z0.AsciCharCode})">
            <summary>
            Fills a caller-supplied target span with asci codes corresponding to characters in a source span
            </summary>
            <param name="src">The data source</param>
            <param name="dst">The data target</param>
        </member>
        <member name="M:Z0.asci.encode(System.ReadOnlySpan{System.Char},System.UInt32,System.UInt32,System.Span{Z0.AsciCharCode})">
            <summary>
            Encodes a specified number of source characters
            </summary>
            <param name="src">The data source</param>
            <param name="offset"></param>
            <param name="count"></param>
            <param name="dst">The data target</param>
        </member>
        <member name="M:Z0.asci.encode(System.ReadOnlySpan{System.Char},Z0.asci2@)">
            <summary>
            Populates a 2-code asci block from the leading cells of a character span
            </summary>
            <param name="src">The data source</param>
            <param name="dst">The target block</param>
        </member>
        <member name="M:Z0.asci.encode(System.ReadOnlySpan{System.Char},Z0.asci4@)">
            <summary>
            Populates a 4-code asci block from the leading cells of a character span
            </summary>
            <param name="src">The data source</param>
            <param name="dst">The target block</param>
        </member>
        <member name="M:Z0.asci.encode(System.ReadOnlySpan{System.Char},Z0.asci8@)">
            <summary>
            Populates an 8-code asci block from the leading cells of a character span
            </summary>
            <param name="src">The data source</param>
            <param name="dst">The target block</param>
        </member>
        <member name="M:Z0.asci.encode(System.ReadOnlySpan{System.Char},Z0.asci16@)">
            <summary>
            Populates a 16-code asci block from the leading cells of a character span
            </summary>
            <param name="src">The data source</param>
            <param name="dst">The target block</param>
        </member>
        <member name="M:Z0.asci.encode(System.ReadOnlySpan{System.Char},Z0.asci32@)">
            <summary>
            Populates a 32-code asci block from the leading cells of a character span
            </summary>
            <param name="src">The data source</param>
            <param name="dst">The target block</param>
        </member>
        <member name="M:Z0.asci.encode(System.ReadOnlySpan{System.Char},Z0.asci64@)">
            <summary>
            Populates a 64-code asci block from the leading cells of a character span
            </summary>
            <param name="src">The data source</param>
            <param name="dst">The target block</param>
        </member>
        <member name="M:Z0.asci.encode(Z0.N2,System.ReadOnlySpan{System.Char})">
            <summary>
            Populates a 2-code asci block from the leading cells of a character span
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.asci.encode(Z0.N4,System.ReadOnlySpan{System.Char})">
            <summary>
            Populates a 4-code asci block from the leading cells of a character span
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.asci.encode(Z0.N8,System.ReadOnlySpan{System.Char})">
            <summary>
            Populates an 8-code asci block from the leading cells of a character span
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.asci.encode(Z0.N16,System.ReadOnlySpan{System.Char})">
            <summary>
            Populates a 16-code asci block from the leading cells of a character span
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.asci.encode(Z0.N32,System.ReadOnlySpan{System.Char})">
            <summary>
            Populates a 32-code asci block from the leading cells of a character span
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.asci.encode(Z0.N64,System.ReadOnlySpan{System.Char})">
            <summary>
            Populates a 32-code asci block from the leading cells of a character span
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.asci.first(Z0.asci4@,System.Byte)">
            <summary>
            Returns the index of the first source element that matches a specified value
            </summary>
            <param name="src">The source sequence</param>
            <param name="match">The value to match</param>
        </member>
        <member name="M:Z0.asci.first(Z0.asci8@,System.Byte)">
            <summary>
            Returns the index of the first source element that matches a specified value
            </summary>
            <param name="src">The source sequence</param>
            <param name="match">The value to match</param>
        </member>
        <member name="M:Z0.asci.first(Z0.asci16@,System.Byte)">
            <summary>
            Returns the index of the first source element that matches a specified value
            </summary>
            <param name="src">The source sequence</param>
            <param name="match">The value to match</param>
        </member>
        <member name="M:Z0.asci.first(Z0.asci32@,System.Byte)">
            <summary>
            Returns the index of the first source element that matches a specified value
            </summary>
            <param name="src">The source sequence</param>
            <param name="match">The value to match</param>
        </member>
        <member name="M:Z0.asci.first(Z0.asci64@,System.Byte)">
            <summary>
            Returns the index of the first source element that matches a specified value
            </summary>
            <param name="src">The source sequence</param>
            <param name="match">The value to match</param>
        </member>
        <member name="M:Z0.asci.first(System.ReadOnlySpan{System.Char},System.Char)">
            <summary>
            Returns the index of the first source character that matches a target character
            </summary>
            <param name="src">The data source</param>
            <param name="match">The character to match</param>
        </member>
        <member name="M:Z0.asci.number(Z0.HexSymLo)">
            <summary>
            Tests whether a lowercase hex symbol is a numeral
            </summary>
            <param name="src">The symbol to test</param>
        </member>
        <member name="M:Z0.asci.number(Z0.HexSymUp)">
            <summary>
            Tests whether a uppercas hex symbol is a numeral
            </summary>
            <param name="src">The symbol to test</param>
        </member>
        <member name="M:Z0.asci.hext(Z0.HexSymLo)">
            <summary>
            Tests whether a lowercase hex symbol is a letter
            </summary>
            <param name="src">The symbol to test</param>
        </member>
        <member name="M:Z0.asci.hext(Z0.HexSymUp)">
            <summary>
            Tests whether an uppercase hex symbol is a letter
            </summary>
            <param name="src">The symbol to test</param>
        </member>
        <member name="M:Z0.asci.hext(Z0.UpperCased,System.Char)">
            <summary>
            Determines whether a character is an upper-cased hex digit
            </summary>
            <param name="c">The character to test</param>
        </member>
        <member name="M:Z0.asci.hext(Z0.LowerCased,System.Char)">
            <summary>
            Determines whether a character is a lower-cased hex digit
            </summary>
            <param name="c">The character to test</param>
        </member>
        <member name="M:Z0.asci.hext(System.Char)">
            <summary>
            Determines whether a character is a hex digit of any case
            </summary>
            <param name="c">The character to test</param>
        </member>
        <member name="M:Z0.asci.hexscalar(System.Char)">
            <summary>
            Determines whether a character is one of [0..9]
            </summary>
            <param name="c">The character to test</param>
        </member>
        <member name="M:Z0.asci.hexupper(System.Char)">
            <summary>
            Determines whether a character corresponds to one of the uppercase hex code characters
            </summary>
            <param name="c">The character to test</param>
        </member>
        <member name="M:Z0.asci.hexlower(System.Char)">
            <summary>
            Determines whether a character corresponds to one of the lowercase hex code characters
            </summary>
            <param name="c">The character to test</param>
        </member>
        <member name="M:Z0.asci.letter(Z0.UpperCased,System.Char)">
            <summary>
            Tests whether a character is an uppercase asci letter character
            </summary>
            <param name="c">The character to test</param>
        </member>
        <member name="M:Z0.asci.letter(Z0.LowerCased,System.Char)">
            <summary>
            Tests whether a character is a lowercase asci letter character
            </summary>
            <param name="c">The character to test</param>
        </member>
        <member name="M:Z0.asci.letter(System.Char)">
            <summary>
            Tests whether a character is an asci letter character
            </summary>
            <param name="c">The character to test</param>
        </member>
        <member name="M:Z0.asci.length(Z0.asci2@)">
            <summary>
            Counts the number of characters that precede a null terminator, if any
            </summary>
            <param name="src">The asci source</param>
        </member>
        <member name="M:Z0.asci.length(Z0.asci4@)">
            <summary>
            Counts the number of characters that precede a null terminator, if any
            </summary>
            <param name="src">The asci source</param>
        </member>
        <member name="M:Z0.asci.length(Z0.asci8@)">
            <summary>
            Counts the number of characters that precede a null terminator, if any
            </summary>
            <param name="src">The asci source</param>
        </member>
        <member name="M:Z0.asci.length(Z0.asci16@)">
            <summary>
            Counts the number of characters that precede a null terminator, if any
            </summary>
            <param name="src">The asci source</param>
        </member>
        <member name="M:Z0.asci.length(Z0.asci32@)">
            <summary>
            Counts the number of characters that precede a null terminator, if any
            </summary>
            <param name="src">The asci source</param>
        </member>
        <member name="M:Z0.asci.length(Z0.asci64@)">
            <summary>
            Counts the number of characters that precede a null terminator, if any
            </summary>
            <param name="src">The asci source</param>
        </member>
        <member name="M:Z0.asci.lowercase(System.Char)">
            <summary>
            Transforms an uppercase character [A..Z] to the corresponding lowercase character [a..z];
            if the source character is not in the letter domain, the input is returned unharmed
            </summary>
            <param name="src">The source character</param>
        </member>
        <member name="M:Z0.asci.pack(Z0.Base10,System.Char,System.Char)">
            <summary>
            Encodes two decimal digits d := 0x[c1][c0] for characters c2, c1 in the inclusive range [0,9]
            </summary>
            <param name="c1">The source for digit 1, the most significant digit</param>
            <param name="c0">The source for digit 0, the least significant digit</param>
        </member>
        <member name="M:Z0.asci.pack(Z0.Base10,System.Char,System.Char,System.Char)">
            <summary>
            Encodes three decimal digits d := 0x[c2][c1][c0] for characters c2, c1, c0 in the inclusive range [0,9]
            </summary>
            <param name="c2">The source for digit 2, the most significant digit</param>
            <param name="c1">The source for digit 1</param>
            <param name="c0">The source for digit 0, the least significant digit</param>
        </member>
        <member name="M:Z0.asci.pack(Z0.Base10,System.Char,System.Char,System.Char,System.Char)">
            <summary>
            Encodes four decimal digits d := 0x[c3][c2][c1][c0] for characters c3, c2, c1, c0 in the inclusive range [0,9]
            </summary>
            <param name="c3">The source for digit 3, the most significant digit</param>
            <param name="c2">The source for digit 2</param>
            <param name="c1">The source for digit 1</param>
            <param name="c0">The source for digit 0, the least significant digit</param>
        </member>
        <member name="M:Z0.asci.pack(Z0.Base10,System.Char,System.Char,System.Char,System.Char,System.Char)">
            <summary>
            Encodes five decimal digits d := 0x[c4][c3][c2][c1][c0] for characters c4, c3, c2, c1, c0 in the inclusive range [0,9]
            </summary>
            <param name="c4">The source for digit 4, the most significant digit</param>
            <param name="c3">The source for digit 3</param>
            <param name="c2">The source for digit 2</param>
            <param name="c1">The source for digit 1</param>
            <param name="c0">The source for digit 0, the least significant digit</param>
        </member>
        <member name="M:Z0.asci.pack(Z0.Base10,System.Char,System.Char,System.Char,System.Char,System.Char,System.Char,System.Char,System.Char)">
            <summary>
            Encodes eight decimal digits d := 0x[c7][c6][c5][c4][c3][c2][c1][c0] for characters c7, c6, c5, c4, c3, c2, c1, c0 in the inclusive range [0,9]
            </summary>
            <param name="c7">The source for digit 7, the most significant digit</param>
            <param name="c6">The source for digit 6</param>
            <param name="c5">The source for digit 5</param>
            <param name="c4">The source for digit 4</param>
            <param name="c3">The source for digit 3</param>
            <param name="c2">The source for digit 2</param>
            <param name="c1">The source for digit 1</param>
            <param name="c0">The source for digit 0, the least significant digit</param>
        </member>
        <member name="M:Z0.asci.unpack(Z0.Base10,System.UInt64,Z0.N8,System.Byte@)">
            <summary>
            Extracts all eight digits from the source
            </summary>
            <param name="src">The digit source</param>
            <param name="count">The digit count selector</param>
            <param name="dst">The digit receiver</param>
        </member>
        <member name="M:Z0.asci.render(System.ReadOnlySpan{Z0.BinaryDigit},System.Span{System.Char})">
            <summary>
            Formats a span of binary digits as a contiguous block
            </summary>
            <param name="src">The source digits</param>
        </member>
        <member name="M:Z0.asci.render(System.ReadOnlySpan{Z0.DecimalDigit},System.Span{System.Char})">
            <summary>
            Formats a span of hex digits as a contiguous block
            </summary>
            <param name="src">The source digits</param>
        </member>
        <member name="M:Z0.asci.render(System.ReadOnlySpan{Z0.HexDigit},System.Span{System.Char})">
            <summary>
            Formats a span of hex digits as a contiguous block
            </summary>
            <param name="src">The source digits</param>
        </member>
        <member name="M:Z0.asci.u8(Z0.Base10,System.Char)">
            <summary>
            Converts a character in the inclusive range [0,9] to the corresponding number in the same range
            </summary>
            <param name="c">The digit character</param>
        </member>
        <member name="M:Z0.asci.u16(Z0.Base10,System.Char)">
            <summary>
            Converts a character in the inclusive range [0,9] to the corresponding number in the same range
            </summary>
            <param name="c">The digit character</param>
        </member>
        <member name="M:Z0.asci.u32(Z0.Base10,System.Char)">
            <summary>
            Converts a character in the inclusive range [0,9] to the corresponding number in the same range
            </summary>
            <param name="c">The digit character</param>
        </member>
        <member name="M:Z0.asci.u64(Z0.Base10,System.Char)">
            <summary>
            Converts a character in the inclusive range [0,9] to the corresponding number in the same range
            </summary>
            <param name="c">The digit character</param>
        </member>
        <member name="M:Z0.asci.spec``3(``0[])">
            <summary>
            Defines a symbol spec
            </summary>
            <param name="symbols"></param>
            <typeparam name="S">The symbol data type</typeparam>
            <typeparam name="T">The symbol domain type</typeparam>
            <typeparam name="W">The symbol bit-width type</typeparam>
        </member>
        <member name="M:Z0.asci.string(Z0.AsciCharCode)">
            <summary>
            Returns a string of length 1 that corresponds to the specified asci code
            </summary>
            <param name="code">The asci code</param>
        </member>
        <member name="M:Z0.asci.symval(Z0.BinaryDigit)">
            <summary>
            Computes the source digit's symbol value
            </summary>
            <param name="src">The source digit</param>
        </member>
        <member name="M:Z0.asci.symval(Z0.OctalDigit)">
            <summary>
            Computes the source digit's symbol value
            </summary>
            <param name="src">The source digit</param>
        </member>
        <member name="M:Z0.asci.symval(Z0.DecimalDigit)">
            <summary>
            Computes the source digit's symbol value
            </summary>
            <param name="src">The source digit</param>
        </member>
        <member name="M:Z0.asci.symval(Z0.LowerCased,Z0.HexDigit)">
            <summary>
            Computes the source digit's symbol value
            </summary>
            <param name="case">The case selector</param>
            <param name="src">The source digit</param>
        </member>
        <member name="M:Z0.asci.symval(Z0.UpperCased,Z0.HexDigit)">
            <summary>
            Computes the source digit's symbol value
            </summary>
            <param name="case">The case selector</param>
            <param name="src">The source digit</param>
        </member>
        <member name="M:Z0.asci.uppercase(System.Char)">
            <summary>
            if given a lowercase character [a..z], produces the corresponding uppercase character [A..z]
            Otherwise, returns the input unharmed
            </summary>
            <param name="src">The source character</param>
        </member>
        <member name="M:Z0.asci.valid(System.Byte)">
            <summary>
            Tests whether a byte represents an asci character
            </summary>
            <param name="src">The data to test</param>
        </member>
        <member name="M:Z0.asci.valid(System.UInt16)">
            <summary>
            Tests whether the data source contains only asci data
            </summary>
            <param name="src">The data to test</param>
        </member>
        <member name="M:Z0.asci.valid(System.UInt32)">
            <summary>
            Tests whether the data source contains only asci data
            </summary>
            <param name="src">The data to test</param>
        </member>
        <member name="M:Z0.asci.valid(System.UInt64)">
            <summary>
            Tests whether the data source contains only asci data
            </summary>
            <param name="src">The data to test</param>
        </member>
        <member name="M:Z0.asci.vasci(Z0.W256,System.SByte,Z0.Hex4Seq)">
            <summary>
            Loads up to 16 asci scalar symbols [offset, offset + count]
            </summary>
            <param name="count">The number of symbols to load</param>
        </member>
        <member name="M:Z0.asci.vasci(Z0.W512,System.SByte,Z0.Hex5Seq)">
            <summary>
            Loads up to 32 asci scalar symbols [offset, offset + count]
            </summary>
            <param name="count">The number of symbols to load</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.AsciSymbols.codes(System.SByte,System.SByte)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.AsciSymbols.chars(System.SByte,System.SByte)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.AsciSymbols.symbols(System.SByte,System.SByte)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.AsciSymbols.scalars(System.SByte,System.SByte)" -->
        <member name="T:Z0.IAsciLetter`1">
            <summary>
            Characterizes a type-level asci letter
            </summary>
            <typeparam name="L">The reification type</typeparam>
        </member>
        <member name="T:Z0.Digital">
            <summary>
            Defines operations over character digits
            </summary>
        </member>
        <member name="M:Z0.Digital.digit(System.Char)">
            <summary>
            Converts a character in the inclusive range [0,9] to the corresponding number in the same range
            </summary>
            <param name="c">The digit character</param>
        </member>
        <member name="M:Z0.Digital.digit8(System.Char)">
            <summary>
            Converts a character in the inclusive range [0,9] to the corresponding number in the same range
            </summary>
            <param name="c">The digit character</param>
        </member>
        <member name="M:Z0.Digital.digit8(System.UInt16,System.Byte)">
            <summary>
            Extracts an index-identified encoded digit
            </summary>
            <param name="src">The digit source</param>
            <param name="index">An integer in the inclusive range [0, 1] that identifies the digit to extract</param>
        </member>
        <member name="M:Z0.Digital.digit8(System.UInt32,System.Byte)">
            <summary>
            Extracts an index-identified encoded digit
            </summary>
            <param name="src">The digit source</param>
            <param name="index">An integer in the inclusive range [0, 3] that identifies the digit to extract</param>
        </member>
        <member name="M:Z0.Digital.digit8(System.UInt64,System.Byte)">
            <summary>
            Extracts an index-identified encoded digit
            </summary>
            <param name="src">The digit source</param>
            <param name="index">An integer in the inclusive range [0, 7] that identifies the digit to extract</param>
        </member>
        <member name="M:Z0.Digital.digits(Z0.Base10,System.Char,System.Char)">
            <summary>
            Encodes two decimal digits d := 0x[c1][c0] for characters c2, c1 in the inclusive range [0,9]
            </summary>
            <param name="c1">The source for digit 1, the most significant digit</param>
            <param name="c0">The source for digit 0, the least significant digit</param>
        </member>
        <member name="M:Z0.Digital.digits(Z0.Base10,System.Char,System.Char,System.Char)">
            <summary>
            Encodes three decimal digits d := 0x[c2][c1][c0] for characters c2, c1, c0 in the inclusive range [0,9]
            </summary>
            <param name="c2">The source for digit 2, the most significant digit</param>
            <param name="c1">The source for digit 1</param>
            <param name="c0">The source for digit 0, the least significant digit</param>
        </member>
        <member name="M:Z0.Digital.digits(Z0.Base10,System.Char,System.Char,System.Char,System.Char)">
            <summary>
            Encodes four decimal digits d := 0x[c3][c2][c1][c0] for characters c3, c2, c1, c0 in the inclusive range [0,9]
            </summary>
            <param name="c3">The source for digit 3, the most significant digit</param>
            <param name="c2">The source for digit 2</param>
            <param name="c1">The source for digit 1</param>
            <param name="c0">The source for digit 0, the least significant digit</param>
        </member>
        <member name="M:Z0.Digital.digits(Z0.Base10,System.Char,System.Char,System.Char,System.Char,System.Char)">
            <summary>
            Encodes five decimal digits d := 0x[c4][c3][c2][c1][c0] for characters c4, c3, c2, c1, c0 in the inclusive range [0,9]
            </summary>
            <param name="c4">The source for digit 4, the most significant digit</param>
            <param name="c3">The source for digit 3</param>
            <param name="c2">The source for digit 2</param>
            <param name="c1">The source for digit 1</param>
            <param name="c0">The source for digit 0, the least significant digit</param>
        </member>
        <member name="M:Z0.Digital.digits(Z0.Base10,System.Char,System.Char,System.Char,System.Char,System.Char,System.Char,System.Char,System.Char)">
            <summary>
            Encodes eight decimal digits d := 0x[c7][c6][c5][c4][c3][c2][c1][c0] for characters c7, c6, c5, c4, c3, c2, c1, c0 in the inclusive range [0,9]
            </summary>
            <param name="c7">The source for digit 7, the most significant digit</param>
            <param name="c6">The source for digit 6</param>
            <param name="c5">The source for digit 5</param>
            <param name="c4">The source for digit 4</param>
            <param name="c3">The source for digit 3</param>
            <param name="c2">The source for digit 2</param>
            <param name="c1">The source for digit 1</param>
            <param name="c0">The source for digit 0, the least significant digit</param>
        </member>
        <member name="M:Z0.Digital.digit(System.UInt64,System.Int32)">
            <summary>
            Extracts an index-identified encoded digit
            </summary>
            <param name="src">The digit source</param>
            <param name="index">An integer in the inclusive range [0, 7] that identifies the digit to extract</param>
        </member>
        <member name="M:Z0.Digital.digits(System.UInt64,System.Byte@,System.Byte@)">
            <summary>
            Extracts two encoded digits
            </summary>
            <param name="src">The digit source</param>
            <param name="d1">The most significant digit</param>
            <param name="d0">The least significant digit</param>
        </member>
        <member name="M:Z0.Digital.lo(System.UInt64,System.Byte@,System.Byte@,System.Byte@,System.Byte@)">
            <summary>
            Extracts the four lo digits
            </summary>
            <param name="src">The encoded digit source</param>
            <param name="d3">The target for the fourth and most-significant digit</param>
            <param name="d2">The target for the third digit</param>
            <param name="d1">The target for the second digit</param>
            <param name="d0">The target for the first and least-significant digit</param>
        </member>
        <member name="M:Z0.Digital.hi(System.UInt64,System.Byte@,System.Byte@,System.Byte@,System.Byte@)">
            <summary>
            Extracts the four hi digits
            </summary>
            <param name="src">The encoded digit source</param>
            <param name="d7">The target for the eighth and most-significant digit</param>
            <param name="d6"></param>
            <param name="d5"></param>
            <param name="d4"></param>
        </member>
        <member name="M:Z0.Digital.digits(System.UInt64,Z0.N1,System.Byte@)">
            <summary>
            Extracts the first digit from the source
            </summary>
            <param name="src">The digit source</param>
            <param name="count">The digit count selector</param>
            <param name="dst">The digit receiver</param>
        </member>
        <member name="M:Z0.Digital.digits(System.UInt64,Z0.N2,System.Byte@)">
            <summary>
            Extracts the first two digits from the source
            </summary>
            <param name="src">The digit source</param>
            <param name="count">The digit count selector</param>
            <param name="dst">The digit receiver</param>
        </member>
        <member name="M:Z0.Digital.digits(System.UInt64,Z0.N3,System.Byte@)">
            <summary>
            Extracts the first three digits from the source
            </summary>
            <param name="src">The digit source</param>
            <param name="count">The digit count selector</param>
            <param name="dst">The digit receiver</param>
        </member>
        <member name="M:Z0.Digital.digits(System.UInt64,Z0.N4,System.Byte@)">
            <summary>
            Extracts the first four digits from the source
            </summary>
            <param name="src">The digit source</param>
            <param name="count">The digit count selector</param>
            <param name="dst">The digit receiver</param>
        </member>
        <member name="M:Z0.Digital.digits(System.UInt64,Z0.N5,System.Byte@)">
            <summary>
            Extracts the first five digits from the source
            </summary>
            <param name="src">The digit source</param>
            <param name="count">The digit count selector</param>
            <param name="dst">The digit receiver</param>
        </member>
        <member name="M:Z0.Digital.digits(System.UInt64,Z0.N6,System.Byte@)">
            <summary>
            Extracts the first six digits from the source
            </summary>
            <param name="src">The digit source</param>
            <param name="count">The digit count selector</param>
            <param name="dst">The digit receiver</param>
        </member>
        <member name="M:Z0.Digital.digits(System.UInt64,Z0.N7,System.Byte@)">
            <summary>
            Extracts the first seven digits from the source
            </summary>
            <param name="src">The digit source</param>
            <param name="count">The digit count selector</param>
            <param name="dst">The digit receiver</param>
        </member>
        <member name="M:Z0.Digital.unpack(Z0.Base10,System.UInt64,Z0.N8,System.Byte@)">
            <summary>
            Extracts all eight digits from the source
            </summary>
            <param name="src">The digit source</param>
            <param name="count">The digit count selector</param>
            <param name="dst">The digit receiver</param>
        </member>
        <member name="T:Z0.asci16">
            <summary>
            Defines an asci code sequence of length 16
            </summary>
        </member>
        <member name="T:Z0.asci2">
            <summary>
            Defines an asci code sequence of length 2
            </summary>
        </member>
        <member name="T:Z0.asci32">
            <summary>
            Defines an asci code sequence of length 32
            </summary>
        </member>
        <member name="T:Z0.asci4">
            <summary>
            Defines an asci code sequence of length 4
            </summary>
        </member>
        <member name="T:Z0.asci8">
            <summary>
            Defines a 64-bit asci code sequence of length 8
            </summary>
        </member>
        <member name="P:Z0.asci8.Length">
            <summary>
            Specifies the number of characters that precede a null terminator, if any; otherwise, returns the maximum content length
            </summary>
        </member>
        <member name="T:Z0.AsciNull">
            <summary>
            Stateless polytype that implicitly converts to the asci null defined for a reified asci sequence
            </summary>
        </member>
        <member name="T:Z0.AsciSequence">
            <summary>
            Covers a sequence of asci-encoded bytes
            </summary>
        </member>
        <member name="T:Z0.AsciSequence`1">
            <summary>
            Covers an A-parametric sequence of asci sequences
            </summary>
        </member>
        <member name="T:Z0.AsciSymbol">
            <summary>
            Lifts an asci code to a structural type
            </summary>
        </member>
        <member name="F:Z0.AsciSymbolCover.Data">
            <summary>
            The encoded bytes
            </summary>
        </member>
        <member name="P:Z0.AsciSymbolCover.Ref">
            <summary>
            Returns a reference to the encoded data
            </summary>
        </member>
        <member name="T:Z0.IKindedSymbol`2">
            <summary>
            Characterizes a classified symbol
            </summary>
            <typeparam name="K">The classifier type</typeparam>
            <typeparam name="S">The symbol type</typeparam>
        </member>
        <member name="P:Z0.IKindedSymbol`2.Kind">
            <summary>
            The symbol kind
            </summary>
        </member>
        <member name="T:Z0.IKindedSymbol`3">
            <summary>
            Characterizes a classified symbol
            </summary>
            <typeparam name="K">The classifier type</typeparam>
            <typeparam name="S">The symbol type</typeparam>
        </member>
        <member name="T:Z0.IKindedSymbolic`5">
            <summary>
            Characterizes a classified symbol
            </summary>
            <typeparam name="K">The classifier type</typeparam>
            <typeparam name="S">The symbol type</typeparam>
        </member>
        <member name="T:Z0.ILetter">
            <summary>
            Characterizes a letter
            </summary>
        </member>
        <member name="P:Z0.ILetter.Character">
            <summary>
            The unicode character representation
            </summary>
        </member>
        <member name="T:Z0.ILetter`2">
            <summary>
            Characterizes a letter
            </summary>
            <typeparam name="S"></typeparam>
            <typeparam name="C"></typeparam>
        </member>
        <member name="T:Z0.ISymbol">
            <summary>
            Characterizes a sequence of bits with external semantics
            </summary>
        </member>
        <member name="P:Z0.ISymbol.Encoded">
            <summary>
            The encoded symbol value
            </summary>
        </member>
        <member name="T:Z0.ISymbol`1">
            <summary>
            Characterizes a parametric <see cref='T:Z0.ISymbol'/> value
            </summary>
            <typeparam name="S">The symbol value type</typeparam>
        </member>
        <member name="P:Z0.ISymbol`1.Value">
            <summary>
            The symbol value
            </summary>
        </member>
        <member name="P:Z0.ISymbol`2.SegWidth">
            <summary>
            The <typeparamref name='T' /> cell bit-width
            </summary>
        </member>
        <member name="P:Z0.ISymbol`2.Cell">
            <summary>
            The <typeparamref name='T' /> cell value
            </summary>
        </member>
        <member name="P:Z0.ISymbol`3.SymWidth">
            <summary>
            The bit-width value determined by <typeparamref name='N' />
            </summary>
        </member>
        <member name="P:Z0.ISymbol`3.Capacity">
            <summary>
            The maximum number of symbols that can be packed into a storage cell
            </summary>
        </member>
        <member name="T:Z0.KindedSymbol`2">
            <summary>
            Attaches a classifier to a symbol
            </summary>
        </member>
        <member name="F:Z0.KindedSymbol`2.Kind">
            <summary>
            The symbol kind
            </summary>
        </member>
        <member name="F:Z0.KindedSymbol`2.Value">
            <summary>
            The symbol value
            </summary>
        </member>
        <member name="T:Z0.KindedSymbol`3">
            <summary>
            Attaches a classifier to a symbol
            </summary>
        </member>
        <member name="F:Z0.KindedSymbol`3.Kind">
            <summary>
            The symbol kind
            </summary>
        </member>
        <member name="F:Z0.KindedSymbol`3.Value">
            <summary>
            The symbol value
            </summary>
        </member>
        <member name="P:Z0.KindedSymbol`3.Cell">
            <summary>
            The symbol value, from storage cell perspective
            </summary>
        </member>
        <member name="T:Z0.KindedSymbol`4">
            <summary>
            Attaches a classifier to a symbol
            </summary>
        </member>
        <member name="F:Z0.KindedSymbol`4.Kind">
            <summary>
            The symbol kind
            </summary>
        </member>
        <member name="F:Z0.KindedSymbol`4.Value">
            <summary>
            The symbol value
            </summary>
        </member>
        <member name="P:Z0.KindedSymbol`4.Cell">
            <summary>
            The symbol value, from storage cell perspective
            </summary>
        </member>
        <member name="T:Z0.NamedSymbol`1">
            <summary>
            Captures a symbol name assignment
            </summary>
        </member>
        <member name="T:Z0.Symbol`1">
            <summary>
            Defines a symbol, characterized by its value, that defines an atomic element in some vocabulary/grammar
            </summary>
        </member>
        <member name="F:Z0.Symbol`1.Value">
            <summary>
            The symbol value
            </summary>
        </member>
        <member name="T:Z0.Symbol`2">
            <summary>
            Defines an S-symbol value covered by a T-storage cell
            </summary>
        </member>
        <member name="F:Z0.Symbol`2.Value">
            <summary>
            The symbol value
            </summary>
        </member>
        <member name="P:Z0.Symbol`2.Cell">
            <summary>
            The symbol value, from storage cell perspective
            </summary>
        </member>
        <member name="T:Z0.Symbol`3">
            <summary>
            Defines an S-symbol value, of bit-width N, covered by a T-storage cell
            </summary>
        </member>
        <member name="F:Z0.Symbol`3.Value">
            <summary>
            The symbol value
            </summary>
        </member>
        <member name="P:Z0.Symbol`3.Cell">
            <summary>
            The symbol value, from storage cell perspective
            </summary>
        </member>
        <member name="P:Z0.Symbol`3.SymWidth">
            <summary>
            The bit-width of a symbol
            </summary>
        </member>
        <member name="P:Z0.Symbol`3.SegWidth">
            <summary>
            The bit-width of a storage cell
            </summary>
        </member>
        <member name="P:Z0.Symbol`3.Capacity">
            <summary>
            The maximum number of symbols that can be packed into a storage cell
            </summary>
        </member>
        <member name="T:Z0.SymbolAspectKind">
            <summary>
            Defines symbol field classifiers
            </summary>
        </member>
        <member name="F:Z0.SymbolAspectKind.SymbolValue">
            <summary>
            The raw/absolute symbol value
            </summary>
        </member>
        <member name="F:Z0.SymbolAspectKind.SymbolType">
            <summary>
            The symbolic value's data type
            </summary>
        </member>
        <member name="F:Z0.SymbolAspectKind.CellValue">
            <summary>
            The symbol value expressed in terms of a storage cell value
            </summary>
        </member>
        <member name="F:Z0.SymbolAspectKind.CellType">
            <summary>
            The storage cell's data type
            </summary>
        </member>
        <member name="F:Z0.SymbolAspectKind.SymbolWidth">
            <summary>
            The bit-width of a symbol
            </summary>
        </member>
        <member name="F:Z0.SymbolAspectKind.CellWidth">
            <summary>
            The bit-width of a storage cell
            </summary>
        </member>
        <member name="F:Z0.SymbolAspectKind.Capacity">
            <summary>
            The maximum number of symbols that can be packed into a single storage cell
            </summary>
        </member>
        <member name="F:Z0.SymbolAspectKind.SymbolKind">
            <summary>
            The symbol kind
            </summary>
        </member>
        <member name="F:Z0.SymbolAspectKind.SymbolName">
            <summary>
            The symbol name
            </summary>
        </member>
        <member name="T:Z0.SymbolName">
            <summary>
            Defines the name of a symbol
            </summary>
        </member>
        <member name="P:Z0.SymbolSpec`1.SegWidth">
            <summary>
            The bit-width of a storage cell
            </summary>
        </member>
        <member name="P:Z0.SymbolSpec`1.SegCapacity">
            <summary>
            The maximum number of symbols that can be stored in a segment
            </summary>
        </member>
        <member name="T:Z0.SymbolSpec`2">
            <summary>
            Specifies symbol characteristics
            </summary>
        </member>
        <member name="F:Z0.SymbolSpec`2.Symbols">
            <summary>
            The specified symbols
            </summary>
        </member>
        <member name="P:Z0.SymbolSpec`2.SegWidth">
            <summary>
            The bit-width of a storage cell
            </summary>
        </member>
        <member name="P:Z0.SymbolSpec`2.SegDomain">
            <summary>
            The storage cell type identifier
            </summary>
        </member>
        <member name="P:Z0.SymbolSpec`2.SymWidth">
            <summary>
            The number of bits occupied by a symbol
            </summary>
        </member>
        <member name="P:Z0.SymbolSpec`2.SegCapacity">
            <summary>
            The maximum number of symbols that can be stored in a segment
            </summary>
        </member>
        <member name="T:Z0.SymbolSpec`3">
            <summary>
            Defines a set of S-symbol values, each of bit-width N and covered by a T-storage cell
            </summary>
        </member>
        <member name="P:Z0.SymbolSpec`3.SymWidth">
            <summary>
            The number of bits occupied by a symbol
            </summary>
        </member>
        <member name="P:Z0.SymbolSpec`3.SegWidth">
            <summary>
            The width of the underlying numeric primitive
            </summary>
        </member>
        <member name="P:Z0.SymbolSpec`3.SegCapacity">
            <summary>
            The maximum number of symbols that can be stored in a segment
            </summary>
        </member>
        <member name="T:Z0.ISystemHandle">
            <summary>
            Characterizes a lightweight, perhaps not-so-safe, "SafeHandle"
            </summary>
        </member>
        <member name="P:Z0.ISystemHandle.Address">
            <summary>
            The handle address
            </summary>
        </member>
        <member name="P:Z0.ISystemHandle.IsOwner">
            <summary>
            Specifies whether the instance is responsible for handle lifecycle management
            </summary>
        </member>
        <member name="T:Z0.ISystemHandle`1">
            <summary>
            Characterizes a <see cref='T:Z0.ISystemHandle'/> reification
            </summary>
            <typeparam name="T">The reifying type</typeparam>
        </member>
        <member name="T:Z0.CurrentProcess">
            <summary>
            Surfaces information about the currently executing process
            </summary>
        </member>
        <member name="P:Z0.CurrentProcess.OsThreadId">
            <summary>
            Gets the OS thread ID - not the CRL thread id
            </summary>
        </member>
        <member name="P:Z0.CurrentProcess.ProcessId">
            <summary>
            The process id
            </summary>
        </member>
        <member name="P:Z0.CurrentProcess.ProcessHandle">
            <summary>
            The handle for the current process
            </summary>
        </member>
        <member name="P:Z0.CurrentProcess.ThreadHandle">
            <summary>
            The handle for the current thread
            </summary>
        </member>
        <member name="M:Z0.CurrentProcess.ProcessThread(System.UInt32)">
            <summary>
            Searches for a thread given an OS-assigned id, not the (mostly) useless clr id
            </summary>
            <param name="id">The OS thread Id</param>
        </member>
        <member name="M:Z0.CurrentProcess.GetCurrentThreadId">
            <summary>
            Get the OS ID of the current thread
            </summary>
        </member>
        <member name="M:Z0.CurrentProcess.GetCurrentThread">
            <summary>
            Gets the handle of the current thread
            </summary>
        </member>
        <member name="M:Z0.Interop.offset(System.Reflection.FieldInfo)">
            <summary>
            Invokes <see cref='M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)'/>
            </summary>
            <param name="src">the source field</param>
        </member>
        <member name="M:Z0.Interop.offset(System.Type,Z0.StringRef)">
            <summary>
            Invokes <see cref='M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)'/>
            </summary>
            <param name="src">the source field</param>
        </member>
        <member name="M:Z0.Interop.offset(System.Type,System.String)">
            <summary>
            Invokes <see cref='M:System.Runtime.InteropServices.Marshal.OffsetOf(System.Type,System.String)'/>
            </summary>
            <param name="src">the source field</param>
        </member>
        <member name="M:Z0.Interop.offset``1(System.String)">
            <summary>
            Invokes <see cref='M:System.Runtime.InteropServices.Marshal.OffsetOf``1(System.String)'/>
            </summary>
            <param name="src">the source field name</param>
            <typeparam name="T">The declaring type</typeparam>
        </member>
        <member name="F:Z0.ProcessState.Id">
            <summary>
            The process identifier
            </summary>
        </member>
        <member name="F:Z0.ProcessState.Name">
            <summary>
            The process name
            </summary>
        </member>
        <member name="F:Z0.ProcessState.Base">
            <summary>
            The base address of the process
            </summary>
        </member>
        <member name="F:Z0.ProcessState.Capacity">
            <summary>
            Captures the min/max working set size
            </summary>
        </member>
        <member name="F:Z0.ProcessState.Affinity">
            <summary>
            The cpu affinity provided by <see cref='P:System.Diagnostics.Process.ProcessorAffinity'/>
            </summary>
        </member>
        <member name="F:Z0.ProcessState.StartTime">
            <summary>
            Captures the process start time
            </summary>
        </member>
        <member name="F:Z0.ProcessState.TotalRuntime">
            <summary>
            Captures the value provided by <see cref='P:System.Diagnostics.Process.TotalProcessorTime'/>
            </summary>
        </member>
        <member name="F:Z0.ProcessState.UserRuntime">
            <summary>
            Captures the value provided by <see cref='P:System.Diagnostics.Process.UserProcessorTime'/>
            </summary>
        </member>
        <member name="F:Z0.ProcessState.Main">
            <summary>
            The process main module
            </summary>
        </member>
        <member name="T:Z0.SystemHandle`1">
            <summary>
            Defines a uniform structural representation for <see cref='T:Z0.ISystemHandle`1'/> reifications
            </summary>
        </member>
        <member name="T:Z0.SystemCounters">
            <summary>
            Defines counter api surface
            </summary>
        </member>
        <member name="M:Z0.SystemCounters.delta(System.Int64@)">
            <summary>
            Returns the difference between the current Counter value and a prior counter value
            </summary>
        </member>
        <member name="M:Z0.SystemCounters.ms(System.Int64@)">
            <summary>
            Converts a counter value to milliseconds
            </summary>
            <param name="count">The count value to convert</param>
        </member>
        <member name="M:Z0.SystemCounters.count">
            <summary>
            Gets the current value of the counter
            </summary>
        </member>
        <member name="M:Z0.SystemCounters.cycles">
            <summary>
            Gets the CPU cycles consumed by the calling thread
            </summary>
        </member>
        <member name="M:Z0.SystemCounters.cycles(System.UInt64@)">
            <summary>
            Gets the CPU cycles consumed by the calling thread
            </summary>
        </member>
        <member name="M:Z0.SystemCounters.QueryPerformanceFrequency(System.Int64@)">
            <summary>
            Retrieves the number of performance counter counts per second.
            </summary>
            <remarks>This is determined by the OS at boot time and is invariant until the next reboot</remarks>
        </member>
        <member name="M:Z0.SystemCounters.QueryThreadCycleTime(System.IntPtr,System.UInt64@)">
            <summary>
            Retrieves the cyle time for a specified thread
            </summary>
            <param name="hThread">The handle to the thread</param>
            <param name="cycles">The number of cpu clock cycles used by the thread</param>
        </member>
        <member name="M:Z0.SystemCounters.QueryProcessCycleTime(System.IntPtr,System.UInt64@)">
            <summary>
            Retrieves the sum of the cycle time of all threads of the specified process.
            </summary>
            <param name="hProc">The handle to the process</param>
            <param name="cycles">The number of cpu clock cycles used by the threads of the process</param>
        </member>
        <member name="M:Z0.SystemProcess.state(System.Diagnostics.Process)">
            <summary>
            Captures the current process state
            </summary>
            <param name="src">The source process</param>
        </member>
        <member name="M:Z0.TClocked.counter(System.Boolean)">
            <summary>
            Allocates and optionally starts a system counter
            </summary>
        </member>
        <member name="M:Z0.TClocked.stopwatch(System.Boolean)">
            <summary>
            Creates a new stopwatch and optionally start it
            </summary>
            <param name="start">Whether to start the new stopwatch</param>
        </member>
        <member name="M:Z0.TClocked.snapshot(System.Diagnostics.Stopwatch)">
            <summary>
            Captures a stopwatch duration
            </summary>
            <param name="sw">A running/stopped stopwatch</param>
        </member>
        <member name="M:Z0.Time.contains(Z0.DateRange@,System.Date)">
            <summary>
            Determines whether the test value is within the range
            </summary>
            <param name="test">The date to test</param>
        </member>
        <member name="M:Z0.Time.external(Z0.DateRange@,System.Date)">
            <summary>
            Determines whether the test value is outside the range
            </summary>
            <param name="test">The date to test</param>
        </member>
        <member name="M:Z0.Time.date(System.DateTime)">
            <summary>
            Returns the <see cref="T:System.Date"/> part of the supplied <see cref="T:System.DateTime"/>
            </summary>
            <param name="d">The subject</param>
        </member>
        <member name="M:Z0.Time.now">
            <summary>
            Right now
            </summary>
        </member>
        <member name="M:Z0.Time.timestamp">
            <summary>
            Creates a <see cref='T:Z0.Timestamp'/> populated with the system-reported time
            </summary>
        </member>
        <member name="M:Z0.Time.stopwatch(System.Boolean)">
            <summary>
            Creates a new stopwatch and optionally start it
            </summary>
            <param name="start">Whether to start the new stopwatch</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.Time.counter(System.Boolean)" -->
        <member name="M:Z0.Time.snapshot(System.Diagnostics.Stopwatch)">
            <summary>
            Captures a stopwatch duration
            </summary>
            <param name="sw">A running/stopped stopwatch</param>
        </member>
        <member name="M:Z0.Time.lexical(System.DateTime,Z0.TimeResolution)">
            <summary>
            Renders a string in a more rational manner than the default behavior
            </summary>
            <param name="t">The instant to render</param>
            <param name="accuracy">The accuracy with which to render the instant</param>
        </member>
        <member name="M:Z0.Time.dates(Z0.DateRange)">
            <summary>
            The days that comprise the range
            </summary>
        </member>
        <member name="T:Z0.TableField">
            <summary>
            Describes a column in a table
            </summary>
        </member>
        <member name="F:Z0.TableField.TableType">
            <summary>
            The defining type
            </summary>
        </member>
        <member name="F:Z0.TableField.Index">
            <summary>
            The 0-based, declaration order of the field
            </summary>
        </member>
        <member name="T:Z0.IKeyMap`2">
            <summary>
            Characterizes a bijective correspondence between keys and indexes
            </summary>
            <typeparam name="K">The key type</typeparam>
            <typeparam name="I">The index type</typeparam>
        </member>
        <member name="T:Z0.IKeyMap`3">
            <summary>
            Characterizes a <see cref='T:Z0.IKeyMap`2'/> reification
            </summary>
            <typeparam name="H">The host type</typeparam>
            <typeparam name="K"></typeparam>
            <typeparam name="I"></typeparam>
        </member>
        <member name="T:Z0.ITableProjector`4">
            <summary>
            Characterizes a D-discriminated table processor
            </summary>
            <typeparam name="D">The discriminator type</typeparam>
            <typeparam name="S">The discrimnator's scalar type</typeparam>
            <typeparam name="T">The data type</typeparam>
            <typeparam name="Y">The output type</typeparam>
        </member>
        <member name="T:Z0.ITableProjector`5">
            <summary>
            Characterizes a reified D-discriminated table processor
            </summary>
            <typeparam name="H">The host type</typeparam>
            <typeparam name="D">The discriminator type</typeparam>
            <typeparam name="S">The discrimnator's scalar type</typeparam>
            <typeparam name="T">The data type</typeparam>
            <typeparam name="Y">The output type</typeparam>
        </member>
        <member name="M:Z0.KeyMaps.index``2(``0,``1)">
            <summary>
            Correlates an identifying key and a sequence/index postion
            </summary>
            <param name="key">The identifying key</param>
            <param name="index">The correlated position</param>
            <typeparam name="K">The key type</typeparam>
            <typeparam name="I">The index type</typeparam>
        </member>
        <member name="T:Z0.KeyedIndex`2">
            <summary>
            Defines a finite bijection member that correlates keys and indexes
            </summary>
        </member>
        <member name="P:Z0.KeyedIndex`2.Key">
            <summary>
            The key value
            </summary>
        </member>
        <member name="P:Z0.KeyedIndex`2.Index">
            <summary>
            The index value
            </summary>
        </member>
        <member name="T:Z0.TableProjector`4">
            <summary>
            Defines a projection operator project:T[] -> Y[] where T conforms to <see cref='T:Z0.ITable'/> and Y is arbitrary
            </summary>
        </member>
        <member name="M:Z0.TableProjector`4.Project(`2@)">
            <summary>
            Projects a table onto a target
            </summary>
            <param name="x">The source table</param>
        </member>
        <member name="M:Z0.TableProjector`4.Project(System.ReadOnlySpan{`2})">
            <summary>
            Projects a source sequence onto a target sequence
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="T:Z0.TableDispatchEngine`5">
            <summary>
            Table process orchestrator
            </summary>
        </member>
        <member name="F:Z0.TableDispatchEngine`5.Wf">
            <summary>
            The context in which the dispatcher is running
            </summary>
        </member>
        <member name="F:Z0.TableDispatchEngine`5.Source">
            <summary>
            The data source
            </summary>
        </member>
        <member name="F:Z0.TableDispatchEngine`5.Target">
            <summary>
            The data target
            </summary>
        </member>
        <member name="F:Z0.TableDispatchEngine`5.Projectors">
            <summary>
            The table processors that define/apply target -> source projection
            </summary>
        </member>
        <member name="F:Z0.TableDispatchEngine`5.Selectors">
            <summary>
            Processor selection keys
            </summary>
        </member>
        <member name="M:Z0.TableDispatchEngine`5.Projector(`2)">
            <summary>
            Retrieves a D-identified projector via the D/S selectors
            </summary>
            <param name="id">The projector identity</param>
        </member>
        <member name="M:Z0.DatasetFormatter`1.index(`0)">
            <summary>
            Computes the field index from a field specifier
            </summary>
            <param name="field">The field specifier</param>
            <typeparam name="F">The field specifier type</typeparam>
        </member>
        <member name="M:Z0.DatasetFormatter`1.width(`0)">
            <summary>
            Computes the field width from a field specifier
            </summary>
            <param name="field">The field specifier</param>
            <typeparam name="F">The field specifier type</typeparam>
        </member>
        <member name="M:Z0.ITableStore`2.Save(`1[],Z0.FilePath)">
            <summary>
            Saves tabular data using derived metadata for format configuration
            </summary>
            <param name="src">The source data</param>
            <param name="dst">The target file</param>
            <typeparam name="R">The source type</typeparam>
        </member>
        <member name="M:Z0.TableStore.deposit``1(Z0.EnumLiteralDetails{``0}@,Z0.FS.FilePath)">
            <summary>
            Stores the dataset supplied by <see cref='M:Z0.Enums.index``1'/>
            </summary>
            <param name="src">The source</param>
            <param name="dst">The target</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="T:Z0.IConstIndex`3">
            <summary>
            Characterizes a <typeparamref name='K'/> indexed sequence of readonly <typeparamref name='T'/> terms
            </summary>
            <typeparam name="K">The accessor type</typeparam>
            <typeparam name="M">The measure type</typeparam>
            <typeparam name="T">The term type</typeparam>
        </member>
        <member name="T:Z0.ITableIndex`2">
            <summary>
            Characterizes an index-parametric <see cref='T:Z0.ITableSpan`1' />
            /// </summary>
            <typeparam name="T">The table type</typeparam>
            <typeparam name="I">The index type</typeparam>
        </member>
        <member name="T:Z0.ITableIndex`3">
            <summary>
            Characterizes a field-parametric <see cref='T:Z0.ITableIndex`2'/>
            </summary>
            <typeparam name="F">The field specification</typeparam>
            <typeparam name="T">The table type</typeparam>
            <typeparam name="I">The index type</typeparam>
        </member>
        <member name="T:Z0.ITableSpan">
            <summary>
            Characterizes an in-memory table store
            </summary>
        </member>
        <member name="T:Z0.ITableSpan`1">
            <summary>
            Characterizes a parametric <see cref='T:Z0.ITableSpan' />
            </summary>
            <typeparam name="T">The table type</typeparam>
        </member>
        <member name="M:Z0.ITabular.DelimitedText(System.Char)">
            <summary>
            Returns a line of text represents the record value
            </summary>
        </member>
        <member name="T:Z0.DatasetHeader`1">
            <summary>
            Defines enum-predicated header content
            </summary>
        </member>
        <member name="M:Z0.DatasetHeader`1.Render(System.Func{System.Int32,`0,System.String},System.Char)">
            <summary>
            Formates a header row using a caller-supplied label producer
            </summary>
            <param name="label">The label factory</param>
            <param name="delimiter">The delimiter</param>
            <typeparam name="F">The field type</typeparam>
        </member>
        <member name="F:Z0.Datasets.PosMask">
            <summary>
            Defines a mask that, when applied, reveals the field position
            </summary>
        </member>
        <member name="M:Z0.Datasets.width``1(``0)">
            <summary>
            Computes the field width from a field specifier
            </summary>
            <param name="field">The field specifier</param>
            <typeparam name="F">The field specifier type</typeparam>
        </member>
        <member name="M:Z0.Datasets.index``1(``0)">
            <summary>
            Computes the field index from a field specifier
            </summary>
            <param name="field">The field specifier</param>
            <typeparam name="F">The field specifier type</typeparam>
        </member>
        <member name="F:Z0.AspectRow.Name">
            <summary>
            The aspect name
            </summary>
        </member>
        <member name="F:Z0.AspectRow.Source">
            <summary>
            The defining source
            </summary>
        </member>
        <member name="F:Z0.AspectRow.Value">
            <summary>
            The aspect value
            </summary>
        </member>
        <member name="F:Z0.AspectRow.Description">
            <summary>
            An informative description
            </summary>
        </member>
        <member name="M:Z0.IndexedSeq`2.view``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates an indexed sequence from a parameter array
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="T:Z0.IndexedSeq`1">
            <summary>
            Reifies a canonical indexed sequence container
            </summary>
        </member>
        <member name="M:Z0.IndexedView`2.view``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates an indexed sequence from a parameter array
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.IndexedView`1.view``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates an indexed sequence from a parameter array
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="F:Z0.TableColumn`1.Id">
            <summary>
            The field specifier
            </summary>
        </member>
        <member name="F:Z0.TableColumn`1.Name">
            <summary>
            The field name
            </summary>
        </member>
        <member name="F:Z0.TableColumn`1.Index">
            <summary>
            The 0-based field index
            </summary>
        </member>
        <member name="F:Z0.TableColumn`1.Width">
            <summary>
            The field width
            </summary>
        </member>
        <member name="F:Z0.TableRenderSpec.Fields">
            <summary>
            The field specifications
            </summary>
        </member>
        <member name="F:Z0.TableRenderSpec.Headers">
            <summary>
            The column header names
            </summary>
        </member>
        <member name="F:Z0.TableRenderSpec.Delimiter">
            <summary>
            The default field delimiter
            </summary>
        </member>
        <member name="F:Z0.TableRenderSpec.EmitHeader">
            <summary>
            Whether to produce a header when formatting a collection
            </summary>
        </member>
        <member name="F:Z0.TableRenderSpec.FieldCount">
            <summary>
            The number of fields accounted for
            </summary>
        </member>
        <member name="M:Z0.TableRenderSpec.Format">
            <summary>
            Formats the format specification, not the object being specified
            </summary>
        </member>
        <member name="F:Z0.TableRenderSpec`1.Fields">
            <summary>
            The field specifications
            </summary>
        </member>
        <member name="F:Z0.TableRenderSpec`1.Headers">
            <summary>
            The column header names
            </summary>
        </member>
        <member name="M:Z0.TableRenderSpec`1.Format">
            <summary>
            Formats the format specification, not the object being specified
            </summary>
        </member>
        <member name="T:Z0.TableSpan`3">
            <summary>
            Defines a tabular span of dimension MxN
            </summary>
            <typeparam name="M">The row count type</typeparam>
            <typeparam name="N">The row count type</typeparam>
            <typeparam name="T">The span element type</typeparam>
        </member>
        <member name="P:Z0.TableSpan`3.RowCount">
            <summary>
            The number of rows in the structure
            </summary>
        </member>
        <member name="P:Z0.TableSpan`3.ColCount">
            <summary>
            The number of columns in the structure
            </summary>
        </member>
        <member name="P:Z0.TableSpan`3.RowLength">
            <summary>
            The number of cells in each row
            </summary>
        </member>
        <member name="P:Z0.TableSpan`3.ColLength">
            <summary>
            The number of cells in each column
            </summary>
        </member>
        <member name="P:Z0.TableSpan`3.CellCount">
            <summary>
            The total number of allocated elements
            </summary>
        </member>
        <member name="M:Z0.TableSpan`3.CheckedTransfer(System.Span{`2})">
            <summary>
            Verifies correct source span length prior to backing store assignment
            </summary>
            <param name="src">The source span</param>
            <typeparam name="U">The source element type</typeparam>
        </member>
        <member name="P:Z0.TableSpan`3.Data">
            <summary>
            Provides access to the underlying linear storage
            </summary>
        </member>
        <member name="M:Z0.Table.cells(System.String[])">
            <summary>
            Creates a <see cref='T:Z0.StringTableCells'/> sequence from a <see cref='T:System.String'/> array
            </summary>
            <param name="src">The source array</param>
        </member>
        <member name="M:Z0.Table.entry``2(``0,``1@)">
            <summary>
            Creates a <see cref='T:Z0.LookupTable`2'/> entry
            </summary>
            <param name="key">The lookup key</param>
            <param name="value">The target value</param>
            <typeparam name="K">The key type</typeparam>
            <typeparam name="V">The value type</typeparam>
        </member>
        <member name="M:Z0.Table.flow(System.String[],Z0.StringTableCells@)">
            <summary>
            Creates a <see cref='T:Z0.StringTableCells'/> sequence from a <see cref='T:System.String'/> sequence
            </summary>
            <param name="src">The source sequence</param>
            <param name="dst">The target sequence</param>
        </member>
        <member name="M:Z0.Table.renderspec``1(System.Char)">
            <summary>
            Derives format configuration data from a type
            </summary>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.Table.width``1(``0)">
            <summary>
            Computes the field width from a field specifier
            </summary>
            <param name="field">The field specifier</param>
            <typeparam name="F">The field specifier type</typeparam>
        </member>
        <member name="F:Z0.MessageColor.Unspecified">
            <summary>
            Boring
            </summary>
        </member>
        <member name="F:Z0.MessageColor.Gray">
            <summary>
            Gray foreground
            </summary>
        </member>
        <member name="F:Z0.MessageColor.DarkGray">
            <summary>
            Dark gray foreground
            </summary>
        </member>
        <member name="F:Z0.MessageColor.Green">
            <summary>
            Green foreground
            </summary>
        </member>
        <member name="F:Z0.MessageColor.DarkGreen">
            <summary>
            Dark green foreground
            </summary>
        </member>
        <member name="F:Z0.MessageColor.Blue">
            <summary>
            Light blue foreground
            </summary>
        </member>
        <member name="F:Z0.MessageColor.DarkBlue">
            <summary>
            Dark blue foreground
            </summary>
        </member>
        <member name="F:Z0.MessageColor.Cyan">
            <summary>
            Cyan foreground
            </summary>
        </member>
        <member name="F:Z0.MessageColor.DarkCyan">
            <summary>
            Dark cyan foreground
            </summary>
        </member>
        <member name="F:Z0.MessageColor.Magenta">
            <summary>
            Magenta foreground
            </summary>
        </member>
        <member name="F:Z0.MessageColor.DarkMagenta">
            <summary>
            Dark magenta foreground
            </summary>
        </member>
        <member name="F:Z0.MessageColor.Yellow">
            <summary>
            Yellow foreground
            </summary>
        </member>
        <member name="F:Z0.MessageColor.DarkYellow">
            <summary>
            Dark yellow foreground
            </summary>
        </member>
        <member name="F:Z0.MessageColor.Red">
            <summary>
            Red foreground
            </summary>
        </member>
        <member name="F:Z0.MessageColor.DarkRed">
            <summary>
            Dark red foreground
            </summary>
        </member>
        <member name="M:Z0.term.magenta(System.Object)">
            <summary>
            Emits an information-level message with a magenta foreground
            </summary>
            <param name="content">The message to emit</param>
            <param name="caller">The calling member</param>
        </member>
        <member name="M:Z0.term.magenta(System.String,System.Object)">
            <summary>
            Emits an information-level message with a magenta foreground
            </summary>
            <param name="content">The message to emit</param>
            <param name="caller">The calling member</param>
        </member>
        <member name="M:Z0.term.green(System.Object)">
            <summary>
            Emits an information-level message with a magenta foreground
            </summary>
            <param name="content">The message to emit</param>
            <param name="caller">The calling member</param>
        </member>
        <member name="M:Z0.term.green(System.String,System.Object)">
            <summary>
            Emits an information-level message with a magenta foreground
            </summary>
            <param name="content">The message to emit</param>
            <param name="caller">The calling member</param>
        </member>
        <member name="M:Z0.term.cyan(System.Object)">
            <summary>
            Emits an information-level message with a cyan foreground
            </summary>
            <param name="content">The message to emit</param>
            <param name="caller">The calling member</param>
        </member>
        <member name="M:Z0.term.cyan(System.String,System.Object)">
            <summary>
            Emits an information-level message with a cyan foreground
            </summary>
            <param name="content">The message to emit</param>
            <param name="caller">The calling member</param>
        </member>
        <member name="M:Z0.term.red(System.Object)">
            <summary>
            Emits an information-level message with a red foreground, typically used to emit error messages
            at the point of occurrence, not at the point at which they are handled
            </summary>
            <param name="content">The message to emit</param>
            <param name="caller">The calling member</param>
        </member>
        <member name="M:Z0.term.red(System.String,System.Object)">
            <summary>
            Emits an information-level message with a red foreground, typically used to emit error messages
            at the point of occurrence, not at the point at which they are handled
            </summary>
            <param name="content">The message to emit</param>
            <param name="caller">The calling member</param>
        </member>
        <member name="M:Z0.term.yellow(System.Object)">
            <summary>
            Emits an information-level message with a yellow foreground
            </summary>
            <param name="content">The message to emit</param>
            <param name="caller">The calling member</param>
        </member>
        <member name="M:Z0.term.yellow(System.String,System.Object)">
            <summary>
            Emits an information-level message with a yellow foreground
            </summary>
            <param name="content">The message to emit</param>
            <param name="caller">The calling member</param>
        </member>
        <member name="M:Z0.term.babble(System.Object)">
            <summary>
            Emits a verbose-level message
            </summary>
            <param name="content">The message to emit</param>
        </member>
        <member name="M:Z0.term.inform(System.Object)">
            <summary>
            Emits an information-level message
            </summary>
            <param name="content">The message to emit</param>
            <param name="caller">The calling member</param>
        </member>
        <member name="M:Z0.term.announce(System.String)">
            <summary>
            Announces a menthod invocation
            </summary>
            <param name="caller">The invoked method</param>
        </member>
        <member name="M:Z0.term.warn(System.Object,System.String,System.String,System.Nullable{System.Int32})">
            <summary>
            Emits a warning-level message
            </summary>
            <param name="content">The message to emit</param>
            <param name="caller">The calling member</param>
        </member>
        <member name="M:Z0.term.error(System.Object,System.String,System.String,System.Nullable{System.Int32})">
            <summary>
            Emits message to the error output stream
            </summary>
            <param name="content">The message to emit</param>
            <param name="caller">The calling member</param>
        </member>
        <member name="M:Z0.term.error(System.Exception,System.String,System.String,System.Nullable{System.Int32})">
            <summary>
            Emits a message to the error output stream
            </summary>
            <param name="e">The raised exception</param>
            <param name="title">The name/context of the error</param>
        </member>
        <member name="M:Z0.term.error(Z0.ClaimException,System.String,System.String,System.String,System.Nullable{System.Int32})">
            <summary>
            Emits a message to the error output stream
            </summary>
            <param name="e">The raised exception</param>
            <param name="title">The name/context of the error</param>
        </member>
        <member name="M:Z0.term.errlabel(System.Exception,System.String,System.String,System.String,System.Nullable{System.Int32})">
            <summary>
            Emits a message to the error output stream
            </summary>
            <param name="e">The raised exception</param>
            <param name="title">The name/context of the error</param>
        </member>
        <member name="M:Z0.term.print">
            <summary>
            Writes an empty line to the console
            </summary>
        </member>
        <member name="M:Z0.term.print(System.String,Z0.FlairKind)">
            <summary>
            Writes a colorized message to the console
            </summary>
            <param name="message">The message text</param>
            <param name="color">The emission color</param>
        </member>
        <member name="M:Z0.term.print(Z0.IAppMsg)">
            <summary>
            Writes a single messages to the terminal
            </summary>
            <param name="msg">The message to print</param>
        </member>
        <member name="M:Z0.term.print(Z0.IAppMsg,Z0.FlairKind)">
            <summary>
            Writes a single messages to the terminal
            </summary>
            <param name="msg">The message to print</param>
        </member>
        <member name="M:Z0.term.print(Z0.AppMsg)">
            <summary>
            Writes a single messages to the terminal
            </summary>
            <param name="msg">The message to print</param>
        </member>
        <member name="M:Z0.term.print(System.Object)">
            <summary>
            Writes a single line to the terminal
            </summary>
            <param name="content">The message to print</param>
        </member>
        <member name="M:Z0.term.print``1(``0,Z0.FlairKind)">
            <summary>
            Writes formattables to the console in a contiguous block
            </summary>
            <param name="content">The content to print</param>
        </member>
        <member name="M:Z0.term.print``1(``0)">
            <summary>
            Writes formattables to the console in a contiguous block
            </summary>
            <param name="content">The content to print</param>
        </member>
        <member name="M:Z0.term.print(Z0.IAppEvent)">
            <summary>
            Writes formattables to the console in a contiguous block
            </summary>
            <param name="content">The content to print</param>
        </member>
        <member name="M:Z0.term.print``1(``0[])">
            <summary>
            Writes formattables to the console in a contiguous block
            </summary>
            <param name="content">The content to print</param>
        </member>
        <member name="M:Z0.term.print``1(Z0.FlairKind,``0[])">
            <summary>
            Writes formattables to the console in a contiguous block using a specified foreground color
            </summary>
            <param name="color">The message foreground color</param>
            <param name="content">The content to print</param>
        </member>
        <member name="M:Z0.term.print(System.Collections.Generic.IEnumerable{Z0.AppMsg})">
            <summary>
            Prints a sequence of messages in an unbroken block
            </summary>
            <param name="content">The messages to print</param>
        </member>
        <member name="M:Z0.term.read">
            <summary>
            Reads a line of text from the terminal
            </summary>
        </member>
        <member name="M:Z0.term.readKey(System.String)">
            <summary>
            Reads a character from the terminal
            </summary>
        </member>
        <member name="M:Z0.term.read(System.String)">
            <summary>
            Reads a line of text from the terminal after printing a supplied message
            </summary>
        </member>
        <member name="M:Z0.term.write(System.Char,System.Nullable{Z0.FlairKind})">
            <summary>
            Writes a single character to the terminal
            </summary>
            <param name="c">The character to write</param>
            <param name="color">The foreground color</param>
        </member>
        <member name="T:Z0.TermEventSink">
            <summary>
            Reifies a workflow event receiver that emits received events to the terminal
            </summary>
        </member>
        <member name="T:Z0.Terminal">
            <summary>
            Implements a thread-safe/thread-aware terminal abstraction
            </summary>
        </member>
        <member name="M:Z0.Terminal.SetTerminationHandler(System.Action)">
            <summary>
            Specifies the handler to invoke when the user enters a cancellation
            command, such as Ctrl+C
            </summary>
            <param name="handler">The handler to invoke when a termination command is received</param>
        </member>
        <member name="M:Z0.Terminal.WriteChar(System.Char,System.Nullable{Z0.FlairKind})">
            <summary>
            Writes a single character to the console
            </summary>
            <param name="c">The char to emit</param>
            <param name="severity">The severity</param>
        </member>
        <member name="T:Z0.TextCell">
            <summary>
            Defines a text segment in the context of a line in a file
            </summary>
        </member>
        <member name="F:Z0.TextDocFormat.RowSeparator">
            <summary>
            Specifies leading content that identifies a non-semantic row division marker
            </summary>
        </member>
        <member name="F:Z0.TextDocFormat.HasDataHeader">
            <summary>
            Indicates whether the first line of the data is a header row
            </summary>
        </member>
        <member name="F:Z0.TextDocFormat.IsDelimited">
            <summary>
            Specifes whether the file contains regular delimited contetn
            </summary>
        </member>
        <member name="F:Z0.TextDocFormat.Delimiter">
            <summary>
            The character used to delimit parts of a line, if delimited
            </summary>
        </member>
        <member name="F:Z0.TextDocFormat.CommentPrefix">
            <summary>
            If specified, indicates the character that begins a comment
            </summary>
        </member>
        <member name="F:Z0.TextDocFormat.ColWidth">
            <summary>
            If specified, defines a uniform column width
            </summary>
        </member>
        <member name="T:Z0.TextDocHeader">
            <summary>
            Defines header content in a text data file
            </summary>
        </member>
        <member name="T:Z0.TextDocLine">
            <summary>
            Represents a line of text in the context of a line-oriented text data source
            </summary>
        </member>
        <member name="F:Z0.TextDocLine.LineNumber">
            <summary>
            The line number of the data source from which the line was extracted
            </summary>
        </member>
        <member name="F:Z0.TextDocLine.LineText">
            <summary>
            The line text, as it was found in the source
            </summary>
        </member>
        <member name="T:Z0.TextRow">
            <summary>
            Defines a row of text parttioned into a sequence of cells
            </summary>
        </member>
        <member name="M:Z0.TextRow.Format(System.Nullable{System.Char})">
            <summary>
            Joins the enclosed cells to produce a line of text
            </summary>
            <param name="delimiter">The separator to apply to delimit the cell data in the line </param>
        </member>
        <member name="M:Z0.TextDocParser.header(Z0.TextDocLine,Z0.TextDocFormat@)">
            <summary>
            Parses a header row from a line of text
            </summary>
            <param name="src">The source line</param>
            <param name="spec">The text format</param>
        </member>
        <member name="M:Z0.TextDocParser.parse(System.IO.StreamReader,System.Nullable{Z0.TextDocFormat})">
            <summary>
            Attempts to parse a text document and returns the result if successful
            </summary>
            <param name="src">The source document path</param>
            <param name="format">The document format</param>
            <param name="observer">An optional observer to witness intersting events</param>
        </member>
        <member name="M:Z0.TextDocParser.row(Z0.TextDocLine,Z0.TextDocFormat@)">
            <summary>
            Parses a row from a line of text
            </summary>
            <param name="src">The source text</param>
            <param name="spec">The text format spec</param>
        </member>
        <member name="T:Z0.FormatCodeAttribute">
            <summary>
            Identifies a stateless service
            </summary>
        </member>
        <member name="T:Z0.FormatFunctions.Format`1">
            <summary>
            Characterizes a content render function
            </summary>
            <param name="src">The content value</param>
            <typeparam name="T">The content type</typeparam>
        </member>
        <member name="T:Z0.FormatFunctions.FormatTitle`1">
            <summary>
            Characterizes a title render function
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The type for which titles will be provided</typeparam>
        </member>
        <member name="T:Z0.FormatterAttribute">
            <summary>
            Applied to a type to specify a non-default formatter
            </summary>
        </member>
        <member name="P:Z0.FormatterAttribute.Realization">
            <summary>
            Specifies the type that realizes IFormatter and its generic variants if extant
            </summary>
        </member>
        <member name="T:Z0.IDataFormatter`2">
            <summary>
            Characterizes a configurable formatter, parametric in both type and configuration
            </summary>
        </member>
        <member name="M:Z0.IDataFormatter`2.Format(`1,`0@)">
            <summary>
            Formats a source value according to a supplied configuration
            </summary>
            <param name="src">The source value</param>
            <param name="config">The configuration</param>
        </member>
        <member name="T:Z0.IEntitled`1">
            <summary>
            Characterizes a content formatter that can also produces titles and titled content
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Z0.IFormatter">
            <summary>
            Characterizes a text serializer
            </summary>
        </member>
        <member name="T:Z0.IFormatter`1">
            <summary>
            Characterizes a type-parametric formatter
            </summary>
        </member>
        <member name="M:Z0.IFormatter`1.Format(`0)">
            <summary>
            Renders an object as text
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.ISpanFormatter`1.Format(System.ReadOnlySpan{`0})">
            <summary>
            Formats and concatenates span content
            </summary>
            <param name="src">The source span</param>
        </member>
        <member name="M:Z0.ISpanFormatter`1.FormatItems(System.ReadOnlySpan{`0})">
            <summary>
            Formats span cells
            </summary>
            <param name="src">The source span</param>
        </member>
        <member name="M:Z0.ISpanFormatter`2.Format(System.ReadOnlySpan{`0},`1@)">
            <summary>
            Formats and concatenates span content using a sequence format configuration
            </summary>
            <param name="src">The source span</param>
            <param name="config">The sequence format configuration</param>
        </member>
        <member name="M:Z0.ISpanFormatter`2.FormatItems(System.ReadOnlySpan{`0},`1@)">
            <summary>
            Formats source span cells using a sequence format configuration
            </summary>
            <param name="src">The source span</param>
            <param name="config">The sequence format configuration</param>
        </member>
        <member name="M:Z0.ISpanFormatter`3.Format(System.ReadOnlySpan{`0},`1@,`2@)">
            <summary>
            Formats a span using both sequence and element format configurations
            </summary>
            <param name="src">The source span</param>
            <param name="seq">The sequence format configuration</param>
            <param name="config">The element format configuration</param>
        </member>
        <member name="T:Z0.ITitleFormatter">
            <summary>
            Characterizes a service that knows how to produce titles for things
            </summary>
        </member>
        <member name="T:Z0.ITitleFormatter`1">
            <summary>
            Characterizes a parametric title formatter
            </summary>
        </member>
        <member name="M:Z0.Formatters.content``1(Z0.FormatFunctions.Format{``0})">
            <summary>
            Creates a formatter from a rendering function render:T -> string
            </summary>
            <param name="render">A function that produces text from an element value</param>
            <typeparam name="T">The type of element to render</typeparam>
        </member>
        <member name="M:Z0.Formatters.data``1">
            <summary>
            Creates a data formatter
            </summary>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.Formatters.entitled``1(Z0.TitleFormatter{``0},Z0.Formatter{``0})">
            <summary>
            Creates a <see cref='T:Z0.Entitled`1'/> formatter
            </summary>
            <param name="tf">A tile formatter</param>
            <param name="cf">A content formatter</param>
            <typeparam name="T">The format target type</typeparam>
        </member>
        <member name="M:Z0.Formatters.entitled``1(Z0.FormatFunctions.FormatTitle{``0},Z0.FormatFunctions.Format{``0})">
            <summary>
            Creates an entitled formatter that provides formatting, entitling and entitled formatting
            from a format/title render function pair
            </summary>
            <param name="fx">The format render function</param>
            <param name="tx">The title render function</param>
            <typeparam name="T">The type of element to render</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.Formatters.hex``1" -->
        <member name="M:Z0.Formatters.provided``1(System.IFormatProvider,``0)">
            <summary>
            Creates a delegator that formats T-cells via a <see cref='T:System.IFormatProvider'/>
            </summary>
            <param name="provider">The source provider</param>
            <param name="t">A cell representative</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.Formatters.title``1(Z0.FormatFunctions.FormatTitle{``0})">
            <summary>
            Creates a title formatter from a rendering function render:T -> string
            </summary>
            <param name="fx">A function that produces text from an element value</param>
            <typeparam name="T">The type of element to render</typeparam>
        </member>
        <member name="F:Z0.SequenceFormatKind.List">
            <summary>
            Indicates a sequence of values is formatted as a comma-delimited 
            list between left/right square brackets, e.g., [1, 2, ..., n]
            </summary>
        </member>
        <member name="F:Z0.SequenceFormatKind.Vector">
            <summary>
            Indicates a sequence of values is formatted as a comma-delimited 
            list between left/right angular brackets
            </summary>
        </member>
        <member name="T:Z0.TupleFormat">
            <summary>
            Defines the available tuple format styles that may be applied when representing a tuple as text
            </summary>
        </member>
        <member name="F:Z0.TupleFormat.Coordinate">
            <summary>
            Indicates a tuple text representation of the form "(x1,...xn)"
            </summary>
        </member>
        <member name="F:Z0.TupleFormat.Dimension">
            <summary>
            Indicates a tuple text representation of the form "A1xA2x ... xAn"
            </summary>
        </member>
        <member name="F:Z0.TupleFormat.List">
            <summary>
            Indicates a tuple text representation of the form "[x1,...xn]"
            </summary>
        </member>
        <member name="F:Z0.TupleFormat.Record">
            <summary>
            Indicates a tuple text representation of the form "{x1,...xn}"
            </summary>
        </member>
        <member name="T:Z0.DefaultFormatter">
            <summary>
            Formats anything via <see cref='M:System.Object.ToString'/>
            </summary>
        </member>
        <member name="T:Z0.TitleFormatter`1">
            <summary>
            Provies a parametric title reification predicated on a render function
            </summary>
        </member>
        <member name="T:Z0.HexFormatOptions">
            <summary>
            Defines a common set of hex formatting options
            </summary>
        </member>
        <member name="F:Z0.HexFormatOptions.ZPad">
            <summary>
            Indicates whether the numeric content should be left-padded with zeros
            </summary>
        </member>
        <member name="F:Z0.HexFormatOptions.Specifier">
            <summary>
            Indicates whether a hex specifier, either prefixing or suffixing the numeric content, should be emitted
            </summary>
        </member>
        <member name="F:Z0.HexFormatOptions.Uppercase">
            <summary>
            Indicates whether the hex digits 'A',..,'F' should be upper-cased
            </summary>
        </member>
        <member name="F:Z0.HexFormatOptions.PreSpec">
            <summary>
            Indicates whether the hex numeric specifier, if emitted, prefix the output
            </summary>
        </member>
        <member name="F:Z0.HexFormatOptions.CaseFormatChar">
            <summary>
            The case format character, either 'X' or 'x'
            </summary>
        </member>
        <member name="F:Z0.HexFormatOptions.Delimiter">
            <summary>
            The character with which to intersperse hex number sequences
            </summary>
        </member>
        <member name="P:Z0.HexFormatOptions.FormatCode">
            <summary>
            The hex format string as determined by configuration
            </summary>
        </member>
        <member name="P:Z0.HexFormatOptions.HexData">
            <summary>
            Specifies the default configuration for hex data emission
            </summary>
        </member>
        <member name="P:Z0.HexFormatOptions.HexArray">
            <summary>
            The default configuration for array initialization content
            </summary>
        </member>
        <member name="F:Z0.HexFormatSpecs.UC">
            <summary>
            The uppercase hex format code
            </summary>
        </member>
        <member name="F:Z0.HexFormatSpecs.LC">
            <summary>
            The lowercase hex format code
            </summary>
        </member>
        <member name="F:Z0.HexFormatSpecs.DataDelimiter">
            <summary>
            The delimiter used to separate hex numbers when rendering a hex data sequence
            </summary>
        </member>
        <member name="F:Z0.HexFormatSpecs.HexPad8">
            <summary>
            The maximum number of hex characters required to represent an 8-bit number
            </summary>
        </member>
        <member name="F:Z0.HexFormatSpecs.HexPad16">
            <summary>
            The maximum number of hex characters required to represent a 16-bit number
            </summary>
        </member>
        <member name="F:Z0.HexFormatSpecs.HexPad32">
            <summary>
            The maximum number of hex characters required to represent a 32-bit number
            </summary>
        </member>
        <member name="F:Z0.HexFormatSpecs.HexPad64">
            <summary>
            The maximum number of hex characters required to represent a 64-bit number
            </summary>
        </member>
        <member name="F:Z0.HexFormatSpecs.PreSpec">
            <summary>
            Standard hex specifier that leads the numeric content
            </summary>
        </member>
        <member name="F:Z0.HexFormatSpecs.PostSpec">
            <summary>
            Standard hex specifier that trails the numeric content
            </summary>
        </member>
        <member name="M:Z0.HexFormatSpecs.CaseSpec(System.Boolean)">
            <summary>
            Selects either the uppercase format code 'X' or lowercase format code 'x'
            </summary>
            <param name="upper">True for uppercase, false for lowercase</param>
        </member>
        <member name="M:Z0.HexFormatSpecs.ClearSpecs(System.String)">
            <summary>
            Removes leading or trailing hex specifiers
            </summary>
            <param name="src">The source string</param>
        </member>
        <member name="F:Z0.HexLineConfig.BytesPerLine">
            <summary>
            The maximum byte-count per line
            </summary>
        </member>
        <member name="F:Z0.HexLineConfig.LineLabels">
            <summary>
            Specifies whether offset labels should be emitted
            </summary>
        </member>
        <member name="M:Z0.HexByteParser.Parse(System.Char)">
            <summary>
            Parses a single hex digit
            </summary>
            <param name="c">The source character</param>
        </member>
        <member name="M:Z0.HexByteParser.ParseData(System.String)">
            <summary>
            Parses a space-delimited sequence of hex text
            </summary>
            <param name="src">The space-delimited hex</param>
        </member>
        <member name="M:Z0.HexByteParser.ParseByte(System.String)">
            <summary>
            Parses a hex byte
            </summary>
            <param name="src">hex text</param>
        </member>
        <member name="M:Z0.HexNumericParser.parse(System.String)">
            <summary>
            Attempts to parse a hex string as an unsigned long
            </summary>
            <param name="src">The source text</param>
        </member>
        <member name="M:Z0.Render.concat(System.Collections.Generic.IEnumerable{System.Char})">
            <summary>
            Concatenates a sequence of characters with no intervening delimiter
            </summary>
            <param name="src">The characters to concatenate</param>
        </member>
        <member name="M:Z0.Render.format(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
            <summary>
            Formats the pair of strings represented by respective character spans
            </summary>
            <param name="a">The leading content</param>
            <param name="b">The trailing content</param>
        </member>
        <member name="M:Z0.Render.setting``2(``0,``1)">
            <summary>
            Renders a k/v pair as a setting
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <typeparam name="K"></typeparam>
            <typeparam name="V"></typeparam>
        </member>
        <member name="M:Z0.Render.format(System.ReadOnlySpan{System.Char})">
            <summary>
            Formats the pair of strings represented by respective character spans
            </summary>
            <param name="a">The leading content</param>
            <param name="b">The trailing content</param>
        </member>
        <member name="M:Z0.Render.format(Z0.StringRef@)">
            <summary>
            Formats a <see cref='T:Z0.StringRef'/>
            </summary>
            <param name="src">The source</param>
        </member>
        <member name="M:Z0.Render.format(Z0.StringRef@,Z0.StringRef@)">
            <summary>
            Formats a source operand according to a specified pattern
            </summary>
            <param name="pattern">The format pattern</param>
            <param name="arg0">The source operand</param>
        </member>
        <member name="M:Z0.Render.format(Z0.StringRef@,Z0.StringRef@,Z0.StringRef@)">
            <summary>
            Formats two operands according to a specified pattern
            </summary>
            <param name="pattern">The format pattern</param>
            <param name="arg0">The first operand</param>
            <param name="arg1">The second operand</param>
        </member>
        <member name="M:Z0.Render.format(Z0.StringRef@,Z0.StringRef@,Z0.StringRef@,Z0.StringRef@)">
            <summary>
            Formats three operands according to a specified pattern
            </summary>
            <param name="pattern">The format pattern</param>
            <param name="arg0">The first operand</param>
            <param name="arg1">The second operand</param>
            <param name="arg2">The third operand</param>
        </member>
        <member name="M:Z0.Render.format(System.String,Z0.StringRef@)">
            <summary>
            Formats a source operand according to a specified pattern
            </summary>
            <param name="pattern">The format pattern</param>
            <param name="arg0">The source operand</param>
        </member>
        <member name="M:Z0.Render.format(System.String,Z0.StringRef@,Z0.StringRef@)">
            <summary>
            Formats two operands according to a specified pattern
            </summary>
            <param name="pattern">The format pattern</param>
            <param name="arg0">The first operand</param>
            <param name="arg1">The second operand</param>
        </member>
        <member name="M:Z0.Render.format(System.String,Z0.StringRef@,Z0.StringRef@,Z0.StringRef@)">
            <summary>
            Formats three operands according to a specified pattern
            </summary>
            <param name="pattern">The format pattern</param>
            <param name="arg0">The first operand</param>
            <param name="arg1">The second operand</param>
            <param name="arg2">The third operand</param>
        </member>
        <member name="M:Z0.Render.format``1(``0)">
            <summary>
            Renders a source value as text
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.Render.format``2(``0,``1)">
            <summary>
            Renders a pair of <see cref='T:Z0.ITextual'/> values as <see cref='F:Z0.RP.Pipe'/> delimited text
            </summary>
            <param name="a">The first value</param>
            <param name="b">The second value</param>
            <typeparam name="A">The first value type</typeparam>
            <typeparam name="B">The second value type</typeparam>
        </member>
        <member name="M:Z0.Render.format``3(``0,``1,``2)">
            <summary>
            Renders a triple of <see cref='T:Z0.ITextual'/> values as <see cref='F:Z0.RP.Pipe'/> delimited text
            </summary>
            <param name="a">The first value</param>
            <param name="b">The second value</param>
            <param name="c">The third value</param>
            <typeparam name="A">The first value type</typeparam>
            <typeparam name="B">The second value type</typeparam>
            <typeparam name="C">The third value type</typeparam>
        </member>
        <member name="M:Z0.Render.format``4(``0,``1,``2,``3)">
            <summary>
            Renders a quartet of <see cref='T:Z0.ITextual'/> values as <see cref='F:Z0.RP.Pipe'/> delimited text
            </summary>
            <param name="a">The first value</param>
            <param name="b">The second value</param>
            <param name="c">The third value</param>
            <param name="d">The fourth value</param>
            <typeparam name="A">The first value type</typeparam>
            <typeparam name="B">The second value type</typeparam>
            <typeparam name="C">The third value type</typeparam>
            <typeparam name="D">The fourth value type</typeparam>
        </member>
        <member name="M:Z0.Render.format``5(``0,``1,``2,``3,``4)">
            <summary>
            Renders a quintet of <see cref='T:Z0.ITextual'/> values as <see cref='F:Z0.RP.Pipe'/> delimited text
            </summary>
            <param name="a">The first value</param>
            <param name="b">The second value</param>
            <param name="c">The third value</param>
            <param name="d">The fourth value</param>
            <param name="e">The fifth value</param>
            <typeparam name="A">The first value type</typeparam>
            <typeparam name="B">The second value type</typeparam>
            <typeparam name="C">The third value type</typeparam>
            <typeparam name="D">The fourth value type</typeparam>
            <typeparam name="E">The fifth value type</typeparam>
        </member>
        <member name="M:Z0.Render.format``6(``0,``1,``2,``3,``4,``5)">
            <summary>
            Renders a sextet of <see cref='T:Z0.ITextual'/> values as <see cref='F:Z0.RP.Pipe'/> delimited text
            </summary>
            <param name="a">The first value</param>
            <param name="b">The second value</param>
            <param name="c">The third value</param>
            <param name="d">The fourth value</param>
            <param name="e">The fifth value</param>
            <param name="f">The sixth value</param>
            <typeparam name="A">The first value type</typeparam>
            <typeparam name="B">The second value type</typeparam>
            <typeparam name="C">The third value type</typeparam>
            <typeparam name="D">The fourth value type</typeparam>
            <typeparam name="E">The fifth value type</typeparam>
            <typeparam name="F">The sixth value type</typeparam>
        </member>
        <member name="M:Z0.Render.format``7(``0,``1,``2,``3,``4,``5,``6)">
            <summary>
            Renders a septet of <see cref='T:Z0.ITextual'/> values as <see cref='F:Z0.RP.Pipe'/> delimited text
            </summary>
            <param name="a">The first value</param>
            <param name="b">The second value</param>
            <param name="c">The third value</param>
            <param name="d">The fourth value</param>
            <param name="e">The fifth value</param>
            <param name="f">The sixth value</param>
            <typeparam name="A">The first value type</typeparam>
            <typeparam name="B">The second value type</typeparam>
            <typeparam name="C">The third value type</typeparam>
            <typeparam name="D">The fourth value type</typeparam>
            <typeparam name="E">The fifth value type</typeparam>
            <typeparam name="F">The sixth value type</typeparam>
            <typeparam name="G">The seventh value type</typeparam>
        </member>
        <member name="M:Z0.Render.format``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Formats each <see cref='T:Z0.ITextual'/> in the source
            </summary>
            <param name="items">The source stream</param>
            <typeparam name="F">The element type</typeparam>
        </member>
        <member name="M:Z0.Render.hex``1(``0,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Renders a primal numeric value as hex-formatted text
            </summary>
            <param name="src">The source value</param>
            <param name="zpad">Specifies whether the output should be 0-padded to the data type width</param>
            <param name="specifier">Specifies whether the output should be prefixed/postfixed with a hex specifier</param>
            <param name="uppercase">Specifies whether the alphabetic hex digits should be uppercased</param>
            <param name="prespec">Specifies whether the hex specifier, if emitted, should be the canonical prefix or postfix specifier</param>
            <typeparam name="T">The primal numeric type</typeparam>
        </member>
        <member name="M:Z0.Render.hex``1(System.ReadOnlySpan{``0},Z0.HexFormatOptions@,System.Text.StringBuilder)">
            <summary>
            Renders a sequence of primal numeric T-cells as a sequence of hex-formatted values
            </summary>
            <param name="src">The data source</param>
            <param name="config">The format configuration</param>
            <param name="dst">The rendered data receiver</param>
            <typeparam name="T">The primal numeric type</typeparam>
        </member>
        <member name="M:Z0.Render.hexarray``1(System.ReadOnlySpan{``0})">
            <summary>
            Formats a sequence of primal numeric calls as data-formatted hex
            </summary>
            <param name="src">The source data</param>
            <typeparam name="T">The numeric type</typeparam>
        </member>
        <member name="M:Z0.Render.hexdata``1(System.ReadOnlySpan{``0})">
            <summary>
            Formats a sequence of primal numeric calls as data-formatted hex
            </summary>
            <param name="src">The source data</param>
            <typeparam name="T">The numeric type</typeparam>
        </member>
        <member name="M:Z0.Render.slot(Z0.N0)">
            <summary>
            Retrieves the <see cref='F:Z0.RP.Slot0' /> literal
            </summary>
            <param name="n">The slot selector</param>
        </member>
        <member name="M:Z0.Render.slot(Z0.N1)">
            <summary>
            Retrieves the <see cref='F:Z0.RP.Slot1' /> literal
            </summary>
            <param name="n">The slot selector</param>
        </member>
        <member name="M:Z0.Render.slot(Z0.N2)">
            <summary>
            Retrieves the <see cref='F:Z0.RP.Slot2' /> literal
            </summary>
            <param name="n">The slot selector</param>
        </member>
        <member name="M:Z0.Render.slot(Z0.N3)">
            <summary>
            Retrieves the <see cref='F:Z0.RP.Slot3' /> literal
            </summary>
            <param name="n">The slot selector</param>
        </member>
        <member name="M:Z0.Render.slot(Z0.N4)">
            <summary>
            Retrieves the <see cref='F:Z0.RP.Slot4' /> literal
            </summary>
            <param name="n">The slot selector</param>
        </member>
        <member name="M:Z0.Render.textual``1(System.ReadOnlySpan{``0},System.String)">
            <summary>
            Formats a sequence of <see cref='T:Z0.ITextual'/> cells
            </summary>
            <param name="src">The data source</param>
            <param name="delimiter">The cell delimiter</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.Render.title``1(Z0.FormatFunctions.FormatTitle{``0})">
            <summary>
            Creates a title formatter from a rendering function render:T -> string
            </summary>
            <param name="render">A function that produces text from an element value</param>
            <typeparam name="T">The type of element to render</typeparam>
        </member>
        <member name="T:Z0.Utf8Point">
            <summary>
            Represents the least 8 bits of a unicode code point which, by definition of the encoding, is equivalent to the 7 ascii bits.
            </summary>
        </member>
        <member name="T:Z0.Utf8Data.utf8x0">
            <summary>
            Defines the first segment of an 8, 16, 24 or 32-bit utf8-encoded symbol
            </summary>
        </member>
        <member name="T:Z0.Utf8Data.utf8x1`2">
            <summary>
            Defines a utf8-encoded symbol where <typeparamref name='T'/> is an unmanaged type with interpreted width of <see cref='T:Z0.W8'/>, <see cref='T:Z0.W16'/>, <see cref='T:Z0.W24'/> or <see cref='T:Z0.W32'/>
            </summary>
        </member>
        <member name="P:Z0.Utf8Data.utf8x1`2.AtomWidth">
            <summary>
            The atom width
            </summary>
        </member>
        <member name="P:Z0.Utf8Data.utf8x1`2.CellSize">
            <summary>
            The size of the storage cell, in bytes
            </summary>
        </member>
        <member name="T:Z0.Utf8Data.utf8x2`2">
            <summary>
            Defines an ordered sequence of two utf8-encoded symbols where <typeparamref name='T'/> is an unmanaged type with interpreted width of <see cref='T:Z0.W8'/>, <see cref='T:Z0.W16'/>, <see cref='T:Z0.W24'/> or <see cref='T:Z0.W32'/>
            </summary>
        </member>
        <member name="P:Z0.Utf8Data.utf8x2`2.AtomWidth">
            <summary>
            The atom width
            </summary>
        </member>
        <member name="P:Z0.Utf8Data.utf8x2`2.CellSize">
            <summary>
            The size of the storage cell, in bytes
            </summary>
        </member>
        <member name="T:Z0.Utf8Data.utf8x4`2">
            <summary>
            Defines an ordered sequence of 4 utf8-encoded symbols where <typeparamref name='T'/> is an unmanaged type with interpreted width of <see cref='T:Z0.W8'/>, <see cref='T:Z0.W16'/>, <see cref='T:Z0.W24'/> or <see cref='T:Z0.W32'/>
            </summary>
        </member>
        <member name="P:Z0.Utf8Data.utf8x4`2.AtomWidth">
            <summary>
            The atom width
            </summary>
        </member>
        <member name="P:Z0.Utf8Data.utf8x4`2.CellSize">
            <summary>
            The size of the storage cell, in bytes
            </summary>
        </member>
        <member name="T:Z0.Utf8Data.utf8x8`2">
            <summary>
            Defines an ordered sequence of 8 utf8-encoded symbols where <typeparamref name='T'/> is an unmanaged type
            with interpreted width of <see cref='T:Z0.W8'/>, <see cref='T:Z0.W16'/>, <see cref='T:Z0.W24'/> or <see cref='T:Z0.W32'/>
            </summary>
        </member>
        <member name="P:Z0.Utf8Data.utf8x8`2.AtomWidth">
            <summary>
            The atom width
            </summary>
        </member>
        <member name="P:Z0.Utf8Data.utf8x8`2.CellSize">
            <summary>
            The size of the storage cell, in bytes
            </summary>
        </member>
        <member name="T:Z0.Utf8Data.utf8x16`2">
            <summary>
            Defines an ordered sequence of 16 utf8-encoded symbols where <typeparamref name='T'/> is an unmanaged type with interpreted width of <see cref='T:Z0.W8'/>, <see cref='T:Z0.W16'/>, <see cref='T:Z0.W24'/> or <see cref='T:Z0.W32'/>
            </summary>
        </member>
        <member name="P:Z0.Utf8Data.utf8x16`2.AtomWidth">
            <summary>
            The atom width
            </summary>
        </member>
        <member name="P:Z0.Utf8Data.utf8x16`2.CellSize">
            <summary>
            The size of the storage cell, in bytes
            </summary>
        </member>
        <member name="T:Z0.Utf8Data.utf8x32`2">
            <summary>
            Defines an ordered sequence of 32 utf8-encoded symbols where <typeparamref name='T'/> is an unmanaged type with interpreted width of <see cref='T:Z0.W8'/>, <see cref='T:Z0.W16'/>, <see cref='T:Z0.W24'/> or <see cref='T:Z0.W32'/>
            </summary>
        </member>
        <member name="P:Z0.Utf8Data.utf8x32`2.AtomWidth">
            <summary>
            The atom width
            </summary>
        </member>
        <member name="P:Z0.Utf8Data.utf8x32`2.CellSize">
            <summary>
            The size of the storage cell, in bytes
            </summary>
        </member>
        <member name="T:Z0.Utf8Data.utf8x64`2">
            <summary>
            Defines an ordered sequence of 64 encoded utf8 symbols where <typeparamref name='T'/> is an unmanaged type with interpreted width of <see cref='T:Z0.W8'/>, <see cref='T:Z0.W16'/>, <see cref='T:Z0.W24'/> or <see cref='T:Z0.W32'/>
            </summary>
        </member>
        <member name="P:Z0.Utf8Data.utf8x64`2.AtomWidth">
            <summary>
            The atom width
            </summary>
        </member>
        <member name="P:Z0.Utf8Data.utf8x64`2.CellSize">
            <summary>
            The size of the storage cell, in bytes
            </summary>
        </member>
        <member name="T:Z0.Utf8Data.utf8x128`2">
            <summary>
            Defines an ordered sequence of 128 utf8-encoded symbols where <typeparamref name='T'/> is an unmanaged type with interpreted width of <see cref='T:Z0.W8'/>, <see cref='T:Z0.W16'/>, <see cref='T:Z0.W24'/> or <see cref='T:Z0.W32'/>
            </summary>
        </member>
        <member name="P:Z0.Utf8Data.utf8x128`2.AtomWidth">
            <summary>
            The atom width
            </summary>
        </member>
        <member name="P:Z0.Utf8Data.utf8x128`2.CellSize">
            <summary>
            The size of the storage cell, in bytes
            </summary>
        </member>
        <member name="T:Z0.Utf8Data.utf8x256`2">
            <summary>
            Defines an ordered sequence of 128 utf8-encoded symbols where <typeparamref name='T'/> is an unmanaged type with interpreted width of <see cref='T:Z0.W8'/>, <see cref='T:Z0.W16'/>, <see cref='T:Z0.W24'/> or <see cref='T:Z0.W32'/>
            </summary>
        </member>
        <member name="P:Z0.Utf8Data.utf8x256`2.AtomWidth">
            <summary>
            The atom width
            </summary>
        </member>
        <member name="P:Z0.Utf8Data.utf8x256`2.CellSize">
            <summary>
            The size of the storage cell, in bytes
            </summary>
        </member>
        <member name="M:Z0.ITextEncoder`1.GetBytes(System.ReadOnlySpan{System.Char},System.Span{System.Byte})">
            <summary>
            Encodes the source into the target, returning the number of bytes injected
            </summary>
            <param name="src">The data source</param>
            <param name="dst">The data target</param>
        </member>
        <member name="M:Z0.text.blank(System.String)">
            <summary>
            Tests whether the source string is either empty, null or consists only of whitespace
            </summary>
            <param name="src">The string to evaluate</param>
        </member>
        <member name="M:Z0.text.concat(System.Object[])">
            <summary>
            Joins the string representation of a sequence of items with no interspersed separator
            </summary>
            <param name="src">The values to be joined</param>
        </member>
        <member name="M:Z0.text.concat(System.ReadOnlySpan{System.String},System.ReadOnlySpan{System.Byte},System.Char)">
            <summary>
            Concatenates a sequence of strings, padding each to a specified width and interspersed with a specified delimiter
            </summary>
            <param name="src">The text to join</param>
            <param name="widths">The corresponding widths</param>
            <param name="delimiter">The delimiter to use</param>
        </member>
        <member name="M:Z0.text.content(System.String,System.String,System.String)">
            <summary>
            Extracts text that is enclosed between left and right boundaries, i.e. {left}{content}{right} => {content}
            </summary>
            <param name="src">The source text</param>
            <param name="left">The left boundary</param>
            <param name="right">The right boundary</param>
        </member>
        <member name="M:Z0.text.csv(System.Object,System.Object,System.Object[])">
            <summary>
            Renders a content array as a comma-separated list of values
            </summary>
            <param name="content">The data to delimit and format</param>
        </member>
        <member name="M:Z0.text.denullify(System.String)">
            <summary>
            If the test string is null, returns the empty string; otherwise, returns the test string
            </summary>
            <param name="src">The subject string</param>
            <param name="replace">The replacement value if blank</param>
        </member>
        <member name="M:Z0.text.empty(System.String)">
            <summary>
            Tests whether the source string is either null or of zero length
            </summary>
            <param name="src">The string to test</param>
        </member>
        <member name="M:Z0.text.enclose(System.Object,System.String,System.String)">
            <summary>
            Encloses text within (possibly distinct) left and right boundaries
            </summary>
            <param name="content">The text to be bounded</param>
            <param name="left">The text on the left</param>
            <param name="right">The text on the right</param>
        </member>
        <member name="M:Z0.text.enclose(System.Object,System.String)">
            <summary>
            Encloses text within a bounding string
            </summary>
            <param name="content">The text to enclose</param>
            <param name="sep">The left and right boundary</param>
        </member>
        <member name="M:Z0.text.enclose(System.Char,System.String)">
            <summary>
            Encloses a character within uniform left/right bounding string
            </summary>
            <param name="content">The character to be surrounded by the left and right delimiters</param>
            <param name="sep">The boundary delimiter</param>
        </member>
        <member name="M:Z0.text.enclose(System.Char,System.String,System.String)">
            <summary>
            Encloses a character within (possibly distinct) left and right boundaries
            </summary>
            <param name="content">The character to be bounded</param>
            <param name="left">The text on the left</param>
            <param name="right">The text on the right</param>
        </member>
        <member name="M:Z0.text.enclose(System.Object,System.Char,System.Char)">
            <summary>
            Encloses text within (possibly distinct) left and right boundaries
            </summary>
            <param name="content">The text to be surrounded by the left and right delimiters</param>
            <param name="left">The left delimiter</param>
            <param name="right">The right delimiter</param>
        </member>
        <member name="M:Z0.text.equals(System.String,System.String,System.StringComparison)">
            <summary>
            Performs a string comparison according to a specified comparison type
            </summary>
            <param name="a">The first string</param>
            <param name="b">The second string</param>
            <param name="type">The comparison type</param>
        </member>
        <member name="M:Z0.text.equals(System.String,System.String)">
            <summary>
            Performs a case-insensitive comparison on two source strings
            </summary>
            <param name="a">The first string</param>
            <param name="b">The second string</param>
        </member>
        <member name="M:Z0.text.fenced(System.String,System.Char,System.Char)">
            <summary>
            Determines whether the source text is of the form {left:char}{content:string}{right:char}, ignoring leading/trailing whitespace
            </summary>
            <param name="src">The text to analyze</param>
            <param name="left">The left boundary</param>
            <param name="right">The right boundary</param>
        </member>
        <member name="M:Z0.text.format(System.String,System.Object[])">
            <summary>
            Formats a pattern using an arbitrary kind/number of arguments
            </summary>
            <param name="pattern">The source pattern</param>
            <param name="args">The pattern arguments</param>
        </member>
        <member name="M:Z0.text.format(System.Object)">
            <summary>
            Formats anything
            </summary>
            <param name="rest">The formattables to be rendered and concatenated</param>
        </member>
        <member name="M:Z0.text.format``1(System.String,``0)">
            <summary>
            Formats a pattern using a parametric argument
            </summary>
            <param name="pattern">The format pattern</param>
            <param name="arg0">The pattern argument</param>
            <typeparam name="T">The argument type</typeparam>
        </member>
        <member name="M:Z0.text.format``2(System.String,``0,``1)">
            <summary>
            Formats a pattern using 2 parametric arguments
            </summary>
            <param name="pattern">The source pattern</param>
            <param name="arg0">The first pattern argument</param>
            <param name="arg1">The second pattern argument</param>
            <typeparam name="A">The first argument type</typeparam>
            <typeparam name="B">The second argument type</typeparam>
        </member>
        <member name="M:Z0.text.format``3(System.String,``0,``1,``2)">
            <summary>
            Formats a pattern using 3 parametric arguments
            </summary>
            <param name="pattern">The source pattern</param>
            <param name="arg0">The first pattern argument</param>
            <param name="arg1">The second pattern argument</param>
            <param name="arg2">The third pattern argument</param>
            <typeparam name="A">The first argument type</typeparam>
            <typeparam name="B">The second argument type</typeparam>
            <typeparam name="C">The third argument type</typeparam>
        </member>
        <member name="M:Z0.text.format``4(System.String,``0,``1,``2,``3)">
            <summary>
            Formats a pattern using 4 parametric arguments
            </summary>
            <param name="pattern">The source pattern</param>
            <param name="arg0">The first pattern argument</param>
            <param name="arg1">The second pattern argument</param>
            <param name="arg2">The third pattern argument</param>
            <typeparam name="A">The first argument type</typeparam>
            <typeparam name="B">The second argument type</typeparam>
            <typeparam name="C">The third argument type</typeparam>
        </member>
        <member name="M:Z0.text.format``5(System.String,``0,``1,``2,``3,``4)">
            <summary>
            Formats a pattern using 5 parametric arguments
            </summary>
            <param name="pattern">The source pattern</param>
            <param name="arg0">The first pattern argument</param>
            <param name="arg1">The second pattern argument</param>
            <param name="arg2">The third pattern argument</param>
            <typeparam name="A">The first argument type</typeparam>
            <typeparam name="B">The second argument type</typeparam>
            <typeparam name="C">The third argument type</typeparam>
        </member>
        <member name="M:Z0.text.format``1(``0)">
            <summary>
            Formats a <see cref='T:Z0.ITextual'/>
            </summary>
            <param name="src">The source element</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.text.syshash(System.ReadOnlySpan{System.Char})">
            <summary>
            Returns a system-provided hash code for a specified character span
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.text.hash(System.ReadOnlySpan{System.Char})">
            <summary>
            Returns a hash code predicated on the address of the leading character
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.text.ifempty(System.String,System.String)">
            <summary>
            Returns the replacement text if the source text is blank := {null | empty}
            </summary>
            <param name="src">The source text</param>
            <param name="replace">The replacement value if blank</param>
        </member>
        <member name="M:Z0.text.indices(System.String,System.Char,System.Char)">
            <summary>
            Returns the indices of the first occurrences of the first and second characters in the source, if any
            </summary>
            <param name="src">The source text</param>
            <param name="first">The first character to match</param>
            <param name="second">THe second character to match</param>
        </member>
        <member name="M:Z0.text.indices(System.String,System.String,System.String)">
            <summary>
            Returns the indices of the first occurrences of the first and second strings in the source, if any
            </summary>
            <param name="src">The source text</param>
            <param name="first">The first character to match</param>
            <param name="second">THe second character to match</param>
        </member>
        <member name="M:Z0.text.intern(System.String)">
            <summary>
            Inserts a string into the intern pool if it is not already there and, in any case, returns the string's address
            </summary>
            <param name="src">The text to intern</param>
        </member>
        <member name="M:Z0.text.intersperse(System.String,System.Char)">
            <summary>
            Creates a new string by weaving a specified character between each character in the source
            </summary>
            <param name="src">The source string</param>
            <param name="c">The character to intersperse</param>
        </member>
        <member name="M:Z0.text.intersperse(System.String,System.String)">
            <summary>
            Creates a new string by weaving a substring between each character in the source
            </summary>
            <param name="src">The source string</param>
            <param name="sep">The value to intersperse</param>
        </member>
        <member name="M:Z0.text.intersperse(System.ReadOnlySpan{System.String},System.Char)">
            <summary>
            Intersperses the source strings with a delimiter followed by a space, i.e.,
            result := "{s1}{delimiter} {s2}{delimiter} ... {sn}{delimiter}"
            </summary>
            <param name="fields">The fields to delimit</param>
            <param name="delimiter">The delimiter to use</param>
        </member>
        <member name="M:Z0.text.join``1(System.String,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Functional equivalalent of <see cref="M:System.String.Join(System.String,System.Object[])"/>
            </summary>
            <param name="values">The values to be rendered as text</param>
            <param name="sep">The item delimiter</param>
        </member>
        <member name="M:Z0.text.join``1(System.Char,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Functional equivalalent of <see cref="M:System.String.Join(System.Char,System.Object[])"/>
            </summary>
            <param name="values">The values to be rendered as text</param>
            <param name="sep">The item delimiter</param>
        </member>
        <member name="M:Z0.text.left(System.String,System.Int32)">
            <summary>
            Returns the substring [0,chars-1]
            </summary>
        </member>
        <member name="M:Z0.text.lines(System.String[])">
            <summary>
            Appends each source items to a target stream, appending an EOL after each
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.text.list``1(System.ReadOnlySpan{``0},System.Char,System.Int32)">
            <summary>
            Formats a sequence of formattable things as delimited list
            </summary>
            <param name="src">The source span</param>
            <param name="sep">The delimiter, if specified; otherwise, a system default is chosen</param>
            <param name="offset">The index of the source element at which formatting will begin</param>
            <typeparam name="T">A formattable type</typeparam>
        </member>
        <member name="M:Z0.text.list``1(System.Collections.Generic.IEnumerable{``0},System.Nullable{System.Char},System.Int32)">
            <summary>
            Formats a sequence of formattable things as delimited list
            </summary>
            <param name="src">The source span</param>
            <param name="delimiter">The delimiter, if specified; otherwise, a system default is chosen</param>
            <param name="offset">The index of the source element at which formatting will begin</param>
            <typeparam name="T">A formattable type</typeparam>
        </member>
        <member name="M:Z0.text.nonempty(System.String)">
            <summary>
            Tests whether the source string is nonempty
            </summary>
            <param name="src">The string to evaluate</param>
        </member>
        <member name="M:Z0.text.parser``1(System.Func{Z0.TextDoc,Z0.ParseResult{``0}})">
            <summary>
            Creates a text document parser from a parse function
            </summary>
            <param name="f">The parse function</param>
            <typeparam name="T">The parsed type</typeparam>
        </member>
        <member name="M:Z0.text.bracketed(System.String)">
            <summary>
            Determines whether the source text is of the form "[{content}]"
            </summary>
            <param name="src">The source text</param>
        </member>
        <member name="M:Z0.text.squote(System.Object)">
            <summary>
            Encloses text between single quote (') characters
            </summary>
            <param name="src">The text to enclose</param>
        </member>
        <member name="M:Z0.text.assign(System.Object,System.Object)">
            <summary>
            Creates a string of the form "lhs := rhs"
            </summary>
            <param name="lhs">The left</param>
            <param name="rhs">The right</param>
        </member>
        <member name="M:Z0.text.embrace(System.String)">
            <summary>
            Encloses text content between left and right braces
            </summary>
            <param name="content">The content to be embraced</param>
        </member>
        <member name="M:Z0.text.enquote(System.String)">
            <summary>
            Encloses text in quotation marks if nonempty; otherwise returns empty
            </summary>
            <param name="src">The text to be quoted</param>
        </member>
        <member name="M:Z0.text.parenthetical(System.Object[])">
            <summary>
            Encloses content between '(' and ')' characters
            </summary>
            <param name="content">The items to be enclosed</param>
        </member>
        <member name="M:Z0.text.bracket(System.Object)">
            <summary>
            Encloses text between '[' and ']' characters
            </summary>
            <param name="content">The content to enclose</param>
        </member>
        <member name="M:Z0.text.rspace(System.Object)">
            <summary>
            Appends a space to the source content
            </summary>
            <param name="content">The source content</param>
        </member>
        <member name="M:Z0.text.label(System.Object,System.Object)">
            <summary>
            Creates a string of the form "name: content"
            </summary>
            <param name="name">The label name</param>
            <param name="content">The labeled content</param>
        </member>
        <member name="M:Z0.text.remove(System.String,System.String)">
            <summary>
            Removes an identified substring wherever it occurs in the source
            </summary>
            <param name="src">The source text</param>
            <param name="match">The string to remove</param>
        </member>
        <member name="M:Z0.text.replicate(System.Char,System.Int32)">
            <summary>
            Creates a stream of replicated characters 
            </summary>
            <param name="src">The character to replicate</param>
            <param name="count">The replication count</param>
        </member>
        <member name="M:Z0.text.replicate(System.String,System.Int32)">
            <summary>
            Repeats a string a specified number of times
            </summary>
            <param name="src">The text content to replicate</param>
            <param name="count">The number of copies to produce</param>
        </member>
        <member name="M:Z0.text.segment(System.String,System.Int32,System.Int32)">
            <summary>
            Extracts an index-identified substring
            </summary>
            <param name="src">The source text</param>
            <param name="i0">The index of the first character in the substring</param>
            <param name="i1">The index of the last character in the substring</param>
        </member>
        <member name="M:Z0.text.segment(System.String,System.UInt32,System.UInt32)">
            <summary>
            Extracts an index-identified substring
            </summary>
            <param name="src">The source text</param>
            <param name="i0">The index of the first character in the substring</param>
            <param name="i1">The index of the last character in the substring</param>
        </member>
        <member name="M:Z0.text.slice(System.String,System.Int32)">
            <summary>
            Extracts a substring
            </summary>
            <param name="src">The source text</param>
            <param name="offset">The index of the first character</param>
        </member>
        <member name="M:Z0.text.slice(System.String,System.Int32,System.Int32)">
            <summary>
            Extracts a substring
            </summary>
            <param name="src">The source text</param>
            <param name="offset">The index of the first character</param>
            <param name="length">The substring length</param>
        </member>
        <member name="M:Z0.text.slice(System.String,System.UInt32)">
            <summary>
            Extracts a substring beginning at a specified offset
            </summary>
            <param name="src">The source text</param>
            <param name="offset">The index of the first character</param>
            <param name="length">The substring length</param>
        </member>
        <member name="M:Z0.text.slice(System.String,System.UInt32,System.UInt32)">
            <summary>
            Extracts a substring of specified length beginning at a specified offset
            </summary>
            <param name="src">The source text</param>
            <param name="offset">The index of the first character</param>
            <param name="length">The substring length</param>
        </member>
        <member name="M:Z0.text.spaced(System.Object)">
            <summary>
            Formats the content with a space on either side
            </summary>
            <param name="content">The source content</param>
        </member>
        <member name="M:Z0.text.spaced(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Separates each item with a space
            </summary>
        </member>
        <member name="M:Z0.text.split(System.String,System.Char)">
            <summary>
            Splits the string, removing empty entries
            </summary>
            <param name="src">The source text</param>
            <param name="sep">The delimiter</param>
        </member>
        <member name="M:Z0.text.split(System.String,System.String)">
            <summary>
            Splits the string, removing empty entries
            </summary>
            <param name="src">The source text</param>
            <param name="sep">The delimiter</param>
        </member>
        <member name="M:Z0.text.stream(System.String,System.Text.Encoding)">
            <summary>
            Allocates a stream over a string
            </summary>
            <param name="src">The source text</param>
            <param name="encoding">The text encoding</param>
        </member>
        <member name="M:Z0.text.unbracket(System.String)">
            <summary>
            If bracketed, extracts the enclosed content; otherwise, returns the empty string
            </summary>
            <param name="src">The source text</param>
        </member>
        <member name="M:Z0.text.unfence(System.String,System.Char,System.Char)">
            <summary>
            If fenced with specified left and right characters, extracts the enclosed content; otherwise, returns the content unmolested
            </summary>
            <param name="src">The putative fenced content</param>
        </member>
        <member name="M:Z0.text.build">
            <summary>
            Creates a new stringbuilder
            </summary>
        </member>
        <member name="T:Z0.ITimeInterval">
            <summary>
            Represents the content of a contiguous interval between comparable lower and upper bounds of the same type
            </summary>
        </member>
        <member name="P:Z0.ITimeInterval`1.Min">
            <summary>
            The inclusive lower bound
            </summary>
        </member>
        <member name="P:Z0.ITimeInterval`1.Max">
            <summary>
            The inclusive upper bound
            </summary>
        </member>
        <member name="T:Z0.DateRange">
            <summary>
            Represents a contiguous finite interval of time with calendar day resolution
            </summary>
        </member>
        <member name="F:Z0.DateRange.Min">
            <summary>
            The inclusive lower bound
            </summary>
        </member>
        <member name="F:Z0.DateRange.Max">
            <summary>
            The inclusive upper bound
            </summary>
        </member>
        <member name="M:Z0.DateRange.#ctor(System.Date,System.Date)">
            <summary>
            Initializes a new instance of the <see cref="T:Z0.DateRange"/> type
            </summary>
            <param name="min">The inclusive lower bound of the period</param>
            <param name="max">The inclusive upper bound of the period</param>
        </member>
        <member name="M:Z0.DateRange.op_Implicit(Z0.DateRange)~Z0.TimeInterval{System.DateTime}">
            <summary>
            Converts a <see cref="T:Z0.DateRange"/> value to a <see cref="T:Z0.TimeInterval`1"/> value
            </summary>
            <param name="x">The source range</param>
        </member>
        <member name="M:Z0.DateRange.FY(System.Int32)">
            <summary>
            Produces a <see cref="T:Z0.DateRange"/> that [begins | ends] on the [first | last] day of a given year
            </summary>
            <param name="Year">The year on which the range will be based</param>
        </member>
        <member name="M:Z0.DateRange.Q1(System.Int32)">
            <summary>
            Produces a <see cref="T:Z0.DateRange"/> that begins on the first day of the year
            and ends on the last day of the sixth month of that year
            </summary>
            <param name="Year">The year on which the range will be based</param>
        </member>
        <member name="M:Z0.DateRange.Q2(System.Int32)">
            <summary>
            Produces a <see cref="T:Z0.DateRange"/> that begins on the first day of the fourth month
            and ends on the last day of the sixth month of a specified year
            </summary>
            <param name="Year">The year on which the range will be based</param>
        </member>
        <member name="M:Z0.DateRange.Q3(System.Int32)">
            <summary>
            Produces a <see cref="T:Z0.DateRange"/> that begins on the first day of the seventh month
            and ends on the last day of the ninth month of a specified year
            </summary>
            <param name="Year">The year on which the range will be based</param>
        </member>
        <member name="M:Z0.DateRange.Q4(System.Int32)">
            <summary>
            Produces a <see cref="T:Z0.DateRange"/> that begins on the first day of the tenth month
            and ends on the last day of the of a specified year
            </summary>
            <param name="Year">The year on which the range will be based</param>
        </member>
        <member name="M:Z0.DateRange.op_Implicit(System.ValueTuple{System.Date,System.Date})~Z0.DateRange">
            <summary>
            Produces a date range from a 2-tuple
            </summary>
            <param name="x">The source tuple</param>
        </member>
        <member name="M:Z0.DateRange.In(System.Date)">
            <summary>
            Determines whether the test value is within the range
            </summary>
            <param name="test">The date to test</param>
        </member>
        <member name="M:Z0.DateRange.Out(System.Date)">
            <summary>
            Determines whether the test value is outside the range
            </summary>
            <param name="test">The date to test</param>
        </member>
        <member name="M:Z0.DateRange.Months(System.Date,System.Date)">
            <summary>
            Produces a montnly <see cref="T:Z0.DateRange"/> sequence
            </summary>
            <param name="min">The inclusive minimum month</param>
            <param name="max">The inclusive maximum month</param>
        </member>
        <member name="M:Z0.DateRange.GetDates">
            <summary>
            The days that comprise the range
            </summary>
        </member>
        <member name="P:Z0.DateRange.TotalDays">
            <summary>
            The number of days in the range
            </summary>
        </member>
        <member name="P:Z0.DateRange.IsDegenerate">
            <summary>
            Specifies whether the left and right boundaries are equal
            </summary>
        </member>
        <member name="T:Z0.Duration">
            <summary>
            Captures a duration
            </summary>
        </member>
        <member name="F:Z0.Duration.Ticks">
            <summary>
            The number of elapsed timer ticks that determines the period length
            </summary>
        </member>
        <member name="P:Z0.Duration.Ns">
            <summary>
            The duration expressed in nanoseconds
            </summary>
        </member>
        <member name="P:Z0.Duration.TickCount">
            <summary>
            The duration expressed in timer ticks
            </summary>
        </member>
        <member name="P:Z0.Duration.Ms">
            <summary>
            The duration expressed in milliseconds
            </summary>
        </member>
        <member name="T:Z0.SystemCounter">
            <summary>
            A stopwatch-like type in the form of a struct rather than a class
            </summary>
        </member>
        <member name="P:Z0.SystemCounter.Elapsed">
            <summary>
            Measures the accumulated duration
            </summary>
        </member>
        <member name="M:Z0.SystemCounter.Reset">
            <summary>
            Clears the counter's state
            </summary>
        </member>
        <member name="P:Z0.SystemCounter.Count">
            <summary>
            Gets the total number of timer ticks
            </summary>
        </member>
        <member name="P:Z0.SystemCounter.Time">
            <summary>
            Gets the elapsed time implied by the tick count
            </summary>
        </member>
        <member name="T:Z0.TimeInterval`1">
            <summary>
            Defines inclusive lower and upper bounds for a comparable set of values
            </summary>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="F:Z0.TimeInterval`1.Min">
            <summary>
            The minimum value in the range
            </summary>
        </member>
        <member name="F:Z0.TimeInterval`1.Max">
            <summary>
            The maximum value in the range
            </summary>
        </member>
        <member name="M:Z0.TimeInterval`1.In(`0)">
            <summary>
            Tests whether a value is in the range
            </summary>
            <param name="candidate">The value to test</param>
        </member>
        <member name="T:Z0.TimeResolution">
            <summary>
            Classifies the precision with which time value should be interpreted
            </summary>
        </member>
        <member name="F:Z0.TimeResolution.Date">
            <summary>
            Specifies date-level accuracy
            </summary>
        </member>
        <member name="F:Z0.TimeResolution.Hour">
            <summary>
            Specifies hour-level accuracy
            </summary>
        </member>
        <member name="F:Z0.TimeResolution.Minute">
            <summary>
            Specifies minute-level accuracy
            </summary>
        </member>
        <member name="F:Z0.TimeResolution.Second">
            <summary>
            Specifies second-level accuracy
            </summary>
        </member>
        <member name="F:Z0.TimeResolution.Ms">
            <summary>
            Specifies millisecond-level accuracy
            </summary>
        </member>
        <member name="T:Z0.TimerTicks">
            <summary>
            Captures and explores the relationship between hardware ticks and measured time
            </summary>
        </member>
        <member name="M:Z0.TimerTicks.ms(System.Int64)">
            <summary>
            Computes the number of milliseconds accounted for by a specified number of ticks
            </summary>
            <param name="ticks">The tick count</param>
        </member>
        <member name="M:Z0.TimerTicks.ns(System.Int64)">
            <summary>
            Computes the number of nanoseconds accounted for by a specified number of ticks
            </summary>
            <param name="ticks">The tick count</param>
        </member>
        <member name="P:Z0.TimerTicks.NsPerTick">
            <summary>
            The number of nanoseconds that elapse during a timer tick
            </summary>
        </member>
        <member name="P:Z0.TimerTicks.TicksPerMs">
            <summary>
            The number of ticks per second
            </summary>
        </member>
        <member name="T:Z0.ConstPair">
            <summary>
            Defines const pair manipulation api
            </summary>
        </member>
        <member name="T:Z0.IPair`2">
            <summary>
            Characterizes an homogenous 2-tuple
            </summary>
            <typeparam name="K">The reifying type</typeparam>
            <typeparam name="T">The member type</typeparam>
        </member>
        <member name="P:Z0.IPair`2.Left">
            <summary>
            The left member
            </summary>
        </member>
        <member name="P:Z0.IPair`2.Right">
            <summary>
            The right member
            </summary>
        </member>
        <member name="T:Z0.IPaired`2">
            <summary>
            Characterizes a parametric join of arity 2
            </summary>
            <typeparam name="L">The left value type</typeparam>
            <typeparam name="R">The right value type</typeparam>
        </member>
        <member name="P:Z0.IPaired`2.Left">
            <summary>
            The left value
            </summary>
        </member>
        <member name="P:Z0.IPaired`2.Right">
            <summary>
            The right value
            </summary>
        </member>
        <member name="T:Z0.IQuad`2">
            <summary>
            Characterizes an homogenous 4-tuple
            </summary>
            <typeparam name="K">The reifying type</typeparam>
            <typeparam name="T">The member type</typeparam>
        </member>
        <member name="T:Z0.ITriple`2">
            <summary>
            Characterizes an homogenous 3-tuple
            </summary>
            <typeparam name="K">The reifying type</typeparam>
            <typeparam name="T">The member type</typeparam>
        </member>
        <member name="T:Z0.ITuple">
            <summary>
            Common non-parametric tuple contract
            </summary>
        </member>
        <member name="T:Z0.ITuple`1">
            <summary>
            Common parametric tuple contract
            </summary>
            <typeparam name="K">The reifying type</typeparam>
        </member>
        <member name="T:Z0.ITupled`3">
            <summary>
            Characterizes a potentially non-homogenous 2-tuple
            </summary>
            <typeparam name="K">The reifying type</typeparam>
            <typeparam name="T0">The first member type</typeparam>
            <typeparam name="T1">The second member type</typeparam>
        </member>
        <member name="P:Z0.ITupled`3.Left">
            <summary>
            The left member
            </summary>
        </member>
        <member name="P:Z0.ITupled`3.Right">
            <summary>
            The right member
            </summary>
        </member>
        <member name="T:Z0.ITupled`4">
            <summary>
            Characterizes a potentially non-homogenous 3-tuple
            </summary>
            <typeparam name="K">The reifying type</typeparam>
            <typeparam name="T0">The first member type</typeparam>
            <typeparam name="T1">The second member type</typeparam>
            <typeparam name="T2">The third member type</typeparam>
        </member>
        <member name="T:Z0.ITupled`5">
            <summary>
            Characterizes a potentially non-homogenous 4-tuple
            </summary>
            <typeparam name="K">The reifying type</typeparam>
            <typeparam name="T0">The first member type</typeparam>
            <typeparam name="T1">The second member type</typeparam>
            <typeparam name="T2">The third member type</typeparam>
            <typeparam name="T3">The fourth member type</typeparam>
        </member>
        <member name="T:Z0.ConstPair`1">
            <summary>
            An homogenous immutable 2-tuple
            </summary>
        </member>
        <member name="F:Z0.ConstPair`1.Left">
            <summary>
            The first/left/lo member of the pair
            </summary>
        </member>
        <member name="F:Z0.ConstPair`1.Right">
            <summary>
            The second/right/hi member of the pair
            </summary>
        </member>
        <member name="M:Z0.ConstPair`1.As``1">
            <summary>
            Presents the source T-pair as a U-pair
            </summary>
            <typeparam name="U">The target type</typeparam>
        </member>
        <member name="T:Z0.ConstQuad`1">
            <summary>
            An homogenous immutable 4-tuple
            </summary>
        </member>
        <member name="F:Z0.ConstQuad`1.First">
            <summary>
            The first member
            </summary>
        </member>
        <member name="F:Z0.ConstQuad`1.Second">
            <summary>
            The second member
            </summary>
        </member>
        <member name="F:Z0.ConstQuad`1.Third">
            <summary>
            The third member
            </summary>
        </member>
        <member name="F:Z0.ConstQuad`1.Fourth">
            <summary>
            The fourth member
            </summary>
        </member>
        <member name="M:Z0.ConstQuad`1.As``1">
            <summary>
            Interprets the pair over an alternate domain
            </summary>
            <typeparam name="U">The alternate type</typeparam>
        </member>
        <member name="T:Z0.ConstTriple`1">
            <summary>
            An homogenous immutable 3-tuple
            </summary>
        </member>
        <member name="F:Z0.ConstTriple`1.First">
            <summary>
            The first member
            </summary>
        </member>
        <member name="F:Z0.ConstTriple`1.Second">
            <summary>
            The second member
            </summary>
        </member>
        <member name="F:Z0.ConstTriple`1.Third">
            <summary>
            The third member
            </summary>
        </member>
        <member name="M:Z0.ConstTriple`1.As``1">
            <summary>
            Interprets the pair over an alternate domain
            </summary>
            <typeparam name="U">The alternate type</typeparam>
        </member>
        <member name="T:Z0.Pair`1">
            <summary>
            An homogenous mutable 2-tuple
            </summary>
        </member>
        <member name="F:Z0.Pair`1.Left">
            <summary>
            The first member
            </summary>
        </member>
        <member name="F:Z0.Pair`1.Right">
            <summary>
            The second member
            </summary>
        </member>
        <member name="M:Z0.Pair`1.As``1">
            <summary>
            Interprets the pair over an alternate domain
            </summary>
            <typeparam name="U">The alternate type</typeparam>
        </member>
        <member name="T:Z0.Paired`2">
            <summary>
            A non-homogenous mutable 2-tuple
            </summary>
        </member>
        <member name="F:Z0.Paired`2.Left">
            <summary>
            The first member
            </summary>
        </member>
        <member name="F:Z0.Paired`2.Right">
            <summary>
            The second member
            </summary>
        </member>
        <member name="M:Z0.Paired`2.As``2">
            <summary>
            Interprets the pair over alternate domains
            </summary>
            <typeparam name="U">The alternate type</typeparam>
        </member>
        <member name="T:Z0.Pairings`2">
            <summary>
            Captures a heterogenous pair sequence
            </summary>
            <typeparam name="T">The sequence element type</typeparam>
        </member>
        <member name="F:Z0.Pairings`2.Data">
            <summary>
            The captured sequence
            </summary>
        </member>
        <member name="P:Z0.Pairings`2.Item(System.Int64)">
            <summary>
            Returns a mutable reference to an index-identified sequence element
            </summary>
            <param name="index">The zero-based sequence index</param>
        </member>
        <member name="P:Z0.Pairings`2.Item(System.UInt64)">
            <summary>
            Returns a mutable reference to an index-identified sequence element
            </summary>
            <param name="index">The zero-based sequence index</param>
        </member>
        <member name="P:Z0.Pairings`2.Count">
            <summary>
            Specifies the number of elements in the sequence
            </summary>
        </member>
        <member name="M:Z0.Pairings`2.Enumerate">
            <summary>
            Lifts sequence content into the LINQ monad
            </summary>
        </member>
        <member name="T:Z0.Pairs`1">
            <summary>
            Captures a pair sequence
            </summary>
            <typeparam name="T">The sequence element type</typeparam>
        </member>
        <member name="F:Z0.Pairs`1.Data">
            <summary>
            The captured sequence
            </summary>
        </member>
        <member name="M:Z0.Pairs`1.Select(System.Int32)">
            <summary>
            Returns a mutable reference to an index-identified sequence element
            </summary>
            <param name="index">The zero-based sequence index</param>
        </member>
        <member name="P:Z0.Pairs`1.Item(System.Int32)">
            <summary>
            Returns a mutable reference to an index-identified sequence element
            </summary>
            <param name="index">The zero-based sequence index</param>
        </member>
        <member name="P:Z0.Pairs`1.PointCount">
            <summary>
            Specifies the number of elements in the sequence
            </summary>
        </member>
        <member name="M:Z0.Pairs`1.Enumerate">
            <summary>
            Lifts sequence content into the LINQ monad
            </summary>
        </member>
        <member name="T:Z0.Triple`1">
            <summary>
            An homogenous mutable 3-tuple
            </summary>
        </member>
        <member name="F:Z0.Triple`1.First">
            <summary>
            The first member
            </summary>
        </member>
        <member name="F:Z0.Triple`1.Second">
            <summary>
            The second member
            </summary>
        </member>
        <member name="F:Z0.Triple`1.Third">
            <summary>
            The third member
            </summary>
        </member>
        <member name="M:Z0.Triple`1.As``1">
            <summary>
            Interprets the pair over an alternate domain
            </summary>
            <typeparam name="U">The alternate type</typeparam>
        </member>
        <member name="T:Z0.Tripled`3">
            <summary>
            Defines a non-homogenous mutable 3-tuple
            </summary>
            <typeparam name="T0">The type of the first member</typeparam>
            <typeparam name="T1">The type of the second member</typeparam>
            <typeparam name="T2">The type of the third member</typeparam>
        </member>
        <member name="F:Z0.Tripled`3.First">
            <summary>
            The first member
            </summary>
        </member>
        <member name="F:Z0.Tripled`3.Second">
            <summary>
            The second member
            </summary>
        </member>
        <member name="F:Z0.Tripled`3.Third">
            <summary>
            The third member
            </summary>
        </member>
        <member name="M:Z0.Tripled`3.As``3">
            <summary>
            Interprets the pair over alternate domains
            </summary>
            <typeparam name="U">The alternate type</typeparam>
        </member>
        <member name="M:Z0.Tuples.const``1(``0,``0)">
            <summary>
            Defines an homogenous read-only pair
            </summary>
            <param name="a">The left member</param>
            <param name="b">The right member</param>
            <typeparam name="T">The member type</typeparam>
        </member>
        <member name="M:Z0.Tuples.generic``1(Z0.ConstPair{System.SByte}@)">
            <summary>
            Presents a scalar pair as a parametric pair
            </summary>
            <param name="src">The source pair</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.Tuples.generic``1(Z0.ConstPair{System.Byte}@)">
            <summary>
            Presents a scalar pair as a parametric pair
            </summary>
            <param name="src">The source pair</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.Tuples.generic``1(Z0.ConstPair{System.Int16}@)">
            <summary>
            Presents a scalar pair as a parametric pair
            </summary>
            <param name="src">The source pair</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.Tuples.generic``1(Z0.ConstPair{System.UInt16}@)">
            <summary>
            Presents a scalar pair as a parametric pair
            </summary>
            <param name="src">The source pair</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.Tuples.generic``1(Z0.ConstPair{System.Int32}@)">
            <summary>
            Presents a scalar pair as a parametric pair
            </summary>
            <param name="src">The source pair</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.Tuples.generic``1(Z0.ConstPair{System.UInt32}@)">
            <summary>
            Presents a scalar pair as a parametric pair
            </summary>
            <param name="src">The source pair</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.Tuples.generic``1(Z0.ConstPair{System.Int64}@)">
            <summary>
            Presents a scalar pair as a parametric pair
            </summary>
            <param name="src">The source pair</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.Tuples.generic``1(Z0.ConstPair{System.UInt64}@)">
            <summary>
            Presents a scalar pair as a parametric pair
            </summary>
            <param name="src">The source pair</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.Tuples.generic``1(Z0.ConstPair{System.Single}@)">
            <summary>
            Presents a scalar pair as a parametric pair
            </summary>
            <param name="src">The source pair</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.Tuples.generic``1(Z0.ConstPair{System.Double}@)">
            <summary>
            Presents a scalar pair as a parametric pair
            </summary>
            <param name="src">The source pair</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.Tuples.pair``1(``0,``0)">
            <summary>
            Creates an homogenous pair
            </summary>
            <param name="left">The left member</param>
            <param name="right">The right member</param>
            <typeparam name="T">The member type</typeparam>
        </member>
        <member name="M:Z0.Tuples.paired``2(``0,``1)">
            <summary>
            Creates a non-homogenous pair
            </summary>
            <param name="left">The left member</param>
            <param name="right">The right member</param>
            <typeparam name="L">The first member type</typeparam>
            <typeparam name="R">The second member type</typeparam>
        </member>
        <member name="M:Z0.Tuples.pairs``1(System.UInt32)">
            <summary>
            Allocates an homogenous pair store
            </summary>
            <param name="count">The store capacity</param>
            <typeparam name="T">The member type</typeparam>
        </member>
        <member name="M:Z0.Tuples.quad``1(``0,``0,``0,``0)">
            <summary>
            Creates an immutable homogenous 4-tuple
            </summary>
            <param name="a">The first member</param>
            <param name="b">The second member</param>
            <param name="c">The third member</param>
            <param name="d">The fourth member</param>
            <typeparam name="T">The member type</typeparam>
        </member>
        <member name="M:Z0.Tuples.triple``1(``0,``0,``0)">
            <summary>
            Creates an homogenous triple
            </summary>
            <param name="a">The first member</param>
            <param name="b">The second member</param>
            <param name="c">The third member</param>
            <typeparam name="T">The member type</typeparam>
        </member>
        <member name="M:Z0.Tuples.triple``1(``0,``0,``0,System.Boolean)">
            <summary>
            Creates an immutable homogenous 2-tuple
            </summary>
            <param name="a">The first member</param>
            <param name="b">The second member</param>
            <typeparam name="T">The member type</typeparam>
        </member>
        <member name="M:Z0.Tuples.tripled``3(``0,``1,``2)">
            <summary>
            Creates a non-homogenous triple
            </summary>
            <param name="a">The first member</param>
            <param name="b">The second member</param>
            <param name="c">The third member</param>
            <typeparam name="T0">The first member type</typeparam>
            <typeparam name="T1">The second member type</typeparam>
            <typeparam name="T2">The third member type</typeparam>
        </member>
        <member name="M:Z0.Tuples.triples``1(System.Int32)">
            <summary>
            Allocates an homogenous triplestore
            </summary>
            <param name="count">The store capacity</param>
            <typeparam name="T">The member type</typeparam>
        </member>
        <member name="M:Z0.Dim.define``2(``0,``1)">
            <summary>
            Constructs an natural dimension of order 2
            </summary>
            <typeparam name="M">The type of the first axis</typeparam>
            <typeparam name="N">The type of the second axis</typeparam>
        </member>
        <member name="T:Z0.Dimensions">
            <summary>
            Describes a dimension of any order
            </summary>
        </member>
        <member name="F:Z0.Dimensions.Order">
            <summary>
            The number of dimension axes
            </summary>
        </member>
        <member name="F:Z0.Dimensions.Axes">
            <summary>
            The axis index
            </summary>
        </member>
        <member name="F:Z0.Dimensions.Volume">
            <summary>
            Specifies the maximum number of cells that may inhabit the associated space
            </summary>
        </member>
        <member name="T:Z0.DimK">
            <summary>
            Defines a dimension with an arbitrary number of axes
            </summary>
        </member>
        <member name="T:Z0.Dim`2">
            <summary>
            Defines a rectangular dimension
            </summary>
            <typeparam name="M">The type of the first dimension</typeparam>
            <typeparam name="N">The type of the second dimension</typeparam>
        </member>
        <member name="P:Z0.Dim`2.I">
            <summary>
            Specifies the first component of the dimension
            </summary>
        </member>
        <member name="P:Z0.Dim`2.J">
            <summary>
            Specifies the second component of the dimension
            </summary>
        </member>
        <member name="P:Z0.Dim`2.Volume">
            <summary>
            The volume bound by the rectangle defined by the two axes
            </summary>
        </member>
        <member name="P:Z0.Dim`2.Item(System.Int32)">
            <summary>
            Returns the axis corresponding to its 0-based index
            </summary>
        </member>
        <member name="P:Z0.Dim`2.Order">
            <summary>
            The axis count - 2
            </summary>
        </member>
        <member name="T:Z0.Dim`1">
            <summary>
            Defines a dimension axis which may represent the dimension of a vector of length N
            or the dimensions of a square matrix that contains N vectors of dimension N
            </summary>
            <typeparam name="N">The dimension type</typeparam>
        </member>
        <member name="P:Z0.Dim`1.I">
            <summary>
            The one-dimensional axis
            </summary>
        </member>
        <member name="T:Z0.IDim">
            <summary>
            Characterizes a dimension of arbitrary order
            </summary>
        </member>
        <member name="P:Z0.IDim.Order">
            <summary>
            Specifies the number of axes in the dimension
            </summary>
        </member>
        <member name="P:Z0.IDim.Volume">
            <summary>
            Specifies the maximum number of cells that may inhabit the associated space
            </summary>
        </member>
        <member name="P:Z0.IDim.Item(System.Int32)">
            <summary>
            Gets the dimension axis determined by its 0-based index, an integer in the interval [0,Order-1]
            </summary>
        </member>
        <member name="P:Z0.IDim`2.RowCount">
            <summary>
            Specifies the first component of the dimension
            </summary>
        </member>
        <member name="P:Z0.IDim`2.ColCount">
            <summary>
            Specifies the second component of the dimension
            </summary>
        </member>
        <member name="T:Z0.Mod">
            <summary>
            Defines mod/div operations
            </summary>
            <remarks>See https://arxiv.org/pdf/1902.01961.pdf</remarks>
        </member>
        <member name="F:Z0.Mod.n">
            <summary>
            Specifies the divisor for which the modulus was constructed
            </summary>
        </member>
        <member name="F:Z0.Mod.stateMax">
            <summary>
            The maximum state value
            </summary>
        </member>
        <member name="M:Z0.Mod.Define``1(``0)">
            <summary>
            Constructs a modulus operator with a persistent type-natural divisor
            </summary>
            <param name="n">The divisor</param>
        </member>
        <member name="M:Z0.Mod.Define(System.UInt32,System.UInt32)">
            <summary>
            Constructs a modulus operator with a persistent divisor
            </summary>
            <param name="n">The divisor</param>
        </member>
        <member name="M:Z0.Mod.op_Increment(Z0.Mod)">
            <summary>
            Increments the source operand in-place
            </summary>
            <param name="src">The source operand</param>
        </member>
        <member name="M:Z0.Mod.op_Decrement(Z0.Mod)">
            <summary>
            Decrements the source operand in-place
            </summary>
            <param name="src">The source operand</param>
        </member>
        <member name="M:Z0.Mod.mod(System.UInt32)">
            <summary>
            Computes a % n
            </summary>
            <param name="a">The dividend</param>
        </member>
        <member name="M:Z0.Mod.div(System.UInt32)">
            <summary>
            Computes the quotient a / n
            </summary>
            <param name="a">The dividend</param>
        </member>
        <member name="M:Z0.Mod.divrem(System.UInt32,System.UInt32@)">
            <summary>
            Computes the quotient and remainder
            </summary>
            <param name="a">The dividend</param>
            <param name="rem">The remainder</param>
        </member>
        <member name="M:Z0.Mod.divisible(System.UInt32)">
            <summary>
            Computes whether a % n == 0
            </summary>
            <param name="a">The dividend</param>
        </member>
        <member name="M:Z0.ModOps.mod(System.UInt64,System.UInt64,System.UInt32)">
            <summary>
            Computes a % N
            </summary>
            <param name="a">The dividend</param>
        </member>
        <member name="M:Z0.ModOps.div(System.UInt64,System.UInt64,System.UInt32)">
            <summary>
            Computes the quotient a / N
            </summary>
            <param name="a">The dividend</param>
        </member>
        <member name="M:Z0.ModOps.divisible(System.UInt64,System.UInt64,System.UInt32)">
            <summary>
            Computes whether a % n == 0
            </summary>
            <param name="a">The dividend</param>
        </member>
        <member name="M:Z0.ModOps.add(System.UInt64,System.UInt64,System.UInt32,System.UInt32)">
            <summary>
            Computes (a + b) mod n
            </summary>
        </member>
        <member name="M:Z0.ModOps.mul(System.UInt64,System.UInt64,System.UInt32,System.UInt32)">
            <summary>
            Computes (a * b) mod n
            </summary>
        </member>
        <member name="T:Z0.Mod`1">
            <summary>
            Represents div/mod operations for a divisor of type N; This type forms a commutative
            ring over the set of least residues {0,...,N-1}, i.e. the ring of integers modulo N,
            typically denoted Z/nZ. Moreover, Z/nZ is a field iff n is prime
            </summary>
        </member>
        <member name="P:Z0.Mod`1.M64">
            <summary>
            The fixed 64-bit modulus for the generic closure
            </summary>
        </member>
        <member name="P:Z0.Mod`1.M32">
            <summary>
            The fixed 32-bit modulus for the generic closure
            </summary>
        </member>
        <member name="P:Z0.Mod`1.MR">
            <summary>
            The fixed modulus reciprocal
            </summary>
        </member>
        <member name="M:Z0.Mod`1.Define(System.UInt32)">
            <summary>
            Constructs a modulus with a specified state
            </summary>
            <param name="state">The initial state</param>
        </member>
        <member name="M:Z0.Mod`1.op_Implicit(System.UInt32)~Z0.Mod{`0}">
            <summary>
            Implicitly constructs a typed modulus with an initial state, reducing as necessary
            </summary>
            <param name="state">The intial state</param>
            <typeparam name="N">The modulus type</typeparam>
        </member>
        <member name="M:Z0.Mod`1.op_Implicit(System.Int32)~Z0.Mod{`0}">
            <summary>
            Implicitly constructs a modulus with an initial state from a signed integer, converting/reducing as necessary
            </summary>
            <param name="state">The intial state</param>
            <typeparam name="N">The modulus type</typeparam>
        </member>
        <member name="M:Z0.Mod`1.op_Implicit(Z0.Mod{`0})~System.UInt32">
            <summary>
            Implicitly extracts the state value as an unsigned integer from the source
            </summary>
            <param name="src">The source modulus</param>
        </member>
        <member name="M:Z0.Mod`1.op_Implicit(Z0.Mod{`0})~System.Int32">
            <summary>
            Implicitly extracts the state value as a signed integer from the source
            </summary>
            <param name="src">The source modulus</param>
        </member>
        <member name="M:Z0.Mod`1.op_Increment(Z0.Mod{`0})">
            <summary>
            Increments the source operand in-place
            </summary>
            <param name="src">The source operand</param>
        </member>
        <member name="M:Z0.Mod`1.op_Decrement(Z0.Mod{`0})">
            <summary>
            Decrements the source operand in-place
            </summary>
            <param name="src">The source operand</param>
        </member>
        <member name="M:Z0.Mod`1.op_Subtraction(Z0.Mod{`0},Z0.Mod{`0})">
            <summary>
            Subtracts the second operand from the first
            </summary>
            <param name="lhs">The left operand</param>
            <param name="rhs">The right operand</param>
        </member>
        <member name="M:Z0.Mod`1.mod(System.UInt32)">
            <summary>
            Computes a % n
            </summary>
            <param name="a">The dividend</param>
        </member>
        <member name="M:Z0.Mod`1.div(System.UInt32)">
            <summary>
            Computes the quotient a / n
            </summary>
            <param name="a">The dividend</param>
        </member>
        <member name="M:Z0.Mod`1.divrem(System.UInt32,System.UInt32@)">
            <summary>
            Computes the quotient a / n and remainder a % n
            </summary>
            <param name="a">The dividend</param>
        </member>
        <member name="M:Z0.Mod`1.divisible(System.UInt32)">
            <summary>
            Computes whether a % n == 0
            </summary>
            <param name="a">The dividend</param>
        </member>
        <member name="M:Z0.Mod`1.add(System.UInt64,System.UInt64)">
            <summary>
            Computes the modular sum of the operands
            </summary>
            <param name="a">The lefdt operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.Mod`1.sub(System.UInt64,System.UInt64)">
            <summary>
            Computes the modular difference of the operands
            </summary>
            <param name="a">The lefdt operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.Mod`1.mul(System.UInt64,System.UInt64)">
            <summary>
            Computes the modular product of the operands
            </summary>
            <param name="a">The lefdt operand</param>
            <param name="b">The right operand</param>
            <remarks>Follows the approach of Arndt in Matters Computational, Chapter 39: Modular arithmetic and some number theory</remarks>
        </member>
        <member name="M:Z0.Mod`1.inc(System.UInt64)">
            <summary>
             Modular increment
            </summary>
            <param name="a">The source operand</param>
        </member>
        <member name="M:Z0.Mod`1.dec(System.UInt64)">
            <summary>
             Modular decrement
            </summary>
            <param name="a">The source operand</param>
        </member>
        <member name="P:Z0.Mod`1.State">
            <summary>
            Returns the current state
            </summary>
        </member>
        <member name="P:Z0.Mod`1.StateMax">
            <summary>
            The maximum state value
            </summary>
        </member>
        <member name="P:Z0.Mod`1._Mod">
            <summary>
            The equivalent untyped modulus with nullary state
            </summary>
        </member>
        <member name="M:Z0.NaturalNumericClosures.Define(System.Reflection.MethodInfo,System.Nullable{System.UInt64},System.UInt64,Z0.NumericKind)">
            <summary>
            Defines an untyped closure over a natural numeric method of sort NxT or MxNxT
            </summary>
            <param name="def">A generic method definition that requires either arguments M, and T 
            in that order or, alternately, M, N and T in that order</param>
            <param name="m">The M-natural kind, if present</param>
            <param name="n">The N-natural kind</param>
            <param name="t">The T-numeric kind</param>
        </member>
        <member name="M:Z0.NaturalNumericClosures.Define``1(System.Reflection.MethodInfo,System.Nullable{System.UInt64},System.UInt64)">
            <summary>
            Defines a T-parametric closure that includes either one or two natural parameter specifications
            </summary>
            <param name="def">A generic method definition that requires either arguments M, and T 
            in that order or, alternately, M, N and T in that order</param>
            <typeparam name="N">An intrinsic natural type</typeparam>
            <typeparam name="T">A numeric type</typeparam>
        </member>
        <member name="M:Z0.NaturalNumericClosures.Define``2(System.Reflection.MethodInfo)">
            <summary>
            Defines a closure pair NxT over a conforming generic method definition
            </summary>
            <param name="def">A generic method definition that requires arguments M, and T, in that order</param>
            <typeparam name="N">An intrinsic natural type</typeparam>
            <typeparam name="T">A numeric type</typeparam>
        </member>
        <member name="M:Z0.NaturalNumericClosures.Define``3(System.Reflection.MethodInfo)">
            <summary>
            Defines a closure triple MxNxT over a conforming generic method definition
            </summary>
            <param name="def">A generic method definition that requires arguments M, N, and T, in that order</param>
            <typeparam name="M">An intrinsic natural type</typeparam>
            <typeparam name="N">An intrinsic natural type</typeparam>
            <typeparam name="T">A numeric type</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Z0.INatDifference`3" -->
        <member name="T:Z0.INatEven`1">
            <summary>
            Requires k:K => k % 2 == 0
            </summary>
            <typeparam name="K">An even natural type</typeparam>
        </member>
        <member name="T:Z0.INatPow2`1">
            <summary>
            Characterizes a natural k such that e:E => k = 2^e
            </summary>
            <typeparam name="B">The base type</typeparam>
            <typeparam name="E">The exponent type</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Z0.INatProduct`3" -->
        <member name="T:Z0.INatSum`2">
            <summary>
            Requires k := k1 + k2
            </summary>
            <typeparam name="K1">The first operand type</typeparam>
            <typeparam name="K2">The second operand type</typeparam>
        </member>
        <member name="T:Z0.INaturalized">
            <summary>
            Characterizes a type that identifies as a natural number
            </summary>
        </member>
        <member name="T:Z0.INaturalized`1">
            <summary>
            Characterizes a type with which a number of parametric type is associated
            </summary>
            <typeparam name="N">The natural number type</typeparam>
        </member>
        <member name="T:Z0.IPositional">
            <summary>
            Characterizes an individual that can be uniquely associatd with an integer in the range 0..n-1 
            within the context of a container with a capacity of n items
            </summary>
        </member>
        <member name="P:Z0.IPositional.Position">
            <summary>
            The 0-based position of the item in an enclosing container
            </summary>
        </member>
        <member name="T:Z0.ITypeNat">
            <summary>
            Characterizes a type-level natural number, a *typenat*
            </summary>
        </member>
        <member name="P:Z0.ITypeNat.NatValue">
            <summary>
            The number's value
            </summary>
        </member>
        <member name="T:Z0.ITypeNat`1">
            <summary>
            Characterizes a type with which a natural number type is associated
            </summary>
            <typeparam name="T">The represented type</typeparam>
        </member>
        <member name="T:Z0.INatSeq">
            <summary>
            Characterizes a type-level sequence of typenats
            </summary>
        </member>
        <member name="T:Z0.INatSeq`1">
            <summary>
            Characterizes a reified natural sequence
            </summary>
            <typeparam name="S">The reification type</typeparam>
        </member>
        <member name="T:Z0.INatPrimitive`1">
            <summary>
            Characterizes an atom of the type natural grammar
            </summary>
            <typeparam name="N">The reifying type</typeparam>
        </member>
        <member name="T:Z0.INatNonZero">
            <summary>
            Requires that the natural representative is nonzero
            </summary>
        </member>
        <member name="T:Z0.INatNonZero`1">
            <summary>
            Requires k:K => k != 0
            </summary>
            <typeparam name="K">A nonzero natural type</typeparam>
        </member>
        <member name="T:Z0.INatRelation`2">
            <summary>
            Characterizes binary relationship between two type naturals
            </summary>
            <typeparam name="K1">The first nat type</typeparam>
            <typeparam name="K2">The second nat type</typeparam>
        </member>
        <member name="T:Z0.INatRelation`3">
            <summary>
            Characterizes ternary relationship among three type naturals
            </summary>
            <typeparam name="K1">The first nat type</typeparam>
            <typeparam name="K2">The second nat type</typeparam>
            <typeparam name="K3">The third nat type</typeparam>
        </member>
        <member name="T:Z0.INatDivisible`2">
            <summary>
            Requires k1 = n*k2 for some n>= 1
            </summary>
            <typeparam name="K1">The divisible type</typeparam>
            <typeparam name="K2">The divisor type</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Z0.INatBetween`3" -->
        <member name="T:Z0.INatGt`2">
            <summary>
            Requires k1 > k2
            </summary>
            <typeparam name="K1">The larger nat type</typeparam>
            <typeparam name="K2">The smaller nat type</typeparam>
        </member>
        <member name="T:Z0.INatGtEq`2">
            <summary>
            Requires k1 >= k2
            </summary>
            <typeparam name="K1">The larger nat type</typeparam>
            <typeparam name="K2">The smaller nat type</typeparam>
        </member>
        <member name="T:Z0.INatEq`2">
            <summary>
            Requires k1 == k2
            </summary>
            <typeparam name="K1">The first nat type</typeparam>
            <typeparam name="K2">The second nat type</typeparam>
        </member>
        <member name="T:Z0.INatNEq`2">
            <summary>
            Requires k1 != k2
            </summary>
            <typeparam name="K1">The first nat type</typeparam>
            <typeparam name="K2">The second nat type</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Z0.INatLt`2" -->
        <!-- Badly formed XML comment ignored for member "T:Z0.INatLtEq`2" -->
        <!-- Badly formed XML comment ignored for member "T:Z0.INatMod`3" -->
        <member name="T:Z0.INatOdd`1">
            <summary>
            Requires k:K => k % 2 != 0
            </summary>
            <typeparam name="K">An Odd natural type</typeparam>
        </member>
        <member name="T:Z0.INatPrime`1">
            <summary>
            Requires k prime
            </summary>
            <typeparam name="K">A prime nat type</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Z0.INatPow`2" -->
        <!-- Badly formed XML comment ignored for member "T:Z0.INatPow`3" -->
        <!-- Badly formed XML comment ignored for member "T:Z0.INatPrior`2" -->
        <member name="T:Z0.INatSeq`3">
            <summary>
            Characterizes a reified 2-term natural sequence
            </summary>
            <typeparam name="K">The reification type</typeparam>
            <typeparam name="K1">The first term</typeparam>
            <typeparam name="K2">The second term</typeparam>
        </member>
        <member name="T:Z0.INatSeq`4">
            <summary>
            Characterizes a reified 3-term natural sequence
            </summary>
            <typeparam name="K">The reification type</typeparam>
            <typeparam name="K1">The first term</typeparam>
            <typeparam name="K2">The second term</typeparam>
            <typeparam name="K2">The third term</typeparam>
        </member>
        <member name="M:Z0.NatClaim.sum``2(``0,``1,System.UInt64)">
            <summary>
            Attempts to prove that k1 + k2 = expected
            Signals success by returning evidence
            Signals failure by raising an error
            </summary>
            <param name="k1">The first operand value</param>
            <param name="k2">The second operand value</param>
            <typeparam name="K1">The first type</typeparam>
            <typeparam name="K2">The second type</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.NatClaim.between``3" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.NatClaim.between``3(``0,``1,``2)" -->
        <member name="M:Z0.NatClaim.eq``1(System.UInt64)">
            <summary>
            Retrieves the value of the natural number associated with a typenat
            and returns the value if it agrees with a supplied expected value; otherwise,
            raises an exception
            </summary>
            <param name="expected">The expected natural value</param>
            <typeparam name="K">The natural type</typeparam>
        </member>
        <member name="M:Z0.NatClaim.eq``1(``0,System.UInt64)">
            <summary>
            Retrieves the value of the natural number associated with a typenat
            and returns the value if it agrees with a supplied expected value; othwise,
            raises an exception
            </summary>
            <param name="k">The reification of K</param>
            <param name="expected">The expected natural value</param>
            <typeparam name="K">The natural type</typeparam>
        </member>
        <member name="M:Z0.NatClaim.eq``1(System.Int32)">
            <summary>
            Attempts to prove that k:K => k == expected
            Registers success by returning the expected value
            Registers failure by raising an error
            </summary>
            <param name="expected">The expected natural value</param>
            <typeparam name="K">The natural type</typeparam>
        </member>
        <member name="M:Z0.NatClaim.eq``1(``0,System.Int32)">
            <summary>
            Attempts to prove that k:K => k == expected
            Registers success by returning the expected value
            Registers failure by raising an error
            </summary>
            <param name="k">The reification of K</param>
            <param name="expected">The expected natural value</param>
            <typeparam name="K">The natural type</typeparam>
        </member>
        <member name="M:Z0.NatClaim.eq``1(System.UInt32,System.Boolean)">
            <summary>
            Prooves that a test value is equal to the value of a natural representative
            </summary>
            <param name="test">The value to test</param>
            <param name="raise">Specifies whether an error should be raised if the check fails</param>
            <typeparam name="K">The natural representative</typeparam>
        </member>
        <member name="M:Z0.NatClaim.eq``2(``0,``1)">
            <summary>
            Attemts to construct evidence that k1 == k2
            </summary>
            <typeparam name="K1">The first type</typeparam>
            <typeparam name="K2">The second type</typeparam>
        </member>
        <member name="M:Z0.NatClaim.neq``2(``0,``1)">
            <summary>
            Attemts to construct evidence that k1 != k2
            </summary>
            <typeparam name="K1">The first type</typeparam>
            <typeparam name="K2">The second type</typeparam>
        </member>
        <member name="M:Z0.NatClaim.gt``1(``0,System.UInt64)">
            <summary>
            Attempts to prove k > a
            Signals success by returning true
            Signals failure by raising an error
            </summary>
            <param name="a">The value to test</param>
            <typeparam name="K">The natural representative</typeparam>
        </member>
        <member name="M:Z0.NatClaim.gteq``1(``0,System.UInt64)">
            <summary>
            Attempts to prove k >= a
            Signals success by returning true
            Signals failure by raising an error
            </summary>
            <param name="t">The value to test</param>
            <typeparam name="K">The natural representative</typeparam>
        </member>
        <member name="M:Z0.NatClaim.gt``2(``0,``1)">
            <summary>
            Attempts to prove k1 > k2
            Signals success by returning evidence
            Signals failure by raising an error
            </summary>
            <typeparam name="K1">The larger type</typeparam>
            <typeparam name="K2">The smaller type</typeparam>
        </member>
        <member name="M:Z0.NatClaim.length``2(System.Collections.Generic.IReadOnlyList{``1})">
            <summary>
            Attempts to prove that the k:K => src.length = k
            Registers success by returning src
            Registers failure by raising an error
            </summary>
            <param name="src">The source array</param>
            <typeparam name="K">The natural type</typeparam>
            <typeparam name="T">The list element type</typeparam>
        </member>
        <member name="M:Z0.NatClaim.length``2(``0,System.Collections.Generic.IReadOnlyList{``1})">
            <summary>
            Attempts to prove that the k:K => src.length = k
            Registers success by returning src
            Registers failure by raising an error
            </summary>
            <param name="src">The source array</param>
            <typeparam name="K">The natural type</typeparam>
            <typeparam name="T">The list element type</typeparam>
        </member>
        <member name="M:Z0.NatClaim.length``2(``0,``1[])">
            <summary>
            Attempts to prove that the k:K => src.length = k
            Registers success by returning src
            Registers failure by raising an error
            </summary>
            <param name="src">The source array</param>
            <typeparam name="K">The natural type</typeparam>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.NatClaim.length``2(``1[])">
            <summary>
            Attempts to prove that the k:K => src.length = k
            Registers success by returning src
            Registers failure by raising an error
            </summary>
            <param name="src">The source array</param>
            <typeparam name="K">The natural type</typeparam>
            <typeparam name="T">The element type</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.NatClaim.lt``1(``0,System.UInt64)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.NatClaim.lteq``1(``0,System.UInt64)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.NatClaim.lt``2(``0,``1)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.NatClaim.mod``3" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.NatClaim.mod``3(``0,``1,``2)" -->
        <member name="M:Z0.NatClaim.even``1">
            <summary>
            Attempts to prove that k:K1 => k % 2 == 0
            Signals success by returning evidence
            Signals failure by raising an error
            </summary>
            <typeparam name="K">An even natural type</typeparam>
        </member>
        <member name="M:Z0.NatClaim.even``1(``0)">
            <summary>
            Attempts to prove that k:K1 => k % 2 == 0
            Signals success by returning evidence
            Signals failure by raising an error
            </summary>
            <typeparam name="K">An even natural type</typeparam>
        </member>
        <member name="M:Z0.NatClaim.odd``1">
            <summary>
            Attempts to prove that k:K1 => k % 2 != 0
            Signals success by returning evidence
            Signals failure by raising an error
            </summary>
            <typeparam name="K">An odd natural type</typeparam>
        </member>
        <member name="M:Z0.NatClaim.odd``1(``0)">
            <summary>
            Attempts to prove that k:K1 => k % 2 != 0
            Signals success by returning evidence
            Signals failure by raising an error
            </summary>
            <typeparam name="K">An odd natural type</typeparam>
        </member>
        <member name="M:Z0.NatClaim.mul``2(System.UInt32)">
            <summary>
            Attempts to prove k1 * k2 = expected 
            Signals success by returning evidence
            Signals failure by raising an error
            </summary>
            <typeparam name="K1">The first type</typeparam>
            <typeparam name="K2">The second type</typeparam>
        </member>
        <member name="M:Z0.NatClaim.mul``2(``0,``1,System.UInt32)">
            <summary>
            Attempts to prove k1 * k2 = expected 
            Signals success by returning evidence
            Signals failure by raising an error
            </summary>
            <param name="k1">The first operand value</param>
            <param name="k2">The second operand value</param>
            <typeparam name="K1">The first type</typeparam>
            <typeparam name="K2">The second type</typeparam>
        </member>
        <member name="M:Z0.NatClaim.product``2(``0,``1)">
            <summary>
            Constructs a natural representative that encodes the product of two naturals
            </summary>
            <typeparam name="K1">The first operand type</typeparam>
            <typeparam name="K2">The second operand type</typeparam>
        </member>
        <member name="M:Z0.NatClaim.failure``1(System.String,System.UInt32,System.Boolean)">
            <summary>
            Registers natural constraint failure
            </summary>
            <param name="name">The name of the constraint that failed</param>
            <param name="n">The subject value</param>
            <param name="raise">Specifies whether to raise an error</param>
            <typeparam name="K">The natural type for which a constraint failed</typeparam>
        </member>
        <member name="M:Z0.NatClaim.failure``1(System.String,System.UInt64,System.Boolean)">
            <summary>
            Registers natural constraint failure
            </summary>
            <param name="name">The name of the constraint that failed</param>
            <param name="n">The subject value</param>
            <param name="raise">Specifies whether to raise an error</param>
            <typeparam name="K">The natural type for which a constraint failed</typeparam>
        </member>
        <member name="M:Z0.NatClaim.failure``2(System.String,``1,System.Boolean)">
            <summary>
            Registers a natural constraint failure
            </summary>
            <param name="name">The name of the constraint that failed</param>
            <param name="n">The subject value</param>
            <param name="raise">Specifies whether to raise an error</param>
            <typeparam name="K">The natural type for which a constraint failed</typeparam>
            <typeparam name="T">The subject type</typeparam>
        </member>
        <member name="M:Z0.NatClaim.failure``2(System.String,System.Boolean)">
            <summary>
            Registers a natural pair constraint failure
            </summary>
            <param name="name">The name of the constraint that failed</param>
            <param name="raise">Specifies whether to raise an error</param>
            <typeparam name="K1">The first natural type</typeparam>
            <typeparam name="K2">The second natural type</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.NatClaim.next``2" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.NatClaim.next``2(``0,``1)" -->
        <member name="M:Z0.NatClaim.nonzero``1">
            <summary>
            Attempts to prove that k:K => k != 0
            Signals success by returning evidence
            Signals failure by raising an error
            </summary>
            <typeparam name="K">A nonzero natural type</typeparam>
        </member>
        <member name="M:Z0.NatClaim.nonzero``1(``0)">
            <summary>
            Attempts to prove that k:K => k != 0
            Signals success by returning evidence
            Signals failure by raising an error
            </summary>
            <typeparam name="K">A nonzero natural type</typeparam>
        </member>
        <member name="M:Z0.NatClaim.prime``1">
            <summary>
            If possible, constructs evidence that n:K => n prime; otherwise,
            raises an error
            </summary>
            <typeparam name="K">The subject</typeparam>
        </member>
        <member name="M:Z0.NatClaim.prime``1(``0)">
            <summary>
            If possible, constructs evidence that n:K => n prime; otherwise,
            raises an error
            </summary>
            <typeparam name="K">The subject</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.NatClaim.successor``2(System.Boolean)" -->
        <member name="M:Z0.NatClaim.prior``2(``0,``1)">
            <summary>
            Attempts construct evidence that k1 = k2 + 1;
            </summary>
            <typeparam name="K1">The source type</typeparam>
            <typeparam name="K2">The successor type</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Z0.NatBetween`3" -->
        <member name="T:Z0.NatEq`2">
            <summary>
            Captures evidence that n1 == n2
            </summary>
            <typeparam name="K1">The first nat type</typeparam>
            <typeparam name="N2">The second nat type</typeparam>
        </member>
        <member name="T:Z0.NatNEq`2">
            <summary>
            Captures evidence that k1 != k2
            </summary>
            <typeparam name="K1">The first nat type</typeparam>
            <typeparam name="N2">The second nat type</typeparam>
        </member>
        <member name="T:Z0.NatEven`1">
            <summary>
            Captures evidence that k % 2 == 0
            </summary>
            <typeparam name="K">An even natural type</typeparam>
        </member>
        <member name="T:Z0.NatGt`2">
            <summary>
            Captures evidence that k1 > k2
            </summary>
            <typeparam name="K1">The larger nat type</typeparam>
            <typeparam name="K2">The smaller nat type</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Z0.NatLt`2" -->
        <!-- Badly formed XML comment ignored for member "T:Z0.NatMod`3" -->
        <member name="T:Z0.NatTry">
            <summary>
            Defines proof attempts for type naturals
            </summary>
        </member>
        <member name="M:Z0.NatTry.Try``1(System.Func{``0},System.Action{System.Exception})">
            <summary>
            Evaluates a function within a try block and returns the value of the computation if 
            successful; otherwise, returns None together with the reported exceptions
            </summary>
            <typeparam name="T">The result type</typeparam>
            <param name="f">The function to evaluate</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.NatTry.TryAdd``2(``0,``1,System.UInt64)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.NatTry.TryBetween``3" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.NatTry.TryBetween``3(``0,``1,``2)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.NatTry.TryEqual``2" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.NatTry.TryEqual``2(``0,``1)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.NatTry.TryGt``2" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.NatTry.TryGt``2(``0,``1)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.NatTry.TryLt``2" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.NatTry.TryLt``2(``0,``1)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.NatTry.TryMul``2(System.UInt32)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.NatTry.TryMul``2(``0,``1,System.UInt32)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.NatTry.TryMod``3" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.NatTry.TryMod``3(``0,``1,``2)" -->
        <member name="M:Z0.NatTry.TryEven``1(``0)">
            <summary>
            Attempts to prove that k:K1 => k % 2 == 0
            Signals success by returning evidence
            Signals failure by returning none
            </summary>
            <typeparam name="K">An even natural type</typeparam>
        </member>
        <member name="M:Z0.NatTry.TryEven``1">
            <summary>
            Attempts to prove that k:K1 => k % 2 == 0
            Signals success by returning evidence
            Signals failure by returning none
            </summary>
            <typeparam name="K">An even natural type</typeparam>
        </member>
        <member name="M:Z0.NatTry.tryOdd``1(``0)">
            <summary>
            Attempts to prove that k:K1 => k % 2 != 0
            Signals success by returning evidence
            Signals failure by returning none
            </summary>
            <typeparam name="K">An odd natural type</typeparam>
        </member>
        <member name="M:Z0.NatTry.TryOdd``1">
            <summary>
            Attempts to prove that k:K1 => k % 2 != 0
            Signals success by returning evidence
            Signals failure by returning none
            </summary>
            <typeparam name="K">An odd natural type</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.NatTry.TryNext``2" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.NatTry.TryNext``2(``0,``1)" -->
        <member name="M:Z0.NatTry.TryNonzero``1">
            <summary>
            Attempts to prove that k:K => k != 0
            Signals success by returning evidence
            Signals failure by returning none
            </summary>
            <typeparam name="K">A nonzero natural type</typeparam>
        </member>
        <member name="M:Z0.NatTry.TryNonzero``1(``0)">
            <summary>
            Attempts to prove that k:K => k != 0
            Signals success by returning evidence
            Signals failure by returning none
            </summary>
            <typeparam name="K">A nonzero natural type</typeparam>
        </member>
        <member name="M:Z0.NatTry.TryPrime``1">
            <summary>
            If possible, constructs evidence that n:K => n prime; otherwise,
            yields none
            </summary>
            <typeparam name="K">The subject</typeparam>
        </member>
        <member name="M:Z0.NatTry.TryPrime``1(``0)">
            <summary>
            If possible, constructs evidence that n:K => n prime; otherwise,
            yields none
            </summary>
            <typeparam name="K">The subject</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.NatTry.TryPrior``2" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.NatTry.TryPrior``2(``0,``1)" -->
        <!-- Badly formed XML comment ignored for member "T:Z0.Next`1" -->
        <member name="T:Z0.Nonzero`1">
            <summary>
            Captures evidence that k != 0
            </summary>
            <typeparam name="K">A nonzero natural type</typeparam>
        </member>
        <member name="T:Z0.NatOdd`1">
            <summary>
            Captures evidence that k % 2 != 0
            </summary>
            <typeparam name="K">An odd natural type</typeparam>
        </member>
        <member name="T:Z0.Pow`2">
            <summary>
            Encodes a natural number k := b^e
            </summary>
        </member>
        <member name="M:Z0.Pow`2.pow(System.UInt64,System.UInt64)">
            <summary>
            Raises a baise to a power
            </summary>
            <param name="@base">The base value</param>
            <param name="exp">The exponent value</param>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Z0.NatPrime`1" -->
        <member name="M:Z0.NatPrime.test(System.UInt64)">
            <summary>
            Determines whether an integer is prime, very inefficiently
            </summary>
            <param name="x">The integer to examine</param>
            <typeparam name="T">The underlying integer type</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Z0.INatNext`2" -->
        <member name="T:Z0.NatNext`2">
            <summary>
            Captures evidence that k1 + 1 = k2
            </summary>
            <typeparam name="K1">The first nat type</typeparam>
            <typeparam name="K2">The second nat type</typeparam>
        </member>
        <member name="T:Z0.NatPrior`2">
            <summary>
            Captures evidence that k1 - 1 = k2
            </summary>
            <typeparam name="K1">The first nat type</typeparam>
            <typeparam name="K2">The second nat type</typeparam>
        </member>
        <member name="T:Z0.Product`2">
            <summary>
            Encodes a natural number k := k1*k2
            </summary>
        </member>
        <member name="T:Z0.Sub`2">
            <summary>
            Encodes a natural number k := k1 - k2
            </summary>
        </member>
        <member name="T:Z0.NatSum`2">
            <summary>
            Encodes a natural number k := k1 + k2
            </summary>
        </member>
        <member name="T:Z0.N0">
            <summary>
            The singleton type representative for 0
            </summary>
        </member>
        <member name="T:Z0.N1">
            <summary>
            The singleton type representative for 1
            </summary>
        </member>
        <member name="T:Z0.N2">
            <summary>
            The type that represents 2
            </summary>
        </member>
        <member name="T:Z0.N3">
            <summary>
            The singleton type representative for 3
            </summary>
        </member>
        <member name="T:Z0.N4">
            <summary>
            The singleton type representative for 4
            </summary>
        </member>
        <member name="T:Z0.N5">
            <summary>
            The singleton type representative for 5
            </summary>
        </member>
        <member name="T:Z0.N6">
            <summary>
            The singleton type representative for 6
            </summary>
        </member>
        <member name="T:Z0.N7">
            <summary>
            The singleton type representative for 7
            </summary>
        </member>
        <member name="T:Z0.N8">
            <summary>
            The singleton type representative for 8
            </summary>
        </member>
        <member name="T:Z0.N9">
            <summary>
            The singleton type representative for 9
            </summary>
        </member>
        <member name="T:Z0.NatSeq0`1">
            <summary>
            Reifies a one-term natural sequence
            </summary>
            <typeparam name="D0">The type of the first term</typeparam>
        </member>
        <member name="T:Z0.NatSeq`2">
            <summary>
            Reifies a two-term natural sequence that represents the value k := k1*10 + k2
            </summary>
        </member>
        <member name="T:Z0.NatSeq`3">
            <summary>
            Reifies a three-term natural sequence
            </summary>
        </member>
        <member name="T:Z0.NatSeq`4">
            <summary>
            Reifies a four-term natural sequence
            </summary>
        </member>
        <member name="T:Z0.NatSeq`5">
            <summary>
            Reifies a five-term natural sequence
            </summary>
        </member>
        <member name="T:Z0.NatSeq`6">
            <summary>
            Reifies a six-term natural sequence
            </summary>
        </member>
        <member name="T:Z0.NatSeq`7">
            <summary>
            Reifies a seven-term natural sequence
            </summary>
        </member>
        <member name="T:Z0.NatSeq`8">
            <summary>
            Reifies a seven-term natural sequence
            </summary>
        </member>
        <member name="T:Z0.NatSeq`9">
            <summary>
            Reifies a seven-term natural sequence
            </summary>
        </member>
        <member name="T:Z0.Digit`2">
            <summary>
            Defines a generic digit representation realtive to a natural base
            </summary>
            <typeparam name="N">The natural base type</typeparam>
            <typeparam name="T">The digit's primal type</typeparam>
        </member>
        <member name="T:Z0.NatKind">
            <summary>
            Defines identity for a pair NxT or MxNxT where M and N are natural types and T is numeric
            </summary>
        </member>
        <member name="F:Z0.NatKind.M">
            <summary>
            The number of grid rows
            </summary>
        </member>
        <member name="F:Z0.NatKind.N">
            <summary>
            The number of grid columns
            </summary>
        </member>
        <member name="F:Z0.NatKind.T">
            <summary>
            The numeric cell type
            </summary>
        </member>
        <member name="M:Z0.NatKind.Format">
            <summary>
            Formats the dimension in canonical form
            </summary>
        </member>
        <member name="T:Z0.NatSpan`2">
            <summary>
            Defines a span of natural length N
            </summary>
        </member>
        <member name="P:Z0.NatSpan`2.Edit">
            <summary>
            The backing storage
            </summary>
        </member>
        <member name="P:Z0.NatSpan`2.Head">
            <summary>
            The leading storage cell
            </summary>
        </member>
        <member name="P:Z0.NatSpan`2.IsEmpty">
            <summary>
            True if no capacity exist, false otherwise
            </summary>
        </member>
        <member name="P:Z0.NatSpan`2.IsNonEmpty">
            <summary>
            True if no capacity exist, false otherwise
            </summary>
        </member>
        <member name="P:Z0.NatSpan`2.Item(System.Int64)">
            <summary>
            Queries/manipulates an index-identified cell
            </summary>
        </member>
        <member name="P:Z0.NatSpan`2.Item(System.Byte)">
            <summary>
            Queries/manipulates an index-identified cell
            </summary>
        </member>
        <member name="P:Z0.NatSpan`2.Item(System.UInt16)">
            <summary>
            Queries/manipulates an index-identified cell
            </summary>
        </member>
        <member name="P:Z0.NatSpan`2.Item(System.UInt32)">
            <summary>
            Queries/manipulates an index-identified cell
            </summary>
        </member>
        <member name="P:Z0.NatSpan`2.Item(System.UInt64)">
            <summary>
            Queries/manipulates an index-identified cell
            </summary>
        </member>
        <member name="M:Z0.NatSpan`2.Cell``1(System.UInt64)">
            <summary>
            Queries/manipulates the underlying storage through the perspective of another type
            </summary>
        </member>
        <member name="M:Z0.NatTypes.sequence(System.UInt32)">
            <summary>
            Computes the generic type definition for a natural sequence
            </summary>
            <param name="length">The sequence length</param>
        </member>
        <member name="T:Z0.NatVal">
            <summary>
            Captures the value of a type natural
            </summary>
        </member>
        <member name="M:Z0.TypeNats.between(System.UInt64,System.UInt64)">
            <summary>
            Constructs the canonical sequence representatives for the natural numbers within an inclusive range
            </summary>
            <param name="min">The minimum value</param>
            <param name="max">The maximum value</param>
        </member>
        <member name="M:Z0.TypeNats.add``2(``0,``1)">
            <summary>
            Computes k := k1 + k2
            </summary>
        </member>
        <member name="M:Z0.TypeNats.min``2(``0,``1)">
            <summary>
            Computes k := k1 + k2
            </summary>
        </member>
        <member name="M:Z0.TypeNats.max``2(``0,``1)">
            <summary>
            Computes k := k1 + k2
            </summary>
        </member>
        <member name="M:Z0.TypeNats.digits(System.UInt64)">
            <summary>
            Creates a sequence of primitive values from a natural value
            </summary>
            <param name="src">The source value</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.TypeNats.pairval``2(``0,``1)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.TypeNats.primitive(System.Byte)" -->
        <member name="M:Z0.TypeNats.primitives(System.Byte[])">
            <summary>
            Constructs an array of types that defines a sequence of natural primitives
            </summary>
            <param name="digits">The digit values where each value is in the range 0..9</param>
        </member>
        <member name="M:Z0.TypeNats.seq(System.Byte[])">
            <summary>
            Creates a reflected natural sequence from a sequence of primitive values
            </summary>
            <param name="digits">The source digits</param>
        </member>
        <member name="M:Z0.TypeNats.seq``2(``0,``1)">
            <summary>
            Creates a two-term natural sequence {D0, D1} from primitive natural types D0 and D1 that represents the value k = d0*10 + d1
            </summary>
            <param name="d0">The primal representative of the leading term</param>
            <param name="d1">The primal representative of the second term</param>
            <typeparam name="D0">The primitive type of the leading term</typeparam>
            <typeparam name="D1">The primitive type of the second term</typeparam>
        </member>
        <member name="M:Z0.TypeNats.seq``3(``0,``1,``2)">
            <summary>
            Creates a three-term natural sequence {D0, D1, D2} from natural primitive types D0, D1, D2
            that represents the value k = d0*10^2 + d1*10^1 + d2
            </summary>
            <param name="d0">The primal representative of the leading term</param>
            <param name="d1">The primal representative of the second term</param>
            <param name="d2">The primal representative of the third term</param>
            <typeparam name="D0">The primitive type of the leading term</typeparam>
            <typeparam name="D1">The primitive type of the second term</typeparam>
            <typeparam name="D2">The primitive type of the third term</typeparam>
        </member>
        <member name="M:Z0.TypeNats.seq``4(``0,``1,``2,``3)">
            <summary>
            Creates a four-term natural sequence {D0, D1, D2, D3} from natural primitive types D0, D1, D2, D3
            that represents the value k = d0*10^3 + d1*10^2 + d2*10 + d3
            </summary>
            <param name="d0">The primal representative of the leading term</param>
            <param name="d1">The primal representative of the second term</param>
            <param name="d2">The primal representative of the third term</param>
            <param name="d3">The primal representative of the fourth term</param>
            <typeparam name="D0">The primitive type of the leading term</typeparam>
            <typeparam name="D1">The primitive type of the second term</typeparam>
            <typeparam name="D2">The primitive type of the third term</typeparam>
            <typeparam name="D3">The primitive type of the fourth term</typeparam>
        </member>
        <member name="M:Z0.TypeNats.seq``5(``0,``1,``2,``3,``4)">
            <summary>
            Creates a five-term natural sequence {D0, D1, D2, D3, D4} from natural primitive types D0, D1, D2, D3, D4
            that represents the value k = d0*10^4 + d1*10^3 + d2*10^2 + d3*10 + d4
            </summary>
            <param name="d0">The primal representative of the leading term</param>
            <param name="d1">The primal representative of the second term</param>
            <param name="d2">The primal representative of the third term</param>
            <param name="d3">The primal representative of the fourth term</param>
            <param name="d4">The primal representative of the fifth term</param>
            <typeparam name="D0">The primitive type of the leading term</typeparam>
            <typeparam name="D1">The primitive type of the second term</typeparam>
            <typeparam name="D2">The primitive type of the third term</typeparam>
            <typeparam name="D3">The primitive type of the fourth term</typeparam>
            <typeparam name="D4">The primitive type of the fifth term</typeparam>
        </member>
        <member name="M:Z0.TypeNats.seq(System.Byte,System.Byte)">
            <summary>
            Creates a reflected two-term natural sequence {d0, d1} from three primitive values d0 and d1
            </summary>
            <param name="d0">The value of the leading term</param>
            <param name="d1">The value of the second term</param>
        </member>
        <member name="M:Z0.TypeNats.seq(System.Byte,System.Byte,System.Byte)">
            <summary>
            Creates a reflected three-term natural sequence {d0, d1, d2} from three primitive values d0, d1, d2
            </summary>
            <param name="d0">The value of the leading term</param>
            <param name="d1">The value of the second term</param>
            <param name="d2">The value of the third term</param>
        </member>
        <member name="M:Z0.TypeNats.seq(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Creates a reflected four-term natural sequence from three primitive values
            </summary>
            <param name="d0">The value of the leading term</param>
            <param name="d1">The value of the second term</param>
            <param name="d2">The value of the third term</param>
            <param name="d3">The value of the fourth term</param>
        </member>
        <member name="M:Z0.TypeNats.value``1(``0)">
            <summary>
            Reveals the natural number in bijection with a parametric type natural
            </summary>
            <param name="n">The representative, used only for method invocation type inference</param>
            <typeparam name="K">The natural type</typeparam>
        </member>
        <member name="M:Z0.TypeNats.digit``2(``1,``0)">
            <summary>
            Defines a digit relative to a natural base
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The digit's enumeration type</typeparam>
            <typeparam name="N">The natural base type</typeparam>
        </member>
        <member name="M:Z0.TypeNats.nat``1(``0)">
            <summary>
            Constructs a natural representative for a specified parametric type
            </summary>
            <typeparam name="K">The representative type to construct</typeparam>
        </member>
        <member name="M:Z0.TypeNats.reflect(System.UInt64)">
            <summary>
            Constructs the natural type corresponding to an integral value
            </summary>
            <param name="digits">The source digits</param>
        </member>
        <member name="M:Z0.NatCalc.add``2(``0,``1)">
            <summary>
            Computes k := k1 + k2
            </summary>
        </member>
        <member name="M:Z0.NatCalc.min``2(``0,``1)">
            <summary>
            Computes k := k1 + k2
            </summary>
        </member>
        <member name="M:Z0.NatCalc.max``2(``0,``1)">
            <summary>
            Computes k := k1 + k2
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.NatCalc.and``2(``0,``1)" -->
        <member name="M:Z0.NatCalc.or``2(``0,``1)">
            <summary>
            Computes k := k1 | k2
            </summary>
        </member>
        <member name="M:Z0.NatCalc.xor``2(``0,``1)">
            <summary>
            Computes k := k1 ^ k2
            </summary>
        </member>
        <member name="M:Z0.NatCalc.not``1(``0)">
            <summary>
            Computes k := ~k1
            </summary>
        </member>
        <member name="M:Z0.NatCalc.div``2(``0,``1)">
            <summary>
            Computes k := k1 / k2
            </summary>
        </member>
        <member name="M:Z0.NatCalc.divprod``3(``0,``1,``2)">
            <summary>
            Computes k := (k1*k2) / k3
            </summary>
        </member>
        <member name="M:Z0.NatCalc.divT``2(``0,``1)">
            <summary>
            Computes k := value[N] / bitsize[T]
            </summary>
            <param name="n">The natural representative</param>
            <param name="t">A type representative</param>
            <typeparam name="N">The natural type</typeparam>
            <typeparam name="T">The bit width type</typeparam>
        </member>
        <member name="M:Z0.NatCalc.divT``3(``0,``1,``2)">
            <summary>
            Computes k := (k1 / k2) / bitsize[t]
            </summary>
        </member>
        <member name="M:Z0.NatCalc.divceilT``2(``0,``1)">
            <summary>
            Computes the upward-rounded quotient 
            q := natval[N] % bitsize[T] == 0 ? natval[N] / bitsize[T] : (natval[N] / bitsize[T]) + 1
            </summary>
            <param name="n">The natural representative</param>
            <param name="t">A type representative</param>
            <typeparam name="N">The natural type</typeparam>
            <typeparam name="T">The width type</typeparam>
        </member>
        <member name="M:Z0.NatCalc.eqT``2(``0,``1)">
            <summary>
            Computes the predicate p := natval[N] == bitsize[T]
            </summary>
            <param name="n">The natural representative</param>
            <param name="t">A type representative</param>
            <typeparam name="N">The natural type</typeparam>
            <typeparam name="T">The bit width type</typeparam>
        </member>
        <member name="M:Z0.NatCalc.gt``2(``0,``1)">
            <summary>
            Computes the predicate p := value[K1] > value[K2]
            </summary>
            <param name="k1">The representative of the first natural</param>
            <param name="k2">The representative of the second natural</param>
            <typeparam name="K1">The first natural type</typeparam>
            <typeparam name="K2">The second natural type</typeparam>
        </member>
        <member name="M:Z0.NatCalc.gteq``2(``0,``1)">
            <summary>
            Computes the predicate p := value[K1] >= value[K2]
            </summary>
            <param name="k1">The representative of the first natural</param>
            <param name="k2">The representative of the second natural</param>
            <typeparam name="K1">The first natural type</typeparam>
            <typeparam name="K2">The second natural type</typeparam>
        </member>
        <member name="M:Z0.NatCalc.gtT``2(``0,``1)">
            <summary>
            Computes the predicate p := value[N] > bitsize[T]
            </summary>
            <param name="n">The natural representative</param>
            <param name="t">A type representative</param>
            <typeparam name="N">The natural type</typeparam>
            <typeparam name="T">The bit width type</typeparam>
        </member>
        <member name="M:Z0.NatCalc.gteqT``2(``0,``1)">
            <summary>
            Computes the predicate p := value[N] >= bitsize[T]
            </summary>
            <param name="n">The natural representative</param>
            <param name="t">A type representative</param>
            <typeparam name="N">The natural type</typeparam>
            <typeparam name="T">The bit width type</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.NatCalc.lt``2(``0,``1)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.NatCalc.lteq``2(``0,``1)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.NatCalc.ltT``2(``0,``1)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.NatCalc.lteqT``2(``0,``1)" -->
        <member name="M:Z0.NatCalc.mod``2(``0,``1)">
            <summary>
            Computes k := k1 % k2
            </summary>
        </member>
        <member name="M:Z0.NatCalc.modT``2(``0,``1)">
            <summary>
            Computes k := value[N] % bitsize[T]
            </summary>
            <param name="n">The natural representative</param>
            <param name="t">A type representative</param>
            <typeparam name="N">The natural type</typeparam>
            <typeparam name="T">The bit width type</typeparam>
        </member>
        <member name="M:Z0.NatCalc.modprod``3(``0,``1,``2)">
            <summary>
            Computes k := (k1*k2) % k3
            </summary>
        </member>
        <member name="M:Z0.NatCalc.mul``2(``0,``1)">
            <summary>
            Computes k := k1*k2
            </summary>
        </member>
        <member name="M:Z0.NatCalc.mul``3(``0,``1,``2)">
            <summary>
            Computes k := k1*k2*k3
            </summary>
        </member>
        <member name="M:Z0.NatCalc.even``1(``0)">
            <summary>
            Computes k := k % 2 == 0
            </summary>
        </member>
        <member name="M:Z0.NatCalc.odd``1(``0)">
            <summary>
            Computes k := k % 2 != 0
            </summary>
        </member>
        <member name="M:Z0.NatCalc.pow2m1``1(``0)">
            <summary>
            Computes k := 2^n - 1
            </summary>
            <param name="n">The power of 2 exponent, between 0 and 64</param>
            <typeparam name="K">The exponent type</typeparam>
        </member>
        <member name="M:Z0.NatCalc.pow2``1(``0)">
            <summary>
            Computes k := 2^n
            </summary>
            <param name="n">The power of 2 exponent, between 0 and 63</param>
            <typeparam name="K">The exponent type</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.NatCalc.sll``2(``0,``1)" -->
        <member name="M:Z0.NatCalc.square``1(``0)">
            <summary>
            Computes k := k1*k1
            </summary>
        </member>
        <member name="M:Z0.NatCalc.srl``2(``0,``1)">
            <summary>
            Computes k := x >> n
            </summary>
        </member>
        <member name="M:Z0.NatCalc.sub``2(``0,``1)">
            <summary>
            Computes k := k1 - k2
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.NatCalc.prodlteq``3(``0,``1,``2)" -->
        <member name="M:Z0.NatCalc.prodgteq``3(``0,``1,``2)">
            <summary>
            Computes b := k1 * k2 >= k3
            </summary>
        </member>
        <member name="M:Z0.NatCalc.prodeq``3(``0,``1,``2)">
            <summary>
            Computes b := k1 * k2 == k3
            </summary>
        </member>
        <member name="M:Z0.Typed.value``1(``0)">
            <summary>
            Returns the numeric value represented by a natural type
            </summary>
            <param name="n">The natural type representative</param>
            <typeparam name="K">A natural type</typeparam>
        </member>
        <member name="F:Z0.Typed.z8i">
            <summary>
            The zero-value for an 8-bit signed integer
            </summary>
        </member>
        <member name="F:Z0.Typed.z8">
            <summary>
            The zero-value for an 8-bit unsigned integer
            </summary>
        </member>
        <member name="F:Z0.Typed.z16i">
            <summary>
            The zero-value for a 16-bit signed integer
            </summary>
        </member>
        <member name="F:Z0.Typed.z16">
            <summary>
            The zero-value for a 16-bit unsigned integer
            </summary>
        </member>
        <member name="F:Z0.Typed.z32i">
            <summary>
            The zero-value for a 32-bit signed integer
            </summary>
        </member>
        <member name="F:Z0.Typed.z32">
            <summary>
            The zero-value for a 32-bit unsigned integer
            </summary>
        </member>
        <member name="F:Z0.Typed.z64i">
            <summary>
            The zero-value for a 64-bit signed integer
            </summary>
        </member>
        <member name="F:Z0.Typed.z64">
            <summary>
            The zero-value for a 64-bit usigned integer
            </summary>
        </member>
        <member name="F:Z0.Typed.z32f">
            <summary>
            The zero-value for a 32-bit float
            </summary>
        </member>
        <member name="F:Z0.Typed.z64f">
            <summary>
            The zero-value for a 64-bit float
            </summary>
        </member>
        <member name="T:Z0.Negative">
            <summary>
            Promotes the literal classifier <See cref="F:Z0.SignKind.Signed"/> to a type
            </summary>
        </member>
        <member name="P:Z0.Negative.Kind">
            <summary>
            Reveals the represented literal
            </summary>
        </member>
        <member name="T:Z0.Negative`1">
            <summary>
            Defines a T-parametric <See cref="F:Z0.SignKind.Signed"/> literal classifier promotion
            </summary>
        </member>
        <member name="P:Z0.Negative`1.SignType">
            <summary>
            Reveals the singleton instance of the nonparametric classifier
            </summary>
        </member>
        <member name="P:Z0.Negative`1.Kind">
            <summary>
            Reveals the represented literal
            </summary>
        </member>
        <member name="T:Z0.NK`1">
            <summary>
            Represents the parametrically-identified numeric kind
            </summary>
        </member>
        <member name="T:Z0.Positive">
            <summary>
            Promotes the literal classifier <See cref="F:Z0.SignKind.Unsigned"/> to a type
            </summary>
        </member>
        <member name="P:Z0.Positive.Kind">
            <summary>
            Reveals the represented literal
            </summary>
        </member>
        <member name="T:Z0.Positive`1">
            <summary>
            Defines a T-parametric <See cref="F:Z0.SignKind.Signed"/> literal classifier promotion
            </summary>
        </member>
        <member name="P:Z0.Positive`1.SignType">
            <summary>
            Reveals the singleton instance of the nonparametric classifier
            </summary>
        </member>
        <member name="P:Z0.Positive`1.Kind">
            <summary>
            Reveals the represented literal
            </summary>
        </member>
        <member name="T:Z0.Sign`1">
            <summary>
            Captures an S-parametric sign classifier via parametricity
            </summary>
        </member>
        <member name="P:Z0.Sign`1.SignType">
            <summary>
            Reveals the type-level classifier
            </summary>
        </member>
        <member name="P:Z0.Sign`1.Kind">
            <summary>
            Reveals the literal represented by the type-level classifier
            </summary>
            <remarks>
            The implementation is redundant with that provided by the default interface implementation;
            however, accessing that implementation requires a boxing conversion along with polymorphic
            dispatch
            </remarks>
        </member>
        <member name="T:Z0.Sign`2">
            <summary>
            Captures an S/T-parametric sign classifier via parametricity
            </summary>
        </member>
        <member name="T:Z0.W1">
            <summary>
            Defines a type-level representation of <see cref='F:Z0.DataWidth.W1'/>
            </summary>
        </member>
        <member name="P:Z0.W1.W">
            <summary>
            An instance-level representative
            </summary>
        </member>
        <member name="F:Z0.W1.Identifier">
            <summary>
            The width identity
            </summary>
        </member>
        <member name="T:Z0.W1024">
            <summary>
            Defines a type-level representation of <see cref='F:Z0.DataWidth.W1024'/>
            </summary>
        </member>
        <member name="P:Z0.W1024.W">
            <summary>
            An instance-level representative
            </summary>
        </member>
        <member name="F:Z0.W1024.Identifier">
            <summary>
            The width identity
            </summary>
        </member>
        <member name="T:Z0.W128">
            <summary>
            Defines a type-level representation of <see cref='F:Z0.DataWidth.W128'/> with a <see cref='F:Z0.TypeSignKind.Signed'/> classifier
            </summary>
        </member>
        <member name="P:Z0.W128.W">
            <summary>
            An instance-level representative
            </summary>
        </member>
        <member name="F:Z0.W128.Identifier">
            <summary>
            The width identity
            </summary>
        </member>
        <member name="T:Z0.W128i">
            <summary>
            Defines a type-level representation of <see cref='F:Z0.DataWidth.W128'/> with a <see cref='F:Z0.TypeSignKind.Signed'/> classifier
            </summary>
        </member>
        <member name="P:Z0.W128i.W">
            <summary>
            An instance-level representative
            </summary>
        </member>
        <member name="F:Z0.W128i.Identifier">
            <summary>
            The width identity
            </summary>
        </member>
        <member name="T:Z0.W16">
            <summary>
            Defines a type-level representation of <see cref='F:Z0.DataWidth.W16'/>
            </summary>
        </member>
        <member name="P:Z0.W16.W">
            <summary>
            An instance-level representative
            </summary>
        </member>
        <member name="F:Z0.W16.Identifier">
            <summary>
            The width identity
            </summary>
        </member>
        <member name="T:Z0.W16i">
            <summary>
            Defines a type-level representation of <see cref='F:Z0.DataWidth.W16'/> with a <see cref='F:Z0.TypeSignKind.Signed'/> classifier
            </summary>
        </member>
        <member name="P:Z0.W16i.W">
            <summary>
            An instance-level representative
            </summary>
        </member>
        <member name="F:Z0.W16i.Identifier">
            <summary>
            The width identity
            </summary>
        </member>
        <member name="P:Z0.W2.W">
            <summary>
            An instance-level representative
            </summary>
        </member>
        <member name="F:Z0.W2.Identifier">
            <summary>
            The width identity
            </summary>
        </member>
        <member name="T:Z0.W24">
            <summary>
            Defines a type-level representation of <see cref='F:Z0.DataWidth.W24'/>
            </summary>
        </member>
        <member name="P:Z0.W24.W">
            <summary>
            An instance-level representative
            </summary>
        </member>
        <member name="F:Z0.W24.Identifier">
            <summary>
            The width identity
            </summary>
        </member>
        <member name="F:Z0.W24.ValueText">
            <summary>
            The width represented as text
            </summary>
        </member>
        <member name="T:Z0.W256">
            <summary>
            Defines a type-level representation of <see cref='F:Z0.DataWidth.W256'/>
            </summary>
        </member>
        <member name="P:Z0.W256.W">
            <summary>
            An instance-level representative
            </summary>
        </member>
        <member name="F:Z0.W256.Identifier">
            <summary>
            The width identity
            </summary>
        </member>
        <member name="T:Z0.W256i">
            <summary>
            Defines a type-level representation of <see cref='F:Z0.DataWidth.W256'/> with a <see cref='F:Z0.TypeSignKind.Signed'/> classifier
            </summary>
        </member>
        <member name="P:Z0.W256i.W">
            <summary>
            An instance-level representative
            </summary>
        </member>
        <member name="F:Z0.W256i.Identifier">
            <summary>
            The width identity
            </summary>
        </member>
        <member name="P:Z0.W3.W">
            <summary>
            An instance-level representative
            </summary>
        </member>
        <member name="F:Z0.W3.Identifier">
            <summary>
            The width identity
            </summary>
        </member>
        <member name="T:Z0.W32">
            <summary>
            Defines a type-level representation of <see cref='F:Z0.DataWidth.W32'/>
            </summary>
        </member>
        <member name="P:Z0.W32.W">
            <summary>
            An instance-level representative
            </summary>
        </member>
        <member name="F:Z0.W32.Identifier">
            <summary>
            The width identity
            </summary>
        </member>
        <member name="T:Z0.W32i">
            <summary>
            Defines a type-level representation of <see cref='F:Z0.DataWidth.W32'/> with a <see cref='F:Z0.TypeSignKind.Signed'/> classifier
            </summary>
        </member>
        <member name="P:Z0.W32i.W">
            <summary>
            An instance-level representative
            </summary>
        </member>
        <member name="F:Z0.W32i.Identifier">
            <summary>
            The width identity
            </summary>
        </member>
        <member name="P:Z0.W4.W">
            <summary>
            An instance-level representative
            </summary>
        </member>
        <member name="F:Z0.W4.Identifier">
            <summary>
            The width identity
            </summary>
        </member>
        <member name="T:Z0.W40">
            <summary>
            Defines a type-level representation of <see cref='F:Z0.DataWidth.W40'/>
            </summary>
        </member>
        <member name="P:Z0.W40.W">
            <summary>
            An instance-level representative
            </summary>
        </member>
        <member name="F:Z0.W40.Identifier">
            <summary>
            The width identity
            </summary>
        </member>
        <member name="T:Z0.W5">
            <summary>
            Defines a type-level representation of <see cref='F:Z0.DataWidth.W5'/>
            </summary>
        </member>
        <member name="P:Z0.W5.W">
            <summary>
            An instance-level representative
            </summary>
        </member>
        <member name="F:Z0.W5.Identifier">
            <summary>
            The width identity
            </summary>
        </member>
        <member name="T:Z0.W512">
            <summary>
            Defines a type-level representation of <see cref='F:Z0.DataWidth.W512'/>
            </summary>
        </member>
        <member name="P:Z0.W512.W">
            <summary>
            An instance-level representative
            </summary>
        </member>
        <member name="F:Z0.W512.Identifier">
            <summary>
            The width identity
            </summary>
        </member>
        <member name="T:Z0.W512i">
            <summary>
            Defines a type-level representation of <see cref='F:Z0.DataWidth.W512'/> with a <see cref='F:Z0.TypeSignKind.Signed'/> classifier
            </summary>
        </member>
        <member name="P:Z0.W512i.W">
            <summary>
            An instance-level representative
            </summary>
        </member>
        <member name="F:Z0.W512i.Identifier">
            <summary>
            The width identity
            </summary>
        </member>
        <member name="T:Z0.W6">
            <summary>
            Defines a type-level representation of <see cref='F:Z0.DataWidth.W6'/>
            </summary>
        </member>
        <member name="P:Z0.W6.W">
            <summary>
            An instance-level representative
            </summary>
        </member>
        <member name="F:Z0.W6.Identifier">
            <summary>
            The width identity
            </summary>
        </member>
        <member name="T:Z0.W64">
            <summary>
            Defines a type-level representation of <see cref='F:Z0.DataWidth.W64'/>
            </summary>
        </member>
        <member name="P:Z0.W64.W">
            <summary>
            An instance-level representative
            </summary>
        </member>
        <member name="F:Z0.W64.Identifier">
            <summary>
            The width identity
            </summary>
        </member>
        <member name="T:Z0.W64i">
            <summary>
            Defines a type-level representation of <see cref='F:Z0.DataWidth.W64'/> with a <see cref='F:Z0.TypeSignKind.Signed'/> classifier
            </summary>
        </member>
        <member name="P:Z0.W64i.W">
            <summary>
            An instance-level representative
            </summary>
        </member>
        <member name="F:Z0.W64i.Identifier">
            <summary>
            The width identity
            </summary>
        </member>
        <member name="T:Z0.W7">
            <summary>
            Defines a type-level representation of <see cref='F:Z0.DataWidth.W7'/>
            </summary>
        </member>
        <member name="P:Z0.W7.W">
            <summary>
            An instance-level representative
            </summary>
        </member>
        <member name="F:Z0.W7.Identifier">
            <summary>
            The width identity
            </summary>
        </member>
        <member name="T:Z0.W8">
            <summary>
            Defines a type-level representation of <see cref='F:Z0.DataWidth.W8'/>
            </summary>
        </member>
        <member name="P:Z0.W8.W">
            <summary>
            An instance-level representative
            </summary>
        </member>
        <member name="F:Z0.W8.Identifier">
            <summary>
            The width identity
            </summary>
        </member>
        <member name="T:Z0.W8i">
            <summary>
            Defines a type-level representation of <see cref='F:Z0.DataWidth.W8'/> with a <see cref='F:Z0.TypeSignKind.Signed'/> classifier
            </summary>
        </member>
        <member name="P:Z0.W8i.W">
            <summary>
            An instance-level representative
            </summary>
        </member>
        <member name="F:Z0.W8i.Identifier">
            <summary>
            The width identity
            </summary>
        </member>
        <member name="M:Z0.Widths.bits``1">
            <summary>
            Computes the number of bits occupied by an instance of a parametrically-identified type
            </summary>
            <typeparam name="T">The measurable type</typeparam>
        </member>
        <member name="M:Z0.Widths.blocked(System.Type)">
            <summary>
            Determines the attributed width of a blocked type
            </summary>
            <param name="src">The source type</param>
        </member>
        <member name="M:Z0.Widths.bytes``1">
            <summary>
            Computes the number of bytes occupied by an instance of a parametrically-identified type
            </summary>
            <typeparam name="T">The measurable type</typeparam>
        </member>
        <member name="M:Z0.Widths.cells``2">
            <summary>
            Counts the number of numeric T-cells that can be covered by contiguous memory of width W
            </summary>
            <param name="w">The memory bit-width</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.Widths.cells``1(Z0.W8)">
            <summary>
            Counts the number of numeric T-cells that can be covered by contiguous memory of specified width
            </summary>
            <param name="w">The memory bit-width</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.Widths.cells``1(Z0.W16)">
            <summary>
            Counts the number of numeric T-cells that can be covered by contiguous memory of specified width
            </summary>
            <param name="w">The memory bit-width</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.Widths.cells``1(Z0.W32)">
            <summary>
            Counts the number of numeric T-cells that can be covered by contiguous memory of specified width
            </summary>
            <param name="w">The memory bit-width</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.Widths.cells``1(Z0.W64)">
            <summary>
            Counts the number of numeric T-cells that can be covered by contiguous memory of specified width
            </summary>
            <param name="w">The memory bit-width</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.Widths.cells``1(Z0.W128)">
            <summary>
            Counts the number of numeric T-cells that can be covered by contiguous memory of specified width
            </summary>
            <param name="w">The memory bit-width</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.Widths.cells``1(Z0.W256)">
            <summary>
            Counts the number of numeric T-cells that can be covered by contiguous memory of specified width
            </summary>
            <param name="w">The memory bit-width</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.Widths.cells``1(Z0.W512)">
            <summary>
            Counts the number of numeric T-cells that can be covered by contiguous memory of specified width
            </summary>
            <param name="w">The memory bit-width</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.Widths.cells``1(Z0.W1024)">
            <summary>
            Counts the number of numeric T-cells that can be covered by contiguous memory of specified width
            </summary>
            <param name="w">The memory bit-width</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.Widths.data``1(``0)">
            <summary>
            Computes the literal data width from a parametric width
            </summary>
            <typeparam name="W">The parametric width</typeparam>
        </member>
        <member name="M:Z0.Widths.numeric``1(``0)">
            <summary>
            Computes the literal numeric width from a parametric width
            </summary>
            <typeparam name="W">The parametric width</typeparam>
        </member>
        <member name="M:Z0.Widths.div``2(``0,``1)">
            <summary>
            Computes k := width[W] / bitsize[T]
            </summary>
            <param name="n">The natural representative</param>
            <param name="t">A type representative</param>
            <typeparam name="N">The natural type</typeparam>
            <typeparam name="T">The bit width type</typeparam>
        </member>
        <member name="M:Z0.Widths.segmented(System.Type)">
            <summary>
            Determines the width of a (known) segmented type
            </summary>
            <param name="src">The source type</param>
        </member>
        <member name="M:Z0.Widths.type``1(``0)">
            <summary>
            Computes the literal type width from a parametric width
            </summary>
            <typeparam name="W">The parametric width</typeparam>
        </member>
        <member name="M:Z0.Widths.vector(System.Type)">
            <summary>
            Determines the width of a system-defined or custom intrinsic vector type
            </summary>
            <param name="t">The source type</param>
        </member>
        <member name="T:Z0.TxN`1">
            <summary>
            Identifies a parametric type
            </summary>
        </member>
        <member name="T:Z0.TxN`2">
            <summary>
            Identifies a pair of parametric types
            </summary>
        </member>
        <member name="T:Z0.TxN`3">
            <summary>
            Identifies a triple of parametric types
            </summary>
        </member>
        <member name="T:Z0.TxN`4">
            <summary>
            Identifies a quartet of parametric types
            </summary>
        </member>
        <member name="T:Z0.TxN`5">
            <summary>
            Identifies a quintent of parametric types
            </summary>
        </member>
        <member name="T:Z0.TxN`6">
            <summary>
            Identifies a sextet of parametric types
            </summary>
        </member>
        <member name="T:Z0.TxN`7">
            <summary>
            Identifies a septet of parametric types
            </summary>
        </member>
        <member name="T:Z0.TxN`8">
            <summary>
            Identifies an octet of parametric types
            </summary>
        </member>
        <member name="T:Z0.ClaimException">
            <summary>
            Raised when a validation check has failed
            </summary>
        </member>
        <member name="T:Z0.Any`1">
            <summary>
            A parametric T-equatable value
            </summary>
        </member>
        <member name="M:Z0.VexSFp.vloads(System.Single)">
            <summary>
             __m128 _mm_load_ss (float const* mem_address) MOVSS xmm, m32
            </summary>
            <param name="x">The source value</param>
        </member>
        <member name="M:Z0.VexSFp.vloads(System.Double)">
            <summary>
             __m128d _mm_load_sd (double const* mem_address) MOVSD xmm, m64
            </summary>
            <param name="x">The source value</param>
        </member>
        <member name="M:Z0.VexSFp.vstores(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            void _mm_store_ss (float* mem_addr, __m128 a) MOVSS m32, xmm
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.VexSFp.vstores(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            void _mm_store_sd (double* mem_addr, __m128d a)MOVSD m64, xmm
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.VexSFp.convert(System.Int32,System.Runtime.Intrinsics.Vector128{System.Double}@)">
            <summary>
             __m128d _mm_cvtsi32_sd (__m128d a, int b)CVTSI2SD xmm, reg/m32
            </summary>
            <param name="x"></param>
            <param name="dst"></param>
        </member>
        <member name="M:Z0.VexSFp.convert(System.Int32,System.Runtime.Intrinsics.Vector128{System.Single}@)">
            <summary>
             __m128 _mm_cvtsi32_ss (__m128 a, int b)CVTSI2SS xmm, reg/m32
            </summary>
            <param name="src"></param>
            <param name="src"></param>
        </member>
        <member name="M:Z0.VexSFp.convert(System.Int64,System.Runtime.Intrinsics.Vector128{System.Single}@)">
            <summary>
             __m128 _mm_cvtsi64_ss (__m128 a, __int64 b)CVTSI2SS xmm, reg/m64
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
        </member>
        <member name="M:Z0.VexSFp.to32i(System.Single@)">
            <summary>
            int _mm_cvtss_si32 (__m128 a) CVTSS2SI r32, xmm/m32
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:Z0.VexSFp.to32i(System.Double@)">
            <summary>
            int _mm_cvtsd_si32 (__m128d a) CVTSD2SI r32, xmm/m64
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:Z0.VexSFp.to64i(System.Single@)">
            <summary>
            __int64 _mm_cvtss_si64 (__m128 a) CVTSS2SI r64, xmm/m32
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:Z0.VexSFp.to64i(System.Double@)">
            <summary>
            __int64 _mm_cvtsd_si64 (__m128d a) CVTSD2SI r64, xmm/m64
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:Z0.VexSFp.vadds(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_add_ss (__m128 a, __m128 b)ADDSS xmm, xmm/m32
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.VexSFp.vadds(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_add_sd (__m128d a, __m128d b)ADDSD xmm, xmm/m64
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.VexSFp.vmuls(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
             __m128 _mm_mul_ss (__m128 a, __m128 b) MULPS xmm, xmm/m32
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.VexSFp.vmuls(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
             __m128d _mm_mul_sd (__m128d a, __m128d b) MULSD xmm, xmm/m64
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.VexSFp.vfmadds(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_fmadd_ss (__m128 a, __m128 b, __m128 c) VFMADDSS xmm, xmm, xmm/m32
            </summary>
            <param name="x">The first operand</param>
            <param name="y">The second operand</param>
            <param name="z">The third operand</param>
        </member>
        <member name="M:Z0.VexSFp.vfmadds(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_fmadd_sd (__m128d a, __m128d b, __m128d c) VFMADDSS xmm, xmm, xmm/m64
            </summary>
            <param name="x">The first operand</param>
            <param name="y">The second operand</param>
            <param name="z">The third operand</param>
        </member>
        <member name="M:Z0.VexSFp.fmsub(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_fmsub_ss (__m128 a, __m128 b, __m128 c)VFMSUBSS xmm, xmm, xmm/m32
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:Z0.VexSFp.fmsub(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_fmsub_sd (__m128d a, __m128d b, __m128d c)VFMSUBSD xmm, xmm, xmm/m64
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:Z0.VexSFp.fnmadd(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_fnmadd_ss (__m128 a, __m128 b, __m128 c) VFNMADDSS xmm, xmm, xmm/m32
            dst = -(x*y + z)
            </summary>
            <param name="x">The first operand</param>
            <param name="y">The second operand</param>
            <param name="z">The third operand</param>
        </member>
        <member name="M:Z0.VexSFp.fnmadd(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_fnmadd_sd (__m128d a, __m128d b, __m128d c) VFNMADDSD xmm, xmm, xmm/m64
            dst = -(x*y + z)
            </summary>
            <param name="x">The first operand</param>
            <param name="y">The second operand</param>
            <param name="z">The third operand</param>
        </member>
        <member name="M:Z0.VexSFp.div(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_div_ss (__m128 a, __m128 b) DIVSS xmm, xmm/m32
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.VexSFp.div(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
             __m128d _mm_div_sd (__m128d a, __m128d b) DIVSD xmm, xmm/m64
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.VexSFp.sub(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_sub_ss (__m128 a, __m128 b) SUBSS xmm, xmm/m32
            </summary>
            <param name="x">The left vectorized scalar</param>
            <param name="y">The right vectorized scalar</param>
        </member>
        <member name="M:Z0.VexSFp.sub(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_sub_sd (__m128d a, __m128d b) SUBSD xmm, xmm/m64
            </summary>
            <param name="x">The left vectorized scalar</param>
            <param name="y">The right vectorized scalar</param>
        </member>
        <member name="M:Z0.VexSFp.max(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_max_ss (__m128 a, __m128 b) MAXSS xmm, xmm/m32
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.VexSFp.max(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_max_sd (__m128d a, __m128d b) MAXSD xmm, xmm/m64
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.VexSFp.min(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
             __m128 _mm_min_ss (__m128 a, __m128 b) MINSS xmm, xmm/m32
            </summary>
            <param name="x">The left vectorized scalar</param>
            <param name="y">The right vectorized scalar</param>
        </member>
        <member name="M:Z0.VexSFp.min(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_min_sd (__m128d a, __m128d b) MINSD xmm, xmm/m64
            </summary>
            <param name="x">The left vectorized scalar</param>
            <param name="y">The right vectorized scalar</param>
        </member>
        <member name="M:Z0.VexSFp.eq(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
             int _mm_ucomieq_ss (__m128 a, __m128 b)UCOMISS xmm, xmm/m32
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.VexSFp.eq(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            int _mm_ucomieq_sd (__m128d a, __m128d b)UCOMISD xmm, xmm/m64
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.VexSFp.neq(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            int _mm_comineq_ss (__m128 a, __m128 b)COMISS xmm, xmm/m32
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.VexSFp.neq(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
             int _mm_comineq_sd (__m128d a, __m128d b)COMISD xmm, xmm/m64
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.VexSFp.gt(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            int _mm_comigt_ss (__m128 a, __m128 b)COMISS xmm, xmm/m32
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.VexSFp.gt(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            int _mm_comigt_sd (__m128d a, __m128d b)COMISD xmm, xmm/m64
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.VexSFp.gteq(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            int _mm_comige_ss (__m128 a, __m128 b)COMISS xmm, xmm/m32
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.VexSFp.gteq(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            int _mm_comige_sd (__m128d a, __m128d b)COMISD xmm, xmm/m64
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.VexSFp.ngt(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_cmpngt_ss (__m128 a, __m128 b)CMPSS xmm, xmm/m32, imm8(2)
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.VexSFp.ngt(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_cmpngt_sd (__m128d a, __m128d b)CMPSD xmm, xmm/m64, imm8(2)
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.VexSFp.lt(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            int _mm_comilt_ss (__m128 a, __m128 b)COMISS xmm, xmm/m32
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.VexSFp.lt(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            int _mm_comilt_sd (__m128d a, __m128d b)COMISD xmm, xmm/m64
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.VexSFp.nlt(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
             __m128 _mm_cmpnlt_ss (__m128 a, __m128 b) CMPSS xmm, xmm/m32, imm8(5)
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.VexSFp.nlt(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_cmpnlt_sd (__m128d a, __m128d b) CMPSD xmm, xmm/m64, imm8(5)
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.VexSFp.lteq(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
             int _mm_ucomile_ss (__m128 a, __m128 b) UCOMISS xmm, xmm/m32
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.VexSFp.lteq(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            int _mm_ucomile_sd (__m128d a, __m128d b)UCOMISD xmm, xmm/m64
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.VexSFp.cmp(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single},Z0.FpCmpMode)">
            <summary>
            __m128 _mm_cmp_ss (__m128 a, __m128 b, const int imm8) VCMPSD xmm, xmm, xmm/m64, imm8
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="mode"></param>
        </member>
        <member name="M:Z0.VexSFp.cmp(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double},Z0.FpCmpMode)">
            <summary>
            __m128d _mm_cmp_sd (__m128d a, __m128d b, const int imm8) VCMPSS xmm, xmm, xmm/m32, imm8
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="mode"></param>
        </member>
        <member name="M:Z0.VexSFp.ceil(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_ceil_ss (__m128 a)ROUNDSD xmm, xmm/m128, imm8(10)
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:Z0.VexSFp.ceil(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_ceil_sd (__m128d a)ROUNDSD xmm, xmm/m128, imm8(10)
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:Z0.VexSFp.floor(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
             __m128 _mm_ceil_ss (__m128 a)ROUNDSD xmm, xmm/m128, imm8(10)
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:Z0.VexSFp.floor(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_ceil_sd (__m128d a)ROUNDSD xmm, xmm/m128, imm8(10)
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:Z0.VexSFp.rcp(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_rcp_ss (__m128 a) RCPSS xmm, xmm/m32
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.VexSFp.sqrt(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_sqrt_ss (__m128 a) SQRTSS xmm, xmm/m32
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:Z0.VexSFp.sqrt(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            _m128d _mm_sqrt_sd (__m128d a) SQRTSD xmm, xmm/64
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:Z0.VexSFp.rsqrt(System.Runtime.Intrinsics.Vector128{System.Single}@)">
            <summary>
            __m128 _mm_rsqrt_ss (__m128 a) RSQRTSS xmm, xmm/m32
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:Z0.VexSFp.IsNaN(System.Single)">
            <summary>
            Returns true if a value is the NaN representative
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.VexSFp.IsNaN(System.Double)">
            <summary>
            Returns true if a value is the NaN representative
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.VexSFp.IsNaN(System.Runtime.Intrinsics.Vector128{System.Single},System.Byte)">
            <summary>
            Determines whether the first component is NaN
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.VexSFp.IsNaN(System.Runtime.Intrinsics.Vector128{System.Double},System.Byte)">
            <summary>
            Determines whether the first component is NaN
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.VexKinds.Types128">
            <summary>
            Closed vector types of width 128
            </summary>
        </member>
        <member name="M:Z0.VexKinds.Types256">
            <summary>
            Closed vector types of width 256
            </summary>
        </member>
        <member name="M:Z0.VexKinds.Types512">
            <summary>
            Closed vector types of width 512
            </summary>
        </member>
        <member name="M:Z0.VexKinds.celltype(Z0.VectorKind)">
            <summary>
            Returns the clr cell type of a vector of specified kind
            </summary>
            <param name="kind">The vector kind</param>
        </member>
        <member name="M:Z0.VexKinds.closed(System.Type,Z0.W128)">
            <summary>
            Returns true if a type is a closed 128-bit intrinsic vector
            </summary>
            <param name="param">The source parameter</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.VexKinds.closed(System.Type,Z0.W256)">
            <summary>
            Returns true if a type is a closed 256-bit intrinsic vector
            </summary>
            <param name="param">The source parameter</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.VexKinds.closed(System.Type,Z0.W512)">
            <summary>
            Returns true if a type is a closed 512-bit intrinsic vector
            </summary>
            <param name="param">The source parameter</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.VexKinds.closed(System.Reflection.ParameterInfo,Z0.W128)">
            <summary>
            Returns true if a method parameter is a closed 128-bit intrinsic vector
            </summary>
            <param name="p">The source parameter</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.VexKinds.closed(System.Reflection.ParameterInfo,Z0.W256)">
            <summary>
            Returns true if a method parameter is a closed 256-bit intrinsic vector
            </summary>
            <param name="p">The source parameter</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.VexKinds.closed(System.Reflection.ParameterInfo,Z0.W512)">
            <summary>
            Returns true if a method parameter is a closed 512-bit intrinsic vector
            </summary>
            <param name="p">The source parameter</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.VexKinds.width(Z0.VectorKind)">
            <summary>
            Determines the number of bits covered by a k-kinded vector
            </summary>
            <param name="k">The type kine</param>
        </member>
        <member name="M:Z0.VexKinds.size(Z0.VectorKind)">
            <summary>
            Determines the number of bytes covered by a k-kinded type
            </summary>
            <param name="k">The type kine</param>
        </member>
        <member name="M:Z0.VexKinds.segwidth(Z0.VectorKind)">
            <summary>
            Determines the component width of a k-kinded vector
            </summary>
            <param name="k">The vector kind</param>
        </member>
        <member name="M:Z0.VexKinds.unsigned(Z0.VectorKind)">
            <summary>
            Determines whether a classified vector is defined over primal unsigned integer components
            </summary>
            <param name="k">The vector classifier</param>
        </member>
        <member name="M:Z0.VexKinds.signed(Z0.VectorKind)">
            <summary>
            Determines whether a classified vector is defined over primal signed integer components
            </summary>
            <param name="k">The vector classifier</param>
        </member>
        <member name="M:Z0.VexKinds.floating(Z0.VectorKind)">
            <summary>
            Determines whether a classified vector is defined over floating-point components
            </summary>
            <param name="k">The vector classifier</param>
        </member>
        <member name="M:Z0.VexKinds.integral(Z0.VectorKind)">
            <summary>
            Determines whether a classified vector is defined over primal integer components
            </summary>
            <param name="k">The vector classifier</param>
        </member>
        <member name="M:Z0.VexKinds.kind``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>
            Computes a vector kind classifier from a 128-bit vector instance
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.VexKinds.kind``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>
            Computes a vector kind classifier from a 256-bit vector instance
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.VexKinds.kind``1(Z0.Vector512{``0})">
            <summary>
            Computes a vector kind classifier from a 512-bit vector instance
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.VexKinds.kind``1(Z0.W128,``0)">
            <summary>
            Computes a 128-bit vector kind classifier for a parametrically-specified cell type
            </summary>
            <param name="w">The vector width</param>
            <param name="t">A representative cell value</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.VexKinds.kind``1(Z0.W256,``0)">
            <summary>
            Computes a 256-bit vector kind classifier for a parametrically-specified cell type
            </summary>
            <param name="w">The vector width</param>
            <param name="t">A representative cell value</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.VexKinds.kind``1(Z0.W512,``0)">
            <summary>
            Computes a 512-bit vector kind classifier for a parametrically-specified cell type
            </summary>
            <param name="w">The vector width</param>
            <param name="t">A representative cell value</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.VexKinds.kind``2(``0,``1)">
            <summary>
            Computes the vector kind classifier determined by parametric width and cell types
            </summary>
            <param name="w">A width type representative</param>
            <param name="t">A cell type representative</param>
            <typeparam name="W">The width type</typeparam>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.VexKinds.kind(System.Type)">
            <summary>
            Computes the vector kind classifier determined by a system type
            </summary>
            <param name="src">The source type</param>
        </member>
        <member name="M:Z0.VexKinds.open(System.Type,Z0.W128)">
            <summary>
            Returns true if a type is an open generic 128-bit intrinsic vector
            </summary>
            <param name="t">The type to examine</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.VexKinds.open(System.Type,Z0.W256)">
            <summary>
            Returns true if a type is an open generic 256-bit intrinsic vector
            </summary>
            <param name="t">The type to examine</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.VexKinds.open(System.Type,Z0.W512)">
            <summary>
            Returns true if a type is an open generic 512-bit intrinsic vector
            </summary>
            <param name="t">The type to examine</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.VexKinds.test(System.Type)">
            <summary>
            Determines whether a type is classified as an intrinsic vector
            </summary>
            <param name="t">The type to test</param>
        </member>
        <member name="M:Z0.VexKinds.test(System.Type,System.Nullable{System.Int32})">
            <summary>
            Determines whether a type is an intrinsic vector of specified width
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.VexKinds.test(Z0.VectorKind,System.SByte)">
            <summary>
            Determines whether a vector of specified kind has a singed 8-bit cell type
            </summary>
            <param name="k">The vector kind</param>
            <param name="t">The type to match as specified by a representative value</param>
        </member>
        <member name="M:Z0.VexKinds.test(Z0.VectorKind,System.Byte)">
            <summary>
            Determines whether a vector of specified kind has an unsigned 8-bit cell type
            </summary>
            <param name="k">The vector kind</param>
            <param name="t">The type to match as specified by a representative value</param>
        </member>
        <member name="M:Z0.VexKinds.test(Z0.VectorKind,System.Int16)">
            <summary>
            Determines whether a vector of specified kind has a singed 16-bit cell type
            </summary>
            <param name="k">The vector kind</param>
            <param name="t">The type to match as specified by a representative value</param>
        </member>
        <member name="M:Z0.VexKinds.test(Z0.VectorKind,System.UInt16)">
            <summary>
            Determines whether a vector of specified kind has an unsigned 16-bit cell type
            </summary>
            <param name="k">The vector kind</param>
            <param name="t">The type to match as specified by a representative value</param>
        </member>
        <member name="M:Z0.VexKinds.test(Z0.VectorKind,System.Int32)">
            <summary>
            Determines whether a vector of specified kind has a singed 32-bit cell type
            </summary>
            <param name="k">The vector kind</param>
            <param name="t">The type to match as specified by a representative value</param>
        </member>
        <member name="M:Z0.VexKinds.test(Z0.VectorKind,System.UInt32)">
            <summary>
            Determines whether a vector of specified kind has an unsigned 32-bit cell type
            </summary>
            <param name="k">The vector kind</param>
            <param name="t">The type to match as specified by a representative value</param>
        </member>
        <member name="M:Z0.VexKinds.test(Z0.VectorKind,System.Int64)">
            <summary>
            Determines whether a vector of specified kind has a singed 64-bit cell type
            </summary>
            <param name="k">The vector kind</param>
            <param name="t">The type to match as specified by a representative value</param>
        </member>
        <member name="M:Z0.VexKinds.test(Z0.VectorKind,System.UInt64)">
            <summary>
            Determines whether a vector of specified kind has an unsigned 64-bit cell type
            </summary>
            <param name="k">The vector kind</param>
            <param name="t">The type to match as specified by a representative value</param>
        </member>
        <member name="M:Z0.VexKinds.test(Z0.VectorKind,System.Single)">
            <summary>
            Determines whether a vector of specified kind has a 32-bit floating-point cell type
            </summary>
            <param name="k">The vector kind</param>
            <param name="t">The type to match as specified by a representative value</param>
        </member>
        <member name="M:Z0.VexKinds.test(Z0.VectorKind,System.Double)">
            <summary>
            Determines whether a vector of specified kind has a 64-bit floating-point cell type
            </summary>
            <param name="k">The vector kind</param>
            <param name="t">The type to match as specified by a representative value</param>
        </member>
        <member name="M:Z0.VexKinds.test(System.Type,Z0.W128,System.Type)">
            <summary>
            Determines whether a type is a 128-bit intrinsic vector closed over a specified type
            </summary>
            <param name="t">The type to examine</param>
            <param name="w">The vector width</param>
            <param name="tCell">The vector cell type</param>
        </member>
        <member name="M:Z0.VexKinds.test(System.Type,Z0.W256,System.Type)">
            <summary>
            Determines whether a type is a 256-bit intrinsic vector closed over a specified type
            </summary>
            <param name="t">The type to examine</param>
            <param name="w">The vector width</param>
            <param name="tCell">The vector cell type</param>
        </member>
        <member name="M:Z0.VexKinds.test(System.Type,Z0.W512,System.Type)">
            <summary>
            Determines whether a type is a 512-bit intrinsic vector closed over a specified type
            </summary>
            <param name="t">The type to examine</param>
            <param name="w">The vector width</param>
            <param name="tCell">The vector cell type</param>
        </member>
        <member name="M:Z0.VexKinds.test(System.Type,Z0.W128)">
            <summary>
            Determines whether a type is a 128-bit intrinsic vector
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.VexKinds.test(System.Type,Z0.W256)">
            <summary>
            Determines whether a type is a 256-bit intrinsic vector
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.VexKinds.test(System.Type,Z0.W512)">
            <summary>
            Determines whether a type is a 512-bit intrinsic vector
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.VexKinds.test(System.Reflection.ParameterInfo)">
            <summary>
            Determines whether a parameter is of some intrinsic vector type
            </summary>
            <param name="p">The parameter to examine</param>
        </member>
        <member name="M:Z0.VexKinds.test(System.Reflection.ParameterInfo,Z0.W128)">
            <summary>
            Determines whether a parameter accepts a 128-bit intrinsic vector
            </summary>
            <param name="p">The parameter to examine</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.VexKinds.test(System.Reflection.ParameterInfo,Z0.W256)">
            <summary>
            Determines whether a parameter accepts a 256-bit intrinsic vector
            </summary>
            <param name="p">The parameter to examine</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.VexKinds.test(System.Reflection.ParameterInfo,Z0.W512)">
            <summary>
            Determines whether a parameter accepts a 512-bit intrinsic vector
            </summary>
            <param name="p">The parameter to examine</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.VexKinds.test(System.Reflection.ParameterInfo,Z0.W128,System.Type)">
            <summary>
            Returns true if a method parameter is a 128-bit intrinsic vector closed over a specified argument type
            </summary>
            <param name="p">The source parameter</param>
            <param name="w">The vector width</param>
            <param name="tCell">The argument type to match</param>
        </member>
        <member name="M:Z0.VexKinds.test(System.Reflection.ParameterInfo,Z0.W256,System.Type)">
            <summary>
            Returns true if a method parameter is a 256-bit intrinsic vector closed over a specified argument type
            </summary>
            <param name="p">The source parameter</param>
            <param name="w">The vector width</param>
            <param name="tCell">The argument type to match</param>
        </member>
        <member name="M:Z0.VexKinds.test(System.Reflection.ParameterInfo,Z0.W512,System.Type)">
            <summary>
            Returns true if a method parameter is a 512-bit intrinsic vector closed over a specified argument type
            </summary>
            <param name="p">The source parameter</param>
            <param name="w">The vector width</param>
            <param name="tCell">The argument type to match</param>
        </member>
        <member name="M:Z0.VexPop.vpop(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            Computes the population count of the content of 3 128-bit vectors
            </summary>
            <param name="x">The first vector</param>
            <param name="y">The second vector</param>
            <param name="z">The third vector</param>
            <remarks>
            This is a vectorization of the scalar algorithm found at https://www.chessprogramming.org/Population_Count
            </remarks>
        </member>
        <member name="M:Z0.VexPop.vpop(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            Computes the population count of the content of 3 256-bit vectors
            </summary>
            <param name="a">The first vector</param>
            <param name="b">The second vector</param>
            <param name="c">The third vector</param>
            <remarks>
            This is a vectorization of the scalar algorithm found at https://www.chessprogramming.org/Population_Count
            </remarks>
        </member>
        <member name="M:Z0.VexReflex.IsVector(System.Type)">
            <summary>
            Determines whether a type is classified as an intrinsic vector
            </summary>
            <param name="t">The type to test</param>
        </member>
        <member name="M:Z0.VexReflex.AcceptsVector(System.Reflection.MethodInfo)">
            <summary>
            Determines whether a method accepts an intrinsic vector in some parameter slot
            </summary>
            <param name="src">The method to test</param>
        </member>
        <member name="M:Z0.VexReflex.AcceptsVector(System.Reflection.MethodInfo,System.Int32)">
            <summary>
            Determines whether a method accepts an intrinsic vector at an index-identified parameter
            </summary>
            <param name="src">The method to test</param>
            <param name="index">THe parameter index to match</param>
        </member>
        <member name="M:Z0.VexReflex.AcceptsVector(System.Reflection.MethodInfo,System.Int32,Z0.W512)">
            <summary>
            Determines whether a method accepts a 128-bit intrinsic vector at an index-identified parameter
            </summary>
            <param name="src">The method to test</param>
            <param name="index">THe parameter index to match</param>
            <param name="w">The width to match</param>
        </member>
        <member name="M:Z0.VexReflex.AcceptsVector(System.Reflection.MethodInfo,System.Int32,Z0.W128,System.Type)">
            <summary>
            Determines whether a method accepts a 128-bit intrinsic vector at an index-identified parameter of specified cell type
            </summary>
            <param name="src">The method to test</param>
            <param name="index">THe parameter index to match</param>
            <param name="w">The width to match</param>
            <param name="tCell">The cell type to match</param>
        </member>
        <member name="M:Z0.VexReflex.AcceptsVector(System.Reflection.MethodInfo,System.Int32,Z0.W128)">
            <summary>
            Determines whether a method accepts a 128-bit intrinsic vector at an index-identified parameter
            </summary>
            <param name="src">The method to test</param>
            <param name="index">THe parameter index to match</param>
            <param name="w">The width to match</param>
        </member>
        <member name="M:Z0.VexReflex.AcceptsVector(System.Reflection.MethodInfo,System.Int32,Z0.W256)">
            <summary>
            Determines whether a method accepts a 128-bit intrinsic vector at an index-identified parameter
            </summary>
            <param name="src">The method to test</param>
            <param name="index">THe parameter index to match</param>
            <param name="w">The width to match</param>
        </member>
        <member name="M:Z0.VexReflex.AcceptsVector(System.Reflection.MethodInfo,System.Int32,Z0.W256,System.Type)">
            <summary>
            Determines whether a method accepts a 256-bit intrinsic vector at an index-identified parameter of specified cell type
            </summary>
            <param name="src">The method to test</param>
            <param name="index">THe parameter index to match</param>
            <param name="w">The width to match</param>
            <param name="tCell">The cell type to match</param>
        </member>
        <member name="M:Z0.VexReflex.AcceptsVector(System.Reflection.MethodInfo,System.Int32,Z0.W512,System.Type)">
            <summary>
            Determines whether a method accepts a 512-bit intrinsic vector at an index-identified parameter of specified cell type
            </summary>
            <param name="src">The method to test</param>
            <param name="index">The parameter index to match</param>
            <param name="w">The width to match</param>
            <param name="tCell">The cell type to match</param>
        </member>
        <member name="M:Z0.VexReflex.ReturnsVector(System.Reflection.MethodInfo,Z0.W128)">
            <summary>
            Determines whether a method returns a 128-bit intrinsic vector
            </summary>
            <param name="src">The method to test</param>
        </member>
        <member name="M:Z0.VexReflex.ReturnsVector(System.Reflection.MethodInfo,Z0.W256)">
            <summary>
            Determines whether a method returns a 256-bit intrinsic vector
            </summary>
            <param name="src">The method to test</param>
        </member>
        <member name="M:Z0.VexReflex.ReturnsVector(System.Reflection.MethodInfo,Z0.W512)">
            <summary>
            Determines whether a method returns a 256-bit intrinsic vector
            </summary>
            <param name="src">The method to test</param>
        </member>
        <member name="M:Z0.VexReflex.ReturnsVector(System.Reflection.MethodInfo,Z0.W128,System.Type)">
            <summary>
            Determines whether a method returns a 128-bit intrinsic vector of specified cell type
            </summary>
            <param name="src">The method to test</param>
            <param name="w">The width to match</param>
            <param name="tCell">The cell type to match</param>
        </member>
        <member name="M:Z0.VexReflex.ReturnsVector(System.Reflection.MethodInfo,Z0.W256,System.Type)">
            <summary>
            Determines whether a method returns a 256-bit intrinsic vector of specified cell type
            </summary>
            <param name="src">The method to test</param>
            <param name="w">The width to match</param>
            <param name="tCell">The cell type to match</param>
        </member>
        <member name="M:Z0.VexReflex.ReturnsVector(System.Reflection.MethodInfo,Z0.W512,System.Type)">
            <summary>
            Determines whether a method returns a 512-bit intrinsic vector with of specified cell type
            </summary>
            <param name="src">The method to test</param>
            <param name="w">The width to match</param>
            <param name="tCell">The cell type to match</param>
        </member>
        <member name="M:Z0.VexReflex.IsVectorized(System.Reflection.MethodInfo,System.Nullable{System.Int32},System.Boolean)">
            <summary>
            Determines whether a method has intrinsic paremeters or return type of specified width
            </summary>
            <param name="src">The method to test</param>
            <param name="width">The required vector width</param>
            <param name="total">Whether all parameters and return type must be intrinsic</param>
        </member>
        <member name="M:Z0.VexReflex.IsVectorized(System.Reflection.MethodInfo)">
            <summary>
            Determines whether a method has intrinsic parameters or return type
            </summary>
            <param name="src">The method to test</param>
        </member>
        <member name="M:Z0.VexReflex.IsVectorized(System.Reflection.MethodInfo,Z0.W128)">
            <summary>
            Determines whether a method has at least one 128-bit intrinsic vector parameter
            </summary>
            <param name="m">The method to examine</param>
            <param name="w">The width to match</param>
        </member>
        <member name="M:Z0.VexReflex.IsVectorized(System.Reflection.MethodInfo,Z0.W256)">
            <summary>
            Determines whether a method has at least one 128-bit intrinsic vector parameter
            </summary>
            <param name="m">The method to examine</param>
            <param name="w">The width to match</param>
        </member>
        <member name="M:Z0.VexReflex.IsVectorized(System.Reflection.MethodInfo,Z0.W512)">
            <summary>
            Determines whether a method has at least one 128-bit intrinsic vector parameter
            </summary>
            <param name="src">The method to examine</param>
            <param name="w">The width to match</param>
        </member>
        <member name="M:Z0.VexReflex.IsVectorized(System.Reflection.MethodInfo,Z0.W128,System.Type)">
            <summary>
            Determines whether a method has at least one 128-bit intrinsic vector parameter closed over a specified type
            </summary>
            <param name="src">The method to examine</param>
            <param name="w">The width to match</param>
        </member>
        <member name="M:Z0.VexReflex.IsVectorized(System.Reflection.MethodInfo,Z0.W256,System.Type)">
            <summary>
            Determines whether a method has at least one 256-bit intrinsic vector parameter closed over a specified type
            </summary>
            <param name="src">The method to examine</param>
            <param name="w">The width to match</param>
        </member>
        <member name="M:Z0.VexReflex.IsVectorized(System.Reflection.MethodInfo,Z0.W512,System.Type)">
            <summary>
            Determines whether a method has at least one 512-bit intrinsic vector parameter closed over a specified type
            </summary>
            <param name="src">The method to examine</param>
            <param name="w">The width to match</param>
        </member>
        <member name="M:Z0.VexReflex.IsVectorized(System.Reflection.MethodInfo,Z0.W128,Z0.GenericState)">
            <summary>
            Selects vectorized methods from a source stream
            </summary>
            <param name="src">The source stream</param>
            <param name="w">The vector width</param>
            <param name="g">The generic partition from which methods should be selected</param>
        </member>
        <member name="M:Z0.VexReflex.IsVectorized(System.Reflection.MethodInfo,Z0.W256,Z0.GenericState)">
            <summary>
            Selects vectorized methods from a source stream
            </summary>
            <param name="src">The source stream</param>
            <param name="w">The vector width</param>
            <param name="g">The generic partition from which methods should be selected</param>
        </member>
        <member name="M:Z0.VexReflex.IsVectorized(System.Reflection.MethodInfo,Z0.W512,Z0.GenericState)">
            <summary>
            Selects vectorized methods from a source stream
            </summary>
            <param name="src">The source stream</param>
            <param name="w">The vector width</param>
            <param name="g">The generic partition from which methods should be selected</param>
        </member>
        <member name="M:Z0.XVexKinds.VectorKind``1(Z0.W128)">
            <summary>
            Classifies a 128-bit vector
            </summary>
            <param name="w">The vector width</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.XVexKinds.VectorKind``1(Z0.W256)">
            <summary>
            Classifies a 256-bit vector
            </summary>
            <param name="w">The vector width</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.XVexKinds.VectorKind``1(Z0.W512)">
            <summary>
            Classifies a 512-bit vector
            </summary>
            <param name="w">The vector width</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.XVexKinds.IsVectorizedImm(System.Reflection.MethodInfo,Z0.ScalarRefinementKind)">
            <summary>
            Determines whether a method is (partially) vectorized and accepts an immediate value
            </summary>
            <param name="src">The method to query</param>
        </member>
        <member name="M:Z0.XVexKinds.IsVectorizedUnaryImm(System.Reflection.MethodInfo,Z0.ScalarRefinementKind)">
            <summary>
            Determines whether a method is a vectorized unary operator that accepts an immediate value
            </summary>
            <param name="src">The method to query</param>
        </member>
        <member name="M:Z0.XVexKinds.IsVectorizedBinaryImm(System.Reflection.MethodInfo,Z0.ScalarRefinementKind)">
            <summary>
            Determines whether a method is a vectorized binary operator that accepts an immediate value
            </summary>
            <param name="src">The method to query</param>
        </member>
        <member name="M:Z0.XVexKinds.IsFullyVectorized(System.Reflection.MethodInfo)">
            <summary>
            Determines whether a method has intrinsic parameters or return type
            </summary>
            <param name="src">The method to test</param>
        </member>
        <member name="M:Z0.XVexKinds.IsFullyVectorized(System.Reflection.MethodInfo,Z0.W128)">
            <summary>
            Determines whether all parameters of a method are 128-bit intrinsic vectors
            </summary>
            <param name="src">The method to examine</param>
            <param name="w">The width to match</param>
        </member>
        <member name="M:Z0.XVexKinds.IsFullyVectorized(System.Reflection.MethodInfo,Z0.W256)">
            <summary>
            Determines whether all parameters of a method are 256-bit intrinsic vectors
            </summary>
            <param name="src">The method to examine</param>
            <param name="w">The width to match</param>
        </member>
        <member name="M:Z0.XVexKinds.IsFullyVectorized(System.Reflection.MethodInfo,Z0.W512)">
            <summary>
            Determines whether all parameters of a method are 256-bit intrinsic vectors
            </summary>
            <param name="src">The method to examine</param>
            <param name="w">The width to match</param>
        </member>
        <member name="M:Z0.XVexKinds.IsFullyVectorized(System.Reflection.MethodInfo,Z0.W128,System.Type)">
            <summary>
            Determines whether all parameters of a method are 128-bit intrinsic vectors with a specified cell type
            </summary>
            <param name="src">The method to test</param>
            <param name="w">The width to match</param>
            <param name="tCell">The cell type to match</param>
        </member>
        <member name="M:Z0.XVexKinds.IsFullyVectorized(System.Reflection.MethodInfo,Z0.W256,System.Type)">
            <summary>
            Determines whether all parameters of a method are 256-bit intrinsic vectors with a specified cell type
            </summary>
            <param name="src">The method to test</param>
            <param name="w">The width to match</param>
            <param name="tCell">The cell type to match</param>
        </member>
        <member name="M:Z0.XVexKinds.IsFullyVectorized(System.Reflection.MethodInfo,Z0.W512,System.Type)">
            <summary>
            Determines whether all parameters of a method are 512-bit intrinsic vectors with a specified cell type
            </summary>
            <param name="src">The method to test</param>
            <param name="w">The width to match</param>
            <param name="tCell">The cell type to match</param>
        </member>
        <member name="M:Z0.XVexKinds.IsKind(System.Reflection.MethodInfo,Z0.Vec128Type,System.Boolean)">
            <summary>
            Determines whether a method has intrinsic parameters or return type of specified width
            </summary>
            <param name="m">The method to examine</param>
            <param name="width">The required vector width</param>
            <param name="total">Whether all parameters and return type must be intrinsic</param>
        </member>
        <member name="M:Z0.XVexKinds.IsKind(System.Reflection.MethodInfo,Z0.Vec256Type,System.Boolean)">
            <summary>
            Determines whether a method is of characterized vector kind
            </summary>
            <param name="m">The method to examine</param>
            <param name="vk">The vector kind under test</param>
            <param name="total">Whether all parameters and return type must be intrinsic</param>
        </member>
        <member name="M:Z0.XVexKinds.IsKind(System.Reflection.MethodInfo,Z0.Vec512Type,System.Boolean)">
            <summary>
            Determines whether a method is of characterized vector kind
            </summary>
            <param name="m">The method to examine</param>
            <param name="vk">The vector kind under test</param>
            <param name="total">Whether all parameters and return type must be intrinsic</param>
        </member>
        <member name="M:Z0.XVexKinds.IsKind``1(System.Reflection.MethodInfo,Z0.Vec128Kind{``0})">
            <summary>
            Determines whether a method is of characterized vector kind
            </summary>
            <param name="m">The method to examine</param>
            <param name="vk">The vector kind under test</param>
            <param name="total">Whether all parameters and return type must be intrinsic</param>
        </member>
        <member name="M:Z0.XVexKinds.IsKind``1(System.Reflection.MethodInfo,Z0.Vec256Kind{``0})">
            <summary>
            Determines whether a method is of characterized vector kind
            </summary>
            <param name="m">The method to examine</param>
            <param name="vk">The vector kind under test</param>
            <param name="total">Whether all parameters and return type must be intrinsic</param>
        </member>
        <member name="M:Z0.XVexKinds.IsKind``1(System.Reflection.MethodInfo,Z0.Vec512Kind{``0})">
            <summary>
            Determines whether a method is of characterized vector kind
            </summary>
            <param name="m">The method to examine</param>
            <param name="vk">The vector kind under test</param>
            <param name="total">Whether all parameters and return type must be intrinsic</param>
        </member>
        <member name="M:Z0.XVexKinds.IsVectorFactory(System.Reflection.MethodInfo)">
            <summary>
            Determines whether a method produces, but does not accept, vector values
            </summary>
            <param name="m">The method to examine</param>
        </member>
        <member name="M:Z0.XVexKinds.IsVectorized(System.Reflection.MethodInfo,Z0.W128)">
            <summary>
            Determines whether a method has at least one 128-bit intrinsic vector parameter
            </summary>
            <param name="src">The method to examine</param>
            <param name="w">The width to match</param>
        </member>
        <member name="M:Z0.XVexKinds.IsVectorized(System.Reflection.MethodInfo,Z0.W256)">
            <summary>
            Determines whether a method has at least one 128-bit intrinsic vector parameter
            </summary>
            <param name="src">The method to examine</param>
            <param name="w">The width to match</param>
        </member>
        <member name="M:Z0.XVexKinds.IsVectorized(System.Reflection.MethodInfo)">
            <summary>
            Determines whether a method has intrinsic parameters or return type
            </summary>
            <param name="src">The method to test</param>
        </member>
        <member name="M:Z0.XVexKinds.IsVectorized(System.Reflection.MethodInfo,Z0.W512)">
            <summary>
            Determines whether a method has at least one 128-bit intrinsic vector parameter
            </summary>
            <param name="m">The method to examine</param>
            <param name="w">The width to match</param>
        </member>
        <member name="M:Z0.XVexKinds.IsVectorized(System.Reflection.MethodInfo,Z0.W128,System.Type)">
            <summary>
            Determines whether a method has at least one 128-bit intrinsic vector parameter closed over a specified type
            </summary>
            <param name="m">The method to examine</param>
            <param name="w">The width to match</param>
        </member>
        <member name="M:Z0.XVexKinds.IsVectorized(System.Reflection.MethodInfo,Z0.W256,System.Type)">
            <summary>
            Determines whether a method has at least one 256-bit intrinsic vector parameter closed over a specified type
            </summary>
            <param name="src">The method to examine</param>
            <param name="w">The width to match</param>
        </member>
        <member name="M:Z0.XVexKinds.IsVectorized(System.Reflection.MethodInfo,Z0.W512,System.Type)">
            <summary>
            Determines whether a method has at least one 512-bit intrinsic vector parameter closed over a specified type
            </summary>
            <param name="src">The method to examine</param>
            <param name="w">The width to match</param>
        </member>
        <member name="M:Z0.XVexKinds.IsVectorized(System.Reflection.MethodInfo,Z0.W128,Z0.GenericState)">
            <summary>
            Selects vectorized methods from a source stream
            </summary>
            <param name="src">The data source</param>
            <param name="w">The vector width</param>
            <param name="g">The generic partition from which methods should be selected</param>
        </member>
        <member name="M:Z0.XVexKinds.IsVectorized(System.Reflection.MethodInfo,Z0.W256,Z0.GenericState)">
            <summary>
            Selects vectorized methods from a source stream
            </summary>
            <param name="src">The data source</param>
            <param name="w">The vector width</param>
            <param name="g">The generic partition from which methods should be selected</param>
        </member>
        <member name="M:Z0.XVexKinds.IsVectorized(System.Reflection.MethodInfo,Z0.W512,Z0.GenericState)">
            <summary>
            Selects vectorized methods from a source stream
            </summary>
            <param name="src">The data source</param>
            <param name="w">The vector width</param>
            <param name="g">The generic partition from which methods should be selected</param>
        </member>
        <member name="M:Z0.XVexKinds.IsVectorizedOperator(System.Reflection.MethodInfo)">
            <summary>
            Determines whether a method is a vectorized operator which, by definition, is an operator
            (which, by definition, is an homogenous function) with a vectorized operand which, by definition,
            is an operand of intrinsic vector type (which, by definition, is one of the system-defined intrinsic vector types
            or a custom intrinsic vector type)
            </summary>
            <param name="src">The method to test</param>
        </member>
        <member name="M:Z0.XVexKinds.IsClosedVector(System.Reflection.ParameterInfo,Z0.W128)">
            <summary>
            Returns true if a method parameter is a closed 128-bit intrinsic vector
            </summary>
            <param name="p">The source parameter</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.XVexKinds.IsClosedVector(System.Reflection.ParameterInfo,Z0.W256)">
            <summary>
            Returns true if a method parameter is a closed 256-bit intrinsic vector
            </summary>
            <param name="p">The source parameter</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.XVexKinds.IsClosedVector(System.Reflection.ParameterInfo,Z0.W512)">
            <summary>
            Returns true if a method parameter is a closed 512-bit intrinsic vector
            </summary>
            <param name="p">The source parameter</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.XVexKinds.IsVector(System.Reflection.ParameterInfo)">
            <summary>
            Determines whether a parameter is of intrinsic vector type
            </summary>
            <param name="p">The parameter to examine</param>
        </member>
        <member name="M:Z0.XVexKinds.IsVector(System.Reflection.ParameterInfo,Z0.W128)">
            <summary>
            Determines whether a parameter is of type 128-bit intrinsic vector
            </summary>
            <param name="p">The parameter to examine</param>
        </member>
        <member name="M:Z0.XVexKinds.IsVector(System.Reflection.ParameterInfo,Z0.W256)">
            <summary>
            Determines whether a parameter is of type 256-bit intrinsic vector
            </summary>
            <param name="p">The parameter to examine</param>
        </member>
        <member name="M:Z0.XVexKinds.IsVector(System.Reflection.ParameterInfo,Z0.W512)">
            <summary>
            Determines whether a parameter is of type 512-bit intrinsic vector
            </summary>
            <param name="p">The parameter to examine</param>
        </member>
        <member name="M:Z0.XVexKinds.IsVector(System.Reflection.ParameterInfo,Z0.W128,System.Type)">
            <summary>
            Returns true if a method parameter is a 128-bit intrinsic vector closed over a specified argument type
            </summary>
            <param name="p">The source parameter</param>
            <param name="w">The vector width</param>
            <param name="tCell">The argument type to match</param>
        </member>
        <member name="M:Z0.XVexKinds.IsVector(System.Reflection.ParameterInfo,Z0.W256,System.Type)">
            <summary>
            Returns true if a method parameter is a 256-bit intrinsic vector closed over a specified argument type
            </summary>
            <param name="p">The source parameter</param>
            <param name="w">The vector width</param>
            <param name="tCell">The argument type to match</param>
        </member>
        <member name="M:Z0.XVexKinds.IsVector(System.Reflection.ParameterInfo,Z0.W512,System.Type)">
            <summary>
            Returns true if a method parameter is a 512-bit intrinsic vector closed over a specified argument type
            </summary>
            <param name="p">The source parameter</param>
            <param name="w">The vector width</param>
            <param name="tCell">The argument type to match</param>
        </member>
        <member name="M:Z0.XVexKinds.IsClosedVector(System.Type,Z0.W128)">
            <summary>
            Returns true if a type is a closed 128-bit intrinsic vector
            </summary>
            <param name="param">The source parameter</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.XVexKinds.IsClosedVector(System.Type,Z0.W256)">
            <summary>
            Returns true if a type is a closed 256-bit intrinsic vector
            </summary>
            <param name="param">The source parameter</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.XVexKinds.IsClosedVector(System.Type,Z0.W512)">
            <summary>
            Returns true if a type is a closed 512-bit intrinsic vector
            </summary>
            <param name="param">The source parameter</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.XVexKinds.IsOpenVector(System.Type,Z0.W128)">
            <summary>
            Returns true if a type is an open generic 512-bit intrinsic vector
            </summary>
            <param name="t">The type to examine</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.XVexKinds.IsOpenVector(System.Type,Z0.W256)">
            <summary>
            Returns true if a type is an open generic 512-bit intrinsic vector
            </summary>
            <param name="t">The type to examine</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.XVexKinds.IsOpenVector(System.Type,Z0.W512)">
            <summary>
            Returns true if a type is an open generic 512-bit intrinsic vector
            </summary>
            <param name="t">The type to examine</param>
            <param name="w">The vector width</param>
        </member>
        <member name="M:Z0.XVexKinds.IsVector(System.Type)">
            <summary>
            Determines whether a type is classified as an intrinsic vector
            </summary>
            <param name="t">The type to test</param>
        </member>
        <member name="M:Z0.XVexKinds.IsVector(System.Type,Z0.W128,System.Type)">
            <summary>
            Determines whether a type is a 128-bit intrinsic vector closed over a specified type
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.XVexKinds.IsVector(System.Type,Z0.W256,System.Type)">
            <summary>
            Determines whether a type is a 256-bit intrinsic vector closed over a specified type
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.XVexKinds.IsVector(System.Type,Z0.W512,System.Type)">
            <summary>
            Determines whether a type is a 512-bit intrinsic vector closed over a specified type
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.XVexKinds.IsVector(System.Type,Z0.W128)">
            <summary>
            Determines whether a type is a 128-bit intrinsic vector
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.XVexKinds.IsVector(System.Type,Z0.W256)">
            <summary>
            Determines whether a type is a 256-bit intrinsic vector
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.XVexKinds.IsVector(System.Type,Z0.W512)">
            <summary>
            Determines whether a type is a 512-bit intrinsic vector
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.XVexKinds.BitWidth(Z0.VectorKind)">
            <summary>
            Specifies the bit-width of a classified cpu vector
            </summary>
            <param name="t">The type to examine</param>
        </member>
        <member name="M:Z0.XVexKinds.CellType(Z0.VectorKind)">
            <summary>
            Returns the clr cell type of a vector of specified kind
            </summary>
            <param name="kind">The vector kind</param>
        </member>
        <member name="M:Z0.XVexKinds.HasCellType(Z0.VectorKind,System.SByte)">
            <summary>
            Determines whether a vector of specified kind has a singed 8-bit cell type
            </summary>
            <param name="k">The vector kind</param>
            <param name="t">The type to match as specified by a representative value</param>
        </member>
        <member name="M:Z0.XVexKinds.HasCellType(Z0.VectorKind,System.Byte)">
            <summary>
            Determines whether a vector of specified kind has an unsigned 8-bit cell type
            </summary>
            <param name="k">The vector kind</param>
            <param name="t">The type to match as specified by a representative value</param>
        </member>
        <member name="M:Z0.XVexKinds.HasCellType(Z0.VectorKind,System.Int16)">
            <summary>
            Determines whether a vector of specified kind has a singed 16-bit cell type
            </summary>
            <param name="k">The vector kind</param>
            <param name="t">The type to match as specified by a representative value</param>
        </member>
        <member name="M:Z0.XVexKinds.HasCellType(Z0.VectorKind,System.UInt16)">
            <summary>
            Determines whether a vector of specified kind has an unsigned 16-bit cell type
            </summary>
            <param name="k">The vector kind</param>
            <param name="t">The type to match as specified by a representative value</param>
        </member>
        <member name="M:Z0.XVexKinds.HasCellType(Z0.VectorKind,System.Int32)">
            <summary>
            Determines whether a vector of specified kind has a singed 32-bit cell type
            </summary>
            <param name="k">The vector kind</param>
            <param name="t">The type to match as specified by a representative value</param>
        </member>
        <member name="M:Z0.XVexKinds.HasCellType(Z0.VectorKind,System.UInt32)">
            <summary>
            Determines whether a vector of specified kind has an unsigned 32-bit cell type
            </summary>
            <param name="k">The vector kind</param>
            <param name="t">The type to match as specified by a representative value</param>
        </member>
        <member name="M:Z0.XVexKinds.HasCellType(Z0.VectorKind,System.Int64)">
            <summary>
            Determines whether a vector of specified kind has a singed 64-bit cell type
            </summary>
            <param name="k">The vector kind</param>
            <param name="t">The type to match as specified by a representative value</param>
        </member>
        <member name="M:Z0.XVexKinds.HasCellType(Z0.VectorKind,System.UInt64)">
            <summary>
            Determines whether a vector of specified kind has an unsigned 64-bit cell type
            </summary>
            <param name="k">The vector kind</param>
            <param name="t">The type to match as specified by a representative value</param>
        </member>
        <member name="M:Z0.XVexKinds.HasCellType(Z0.VectorKind,System.Single)">
            <summary>
            Determines whether a vector of specified kind has a 32-bit floating-point cell type
            </summary>
            <param name="k">The vector kind</param>
            <param name="t">The type to match as specified by a representative value</param>
        </member>
        <member name="M:Z0.XVexKinds.HasCellType(Z0.VectorKind,System.Double)">
            <summary>
            Determines whether a vector of specified kind has a 64-bit floating-point cell type
            </summary>
            <param name="k">The vector kind</param>
            <param name="t">The type to match as specified by a representative value</param>
        </member>
        <member name="P:Z0.IVectorKind.TypeDefinition">
            <summary>
            The vector's generic type definition
            </summary>
        </member>
        <member name="P:Z0.IVectorKind.CellKind">
            <summary>
            The vector numeric cell kind
            </summary>
        </member>
        <member name="M:Z0.IVectorKind.Close(System.Type)">
            <summary>
            The reified vector type as determined by kind facets
            </summary>
        </member>
        <member name="T:Z0.IVectorKind`2">
            <summary>
            Characterizes an F-bound polymorphic reification that identifies an intrinsic vector generic type definition
            </summary>
            <typeparam name="F">The reification type</typeparam>
        </member>
        <member name="M:Z0.IVectorKind`3.Close">
            <summary>
            The reified vector type as determined by kind facets
            </summary>
        </member>
        <member name="T:Z0.Vector1024`1">
            <summary>
            4x256 / 2x512
            </summary>
        </member>
        <member name="F:Z0.Vector1024`1.A">
            <summary>
            The lo 256 bit segment
            </summary>
        </member>
        <member name="F:Z0.Vector1024`1.B">
            <summary>
            The second 256-bit segment
            </summary>
        </member>
        <member name="F:Z0.Vector1024`1.C">
            <summary>
            The third 256-bit segment
            </summary>
        </member>
        <member name="F:Z0.Vector1024`1.D">
            <summary>
            The hi 256-bit segment
            </summary>
        </member>
        <member name="P:Z0.Vector1024`1.Count">
            <summary>
            The number of cells covered by the vector
            </summary>
        </member>
        <member name="M:Z0.Vector1024`1.As``1">
            <summary>
            Interprets the pair over an alternate domain
            </summary>
            <typeparam name="U">The alternate type</typeparam>
        </member>
        <member name="F:Z0.Vector512`1.Lo">
            <summary>
            The lo 256 bits 
            </summary>
        </member>
        <member name="F:Z0.Vector512`1.Hi">
            <summary>
            The hi 256 bits
            </summary>
        </member>
        <member name="M:Z0.Vector512`1.As``1">
            <summary>
            Interprets the pair over an alternate domain
            </summary>
            <typeparam name="U">The alternate type</typeparam>
        </member>
        <member name="P:Z0.Vector512`1.Count">
            <summary>
            The number of cells covered by the vector
            </summary>
        </member>
        <member name="T:Z0.Vec128Type">
            <summary>
            Represents the generic type definition for a 128-bit vector
            </summary>
        </member>
        <member name="T:Z0.Vec256Type">
            <summary>
            Represents the generic type definition for a 256-bit vector
            </summary>
        </member>
        <member name="T:Z0.Vec512Type">
            <summary>
            Represents the generic type definition for a 512-bit vector
            </summary>
        </member>
        <member name="T:Z0.z">
            <summary>
            Surfaces AES intrinsics
            </summary>
            <summary>
            Direct floating-point scalar intrinsics
            </summary>
        </member>
        <member name="M:Z0.z.v16i``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>
            Presents a generic cpu vector as a cpu vector with components of type int16
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.v16i``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>
            Presents a generic cpu vector as a cpu vector with components of type int16
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.v16i``1(Z0.Vector512{``0})">
            <summary>
            Presents a generic cpu vector as a cpu vector with components of type int16
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.v16u``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>
            Presents a generic cpu vector as a cpu vector with components of type uint16
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.v16u``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>
            Presents a generic cpu vector as a cpu vector with components of type uint16
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.v32f``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>
            Presents a generic cpu vector as a cpu vector with components of type float32
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.v32f``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>
            Presents a generic cpu vector as a cpu vector with components of type float32
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.v32i``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>
            Presents a generic cpu vector as a cpu vector with components of type int32
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.v32i``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>
            Presents a generic cpu vector as a cpu vector with components of type int32
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.v32u``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>
            Presents a generic cpu vector as a cpu vector with components of type uint32
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.v32u``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>
            Presents a generic cpu vector as a cpu vector with components of type uint32
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.v64f``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>
            Presents a generic cpu vector as a cpu vector with components of type float64
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.v64f``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>
            Presents a generic cpu vector as a cpu vector with components of type float64
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.v64f``1(Z0.Vector512{``0})">
            <summary>
            Presents a generic cpu vector as a cpu vector with components of type float64
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.v64i``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>
            Presents a generic cpu vector as a cpu vector with components of type int64
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.v64i``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>
            Presents a generic cpu vector as a cpu vector with components of type int64
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.v64u``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>
            Presents a generic cpu vector as a cpu vector with components of type uint64
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.v64u``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>
            Presents a generic cpu vector as a cpu vector with components of type uint64
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.v64u``1(Z0.Vector512{``0})">
            <summary>
            Presents a generic cpu vector as a cpu vector with components of type uint64
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.v8i``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>
            Presents a generic cpu vector as a cpu vector with components of type int8
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The primal component type</typeparam>
        </member>
        <member name="M:Z0.z.v8i``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>
            Presents a generic cpu vector as a cpu vector with components of type int8
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.v8i``1(Z0.Vector512{``0})">
            <summary>
            Presents a generic cpu vector as a cpu vector with components of type int8
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.v8u``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>
            Presents a generic cpu vector as a cpu vector with components of type uint8
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.v8u``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>
            Presents a generic cpu vector as a cpu vector with components of type uint8
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.v8u``1(Z0.Vector512{``0})">
            <summary>
            Presents a generic cpu vector as a cpu vector with components of type uint8
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.aesEncode(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_aesenc_si128 (__m128i a, __m128i RoundKey) AESENC xmm, xmm/m128
            Performs one round of an AES encryption flow on the source data using the round key
            </summary>
            <param name="src">The data to be encrypted</param>
            <param name="key">The round key</param>
        </member>
        <member name="M:Z0.z.aesEncodeLast(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_aesenclast_si128 (__m128i a, __m128i RoundKey) AESENCLAST xmm, xmm/m128
            AES Encrypt (last)
            </summary>
            <param name="src">The last block of data to be encrypted</param>
            <param name="key">The round key</param>
        </member>
        <member name="M:Z0.z.aesDecode(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_aesdec_si128 (__m128i a, __m128i RoundKey) AESDEC xmm, xmm/m128
            Performs one round of an AES decryption flow on the source data using the round key
            </summary>
            <param name="src">The data to be decrypted</param>
            <param name="key">The round key</param>
        </member>
        <member name="M:Z0.z.aesDecodeLast(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_aesdeclast_si128 (__m128i a, __m128i RoundKey) AESDECLAST xmm, xmm/m128
            Performs the last round of an AES decryption flow on the source data using the round key
            </summary>
            <param name="src">The data to be decrypted</param>
            <param name="key">The round key</param>
        </member>
        <member name="M:Z0.z.aesInvMix(System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_aesimc_si128 (__m128i a) AESIMC xmm, xmm/m128
            Applies the InvMixColumns transformation to the source
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.aesKeyGen(System.Runtime.Intrinsics.Vector128{System.Byte},System.Byte)">
            <summary>
            _m128i _mm_aeskeygenassist_si128 (__m128i a, const int imm8) AESKEYGENASSIST xmm, xmm/m128, imm8
            Assist in expanding the AES cipher key by computing steps towards generating a round key for
            encryption cipher using data from a and an 8-bit round constant specified in imm8
            </summary>
            <param name="src"></param>
            <param name="imm8"></param>
        </member>
        <member name="M:Z0.z.vabs(System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_abs_epi8 (__m128i a) PABSB xmm, xmm/m128
            Computes the absolute value of each source component
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vabs(System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_abs_epi16 (__m128i a) PABSW xmm, xmm/m128
            Computes the absolute value of each source component
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vabs(System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_abs_epi32 (__m128i a)PABSD xmm, xmm/m128
            Computes the absolute value of each source component
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vabs(System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            Computes the absolute value of each source component
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vabs(System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
             __m256i _mm256_abs_epi8 (__m256i a) VPABSB ymm, ymm/m256
            Computes the absolute value of each source component
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vabs(System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_abs_epi16 (__m256i a)VPABSW ymm, ymm/m256
            Computes the absolute value of each source component
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vabs(System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            Computes the absolute value of each source component
             __m256i _mm256_abs_epi32 (__m256i a)VPABSD ymm, ymm/m256
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vabs(System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            Computes the absolute value of each source component
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vadd(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_add_epi8 (__m128i a, __m128i b) PADDB xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vadd(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_add_epi8 (__m128i a, __m128i b) PADDB xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vadd(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_add_epi16 (__m128i a, __m128i b) PADDW xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vadd(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_add_epi16 (__m128i a, __m128i b) PADDW xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vadd(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
             __m128d _mm_add_pd (__m128d a, __m128d b) ADDPD xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vadd(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_add_epi32 (__m128i a, __m128i b) PADDD xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vadd(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
             __m128i _mm_add_epi64 (__m128i a, __m128i b)PADDQ xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vadd(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m128i _mm_add_epi64 (__m128i a, __m128i b) PADDQ xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vadd(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
             __m256i _mm256_add_epi8 (__m256i a, __m256i b) VPADDB ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vadd(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            __m256i _mm256_add_epi8 (__m256i a, __m256i b) VPADDB ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vadd(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_add_epi16 (__m256i a, __m256i b) VPADDW ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vadd(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            __m256i _mm256_add_epi16 (__m256i a, __m256i b) VPADDW ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vadd(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
             __m256i _mm256_add_epi32 (__m256i a, __m256i b) VPADDD ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vadd(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
             __m256i _mm256_add_epi32 (__m256i a, __m256i b) VPADDD ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vadd(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            __m256i _mm256_add_epi64 (__m256i a, __m256i b) VPADDQ ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vadd(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            __m256i _mm256_add_epi64 (__m256i a, __m256i b) VPADDQ ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vadd(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_add_ps (__m128 a, __m128 b) ADDPS xmm, xmm/m128
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.z.vadd(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_add_pd (__m128d a, __m128d b)ADDPD xmm, xmm/m128
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.z.vadd(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_add_ps (__m256 a, __m256 b) VADDPS ymm, ymm, ymm/m256
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.z.vadd(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_add_pd (__m256d a, __m256d b) VADDPD ymm, ymm, ymm/m256
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.z.vadds(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_adds_epu8 (__m128i a, __m128i b) PADDUSB xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vadds(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_adds_epi8 (__m128i a, __m128i b) PADDSB xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vadds(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_adds_epi16 (__m128i a, __m128i b) PADDSW xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vadds(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_adds_epu16 (__m128i a, __m128i b) PADDUSW xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vadds(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_adds_epu8 (__m256i a, __m256i b) VPADDUSB ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vadds(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
             __m256i _mm256_adds_epi8 (__m256i a, __m256i b) VPADDSB ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vadds(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_adds_epi16 (__m256i a, __m256i b) VPADDSW ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vadds(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
             __m256i _mm256_adds_epu16 (__m256i a, __m256i b) VPADDUSW ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.valignr(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64},System.Byte)">
            <summary>
            __m128i _mm_alignr_epi8 (__m128i a, __m128i b, int count) PALIGNR xmm, xmm/m128, imm8
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="offset"></param>
        </member>
        <member name="M:Z0.z.valignr(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64},System.Byte)">
            <summary>
            __m256i _mm256_alignr_epi8 (__m256i a, __m256i b, const int count) VPALIGNR ymm, ymm, ymm/m256, imm8
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="offset"></param>
        </member>
        <member name="M:Z0.z.valignr(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte},System.Byte)">
            <summary>
            __m128i _mm_alignr_epi8 (__m128i a, __m128i b, int count) PALIGNR xmm, xmm/m128, imm8
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="offset"></param>
        </member>
        <member name="M:Z0.z.valignr(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte},System.Byte)">
            <summary>
            __m256i _mm256_alignr_epi8 (__m256i a, __m256i b, const int count)VPALIGNR ymm, ymm, ymm/m256, imm8
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="offset"></param>
        </member>
        <member name="M:Z0.z.vand(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_and_si128 (__m128i a, __m128i b) PAND xmm, xmm/m128
            Computes the logical and of the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vand(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_and_si128 (__m128i a, __m128i b) PAND xmm, xmm/m128
            Computes the logical and of the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vand(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_and_si128 (__m128i a, __m128i b) PAND xmm, xmm/m128
            Computes the logical and of the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vand(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_and_si128 (__m128i a, __m128i b) PAND xmm, xmm/m128
            Computes the logical and of the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vand(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_and_si128 (__m128i a, __m128i b) PAND xmm, xmm/m128
            Computes the logical and of the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vand(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_and_si128 (__m128i a, __m128i b) PAND xmm, xmm/m128
            Computes the logical and of the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vand(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            __m128i _mm_and_si128 (__m128i a, __m128i b) PAND xmm, xmm/m128
            Computes the logical and of the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vand(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m128i _mm_and_si128 (__m128i a, __m128i b) PAND xmm, xmm/m128
            Computes the logical and of the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vand(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_and_si256 (__m256i a, __m256i b) VPAND ymm, ymm, ymm/m256
            Computes the logical and of the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vand(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_and_si256 (__m256i a, __m256i b) VPAND ymm, ymm, ymm/m256
            Computes the logical and of the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vand(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            __m256i _mm256_and_si256 (__m256i a, __m256i b) VPAND ymm, ymm, ymm/m256
            Computes the logical and of the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vand(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            __m256i _mm256_and_si256 (__m256i a, __m256i b) VPAND ymm, ymm, ymm/m256
            Computes the logical and of the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vand(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_and_si256 (__m256i a, __m256i b) VPAND ymm, ymm, ymm/m256
            Computes the logical and of the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vand(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_and_si256 (__m256i a, __m256i b) VPAND ymm, ymm, ymm/m256
            Computes the logical and of the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vand(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            __m256i _mm256_and_si256 (__m256i a, __m256i b) VPAND ymm, ymm, ymm/m256
            Computes the logical and of the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vand(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            __m256i _mm256_and_si256 (__m256i a, __m256i b) VPAND ymm, ymm, ymm/m256
            Computes the logical and of the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vand(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_and_ps (__m128 a, __m128 b)ANDPS xmm, xmm/m128
            Computes the logical and of the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vand(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_and_pd (__m128d a, __m128d b) ANDPD xmm, xmm/m128
            Computes the logical and of the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vand(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m128 _mm_and_ps (__m128 a, __m128 b) ANDPS xmm, xmm/m128
            Computes the logical and of the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vand(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m128d _mm_and_pd (__m128d a, __m128d b) ANDPD xmm, xmm/m128
            Computes the logical and of the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vandnot(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vandnot(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vandnot(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vandnot(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})" -->
        <member name="M:Z0.z.vavg(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_avg_epu8 (__m128i a, __m128i b) PAVGB xmm, xmm/m128
            </summary>
            <param name="lhs">The left vector</param>
            <param name="rhs">The right vector</param>
        </member>
        <member name="M:Z0.z.vavg(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_avg_epu16 (__m128i a, __m128i b) PAVGW xmm, xmm/m128
            </summary>
            <param name="lhs">The left vector</param>
            <param name="rhs">The right vector</param>
        </member>
        <member name="M:Z0.z.vavg(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_avg_epu8 (__m256i a, __m256i b) VPAVGB ymm, ymm, ymm/m256
            </summary>
            <param name="lhs">The left vector</param>
            <param name="rhs">The right vector</param>
        </member>
        <member name="M:Z0.z.vavg(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
             __m256i _mm256_avg_epu16 (__m256i a, __m256i b) VPAVGW ymm, ymm, ymm/m256
            </summary>
            <param name="lhs">The left vector</param>
            <param name="rhs">The right vector</param>
        </member>
        <member name="M:Z0.z.vblend4x32(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_blendv_ps (__m128 a, __m128 b, __m128 mask) BLENDVPS xmm, xmm/m128,xmm0
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend2x64(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_blendv_pd (__m128d a, __m128d b, __m128d mask) BLENDVPD xmm, xmm/m128,xmm0
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend8x32(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_blendv_ps (__m256 a, __m256 b, __m256 mask) VBLENDVPS ymm, ymm, ymm/m256, ymm
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend4x64(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256 _mm256_blendv_ps (__m256 a, __m256 b, __m256 mask) VBLENDVPS ymm, ymm, ymm/m256, ymm
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblendv(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_blendv_epi8 (__m128i a, __m128i b, __m128i mask) PBLENDVB xmm, xmm/m128, xmm
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblendv(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_blendv_epi8 (__m128i a, __m128i b, __m128i mask) PBLENDVB xmm, xmm/m128, xmm
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblendv(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_blendv_epi8 (__m128i a, __m128i b, __m128i mask)PBLENDVB xmm, xmm/m128,xmm
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblendv(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_blendv_epi8 (__m128i a, __m128i b, __m128i mask)PBLENDVB xmm, xmm/m128,xmm
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblendv(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_blendv_epi8 (__m128i a, __m128i b, __m128i mask)PBLENDVB xmm, xmm/m128,xmm
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblendv(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_blendv_epi8 (__m128i a, __m128i b, __m128i mask)PBLENDVB xmm, xmm/m128,xmm
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblendv(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            __m128i _mm_blendv_epi8 (__m128i a, __m128i b, __m128i mask)PBLENDVB xmm, xmm/m128,xmm
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblendv(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m128i _mm_blendv_epi8 (__m128i a, __m128i b, __m128i mask)PBLENDVB xmm, xmm/m128,xmm
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblendv(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_blendv_ps (__m128 a, __m128 b, __m128 mask) BLENDVPS xmm, xmm/m128,xmm0
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblendv(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            _m128d _mm_blendv_pd (__m128d a, __m128d b, __m128d mask) BLENDVPD xmm, xmm/m128, xmm0
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblendv(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m128i _mm_blendv_epi8 (__m128i a, __m128i b, __m128i mask) PBLENDVB xmm, xmm/m128, xmm
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblendv(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            __m128i _mm_blendv_epi8 (__m128i a, __m128i b, __m128i mask)PBLENDVB xmm, xmm/m128, xmm
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblendv(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_blendv_epi8 (__m256i a, __m256i b, __m256i mask)VPBLENDVB ymm, ymm, ymm/m256, ymm
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblendv(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            __m256i _mm256_blendv_epi8 (__m256i a, __m256i b, __m256i mask)VPBLENDVB ymm, ymm, ymm/m256, ymm
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblendv(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_blendv_epi8 (__m256i a, __m256i b, __m256i mask)VPBLENDVB ymm, ymm, ymm/m256, ymm
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblendv(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_blendv_epi8 (__m256i a, __m256i b, __m256i mask)VPBLENDVB ymm, ymm, ymm/m256, ymm
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblendv(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            __m256i _mm256_blendv_epi8 (__m256i a, __m256i b, __m256i mask)VPBLENDVB ymm, ymm, ymm/m256, ymm
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblendv(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            __m256i _mm256_blendv_epi8 (__m256i a, __m256i b, __m256i mask) VPBLENDVB ymm, ymm, ymm/m256, ymm
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblendv(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_blendv_ps (__m256 a, __m256 b, __m256 mask) VBLENDVPS ymm, ymm, ymm/m256, ymm
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblendv(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_blendv_pd (__m256d a, __m256d b, __m256d mask)VBLENDVPD ymm, ymm,ymm/m256, ymm
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16},Z0.Blend8x16)">
            <summary>
            __m128i _mm_blend_epi16 (__m128i a, __m128i b, const int imm8)PBLENDW xmm, xmm/m128, imm8
            Combines components from left/right vectors per the blend spec
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.Blend8x16)">
            <summary>
            __m128i _mm_blend_epi16 (__m128i a, __m128i b, const int imm8) PBLENDW xmm, xmm/m128, imm8
            Combines components from left/right vectors per the blend spec
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16},Z0.Blend8x16)">
            <summary>
            __m256i _mm256_blend_epi16 (__m256i a, __m256i b, const int imm8) VPBLENDW ymm, ymm, ymm/m256, imm8
            Combines components from left/right vectors within 128-bit lanes per the blend spec
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16},Z0.Blend8x16)">
            <summary>
            __m256i _mm256_blend_epi16 (__m256i a, __m256i b, const int imm8) VPBLENDW ymm, ymm, ymm/m256, imm8
            Combines components from left/right vectors within 128-bit lanes per the blend spec
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32},Z0.Blend8x32)">
            <summary>
             __m256i _mm256_blend_epi32 (__m256i a, __m256i b, const int imm8) VPBLENDD ymm,ymm, ymm/m256, imm8
            Forms a vector z[i] := testbit(spec,i) ? x[i] : y[i], i = 0,...7
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32},Z0.Blend8x32)">
            <summary>
            __m256i _mm256_blend_epi32 (__m256i a, __m256i b, const int imm8) VPBLENDD ymm, ymm, ymm/m256, imm8
            Forms a vector z[i] := testbit(spec,i) ? x[i] : y[i], i = 0,...7
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend2x64(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte},System.Byte)">
            <summary>
            __m128d _mm_blend_pd (__m128d a, __m128d b, const int imm8) BLENDPD xmm, xmm/m128, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend2x64(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte},System.Byte)">
            <summary>
            __m128d _mm_blend_pd (__m128d a, __m128d b, const int imm8) BLENDPD xmm, xmm/m128, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend2x64(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64},System.Byte)">
            <summary>
            __m128d _mm_blend_pd (__m128d a, __m128d b, const int imm8) BLENDPD xmm, xmm/m128, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend2x64(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16},System.Byte)">
            <summary>
            __m128d _mm_blend_pd (__m128d a, __m128d b, const int imm8) BLENDPD xmm, xmm/m128, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend2x64(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16},System.Byte)">
            <summary>
            __m128d _mm_blend_pd (__m128d a, __m128d b, const int imm8) BLENDPD xmm, xmm/m128, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend2x64(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32},System.Byte)">
            <summary>
            __m128d _mm_blend_pd (__m128d a, __m128d b, const int imm8) BLENDPD xmm, xmm/m128, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend2x64(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32},System.Byte)">
            <summary>
            __m128d _mm_blend_pd (__m128d a, __m128d b, const int imm8) BLENDPD xmm, xmm/m128, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend2x64(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64},System.Byte)">
            <summary>
            __m128d _mm_blend_pd (__m128d a, __m128d b, const int imm8) BLENDPD xmm, xmm/m128, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte},Z0.Blend2x64)">
            <summary>
            __m128d _mm_blend_pd (__m128d a, __m128d b, const int imm8) BLENDPD xmm, xmm/m128, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte},Z0.Blend2x64)">
            <summary>
            __m128d _mm_blend_pd (__m128d a, __m128d b, const int imm8) BLENDPD xmm, xmm/m128, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16},Z0.Blend2x64)">
            <summary>
            __m128d _mm_blend_pd (__m128d a, __m128d b, const int imm8)BLENDPD xmm, xmm/m128, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.Blend2x64)">
            <summary>
            __m128d _mm_blend_pd (__m128d a, __m128d b, const int imm8) BLENDPD xmm, xmm/m128, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32},Z0.Blend2x64)">
            <summary>
            __m128d _mm_blend_pd (__m128d a, __m128d b, const int imm8) BLENDPD xmm, xmm/m128, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32},Z0.Blend2x64)">
            <summary>
            __m128d _mm_blend_pd (__m128d a, __m128d b, const int imm8) BLENDPD xmm, xmm/m128, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64},Z0.Blend2x64)">
            <summary>
            __m128d _mm_blend_pd (__m128d a, __m128d b, const int imm8) BLENDPD xmm, xmm/m128, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64},Z0.Blend2x64)">
            <summary>
            __m128d _mm_blend_pd (__m128d a, __m128d b, const int imm8) BLENDPD xmm, xmm/m128, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double},Z0.Blend2x64)">
            <summary>
            __m128d _mm_blend_pd (__m128d a, __m128d b, const int imm8) BLENDPD xmm, xmm/m128, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single},System.Byte)">
            <summary>
            __m128 _mm_blend_ps (__m128 a, __m128 b, const int imm8) BLENDPS xmm, xmm/m128, imm8
            Produces a new vector by assembling components from two source vectors as dermined by a mask
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double},System.Byte)">
            <summary>
            __m128d _mm_blend_pd (__m128d a, __m128d b, const int imm8) BLENDPD xmm, xmm/m128, imm8
            Produces a new vector by assembling components from two source vectors as dermined by a mask
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single},System.Byte)">
            <summary>
            __m256 _mm256_blend_ps (__m256 a, __m256 b, const int imm8) VBLENDPS ymm, ymm, ymm/m256, imm8
            Produces a new vector by assembling components from two source vectors as dermined by a mask
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double},System.Byte)">
            <summary>
            __m256d _mm256_blend_pd (__m256d a, __m256d b, const int imm8) VBLENDPD ymm, ymm, ymm/m256, imm8
            Produces a new vector by assembling components from two source vectors as dermined by a mask
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend4x32(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32},System.Byte)">
            <summary>
            __m128i _mm_blend_epi32 (__m128i a, __m128i b, const int imm8) VPBLENDD xmm, xmm, xmm/m128, imm8
            Combines components from left/right vectors per the blend spec
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend4x32(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32},System.Byte)">
            <summary>
            __m128i _mm_blend_epi32 (__m128i a, __m128i b, const int imm8) VPBLENDD xmm, xmm, xmm/m128, imm8
            Combines components from left/right vectors per the blend spec
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32},Z0.Blend4x32)">
            <summary>
            __m128i _mm_blend_epi32 (__m128i a, __m128i b, const int imm8) VPBLENDD xmm, xmm, xmm/m128, imm8
            Combines components from left/right vectors per the blend spec
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32},Z0.Blend4x32)">
            <summary>
            __m128i _mm_blend_epi32 (__m128i a, __m128i b, const int imm8) VPBLENDD xmm, xmm, xmm/m128, imm8
            Combines components from left/right vectors per the blend spec
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend4x64(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte},System.Byte)">
            <summary>
            __m256d _mm256_blend_pd (__m256d a, __m256d b, const int imm8) VBLENDPD ymm, ymm, ymm/m256, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend4x64(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte},System.Byte)">
            <summary>
            __m256d _mm256_blend_pd (__m256d a, __m256d b, const int imm8) VBLENDPD ymm, ymm, ymm/m256, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend4x64(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16},System.Byte)">
            <summary>
            __m256d _mm256_blend_pd (__m256d a, __m256d b, const int imm8) VBLENDPD ymm, ymm, ymm/m256, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend4x64(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16},System.Byte)">
            <summary>
            __m256d _mm256_blend_pd (__m256d a, __m256d b, const int imm8) VBLENDPD ymm, ymm, ymm/m256, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend4x64(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32},System.Byte)">
            <summary>
            __m256d _mm256_blend_pd (__m256d a, __m256d b, const int imm8) VBLENDPD ymm, ymm, ymm/m256, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend4x64(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32},System.Byte)">
            <summary>
            __m256d _mm256_blend_pd (__m256d a, __m256d b, const int imm8) VBLENDPD ymm, ymm, ymm/m256, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend4x64(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64},System.Byte)">
            <summary>
            __m256d _mm256_blend_pd (__m256d a, __m256d b, const int imm8) VBLENDPD ymm, ymm, ymm/m256, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend4x64(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64},System.Byte)">
            <summary>
            __m256d _mm256_blend_pd (__m256d a, __m256d b, const int imm8) VBLENDPD ymm, ymm, ymm/m256, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte},Z0.Blend4x64)">
            <summary>
            __m256d _mm256_blend_pd (__m256d a, __m256d b, const int imm8) VBLENDPD ymm, ymm, ymm/m256, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte},Z0.Blend4x64)">
            <summary>
            __m256d _mm256_blend_pd (__m256d a, __m256d b, const int imm8) VBLENDPD ymm, ymm, ymm/m256, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16},Z0.Blend4x64)">
            <summary>
            __m256d _mm256_blend_pd (__m256d a, __m256d b, const int imm8) VBLENDPD ymm, ymm, ymm/m256, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16},Z0.Blend4x64)">
            <summary>
            __m256d _mm256_blend_pd (__m256d a, __m256d b, const int imm8) VBLENDPD ymm, ymm, ymm/m256, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32},Z0.Blend4x64)">
            <summary>
            __m256d _mm256_blend_pd (__m256d a, __m256d b, const int imm8) VBLENDPD ymm, ymm, ymm/m256, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32},Z0.Blend4x64)">
            <summary>
            __m256d _mm256_blend_pd (__m256d a, __m256d b, const int imm8) VBLENDPD ymm, ymm, ymm/m256, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64},Z0.Blend4x64)">
            <summary>
            __m256d _mm256_blend_pd (__m256d a, __m256d b, const int imm8) VBLENDPD ymm, ymm, ymm/m256, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64},Z0.Blend4x64)">
            <summary>
            __m256d _mm256_blend_pd (__m256d a, __m256d b, const int imm8) VBLENDPD ymm, ymm, ymm/m256, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double},Z0.Blend4x64)">
            <summary>
            __m256d _mm256_blend_pd (__m256d a, __m256d b, const int imm8) VBLENDPD ymm, ymm, ymm/m256, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_blendv_epi8 (__m128i a, __m128i b, __m128i mask) PBLENDVB xmm, xmm/m128, xmm
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_blendv_epi8 (__m128i a, __m128i b, __m128i mask)PBLENDVB xmm, xmm/m128, xmm
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_blendv_epi8 (__m128i a, __m128i b, __m128i mask) PBLENDVB xmm, xmm/m128, xmm
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_blendv_epi8 (__m128i a, __m128i b, __m128i mask) PBLENDVB xmm, xmm/m128, xmm
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_blendv_epi8 (__m128i a, __m128i b, __m128i mask) PBLENDVB xmm, xmm/m128, xmm
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_blendv_epi8 (__m128i a, __m128i b, __m128i mask) PBLENDVB xmm, xmm/m128, xmm
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_blendv_epi8 (__m128i a, __m128i b, __m128i mask) PBLENDVB xmm, xmm/m128, xmm
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_blendv_epi8 (__m128i a, __m128i b, __m128i mask) PBLENDVB xmm, xmm/m128, xmm
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_blendv_epi8 (__m256i a, __m256i b, __m256i mask) VPBLENDVB ymm,ymm, ymm/m256, ymm
            Forms a vector z[i] = testbit(spec[i],7) ? x[i] : y[i] where i = 0,...31
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
            <remarks>https://www.felixcloutier.com/x86/pblendvb</remarks>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_blendv_epi8 (__m256i a, __m256i b, __m256i mask) VPBLENDVB ymm,ymm, ymm/m256, ymm
            Forms a vector z[i] = testbit(spec[i],7) ? x[i] : y[i] where i = 0,...31
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
            <remarks>https://www.felixcloutier.com/x86/pblendvb</remarks>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_blendv_epi8 (__m256i a, __m256i b, __m256i mask) VPBLENDVB ymm,ymm, ymm/m256, ymm
            Forms a vector z[i] = testbit(spec[i],7) ? x[i] : y[i] where i = 0,...31
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
            <remarks>https://www.felixcloutier.com/x86/pblendvb</remarks>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_blendv_epi8 (__m256i a, __m256i b, __m256i mask) VPBLENDVB ymm,ymm, ymm/m256, ymm
            Forms a vector z[i] = testbit(spec[i],7) ? x[i] : y[i] where i = 0,...31
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
            <remarks>https://www.felixcloutier.com/x86/pblendvb</remarks>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_blendv_epi8 (__m256i a, __m256i b, __m256i mask) VPBLENDVB ymm,ymm, ymm/m256, ymm
            Forms a vector z[i] = testbit(spec[i],7) ? x[i] : y[i] where i = 0,...31
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
            <remarks>https://www.felixcloutier.com/x86/pblendvb</remarks>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_blendv_epi8 (__m256i a, __m256i b, __m256i mask) VPBLENDVB ymm,ymm, ymm/m256, ymm
            Forms a vector z[i] = testbit(spec[i],7) ? x[i] : y[i] where i = 0,...31
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
            <remarks>https://www.felixcloutier.com/x86/pblendvb</remarks>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_blendv_epi8 (__m256i a, __m256i b, __m256i mask) VPBLENDVB ymm,ymm, ymm/m256, ymm
            Forms a vector z[i] = testbit(spec[i],7) ? x[i] : y[i] where i = 0,...31
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
            <remarks>https://www.felixcloutier.com/x86/pblendvb</remarks>
        </member>
        <member name="M:Z0.z.vblend(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_blendv_epi8 (__m256i a, __m256i b, __m256i mask) VPBLENDVB ymm,ymm, ymm/m256, ymm
            Forms a vector z[i] = testbit(spec[i],7) ? x[i] : y[i] where i = 0,...31
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
            <remarks>https://www.felixcloutier.com/x86/pblendvb</remarks>
        </member>
        <member name="M:Z0.z.vblend8x16(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16},System.Byte)">
            <summary>
            __m128i _mm_blend_epi16 (__m128i a, __m128i b, const int imm8) PBLENDW xmm, xmm/m128, imm8
            Combines components from left/right vectors per the blend spec
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend8x16(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16},System.Byte)">
            <summary>
            __m128i _mm_blend_epi16 (__m128i a, __m128i b, const int imm8) PBLENDW xmm, xmm/m128, imm8
            Combines components from left/right vectors per the blend spec
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend8x16(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16},System.Byte)">
            <summary>
            __m256i _mm256_blend_epi16 (__m256i a, __m256i b, const int imm8) VPBLENDW ymm, ymm, ymm/m256, imm8
            Combines components from left/right vectors within 128-bit lanes per the blend spec
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend8x16(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16},System.Byte)">
            <summary>
            __m256i _mm256_blend_epi16 (__m256i a, __m256i b, const int imm8) VPBLENDW ymm, ymm, ymm/m256, imm8
            Combines components from left/right vectors within 128-bit lanes per the blend spec
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend8x32(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32},System.Byte)">
            <summary>
             __m256i _mm256_blend_epi32 (__m256i a, __m256i b, const int imm8) VPBLENDD ymm,ymm, ymm/m256, imm8
            Forms a vector z[i] := testbit(spec,i) ? x[i] : y[i], i = 0,...7
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblend8x32(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32},System.Byte)">
            <summary>
            __m256i _mm256_blend_epi32 (__m256i a, __m256i b, const int imm8) VPBLENDD ymm, ymm, ymm/m256, imm8
            Forms a vector z[i] := testbit(spec,i) ? x[i] : y[i], i = 0,...7
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The blend specification</param>
        </member>
        <member name="M:Z0.z.vblendbits(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            Blends the left and right vectors at the bit-level as specified by the mask operand.
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="mask">The selection mask</param>
            <remarks>Equivalent to select</remarks>
        </member>
        <member name="M:Z0.z.vblendbits(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            Blends the left and right vectors at the bit-level as specified by the mask operand.
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="mask">The selection mask</param>
            <remarks>Equivalent to select</remarks>
        </member>
        <member name="M:Z0.z.vblendbits(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            Blends the left and right vectors at the bit-level as specified by the mask operand.
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="mask">The selection mask</param>
            <remarks>Equivalent to select</remarks>
        </member>
        <member name="M:Z0.z.vblendbits(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            Blends the left and right vectors at the bit-level as specified by the mask operand.
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="mask">The selection mask</param>
            <remarks>Equivalent to select</remarks>
        </member>
        <member name="M:Z0.z.vblendbits(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            Blends the left and right vectors at the bit-level as specified by the mask operand.
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="mask">The selection mask</param>
            <remarks>Equivalent to select</remarks>
        </member>
        <member name="M:Z0.z.vblendbits(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            Blends the left and right vectors at the bit-level as specified by the mask operand.
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="mask">The selection mask</param>
            <remarks>Equivalent to select</remarks>
        </member>
        <member name="M:Z0.z.vblendbits(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            Blends the left and right vectors at the bit-level as specified by the mask operand.
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="mask">The selection mask</param>
            <remarks>Equivalent to select</remarks>
        </member>
        <member name="M:Z0.z.vblendbits(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            Blends the left and right vectors at the bit-level as specified by the mask operand.
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="mask">The selection mask</param>
            <remarks>Equivalent to select</remarks>
        </member>
        <member name="M:Z0.z.vblendspec``1(Z0.W256,System.Boolean)">
            <summary>
            Defines a blend specification for combining 2 256-bit vectors that selects the odd components from each vector
            </summary>
            <param name="n">The vector width selector</param>
            <param name="odd">Whether to select odd or even components</param>
            <typeparam name="T">The component type</typeparam>
        </member>
        <member name="M:Z0.z.vblendspec``1(Z0.W256,System.Boolean,``0)">
            <summary>
            Retrieves a blend specification for combining 2 256-bit vectors that selects the even components from each vector
            </summary>
            <param name="n">The vector width selector</param>
            <param name="odd">Whether to select odd or even components</param>
            <typeparam name="N">The component width type</typeparam>
        </member>
        <member name="M:Z0.z.vbroadcast(Z0.W128,System.SByte)">
            <summary>
            Creates a target vector where each component is initialized with the same value
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The value to broadcast</param>
        </member>
        <member name="M:Z0.z.vbroadcast(Z0.W128,System.Byte)">
            <summary>
            Creates a target vector where each component is initialized with the same value
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The value to broadcast</param>
        </member>
        <member name="M:Z0.z.vbroadcast(Z0.W128,System.Int16)">
            <summary>
            Creates a target vector where each component is initialized with the same value
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The value to broadcast</param>
        </member>
        <member name="M:Z0.z.vbroadcast(Z0.W128,System.UInt16)">
            <summary>
            Creates a target vector where each component is initialized with the same value
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The value to broadcast</param>
        </member>
        <member name="M:Z0.z.vbroadcast(Z0.W128,System.Int32)">
            <summary>
            Creates a target vector where each component is initialized with the same value
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The value to broadcast</param>
        </member>
        <member name="M:Z0.z.vbroadcast(Z0.W128,System.UInt32)">
            <summary>
            Creates a target vector where each component is initialized with the same value
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The value to broadcast</param>
        </member>
        <member name="M:Z0.z.vbroadcast(Z0.W128,System.Int64)">
            <summary>
            Creates a target vector where each component is initialized with the same value
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The value to broadcast</param>
        </member>
        <member name="M:Z0.z.vbroadcast(Z0.W128,System.UInt64)">
            <summary>
            Creates a target vector where each component is initialized with the same value
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The value to broadcast</param>
        </member>
        <member name="M:Z0.z.vbroadcast(Z0.W256,System.SByte)">
            <summary>
            __m256i _mm256_broadcastb_epi8 (__m128i a) VPBROADCASTB ymm, m8
            Creates a target vector where each component is initialized with the same value
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The value to broadcast</param>
        </member>
        <member name="M:Z0.z.vbroadcast(Z0.W256,System.Byte)">
            <summary>
            __m256i _mm256_broadcastb_epi8 (__m128i a) VPBROADCASTB ymm, m8
            Creates a target vector where each component is initialized with the same value
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The value to broadcast</param>
        </member>
        <member name="M:Z0.z.vbroadcast(Z0.W256,System.Int16)">
            <summary>
             __m256i _mm256_broadcastw_epi16 (__m128i a) VPBROADCASTW ymm, m16
            Creates a target vector where each component is initialized with the same value
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The value to broadcast</param>
        </member>
        <member name="M:Z0.z.vbroadcast(Z0.W256,System.UInt16)">
            <summary>
             __m256i _mm256_broadcastw_epi16 (__m128i a) VPBROADCASTW ymm, m16
            Creates a target vector where each component is initialized with the same value
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The value to broadcast</param>
        </member>
        <member name="M:Z0.z.vbroadcast(Z0.W256,System.Int32)">
            <summary>
            __m256i _mm256_broadcastd_epi32 (__m128i a) VPBROADCASTD ymm, m32
            Creates a target vector where each component is initialized with the same value
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The value to broadcast</param>
        </member>
        <member name="M:Z0.z.vbroadcast(Z0.W256,System.UInt32)">
            <summary>
            __m256i _mm256_broadcastd_epi32 (__m128i a) VPBROADCASTD ymm, m32
            Creates a target vector where each component is initialized with the same value
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The value to broadcast</param>
        </member>
        <member name="M:Z0.z.vbroadcast(Z0.W256,System.Int64)">
            <summary>
            __m256i _mm256_broadcastq_epi64 (__m128i a) VPBROADCASTQ ymm, m64
            Creates a target vector where each component is initialized with the same value
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The value to broadcast</param>
        </member>
        <member name="M:Z0.z.vbroadcast(Z0.W256,System.UInt64)">
            <summary>
             __m256i _mm256_broadcastq_epi64 (__m128i a) VPBROADCASTQ ymm, m64
            Creates a target vector where each component is initialized with the same value
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The value to broadcast</param>
        </member>
        <member name="M:Z0.z.vbroadcast(Z0.W256,System.Single)">
            <summary>
            __m256 _mm256_broadcast_ss (float const * mem_addr) VBROADCASTSS ymm, m32
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The value to broadcast</param>
        </member>
        <member name="M:Z0.z.vbroadcast(Z0.W256,System.Double)">
            <summary>
            __m256d _mm256_broadcast_sd (double const * mem_addr) VBROADCASTSD ymm, m64
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The value to broadcast</param>
        </member>
        <member name="M:Z0.z.vbroadcast(Z0.W128,System.Single)">
            <summary>
            __m128 _mm_broadcast_ss (float const * mem_addr) VBROADCASTSS xmm, m32
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The value to broadcast</param>
        </member>
        <member name="M:Z0.z.vbroadcast(Z0.W128,System.Double)">
            <summary>
            Broadcasts a 64-bit floating point value to the upper and lower cells of a 128-bit floating-point vector
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The value to broadcast</param>
        </member>
        <member name="M:Z0.z.vbroadcast(Z0.W256,System.Byte,System.Byte)">
            <summary>
            Creates a 256-bit vector where the lower 128-bit lane is filled with replicas of the lo value
            and the upper 128-bit lane is filled with replicas of the hi value
            </summary>
            <param name="w">The target vector width</param>
            <param name="lo">The value to replicate in the lower lane</param>
            <param name="hi">The value to replicate in the upper lane</param>
        </member>
        <member name="M:Z0.z.vbroadcast(Z0.W256,System.UInt16,System.UInt16)">
            <summary>
            Creates a 256-bit vector where the lower 128-bit lane is filled with replicas of the lo value
            and the upper 128-bit lane is filled with replicas of the hi value
            </summary>
            <param name="w">The target vector width</param>
            <param name="lo">The value to replicate in the lower lane</param>
            <param name="hi">The value to replicate in the upper lane</param>
        </member>
        <member name="M:Z0.z.vbroadcast(Z0.W256,System.UInt32,System.UInt32)">
            <summary>
            Creates a 256-bit vector where the lower 128-bit lane is filled with replicas of the lo value
            and the upper 128-bit lane is filled with replicas of the hi value
            </summary>
            <param name="w">The target vector width</param>
            <param name="lo">The value to replicate in the lower lane</param>
            <param name="hi">The value to replicate in the upper lane</param>
        </member>
        <member name="M:Z0.z.vbroadcast(Z0.W256,System.UInt64,System.UInt64)">
            <summary>
            Creates a 256-bit vector where the lower 128-bit lane is filled with replicas of the lo value
            and the upper 128-bit lane is filled with replicas of the hi value
            </summary>
            <param name="w">The target vector width</param>
            <param name="lo">The value to replicate in the lower lane</param>
            <param name="hi">The value to replicate in the upper lane</param>
        </member>
        <member name="M:Z0.z.vbroadcast``1(Z0.W128,``0)">
            <summary>
            Projects a scalar value onto each component of a 128-bit vector
            </summary>
            <param name="w">The bitness selector</param>
            <param name="src">The source value</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.z.vbroadcast``1(Z0.W256,``0)">
            <summary>
            Projects a scalar value onto each component of a 256-bit vector
            </summary>
            <param name="w">The bitness selector</param>
            <param name="src">The source value</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.z.vbroadcast``1(Z0.W512,``0)">
            <summary>
            Projects a scalar value onto each component of a 512-bit vector
            </summary>
            <param name="w">The bitness selector</param>
            <param name="src">The source value</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.z.vbsll(System.Runtime.Intrinsics.Vector128{System.SByte},System.Byte)">
            <summary>
             __m128i _mm_bslli_si128 (__m128i a, int imm8) PSLLDQ xmm, imm8
            Shifts the source vector leftwards with byte-level resolution
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The number of bytes to shift</param>
        </member>
        <member name="M:Z0.z.vbsll(System.Runtime.Intrinsics.Vector128{System.Byte},System.Byte)">
            <summary>
             __m128i _mm_bslli_si128 (__m128i a, int imm8) PSLLDQ xmm, imm8
            Shifts the source vector leftwards with byte-level resolution
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The number of bytes to shift</param>
        </member>
        <member name="M:Z0.z.vbsll(System.Runtime.Intrinsics.Vector128{System.Int16},System.Byte)">
            <summary>
             __m128i _mm_bslli_si128 (__m128i a, int imm8) PSLLDQ xmm, imm8
            Shifts the source vector leftwards with byte-level resolution
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The number of bytes to shift</param>
        </member>
        <member name="M:Z0.z.vbsll(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Byte)">
            <summary>
             __m128i _mm_bslli_si128 (__m128i a, int imm8) PSLLDQ xmm, imm8
            Shifts the source vector leftwards with byte-level resolution
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The number of bytes to shift</param>
        </member>
        <member name="M:Z0.z.vbsll(System.Runtime.Intrinsics.Vector128{System.Int32},System.Byte)">
            <summary>
             __m128i _mm_bslli_si128 (__m128i a, int imm8) PSLLDQ xmm, imm8
            Shifts the source vector leftwards with byte-level resolution
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The number of bytes to shift</param>
        </member>
        <member name="M:Z0.z.vbsll(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Byte)">
            <summary>
             __m128i _mm_bslli_si128 (__m128i a, int imm8) PSLLDQ xmm, imm8
            Shifts the source vector leftwards with byte-level resolution
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The number of bytes to shift</param>
        </member>
        <member name="M:Z0.z.vbsll(System.Runtime.Intrinsics.Vector128{System.Int64},System.Byte)">
            <summary>
             __m128i _mm_bslli_si128 (__m128i a, int imm8) PSLLDQ xmm, imm8
            Shifts the source vector leftwards with byte-level resolution
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The number of bytes to shift</param>
        </member>
        <member name="M:Z0.z.vbsll(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Byte)">
            <summary>
             __m128i _mm_bslli_si128 (__m128i a, int imm8) PSLLDQ xmm, imm8
            Shifts the source vector leftwards with byte-level resolution
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The number of bytes to shift</param>
        </member>
        <member name="M:Z0.z.vbsll(System.Runtime.Intrinsics.Vector256{System.SByte},System.Byte)">
            <summary>
            __m256i _mm256_bslli_epi128 (__m256i a, const int imm8) VPSLLDQ ymm, ymm, imm8
            Shifts the source vector leftwards with byte-level resolution
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The number of bytes to shift</param>
        </member>
        <member name="M:Z0.z.vbsll(System.Runtime.Intrinsics.Vector256{System.Byte},System.Byte)">
            <summary>
            __m256i _mm256_bslli_epi128 (__m256i a, const int imm8) VPSLLDQ ymm, ymm, imm8
            Shifts the source vector leftwards with byte-level resolution
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The number of bytes to shift</param>
        </member>
        <member name="M:Z0.z.vbsll(System.Runtime.Intrinsics.Vector256{System.Int16},System.Byte)">
            <summary>
            __m256i _mm256_bslli_epi128 (__m256i a, const int imm8) VPSLLDQ ymm, ymm, imm8
            Shifts the source vector leftwards with byte-level resolution
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The number of bytes to shift</param>
        </member>
        <member name="M:Z0.z.vbsll(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Byte)">
            <summary>
            __m256i _mm256_bslli_epi128 (__m256i a, const int imm8) VPSLLDQ ymm, ymm, imm8
            Shifts the source vector leftwards with byte-level resolution
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The number of bytes to shift</param>
        </member>
        <member name="M:Z0.z.vbsll(System.Runtime.Intrinsics.Vector256{System.Int32},System.Byte)">
            <summary>
            __m256i _mm256_bslli_epi128 (__m256i a, const int imm8) VPSLLDQ ymm, ymm, imm8
            Shifts the source vector leftwards with byte-level resolution
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The number of bytes to shift</param>
        </member>
        <member name="M:Z0.z.vbsll(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Byte)">
            <summary>
            __m256i _mm256_bslli_epi128 (__m256i a, const int imm8) VPSLLDQ ymm, ymm, imm8
            Shifts the source vector leftwards with byte-level resolution
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The number of bytes to shift</param>
        </member>
        <member name="M:Z0.z.vbsll(System.Runtime.Intrinsics.Vector256{System.Int64},System.Byte)">
            <summary>
            __m256i _mm256_bslli_epi128 (__m256i a, const int imm8) VPSLLDQ ymm, ymm, imm8
            Shifts the source vector leftwards with byte-level resolution
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The number of bytes to shift</param>
        </member>
        <member name="M:Z0.z.vbsll(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Byte)">
            <summary>
            __m256i _mm256_bslli_epi128 (__m256i a, const int imm8) VPSLLDQ ymm, ymm, imm8
            Shifts the source vector leftwards with byte-level resolution
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The number of bytes to shift</param>
        </member>
        <member name="M:Z0.z.vbsrl(System.Runtime.Intrinsics.Vector128{System.SByte},System.Byte)">
            <summary>
            __m128i _mm_bsrli_si128 (__m128i a, int imm8) PSRLDQ xmm, imm8
            Shifts the source vector rightwards with byte-level resolution
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The number of bytes to shift</param>
        </member>
        <member name="M:Z0.z.vbsrl(System.Runtime.Intrinsics.Vector128{System.Byte},System.Byte)">
            <summary>
            __m128i _mm_bsrli_si128 (__m128i a, int imm8) PSRLDQ xmm, imm8
            Shifts the source vector rightwards with byte-level resolution
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The number of bytes to shift</param>
        </member>
        <member name="M:Z0.z.vbsrl(System.Runtime.Intrinsics.Vector128{System.Int16},System.Byte)">
            <summary>
            __m128i _mm_bsrli_si128 (__m128i a, int imm8) PSRLDQ xmm, imm8
            Shifts the source vector rightwards with byte-level resolution
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The number of bytes to shift</param>
        </member>
        <member name="M:Z0.z.vbsrl(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Byte)">
            <summary>
            __m128i _mm_bsrli_si128 (__m128i a, int imm8) PSRLDQ xmm, imm8
            Shifts the source vector rightwards with byte-level resolution
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The number of bytes to shift</param>
        </member>
        <member name="M:Z0.z.vbsrl(System.Runtime.Intrinsics.Vector128{System.Int32},System.Byte)">
            <summary>
            __m128i _mm_bsrli_si128 (__m128i a, int imm8) PSRLDQ xmm, imm8
            Shifts the source vector rightwards with byte-level resolution
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The number of bytes to shift</param>
        </member>
        <member name="M:Z0.z.vbsrl(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Byte)">
            <summary>
            __m128i _mm_bsrli_si128 (__m128i a, int imm8) PSRLDQ xmm, imm8
            Shifts the source vector rightwards with byte-level resolution
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The number of bytes to shift</param>
        </member>
        <member name="M:Z0.z.vbsrl(System.Runtime.Intrinsics.Vector128{System.Int64},System.Byte)">
            <summary>
            __m128i _mm_bsrli_si128 (__m128i a, int imm8) PSRLDQ xmm, imm8
            Shifts the source vector rightwards with byte-level resolution
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The number of bytes to shift</param>
        </member>
        <member name="M:Z0.z.vbsrl(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Byte)">
            <summary>
            __m128i _mm_bsrli_si128 (__m128i a, int imm8) PSRLDQ xmm, imm8
            Shifts the source vector rightwards with byte-level resolution
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The number of bytes to shift</param>
        </member>
        <member name="M:Z0.z.vbsrl(System.Runtime.Intrinsics.Vector256{System.SByte},System.Byte)">
            <summary>
            __m256i _mm256_bsrli_epi128 (__m256i a, const int imm8) VPSRLDQ ymm, ymm, imm8
            Shifts the source vector rightwards with byte-level resolution
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The number of bytes to shift</param>
        </member>
        <member name="M:Z0.z.vbsrl(System.Runtime.Intrinsics.Vector256{System.Byte},System.Byte)">
            <summary>
            __m256i _mm256_bsrli_epi128 (__m256i a, const int imm8) VPSRLDQ ymm, ymm, imm8
            Shifts the source vector rightwards with byte-level resolution
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The number of bytes to shift</param>
        </member>
        <member name="M:Z0.z.vbsrl(System.Runtime.Intrinsics.Vector256{System.Int16},System.Byte)">
            <summary>
            __m256i _mm256_bsrli_epi128 (__m256i a, const int imm8) VPSRLDQ ymm, ymm, imm8
            Shifts the source vector rightwards with byte-level resolution
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The number of bytes to shift</param>
        </member>
        <member name="M:Z0.z.vbsrl(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Byte)">
            <summary>
            __m256i _mm256_bsrli_epi128 (__m256i a, const int imm8) VPSRLDQ ymm, ymm, imm8
            Shifts the source vector rightwards with byte-level resolution
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The number of bytes to shift</param>
        </member>
        <member name="M:Z0.z.vbsrl(System.Runtime.Intrinsics.Vector256{System.Int32},System.Byte)">
            <summary>
            __m256i _mm256_bsrli_epi128 (__m256i a, const int imm8) VPSRLDQ ymm, ymm, imm8
            Shifts the source vector rightwards with byte-level resolution
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The number of bytes to shift</param>
        </member>
        <member name="M:Z0.z.vbsrl(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Byte)">
            <summary>
            __m256i _mm256_bsrli_epi128 (__m256i a, const int imm8) VPSRLDQ ymm, ymm, imm8
            Shifts the source vector rightwards with byte-level resolution
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The number of bytes to shift</param>
        </member>
        <member name="M:Z0.z.vbsrl(System.Runtime.Intrinsics.Vector256{System.Int64},System.Byte)">
            <summary>
            __m256i _mm256_bsrli_epi128 (__m256i a, const int imm8) VPSRLDQ ymm, ymm, imm8
            Shifts the source vector rightwards with byte-level resolution
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The number of bytes to shift</param>
        </member>
        <member name="M:Z0.z.vbsrl(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Byte)">
            <summary>
            __m256i _mm256_bsrli_epi128 (__m256i a, const int imm8) VPSRLDQ ymm, ymm, imm8
            Shifts the source vector rightwards with byte-level resolution
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The number of bytes to shift</param>
        </member>
        <member name="M:Z0.z.vbyteswap``1(Z0.N128,``0)">
            <summary>
            Retrieves the shuffle pattern that, when applied, swaps the byte-level representation
            of each  unsigned 16,32, or 64-bit integer component value
            </summary>
            <param name="w">The vector width selector</param>
            <param name="n">The integer width representative where n = 16 | 32 | 64</param>
            <typeparam name="N">The integer width type</typeparam>
        </member>
        <member name="M:Z0.z.vbyteswap``1(Z0.N256,``0)">
            <summary>
            Retrieves the shuffle pattern that, when applied, swaps the byte-level representation
            of each  unsigned 16,32, or 64-bit integer component value
            </summary>
            <param name="w">The vector width selector</param>
            <param name="n">The integer width representative where n = 16 | 32 | 64</param>
            <typeparam name="N">The integer width type</typeparam>
        </member>
        <member name="M:Z0.z.vbyteswap(System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            Effects the reversal of the byte-level representation of each component in the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vbyteswap(System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            Effects the reversal of the byte-level representation of each component in the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vbyteswap(System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            Effects the reversal of the byte-level representation of each component in the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vbyteswap(System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            Effects the reversal of the byte-level representation of each component in the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vbyteswap(System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            Effects the reversal of the byte-level representation of each component in the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vbyteswap(System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            Effects the reversal of the byte-level representation of each component in the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.clmul(System.Byte,System.Byte)">
            <summary>
            Computes the caryless 16-bit product of two 8-bit operands
            </summary>
            <param name="lhs">The left operand</param>
            <param name="rhs">The right operand</param>
        </member>
        <member name="M:Z0.z.clmul(System.UInt16,System.UInt16)">
            <summary>
            Returns the caryless 32 bit product of two 16-bit operands
            </summary>
            <param name="lhs">The left operand</param>
            <param name="rhs">The right operand</param>
        </member>
        <member name="M:Z0.z.clmul(System.UInt32,System.UInt32)">
            <summary>
            Returns the caryless 64 bit product from two 32-bit operands
            </summary>
            <param name="lhs">The left operand</param>
            <param name="rhs">The right operand</param>
        </member>
        <member name="M:Z0.z.clmul(System.UInt64,System.UInt64)">
            <summary>
            __m128i _mm_clmulepi64_si128 (__m128i a, __m128i b, const int imm8) PCLMULQDQ xmm, xmm/m128, imm8
            Computes the caryless 128-bit product of two 64-bit operands
            </summary>
            <param name="lhs">The left operand</param>
            <param name="rhs">The right operand</param>
        </member>
        <member name="M:Z0.z.clmulr(Z0.N8,System.Byte,System.Byte,System.UInt16)">
            <summary>
            Computes the carryless product of the operands reduced by a specified polynomial
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <param name="poly">The reducing polynomial</param>
        </member>
        <member name="M:Z0.z.clmulr(Z0.N16,System.UInt16,System.UInt16,System.UInt32)">
            <summary>
            Computes the carryless product of the operands reduced by a specified polynomial
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <param name="poly">The reducing polynomial</param>
        </member>
        <member name="M:Z0.z.clmulr(Z0.N32,System.UInt32,System.UInt32,System.UInt64)">
            <summary>
            Computes the carryless product of the operands reduced by a specified polynomial
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <param name="poly">The reducing polynomial</param>
        </member>
        <member name="M:Z0.z.convert(System.Runtime.Intrinsics.Vector128{System.Single},Z0.N64,System.Int64)">
            <summary>
            __int64 _mm_cvtss_si64 (__m128 a) CVTSS2SI r64, xmm/m32
            src[0..31] -> r64
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="t">A target type representative</param>
        </member>
        <member name="M:Z0.z.convert(System.Runtime.Intrinsics.Vector128{System.Single},Z0.N32,System.Int32)">
            <summary>
            int _mm_cvtss_si32 (__m128 a) CVTSS2SI r32, xmm/m32
            src[0..31] -> r32
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="t">A target type representative</param>
        </member>
        <member name="M:Z0.z.convert(System.Runtime.Intrinsics.Vector128{System.Double},Z0.N64,System.Int64)">
            <summary>
             __int64 _mm_cvtsd_si64 (__m128d a) CVTSD2SI r64, xmm/m64
            src[0..63] -> r64
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="t">A target type representative</param>
        </member>
        <member name="M:Z0.z.convert(System.Runtime.Intrinsics.Vector128{System.Single},Z0.N128,System.Int32)">
            <summary>
            __m128i _mm_cvttps_epi32 (__m128 a) CVTTPS2DQ xmm, xmm/m128
            Converts a floating-point source vector to an 32-bit integer target vector with a loss of precision
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="t">A target type representative</param>
        </member>
        <member name="M:Z0.z.convert(System.Runtime.Intrinsics.Vector128{System.Int32},Z0.N128,System.Single)">
            <summary>
            __m128 _mm_cvtepi32_ps (__m128i a) CVTDQ2PS xmm, xmm/m128
            Converts an integer source vector to a floating-point target vector
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="t">A target type representative</param>
        </member>
        <member name="M:Z0.z.convert(System.Runtime.Intrinsics.Vector128{System.Int32},Z0.N256,System.Double)">
            <summary>
            __m256d _mm256_cvtepi32_pd (__m128i a) VCVTDQ2PD ymm, xmm/m128
            4x32i ->4x64f
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.convert(System.Runtime.Intrinsics.Vector128{System.Double},Z0.N128,System.Single)">
            <summary>
            __m128 _mm_cvtpd_ps (__m128d a) CVTPD2PS xmm, xmm/m128
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="t">A target type representative</param>
        </member>
        <member name="M:Z0.z.convert(System.Runtime.Intrinsics.Vector256{System.Int32},Z0.N256,System.Single)">
            <summary>
            __m256 _mm256_cvtepi32_ps (__m256i a) VCVTDQ2PS ymm, ymm/m256
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="t">A target type representative</param>
        </member>
        <member name="M:Z0.z.convert(System.Runtime.Intrinsics.Vector128{System.Double},Z0.N128,System.Int32)">
            <summary>
             __m128i _mm_cvttpd_epi32 (__m128d a) CVTTPD2DQ xmm, xmm/m128
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="t">A target type representative</param>
        </member>
        <member name="M:Z0.z.convert(System.Runtime.Intrinsics.Vector256{System.Single},Z0.N256,System.Int32)">
            <summary>
            __m256i _mm256_cvttps_epi32 (__m256 a) VCVTTPS2DQ ymm, ymm/m256
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="t">A target type representative</param>
        </member>
        <member name="M:Z0.z.convert(System.Runtime.Intrinsics.Vector256{System.Double},Z0.N128,System.Int32)">
            <summary>
            __m128i _mm256_cvtpd_epi32 (__m256d a) VCVTPD2DQ xmm, ymm/m256
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="t">A target type representative</param>
        </member>
        <member name="M:Z0.z.convert(System.Runtime.Intrinsics.Vector256{System.Double},Z0.N128,System.Single)">
            <summary>
            __m128 _mm256_cvtpd_ps (__m256d a)VCVTPD2PS xmm, ymm/m256
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="t">A target type representative</param>
        </member>
        <member name="M:Z0.z.vcast``2(System.Runtime.Intrinsics.Vector128{``0},``1)">
            <summary>
            Presents a 128-bit S-cell vector as a 128-bit T-cell vector
            </summary>
            <param name="x">The source vector</param>
            <param name="t">A target cell representative used only for type inference</param>
            <typeparam name="S">The source cell type</typeparam>
            <typeparam name="T">The target cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcast``2(System.Runtime.Intrinsics.Vector256{``0},``1)">
            <summary>
            Presents a 256-bit S-cell vector as a 256-bit T-cell vector
            </summary>
            <param name="x">The source vector</param>
            <param name="t">A target cell representative used only for type inference</param>
            <typeparam name="S">The source cell type</typeparam>
            <typeparam name="T">The target cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcast``2(Z0.Vector512{``0},``1)">
            <summary>
            Presents a 512-bit S-cell vector as a 512-bit T-cell vector
            </summary>
            <param name="x">The source vector</param>
            <param name="t">A target cell representative used only for type inference</param>
            <typeparam name="S">The source cell type</typeparam>
            <typeparam name="T">The target cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcell``1(System.Runtime.Intrinsics.Vector128{``0},System.Byte)">
            <summary>
            Returns a reference to an index-identified cell
            </summary>
            <param name="src">The source vector</param>
            <param name="index">The cell index</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcell``1(System.Runtime.Intrinsics.Vector256{``0},System.Byte)">
            <summary>
            Returns a reference to an index-identified cell
            </summary>
            <param name="src">The source vector</param>
            <param name="index">The cell index</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcell``1(System.Runtime.Intrinsics.Vector128{``0},System.Byte,``0)">
            <summary>
            Sets an index-identified component to a specified value
            </summary>
            <param name="src">The source vector</param>
            <param name="index">The index of the component to extract</param>
            <param name="value">The new component value</param>
            <typeparam name="T">The primal component type</typeparam>
        </member>
        <member name="M:Z0.z.vcell``1(``0,System.Byte,System.Runtime.Intrinsics.Vector128{``0})">
            <summary>
            Sets an index-identified component to a specified value
            </summary>
            <param name="src">The source vector</param>
            <param name="index">The index of the component to extract</param>
            <param name="value">The new component value</param>
            <typeparam name="T">The primal component type</typeparam>
        </member>
        <member name="M:Z0.z.vcell``1(``0,System.Byte,System.Runtime.Intrinsics.Vector256{``0})">
            <summary>
            Sets an index-identified component to a specified value
            </summary>
            <param name="src">The source vector</param>
            <param name="index">The index of the component to extract</param>
            <param name="value">The new component value</param>
            <typeparam name="T">The primal component type</typeparam>
        </member>
        <member name="M:Z0.z.vcell``2(System.Runtime.Intrinsics.Vector128{``0},System.Byte)">
            <summary>
            Extracts a T-indexed component from a vector obtained by converting the S-vector to a T-vector
            </summary>
            <param name="src">The source vector</param>
            <param name="index">The index of the component to extract</param>
            <typeparam name="T">The primal component type</typeparam>
        </member>
        <member name="M:Z0.z.vcell16``1(System.Runtime.Intrinsics.Vector128{``0},System.Byte)">
            <summary>
            Extract an index-identified component of a reinterpreted vector
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.vcell16``1(System.Runtime.Intrinsics.Vector256{``0},System.Byte)">
            <summary>
            Extract an index-identified component of a reinterpreted vector
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.vcell16i``1(System.Runtime.Intrinsics.Vector128{``0},System.Byte)">
            <summary>
            Extract an index-identified component of a reinterpreted vector
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.vcell16i``1(System.Runtime.Intrinsics.Vector256{``0},System.Byte)">
            <summary>
            Extract an index-identified component of a reinterpreted vector
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.vcell32``1(System.Runtime.Intrinsics.Vector128{``0},System.Byte)">
            <summary>
            Extract an index-identified component of a reinterpreted vector
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.vcell32``1(System.Runtime.Intrinsics.Vector256{``0},System.Byte)">
            <summary>
            Extract an index-identified component of a reinterpreted vector
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.vcell32i``1(System.Runtime.Intrinsics.Vector128{``0},System.Byte)">
            <summary>
            Extract an index-identified component of a reinterpreted vector
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.vcell32f``1(System.Runtime.Intrinsics.Vector128{``0},System.Byte)">
            <summary>
            Extract an index-identified component of a reinterpreted vector
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.vcell32i``1(System.Runtime.Intrinsics.Vector256{``0},System.Byte)">
            <summary>
            Extract an index-identified component of a reinterpreted vector
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.vcell32f``1(System.Runtime.Intrinsics.Vector256{``0},System.Byte)">
            <summary>
            Extract an index-identified component of a reinterpreted vector
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.vcell64``1(System.Runtime.Intrinsics.Vector128{``0},System.Byte)">
            <summary>
            Extract an index-identified component of a reinterpreted vector
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.vcell64``1(System.Runtime.Intrinsics.Vector256{``0},System.Byte)">
            <summary>
            Extract an index-identified component of a reinterpreted vector
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.vcell64i``1(System.Runtime.Intrinsics.Vector128{``0},System.Byte)">
            <summary>
            Extract an index-identified component of a reinterpreted vector
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.vcell64i``1(System.Runtime.Intrinsics.Vector256{``0},System.Byte)">
            <summary>
            Extract an index-identified component of a reinterpreted vector
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.vcell64f``1(System.Runtime.Intrinsics.Vector128{``0},System.Byte)">
            <summary>
            Extract an index-identified component of a reinterpreted vector
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.vcell64f``1(System.Runtime.Intrinsics.Vector256{``0},System.Byte)">
            <summary>
            Extract an index-identified component of a reinterpreted vector
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.vcell8``1(System.Runtime.Intrinsics.Vector128{``0},System.Byte)">
            <summary>
            Extract an index-identified component of a reinterpreted vector
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.vcell8``1(System.Runtime.Intrinsics.Vector256{``0},System.Byte)">
            <summary>
            Extract an index-identified component of a reinterpreted vector
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.vcell8i``1(System.Runtime.Intrinsics.Vector128{``0},System.Byte)">
            <summary>
            Extract an index-identified component of a reinterpreted vector
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.vcell8i``1(System.Runtime.Intrinsics.Vector256{``0},System.Byte)">
            <summary>
            Extract an index-identified component of a reinterpreted vector
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The source vector primal component type</typeparam>
        </member>
        <member name="M:Z0.z.vcellref``1(System.Runtime.Intrinsics.Vector128{``0}@,System.Byte)">
            <summary>
            Returns a reference to an index-identified cell
            </summary>
            <param name="src">The source vector</param>
            <param name="index">The cell index</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcellref``1(System.Runtime.Intrinsics.Vector256{``0}@,System.Byte)">
            <summary>
            Returns a reference to an index-identified cell
            </summary>
            <param name="src">The source vector</param>
            <param name="index">The cell index</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcellref``1(Z0.Vector512{``0}@,System.Byte)">
            <summary>
            Returns a reference to an index-identified cell
            </summary>
            <param name="src">The source vector</param>
            <param name="index">The cell index</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcimpl(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            Computes the converse implication, ~x | y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vcimpl(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            Computes the converse implication, ~x | y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vcimpl(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            Computes the converse implication, ~x | y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vcimpl(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            Computes the converse implication, ~x | y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vcimpl(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            Computes the converse implication, ~x | y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vcimpl(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            Computes the converse implication, ~x | y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vcimpl(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            Computes the converse implication, ~x | y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vcimpl(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            Computes the converse implication, ~x | y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vcimpl(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            Computes the converse implication, ~x | y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vcimpl(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            Computes the converse implication, ~x | y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vcimpl(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            Computes the converse implication, ~x | y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vcimpl(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            Computes the converse implication, ~x | y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vcimpl(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            Computes the converse implication, ~x | y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vcimpl(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            Computes the converse implication, ~x | y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vcimpl(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            Computes the converse implication, ~x | y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vcimpl(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            Computes the converse implication, ~x | y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vclearalt``1(Z0.N256)">
            <summary>
            Creates a shuffle mask that clears every-other vector component
            </summary>
            <typeparam name="T">The primal component type</typeparam>
        </member>
        <member name="M:Z0.z.vclmul(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m128i _mm_clmulepi64_si128 (__m128i a, __m128i b, const int imm8) PCLMULQDQ xmm, xmm/m128, imm8
            Computes the caryless 128-bit product of two 64-bit operands
            </summary>
            <param name="lhs">The left operand</param>
            <param name="rhs">The right operand</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vclmul(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64},Z0.ClMulMask)" -->
        <member name="M:Z0.z.vclmulr(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            Computes the carryless product of two 64-bit operands reduced by a specified polynomial
            </summary>
            <param name="a">The first operand</param>
            <param name="b">The second operand</param>
            <param name="poly">The reducing polynomial</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vcnonimpl(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vcnonimpl(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vcnonimpl(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vcnonimpl(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vcnonimpl(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vcnonimpl(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vcnonimpl(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vcnonimpl(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vcnonimpl(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vcnonimpl(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vcnonimpl(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vcnonimpl(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vcnonimpl(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vcnonimpl(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vcnonimpl(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vcnonimpl(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})" -->
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector256{System.Int16},Z0.W8,Z0.N0)">
            <summary>
            16x16i -> 16x8u
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.W8)">
            <summary>
            8x16u -> 8x8u
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target vector width</param>
            <param name="t">A target component type representative</param>
        </member>
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector256{System.UInt16},Z0.W8)">
            <summary>
            16x16u -> 16x8u
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector256{System.UInt32},Z0.W8)">
            <summary>
            8x32u -> 8x8u (a scalar vector)
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="t">A target component type representative</param>
        </member>
        <member name="M:Z0.z.vcompact(Z0.Vector512{System.UInt32}@,Z0.W8)">
            <summary>
            16x32u -> 16x8u
            </summary>
            <param name="src">The source vector tuple</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector256{System.Int16},Z0.W8)">
            <summary>
            16x16i -> 16x8i
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector256{System.UInt32},Z0.W16)">
            <summary>
            8x32u -> 8x16u
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target vector width</param>
            <param name="t">A target component type representative</param>
        </member>
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector256{System.Int32},Z0.W16)">
            <summary>
            8x32i -> 8x16i
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target vector width</param>
            <param name="t">A target component type representative</param>
        </member>
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector256{System.UInt64},Z0.W32)">
            <summary>
            4x64w -> 4x32w
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector256{System.Int64},Z0.W32)">
            <summary>
            4x64w -> 4x32w
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.W64)">
            <summary>
            8x16u -> 64u (a scalar)
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="t">A target type representative</param>
        </member>
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector256{System.UInt32},Z0.W64)">
            <summary>
            8x32u -> 64u (a scalar)
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="t">A target type representative</param>
        </member>
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16},Z0.N128,System.SByte)">
            <summary>
            (8x16i,8x16i) -> 16x8i
            </summary>
            <param name="x">The first source vector</param>
            <param name="y">The second source vector</param>
        </member>
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16},Z0.N128,System.Byte)">
            <summary>
            (8x16i,8x16i) -> 16x8u
            </summary>
            <param name="x">The first source vector</param>
            <param name="y">The second source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16},Z0.N256,System.SByte)">
            <summary>
            (16x16i,16x16i) -> 32x8i
            </summary>
            <param name="x">The first source vector</param>
            <param name="y">The second source vector</param>
        </member>
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.N128,System.Byte)">
            <summary>
            (8x16u,8x16u) -> 16x8u
            </summary>
            <param name="x">The first source vector</param>
            <param name="y">The second source vector</param>
        </member>
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16},Z0.N256,System.Byte)">
            <summary>
            (16x16u,16x16u) -> 32x8u
            </summary>
            <param name="x">The first source vector</param>
            <param name="y">The second source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32},Z0.N128,System.Int16)">
            <summary>
            (4x32i,4x32i) -> 8x16i
            </summary>
            <param name="x">The first source vector</param>
            <param name="y">The second source vector</param>
            <param name="w">The target vector width</param>
            <param name="t">A target component type representative</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32},Z0.N256,System.Int16)" -->
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32},Z0.N128,System.UInt16)">
            <summary>
            (4x32u,4x32u) -> 8x16u
            </summary>
            <param name="x">The first source vector</param>
            <param name="y">The second source vector</param>
            <param name="w">The target vector width</param>
            <param name="t">A target component type representative</param>
        </member>
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32},Z0.N256,System.UInt16)">
            <summary>
            (8x32w,8x32w) -> 16x16w
            </summary>
            <param name="x">The first source vector</param>
            <param name="y">The second source vector</param>
            <remarks>The vpackus intrinsic emits a vector in the following form:
            [0, 1, 2, 3, 8, 9, 10, 11, 4, 5, 6, 7, 12, 13, 14, 15]
            To make use of the result, it must be permuted to a more reasonable order,
            [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
            </remarks>
        </member>
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32},Z0.N128,System.Byte)">
            <summary>
            (8x32u, 8x32u) -> 16x8u
            </summary>
            <param name="x0">The first source vector</param>
            <param name="x1">The second source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64},Z0.N128,System.UInt32)">
            <summary>
            (2x64w,2x64w) -> 4x32w
            </summary>
            <param name="x0">The first source vector</param>
            <param name="x1">The second source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64},Z0.N256,System.UInt32)">
            <summary>
            (4x64w,4x64w) -> 8x32w
            </summary>
            <param name="x0">The first source vector</param>
            <param name="x1">The second source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32},Z0.N128,System.Byte)">
            <summary>
            (4x32u,4x32u,4x32u,4x32u) -> 16x8u
            </summary>
            <param name="x0">The first source vector</param>
            <param name="x1">The second source vector</param>
            <param name="x2">The third source vector</param>
            <param name="x3">The fourth source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32},Z0.N256,System.Byte)">
            <summary>
            (8x32u,8x32u,8x32u,8x32u) -> 32x8w
            </summary>
            <param name="x0">The first source vector</param>
            <param name="x1">The second source vector</param>
            <param name="x2">The third source vector</param>
            <param name="x3">The fourth source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vcompact(Z0.Vector512{System.UInt32}@,Z0.N128,System.Byte)">
            <summary>
            16x32u -> 16x8u
            </summary>
            <param name="src">The source vector tuple</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector256{System.UInt64},Z0.N128,System.UInt32)">
            <summary>
            4x64w -> 4x32w
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector256{System.Int64},Z0.N128,System.Int32)">
            <summary>
            4x64w -> 4x32w
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector256{System.Int16},Z0.N128,System.SByte)">
            <summary>
            16x16i -> 16x8i
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector256{System.Int16},Z0.N128,System.Byte)">
            <summary>
            16x16i -> 16x8u
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.N128,System.Byte)">
            <summary>
            8x16u -> 8x8u
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target vector width</param>
            <param name="t">A target component type representative</param>
        </member>
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector256{System.UInt16},Z0.N128,System.Byte)">
            <summary>
            16x16u -> 16x8u
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.N64,System.UInt64)">
            <summary>
            8x16u -> 64u (a scalar)
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="t">A target type representative</param>
        </member>
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector256{System.UInt32},Z0.N128,System.UInt16)">
            <summary>
            8x32u -> 8x16u
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target vector width</param>
            <param name="t">A target component type representative</param>
        </member>
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector256{System.UInt32},Z0.N64,System.UInt64)">
            <summary>
            8x32u -> 64u (a scalar)
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="t">A target type representative</param>
        </member>
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector256{System.UInt32},Z0.N128,System.Byte)">
            <summary>
            8x32u -> 8x8u (a scalar vector)
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="t">A target component type representative</param>
        </member>
        <member name="M:Z0.z.vcompact(System.Runtime.Intrinsics.Vector256{System.Int32},Z0.N128,System.Int16)">
            <summary>
            8x32i -> 8x16i
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target vector width</param>
            <param name="t">A target component type representative</param>
        </member>
        <member name="M:Z0.z.vconcat(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            Creates a 256-bit vector by concatenating two 128-bit source vectors
            </summary>
            <param name="lo">The lower 128-bits of the target vector</param>
            <param name="hi">The upper 128-bits of the target vector</param>
        </member>
        <member name="M:Z0.z.vconcat(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            Creates a 256-bit vector by concatenating two 128-bit source vectors
            </summary>
            <param name="lo">The lower 128-bits of the target vector</param>
            <param name="hi">The upper 128-bits of the target vector</param>
        </member>
        <member name="M:Z0.z.vconcat(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            Creates a 256-bit vector by concatenating two 128-bit source vectors
            </summary>
            <param name="lo">The lower 128-bits of the target vector</param>
            <param name="hi">The upper 128-bits of the target vector</param>
        </member>
        <member name="M:Z0.z.vconcat(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            Creates a 256-bit vector by concatenating two 128-bit source vectors
            </summary>
            <param name="lo">The lower 128-bits of the target vector</param>
            <param name="hi">The upper 128-bits of the target vector</param>
        </member>
        <member name="M:Z0.z.vconcat(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            Creates a 256-bit vector by concatenating two 128-bit source vectors
            </summary>
            <param name="lo">The lower 128-bits of the target vector</param>
            <param name="hi">The upper 128-bits of the target vector</param>
        </member>
        <member name="M:Z0.z.vconcat(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            Creates a 256-bit vector by concatenating two 128-bit source vectors
            </summary>
            <param name="lo">The lower 128-bits of the target vector</param>
            <param name="hi">The upper 128-bits of the target vector</param>
        </member>
        <member name="M:Z0.z.vconcat(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            Creates a 256-bit vector by concatenating two 128-bit source vectors
            </summary>
            <param name="lo">The lower 128-bits of the target vector</param>
            <param name="hi">The upper 128-bits of the target vector</param>
        </member>
        <member name="M:Z0.z.vconcat(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            Creates a 256-bit vector by concatenating two 128-bit source vectors
            </summary>
            <param name="lo">The lower 128-bits of the target vector</param>
            <param name="hi">The upper 128-bits of the target vector</param>
        </member>
        <member name="M:Z0.z.vconcat(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            Creates a 256-bit vector by concatenating two 128-bit source vectors
            </summary>
            <param name="lo">The lower 128-bits of the target vector</param>
            <param name="hi">The upper 128-bits of the target vector</param>
        </member>
        <member name="M:Z0.z.vconcat(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            Creates a 256-bit vector by concatenating two 128-bit source vectors
            </summary>
            <param name="lo">The lower 128-bits of the target vector</param>
            <param name="hi">The upper 128-bits of the target vector</param>
        </member>
        <member name="M:Z0.z.vconcat``1(System.Runtime.Intrinsics.Vector128{``0},System.Runtime.Intrinsics.Vector128{``0})">
            <summary>
            Creates a 256-bit vector from two 128-bit vectors
            This mimics the _mm256_set_m128i intrinsic which does not appear to be available
            </summary>
            <param name="lo">The lo part</param>
            <param name="hi">The hi part</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock16{System.SByte}@,Z0.N128,System.Int64)">
            <summary>
            PMOVSXBQ xmm, m16
            2x8i -> 2x64i
            </summary>
            <param name="src">The memory source</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock32{System.SByte}@,Z0.N128,System.Int32)">
            <summary>
            PMOVSXBD xmm, m32
            4x8i -> 4x32i
            </summary>
            <param name="src">The memory source</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock32{System.SByte}@,Z0.N256,System.Int64)">
            <summary>
             VPMOVSXBQ ymm, m32
            4x8i -> 4x64i
            </summary>
            <param name="src">The memory source</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock64{System.SByte}@,Z0.N128,System.Int16)">
            <summary>
            PMOVSXBW xmm, m64
            8x8i -> 8x16i
            </summary>
            <param name="src">The blocked memory source</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock64{System.SByte}@,Z0.N256,System.Int32)">
            <summary>
             VPMOVSXBD ymm, m64
            8x8i -> 8x32i
            </summary>
            <param name="src">The memory source</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock128{System.SByte}@,Z0.N256,System.Int16)">
            <summary>
            VPMOVSXBW ymm, m128
            16x8i -> 16x16i
            </summary>
            <param name="src">The memory source</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock16{System.Byte}@,Z0.N128,System.Int64)">
            <summary>
            PMOVZXBQ xmm, m16
            2x8u -> 2x64i
            </summary>
            <param name="src">The memory source</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock16{System.Byte}@,Z0.N128,System.UInt64)">
            <summary>
            PMOVZXBQ xmm, m16
            2x8u -> 2x64u
            </summary>
            <param name="src">The blocked memory source</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock32{System.Byte}@,Z0.N128,System.Int32)">
            <summary>
            PMOVZXBD xmm, m32
            4x8u -> 4x32i
            </summary>
            <param name="src">The memory source</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock32{System.Byte}@,Z0.N128,System.UInt32)">
            <summary>
            PMOVZXBD xmm, m32
            4x8u -> 4x32u
            </summary>
            <param name="src">The blocked memory source</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock32{System.Byte}@,Z0.N256,System.UInt64)">
            <summary>
            VPMOVZXBQ ymm, m32
            4x8u -> 4x64u
            </summary>
            <param name="src">The blocked memory source</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock32{System.Byte}@,Z0.N256,System.Int64)">
            <summary>
            VPMOVZXBQ ymm, m32
            4x8u -> 4x64i
            </summary>
            <param name="src">The memory source</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock64{System.Byte}@,Z0.N128,System.Int16)">
            <summary>
            PMOVZXBW xmm, m64
            8x8u -> 8x16u
            </summary>
            <param name="src">The memory source</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock64{System.Byte}@,Z0.N128,System.UInt16)">
            <summary>
            PMOVZXBW xmm, m64
            8x8u -> 8x16u
            </summary>
            <param name="src">The blocked memory source</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock64{System.Byte}@,Z0.N256,System.UInt32)">
            <summary>
            VPMOVZXBD ymm, m64
            8x8u -> 8x32u
            </summary>
            <param name="src">The blocked memory source</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock128{System.Byte}@,Z0.N256,System.Int16)">
            <summary>
            VPMOVZXBW ymm, m128
            16x8u -> 16x16i
            </summary>
            <param name="src">The memory source</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock128{System.Byte}@,Z0.N256,System.UInt16)">
            <summary>
            VPMOVZXBW ymm, m128
            16x8u -> 16x16u
            </summary>
            <param name="src">The blocked memory source</param>
            <param name="w">The target width</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock32{System.Int16}@,Z0.N128,System.Int64)">
            <summary>
            PMOVSXWQ xmm, m32
            2x16i -> 2x64u
            </summary>
            <param name="src">The memory source</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock64{System.Int16}@,Z0.N128,System.Int32)">
            <summary>
            PMOVSXWD xmm, m64
            4x16i -> 4x32i
            </summary>
            <param name="src">The blocked memory source</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock32{System.UInt16}@,Z0.N128,System.Int64)">
            <summary>
            PMOVZXWQ xmm, m32
            </summary>
            <param name="src">The memory source</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock32{System.UInt16}@,Z0.N128,System.UInt64)">
            <summary>
            PMOVZXWQ xmm, m32
            2x16u -> 2x64u
            </summary>
            <param name="src">The blocked memory source</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock64{System.UInt16}@,Z0.N256,System.UInt64)">
            <summary>
            VPMOVZXWQ ymm, m64
            4x16u -> 4x64u
            </summary>
            <param name="src">The blocked memory source</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock64{System.UInt16}@,Z0.N128,System.UInt32)">
            <summary>
            PMOVSXWD xmm, m64
            4x16u -> 4x32u
            </summary>
            <param name="src">The blocked memory source</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock128{System.UInt16}@,System.UInt32)">
            <summary>
            VPMOVZXWD ymm, m128
            8x16u -> 8x32u
            </summary>
            <param name="src">The blocked memory source</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock128{System.UInt16}@,System.Int32)">
            <summary>
            VPMOVZXWD ymm, m128
            8x16u -> 8x32i
            </summary>
            <param name="src">The blocked memory source</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock64{System.UInt16}@,Z0.N256,System.Int64)">
            <summary>
            VPMOVZXWQ ymm, m64
            4x16u -> 4x64i
            </summary>
            <param name="src">The memory source</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock128{System.UInt32}@,Z0.N256,System.Int64)">
            <summary>
            VPMOVZXDQ ymm, m128
            4x32u -> 4x64i
            </summary>
            <param name="src">The memory source</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock128{System.UInt32}@,System.UInt64)">
            <summary>
            VPMOVZXDQ ymm, m128
            4x32u -> 4x64u
            </summary>
            <param name="src">The blocked memory source</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock64{System.UInt32}@,Z0.N128,System.UInt64)">
            <summary>
            PMOVZXDQ xmm, m64
            2x32u -> 2x64u
            </summary>
            <param name="src">The memory source</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock64{System.Int32}@,Z0.N128,System.Int64)">
            <summary>
            PMOVSXDQ xmm, m64
            2x32i -> 2x64i
            </summary>
            <param name="src">The memory source</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock128{System.Int32}@,Z0.N256,System.Int64)">
            <summary>
            VPMOVSXDQ ymm, m128
            4x32i -> 4x64i
            </summary>
            <param name="src">The memory source</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock256{System.UInt16}@,Z0.N512,System.UInt32)">
            <summary>
            VPMOVZXWD ymm, m128
            16x16u ->16x32u
            </summary>
            <param name="src">The blocked memory source</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock128{System.Int16}@,Z0.N512,System.Int32)">
            <summary>
            VPMOVSXWD ymm, m128
            16x16u ->16x32u
            </summary>
            <param name="src">The memory source</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock256{System.Byte}@,Z0.N512,System.UInt16)">
            <summary>
            VPMOVZXBW ymm, m128
            32x8u -> 32x16u
            </summary>
            <param name="src">The memory source</param>
            <param name="lo">The lo target</param>
            <param name="hi">The hi target</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock128{System.UInt16}@,Z0.N512,System.UInt64)">
            <summary>
            VPMOVZXWQ ymm, m64
            8x16u -> 8x64u
            </summary>
            <param name="src">The blocked memory source</param>
            <param name="lo">The lower target</param>
            <param name="hi">The upper target</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.SpanBlock256{System.UInt32}@,Z0.N512,System.UInt64)">
            <summary>
            VPMOVZXDQ ymm, m128
            8x32u -> 8x64u
            </summary>
            <param name="src">The blocked memory source</param>
            <param name="lo">The lower target</param>
            <param name="hi">The upper target</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.N64,System.Byte@,Z0.N256,Z0.N32)">
            <summary>
            VPMOVZXBD ymm, m64
            8x8u -> 8x32u
            Evenly covers a 256-bit target vector with a 64-bit source
            </summary>
            <param name="n64">The number of bits covered by the source reference</param>
            <param name="src">The source reference</param>
            <param name="w">The target vector width</param>
            <param name="n">The target component width</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.N64,System.UInt16@,Z0.N256,Z0.N32)">
            <summary>
            VPMOVZXBD ymm, m64
            8x8u -> 8x32u
            Evenly covers a 256-bit target vector with a 64-bit source
            </summary>
            <param name="n64">The number of bits covered by the source reference</param>
            <param name="src">The source reference</param>
            <param name="w">The target vector width</param>
            <param name="n">The target component width</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.N64,System.UInt32@,Z0.N256,Z0.N32)">
            <summary>
            VPMOVZXBD ymm, m64
            8x8u -> 8x32u
            Evenly covers a 256-bit target vector with a 64-bit source
            </summary>
            <param name="n64">The number of bits covered by the source reference</param>
            <param name="src">The source reference</param>
            <param name="w">The target vector width</param>
            <param name="n">The target component width</param>
        </member>
        <member name="M:Z0.z.vconvert(Z0.N64,System.UInt64@,Z0.N256,Z0.N32)">
            <summary>
            VPMOVZXBD ymm, m64
            8x8u -> 8x32u
            Evenly covers a 256-bit target vector with a 64-bit source
            </summary>
            <param name="n64">The number of bits covered by the source reference</param>
            <param name="src">The source reference</param>
            <param name="w">The target vector width</param>
            <param name="n">The target component width</param>
        </member>
        <member name="M:Z0.z.convert(System.Runtime.Intrinsics.Vector128{System.Int32},Z0.N32,System.Int32)">
            <summary>
            int _mm_cvtsi128_si32 (__m128i a) MOVD reg/m32, xmm
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="t">A target type representative</param>
        </member>
        <member name="M:Z0.z.convert(System.Runtime.Intrinsics.Vector128{System.UInt32},Z0.N32,System.UInt32)">
            <summary>
            int _mm_cvtsi128_si32 (__m128i a)MOVD reg/m32, xmm
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="t">A target type representative</param>
        </member>
        <member name="M:Z0.z.convert(System.Runtime.Intrinsics.Vector128{System.Int64},Z0.N64,System.Int64)">
            <summary>
            __int64 _mm_cvtsi128_si64 (__m128i a) MOVQ reg/m64, xmm
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="t">A target type representative</param>
        </member>
        <member name="M:Z0.z.convert(System.Runtime.Intrinsics.Vector128{System.UInt64},Z0.N64,System.UInt64)">
            <summary>
            __int64 _mm_cvtsi128_si64 (__m128i a) MOVQ reg/m64, xmm
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="t">A target type representative</param>
        </member>
        <member name="M:Z0.z.vconvert(System.Runtime.Intrinsics.Vector128{System.Int32},Z0.N256,System.Int64)">
            <summary>
            __m256i _mm256_cvtepi32_epi64 (__m128i a) VPMOVSXDQ ymm, xmm/m128
            4x32i -> 4x64i
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(System.Runtime.Intrinsics.Vector128{System.UInt32},Z0.N256,System.Int64)">
            <summary>
             __m256i _mm256_cvtepu32_epi64 (__m128i a) VPMOVZXDQ ymm, xmm
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(System.Runtime.Intrinsics.Vector128{System.UInt32},Z0.N256,System.UInt64)">
            <summary>
            _m256i _mm256_cvtepu32_epi64 (__m128i a) VPMOVZXDQ ymm, xmm
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64},Z0.N128,System.UInt32)">
            <summary>
            __m128i _mm256_cvtpd_epi32 (__m256d a) VCVTPD2DQ xmm, ymm/m256
            (2x64u,2x64u) -> 4x32u
            </summary>
            <param name="lo">The source vector</param>
            <param name="w">The target width</param>
            <param name="t">A target type representative</param>
        </member>
        <member name="M:Z0.z.vconvert(System.Runtime.Intrinsics.Vector128{System.SByte},Z0.N256,System.UInt16)">
            <summary>
            16x8i -> (8x16u, 8x16u)
            </summary>
            <param name="src">The source vector</param>
            <param name="lo">The first target vector</param>
            <param name="hi">The second target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(System.Runtime.Intrinsics.Vector128{System.SByte},Z0.N256,System.Int16)">
            <summary>
            __m256i _mm256_cvtepi8_epi16 (__m128i a) VPMOVSXBW ymm, xmm/m128
            16x8i -> 16x16u
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(System.Runtime.Intrinsics.Vector128{System.SByte},Z0.N128,System.Int32)">
            <summary>
            __m128i _mm_cvtepi8_epi32 (__m128i a) PMOVSXBD xmm, xmm/m32
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.N256,System.Int16)">
            <summary>
            __m256i _mm256_cvtepu8_epi16 (__m128i a) vpmovzxbw ymm, xmm
            16x8u -> 16x16i
            src[i] -> dst[i], i = 0,...,15
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.N256,System.UInt16)">
            <summary>
             __m256i _mm256_cvtepu8_epi16 (__m128i a) VPMOVZXBW ymm, xmm
            16x8u -> 16x16u
            src[i] -> dst[i], i = 0,...,15
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width selector</param>
            <param name="t">A target cell type representative</param>
        </member>
        <member name="M:Z0.z.vconvert(System.Runtime.Intrinsics.Vector128{System.Int16},Z0.N256,System.Int32)">
            <summary>
            __m256i _mm256_cvtepu8_epi32 (__m128i a) VPMOVZXBD ymm, xmm
            8x16i -> 8x32i
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(System.Runtime.Intrinsics.Vector128{System.Int16},Z0.N256,System.UInt32)">
            <summary>
            __m256i _mm256_cvtepu8_epi32 (__m128i a) VPMOVZXBD ymm, xmm
            8x16i -> 8x32u
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.N256,System.Int32)">
            <summary>
            __m256i _mm256_cvtepu16_epi32 (__m128i a) VPMOVZXWD ymm, xmm
            8x16u -> 8x32i
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.N256,System.UInt32)">
            <summary>
            __m256i _mm256_cvtepu16_epi32 (__m128i a) VPMOVZXWD ymm, xmm
            8x16u -> 8x32u
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vconvert(System.Runtime.Intrinsics.Vector128{System.Int16},Z0.N512,System.Int64)">
            <summary>
            8x16x -> (4x64u,4x64u)
            </summary>
            <param name="src">The source vector</param>
            <param name="lo">The lo target</param>
            <param name="hi">The hi target</param>
        </member>
        <member name="M:Z0.z.vconvert(System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.N512,System.UInt64)">
            <summary>
            8x16x -> (4x64u,4x64u)
            </summary>
            <param name="src">The source vector</param>
            <param name="lo">The lo target</param>
            <param name="hi">The hi target</param>
        </member>
        <member name="M:Z0.z.vconvert(System.Runtime.Intrinsics.Vector128{System.SByte},Z0.N512,System.Int32)">
            <summary>
            16x8i -> 16x32i
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="t">A target cell type representative</param>
        </member>
        <member name="M:Z0.z.vconvert(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.N512,System.UInt32)">
            <summary>
            16x8u -> 16x32u
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width selector</param>
            <param name="t">A target cell type representative</param>
        </member>
        <member name="M:Z0.z.vconvert(System.Runtime.Intrinsics.Vector256{System.UInt64},Z0.W128,System.UInt32)">
            <summary>
            __m128i _mm256_cvtpd_epi32 (__m256d a) VCVTPD2DQ xmm, ymm/m256
            4x64u -> 4x32u
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="t">A target type representative</param>
        </member>
        <member name="M:Z0.z.vconvert(System.Runtime.Intrinsics.Vector256{System.SByte},Z0.N512,System.Int16)">
            <summary>
            src[i] -> lo[i], i = 1,..,15
            src[i] -> hi[i], i = 16,..,31
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vconvert(System.Runtime.Intrinsics.Vector256{System.Byte},Z0.N512,System.Int16)">
            <summary>
            32x8u -> (16x16i, 16x16i)
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vconvert(System.Runtime.Intrinsics.Vector256{System.Int16},Z0.N512,System.Int32)">
            <summary>
            16x16i -> 16x32i
            </summary>
            <param name="src">The source vector</param>
            <param name="lo">The lo target</param>
            <param name="hi">The hi target</param>
        </member>
        <member name="M:Z0.z.vconvert(System.Runtime.Intrinsics.Vector256{System.UInt16},Z0.N512,System.UInt32)">
            <summary>
            16x16u -> 16x32u
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vconvert(System.Runtime.Intrinsics.Vector256{System.Int32},Z0.N512,System.Int64)">
            <summary>
            8x32i -> (4x64i, 4x64i)
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vconvert(System.Runtime.Intrinsics.Vector256{System.UInt32},Z0.N512,System.UInt64)">
            <summary>
            8x32u -> (4x64u, 4x64u)
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vconvert(System.Runtime.Intrinsics.Vector256{System.Byte},Z0.N512,System.UInt16)">
            <summary>
            32x8u -> (16x16u, 16x16u)
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vconvert(System.Runtime.Intrinsics.Vector256{System.SByte},Z0.N1024,System.Int32)">
            <summary>
            32x8i -> (8x32i, 8x32i, 8x32i, 8x32i)
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vconvert(System.Runtime.Intrinsics.Vector256{System.Byte},Z0.N1024,System.UInt32)">
            <summary>
            32x8u -> (8x32u, 8x32u, 8x32u, 8x32u)
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="x1">A target cell type representative</param>
        </member>
        <member name="M:Z0.z.vconvert(System.Runtime.Intrinsics.Vector256{System.UInt16},Z0.N1024,System.UInt64)">
            <summary>
            16x16u -> 16x64u
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="t">A target cell type representative</param>
        </member>
        <member name="M:Z0.z.vcount``2(``0,``1)">
            <summary>
            Computes the vector component count for a given bit-width and component type
            </summary>
            <param name="w">The width selector</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.z.vcount``1(Z0.N128,``0)">
            <summary>
            Computes the vector component count for a given bit-width and component type
            </summary>
            <param name="w">The width selector</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.z.vcount``1(Z0.N256,``0)">
            <summary>
            Computes the vector component count for a given bit-width and component type
            </summary>
            <param name="w">The width selector</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.z.vcount``1(Z0.N512,``0)">
            <summary>
            Computes the vector component count for a given bit-width and component type
            </summary>
            <param name="w">The width selector</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``2(Z0.W128,``0@)">
            <summary>
            Hydrates a 128-bit T-vector from an S-reference
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="S">The source reference type</typeparam>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``2(Z0.W256,``0@)">
            <summary>
            Hydrates a 256-bit T-vector from an S-reference
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="S">The source reference type</typeparam>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``2(Z0.W512,``0@)">
            <summary>
            Hydrates a 512-bit T-vector from an S-reference
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="S">The source reference type</typeparam>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``1(Z0.W128,System.Byte@)">
            <summary>
            Covers a 16-byte segment with a 128-bit T-vector
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``1(Z0.W128,System.SByte@)">
            <summary>
            Covers a 16-byte segment with a 128-bit T-vector
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``1(Z0.W128,System.Int16@)">
            <summary>
            Covers a 16-byte segment with a 128-bit T-vector
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``1(Z0.W128,System.UInt16@)">
            <summary>
            Covers a 16-byte segment with a 128-bit T-vector
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``1(Z0.W128,System.Int32@)">
            <summary>
            Covers a 16-byte segment with a 128-bit T-vector
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``1(Z0.W128,System.UInt32@)">
            <summary>
            Covers a 16-byte segment with a 128-bit T-vector
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``1(Z0.W128,System.Int64@)">
            <summary>
            Covers a 16-byte segment with a 128-bit T-vector
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``1(Z0.W128,System.UInt64@)">
            <summary>
            Covers a 16-byte segment with a 128-bit T-vector
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``1(Z0.W128,System.Boolean@)">
            <summary>
            Covers a 16-byte segment with a 128-bit T-vector
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``1(Z0.W128,System.Char@)">
            <summary>
            Covers a 16-byte segment with a 128-bit T-vector
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``1(Z0.W128,System.Decimal@)">
            <summary>
            Covers a 16-byte segment with a 128-bit T-vector
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``1(Z0.W256,System.Byte@)">
            <summary>
            Covers a 32-byte segment with a 256-bit T-vector
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``1(Z0.W256,System.SByte@)">
            <summary>
            Covers a 32-byte segment with a 256-bit T-vector
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``1(Z0.W256,System.Int16@)">
            <summary>
            Covers a 32-byte segment with a 256-bit T-vector
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``1(Z0.W256,System.UInt16@)">
            <summary>
            Covers a 32-byte segment with a 256-bit T-vector
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``1(Z0.W256,System.Int32@)">
            <summary>
            Covers a 32-byte segment with a 256-bit T-vector
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``1(Z0.W256,System.UInt32@)">
            <summary>
            Covers a 32-byte segment with a 256-bit T-vector
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``1(Z0.W256,System.Int64@)">
            <summary>
            Covers a 32-byte segment with a 256-bit T-vector
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``1(Z0.W256,System.UInt64@)">
            <summary>
            Covers a 32-byte segment with a 256-bit T-vector
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``1(Z0.W256,System.Boolean@)">
            <summary>
            Covers a 32-byte segment with a 256-bit T-vector
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``1(Z0.W256,System.Char@)">
            <summary>
            Covers a 32-byte segment with a 256-bit T-vector
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``1(Z0.W256,System.Decimal@)">
            <summary>
            Covers a 32-byte segment with a 256-bit T-vector
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``1(Z0.W512,System.Byte@)">
            <summary>
            Covers a 64-byte segment with a 256-bit T-vector
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``1(Z0.W512,System.SByte@)">
            <summary>
            Covers a 64-byte segment with a 256-bit T-vector
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``1(Z0.W512,System.Int16@)">
            <summary>
            Covers a 64-byte segment with a 256-bit T-vector
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``1(Z0.W512,System.UInt16@)">
            <summary>
            Covers a 64-byte segment with a 256-bit T-vector
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``1(Z0.W512,System.Int32@)">
            <summary>
            Covers a 64-byte segment with a 256-bit T-vector
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``1(Z0.W512,System.UInt32@)">
            <summary>
            Covers a 64-byte segment with a 256-bit T-vector
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``1(Z0.W512,System.Int64@)">
            <summary>
            Covers a 64-byte segment with a 256-bit T-vector
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``1(Z0.W512,System.UInt64@)">
            <summary>
            Covers a 64-byte segment with a 256-bit T-vector
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``1(Z0.W512,System.Boolean@)">
            <summary>
            Covers a 64-byte segment with a 256-bit T-vector
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``1(Z0.W512,System.Char@)">
            <summary>
            Covers a 64-byte segment with a 256-bit T-vector
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover``1(Z0.W512,System.Decimal@)">
            <summary>
            Covers a 64-byte segment with a 256-bit T-vector
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The target vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vcover(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.Byte}@)">
            <summary>
            8x16w -> 16x8w
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vcover(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.Byte}@)">
            <summary>
            16x16w -> 32x8w
            [0, 1, ... 14, 15] -> [0, 0, 1, 1, ... 14, 14, 15, 15]
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vcover(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt16}@)">
            <summary>
            4x8w -> 8x16w
            [0, 1, 2, 3] -> [0, 0, 1, 1, 2, 2, 3, 3]
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vcover(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt16}@)">
            <summary>
            8x32w -> 16x16w
            [0, 1, 2, 3, 4, 5, 6, 7] -> [0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7]
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vcover(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt32}@)">
            <summary>
            2x64w -> 4x32w
            [0, 1] -> [0, 0, 1, 1]
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vcover(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt32}@)">
            <summary>
            4x64w -> 8x32w
            [0, 1, 2, 3] -> [0, 0, 1, 1, 2, 2, 3, 3]
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vcover(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.Byte}@)">
            <summary>
            4x32w -> 16x8w
            [0, 1, 2, 3] -> [0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3]
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vcover(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.Byte}@)">
            <summary>
            8x32w -> 32x8w
            [0, 1, 2, 3, 4, 5, 6, 7] -> [0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7]
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vcover(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.Byte}@)">
            <summary>
            2x64w -> 16x8w
            [0,1] -> [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1]
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vcover(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.Byte}@)">
            <summary>
            4x64w -> 32x8w
            [0, 1, 2, 3] -> [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3]
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.crc(System.UInt32,System.Byte)">
            <summary>
            unsigned int _mm_crc32_u8 (unsigned int crc, unsigned char v) CRC32 reg, reg/m8
            </summary>
            <param name="crc"></param>
            <param name="data"></param>
        </member>
        <member name="M:Z0.z.crc(System.UInt32,System.UInt16)">
            <summary>
            unsigned int _mm_crc32_u16 (unsigned int crc, unsigned short v) CRC32 reg, reg/m16
            </summary>
            <param name="crc"></param>
            <param name="data"></param>
        </member>
        <member name="M:Z0.z.crc(System.UInt32,System.UInt32)">
            <summary>
            unsigned int _mm_crc32_u32 (unsigned int crc, unsigned int v) CRC32 reg, reg/m32
            </summary>
            <param name="crc"></param>
            <param name="data"></param>
        </member>
        <member name="M:Z0.z.crc(System.UInt32,System.UInt64)">
            <summary>
            unsigned __int64 _mm_crc32_u64 (unsigned __int64 crc, unsigned __int64 v) CRC32 reg, reg/m64
            </summary>
            <param name="crc"></param>
            <param name="data"></param>
        </member>
        <member name="M:Z0.z.vdec(System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            Decrements each component by 1
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vdec(System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            Decrements each component by 1
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vdec(System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            Decrements each component by 1
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vdec(System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            Decrements each component by 1
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vdec(System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            Decrements each component by 1
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vdec(System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            Decrements each component by 1
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vdec(System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            Decrements each component by 1
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vdec(System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            Decrements each component by 1
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vdec(System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            Decrements each component by 1
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vdec(System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            Decrements each component by 1
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vdec(System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            Decrements each component by 1
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vdec(System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            Decrements each component by 1
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vdec(System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            Decrements each component by 1
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vdec(System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            Decrements each component by 1
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vdec(System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            Decrements each component by 1
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vdec(System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            Decrements each component by 1
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vdec``1(Z0.N128)">
            <summary>
            Creates a 128-bit vector with component values k - 1, ..., 1, 0  where k is the length of the target vector
            </summary>
            <param name="w">The target vector width</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.z.vdec``1(Z0.N256)">
            <summary>
            Creates a 256-bit vector with component values k - 1, ..., 1, 0  where k is the length of the target vector
            </summary>
            <param name="w">The target vector width</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.z.vdup64(System.Double@)">
            <summary>
            __m128d _mm_loaddup_pd (double const* mem_addr) MOVDDUP xmm, m64
            </summary>
            <param name="w">The width selector</param>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.z.vdup32(Z0.N0,System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_moveldup_ps (__m256 a) VMOVSLDUP ymm, ymm/m256
            </summary>
            <param name="even"></param>
            <param name="src"></param>
        </member>
        <member name="M:Z0.z.vdup32(Z0.N1,System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_movehdup_ps (__m256 a) VMOVSHDUP ymm, ymm/m256
            </summary>
            <param name="odd"></param>
            <param name="src"></param>
        </member>
        <member name="M:Z0.z.vdup64(Z0.N0,System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_movedup_pd (__m256d a) VMOVDDUP ymm, ymm/m256
            </summary>
            <param name="even"></param>
            <param name="src"></param>
        </member>
        <member name="M:Z0.z.veq(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_cmpeq_epi8 (__m128i a, __m128i b) PCMPEQB xmm, xmm/m128
            Compares corresponding components each vector for equality. For equal
            components, the corresponding component the result vector has all bits 
            enabled; otherwise, all bits the component are disabled
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.veq(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_cmpeq_epi8 (__m128i a, __m128i b) PCMPEQB xmm, xmm/m128
            Compares corresponding components each vector for equality. For equal
            components, the corresponding component the result vector has all bits 
            enabled; otherwise, all bits the component are disabled
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.veq(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
             __m128i _mm_cmpeq_epi16 (__m128i a, __m128i b) PCMPEQW xmm, xmm/m128 
            Compares corresponding components each vector for equality. For equal
            components, the corresponding component the result vector has all bits 
            enabled; otherwise, all bits the component are disabled
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.veq(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
             __m128i _mm_cmpeq_epi16 (__m128i a, __m128i b) PCMPEQW xmm, xmm/m128 
            Compares corresponding components each vector for equality. For equal
            components, the corresponding component the result vector has all bits 
            enabled; otherwise, all bits the component are disabled
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.veq(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_cmpeq_epi32 (__m128i a, __m128i b) PCMPEQD xmm, xmm/m128
            </summary>
            Compares corresponding components each vector for equality. For equal
            components, the corresponding component the result vector has all bits 
            enabled; otherwise, all bits the component are disabled
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.veq(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_cmpeq_epi32 (__m128i a, __m128i b) PCMPEQD xmm, xmm/m128
            </summary>
            Compares corresponding components each vector for equality. For equal
            components, the corresponding component the result vector has all bits 
            enabled; otherwise, all bits the component are disabled
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.veq(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            __m128i _mm_cmpeq_epi64 (__m128i a, __m128i b) PCMPEQQ xmm, xmm/m128
            Compares corresponding components each vector for equality. For equal
            components, the corresponding component the result vector has all bits 
            enabled; otherwise, all bits the component are disabled
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.veq(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m128i _mm_cmpeq_epi64 (__m128i a, __m128i b) PCMPEQQ xmm, xmm/m128
            Compares corresponding components each vector for equality. For equal
            components, the corresponding component the result vector has all bits 
            enabled; otherwise, all bits the component are disabled
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.veq(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
             __m128 _mm_cmpeq_ps (__m128 a, __m128 b) CMPPS xmm, xmm/m128, imm8(0)
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.veq(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_cmpeq_pd (__m128d a, __m128d b) CMPPD xmm, xmm/m128, imm8(0)
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.veq(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            __m256i _mm256_cmpeq_epi8 (__m256i a, __m256i b) VPCMPEQB ymm, ymm, ymm/m256
            Compares corresponding components each vector for equality. For equal
            components, the corresponding component the result vector has all bits 
            enabled; otherwise, all bits the component are disabled
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.veq(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_cmpeq_epi8 (__m256i a, __m256i b) VPCMPEQB ymm, ymm, ymm/m256
            Compares the operands for equality
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.veq(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
             __m256i _mm256_cmpeq_epi16 (__m256i a, __m256i b) VPCMPEQW ymm, ymm, ymm/m256
            Compares corresponding components each vector for equality. For equal
            components, the corresponding component the result vector has all bits 
            enabled; otherwise, all bits the component are disabled
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.veq(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            __m256i _mm256_cmpeq_epi16 (__m256i a, __m256i b) VPCMPEQW ymm, ymm, ymm/m256 
            Compares corresponding components each vector for equality. For equal
            components, the corresponding component the result vector has all bits 
            enabled; otherwise, all bits the component are disabled
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.veq(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            _mm256_cmpeq_epi32 (__m256i a, __m256i b) VPCMPEQD ymm, ymm, ymm/m256
            Compares corresponding components each vector for equality. For equal
            components, the corresponding component the result vector has all bits 
            enabled; otherwise, all bits the component are disabled
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.veq(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_cmpeq_epi32 (__m256i a, __m256i b) VPCMPEQD ymm, ymm, ymm/m256
            Compares corresponding components each vector for equality. For equal
            components, the corresponding component the result vector has all bits 
            enabled; otherwise, all bits the component are disabled
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.veq(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            __m256i _mm256_cmpeq_epi64 (__m256i a, __m256i b) VPCMPEQQ ymm, ymm, ymm/m256
            Compares corresponding components each vector for equality. For equal
            components, the corresponding component the result vector has all bits 
            enabled; otherwise, all bits the component are disabled
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.veq(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
             __m256i _mm256_cmpeq_epi64 (__m256i a, __m256i b) VPCMPEQQ ymm, ymm, ymm/m256
            Compares corresponding components each vector for equality. For equal
            components, the corresponding component the result vector has all bits 
            enabled; otherwise, all bits the component are disabled
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.veq(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_cmp_ps (__m256 a, __m256 b, const int imm8) VCMPPS ymm, ymm, ymm/m256, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.veq(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_cmp_pd (__m256d a, __m256d b, const int imm8) VCMPPD ymm, ymm, ymm/m256, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.veq``1(System.Runtime.Intrinsics.Vector128{``0},System.Runtime.Intrinsics.Vector128{``0})">
            <summary>
            Compares corresponding components in each vector for equality. For equal
            components, the corresponding component the result vector has all bits 
            enabled; otherwise, all bits the component are disabled
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.veq``1(System.Runtime.Intrinsics.Vector256{``0},System.Runtime.Intrinsics.Vector256{``0})">
            <summary>
            Compares corresponding components in each vector for equality. For equal
            components, the corresponding component the result vector has all bits 
            enabled; otherwise, all bits the component are disabled
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.veq``1(Z0.Vector512{``0}@,Z0.Vector512{``0}@)">
            <summary>
            Compares corresponding components in each vector for equality. For equal
            components, the corresponding component the result vector has all bits 
            enabled; otherwise, all bits the component are disabled
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vextract(System.Runtime.Intrinsics.Vector128{System.SByte},Z0.Hex4Seq)">
            <summary>
            int _mm_extract_epi8 (__m128i a, const int imm8) PEXTRB reg/m8, xmm, imm8
            </summary>
            <param name="src">The source vector</param>
            <param name="index">The index of the cell to extract</param>
        </member>
        <member name="M:Z0.z.vextract(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.Hex4Seq)">
            <summary>
            int _mm_extract_epi8 (__m128i a, const int imm8) PEXTRB reg/m8, xmm, imm8
            </summary>
            <param name="src">The source vector</param>
            <param name="index">The index of the cell to extract</param>
        </member>
        <member name="M:Z0.z.vextract(System.Runtime.Intrinsics.Vector128{System.Int16},Z0.Hex3Seq)">
            <summary>
            int _mm_extract_epi16 (__m128i a, int imm8) pextrw r32, xmm, imm8
            </summary>
            <param name="src">The source vector</param>
            <param name="index">The index of the cell to extract</param>
        </member>
        <member name="M:Z0.z.vextract(System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.Hex3Seq)">
            <summary>
            int _mm_extract_epi16 (__m128i a, int imm8) pextrw r32, xmm, imm8
            </summary>
            <param name="src">The source vector</param>
            <param name="index">The index of the cell to extract</param>
        </member>
        <member name="M:Z0.z.vextract(System.Runtime.Intrinsics.Vector128{System.UInt32},Z0.Hex2Seq)">
            <summary>
            int _mm_extract_epi32 (__m128i a, const int imm8) PEXTRD reg/m32, xmm, imm8
            </summary>
            <param name="src">The source vector</param>
            <param name="index">The index of the cell to extract</param>
        </member>
        <member name="M:Z0.z.vextract(System.Runtime.Intrinsics.Vector128{System.Int32},Z0.Hex2Seq)">
            <summary>
            int _mm_extract_epi32 (__m128i a, const int imm8) PEXTRD reg/m32, xmm, imm8
            </summary>
            <param name="src">The source vector</param>
            <param name="index">The index of the cell to extract</param>
        </member>
        <member name="M:Z0.z.vextract``1(System.Runtime.Intrinsics.Vector128{System.Byte},``0)">
            <summary>
            int _mm_extract_epi8 (__m128i a, const int imm8) PEXTRB reg/m8, xmm, imm8
            </summary>
            <param name="src"></param>
            <param name="n"></param>
            <typeparam name="N"></typeparam>
        </member>
        <member name="M:Z0.z.fmsub(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_fmsub_ss (__m128 a, __m128 b, __m128 c) VFMSUBSS xmm, xmm, xmm/m32
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:Z0.z.fmsub(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_fmsub_sd (__m128d a, __m128d b, __m128d c)VFMSUBSD xmm, xmm, xmm/m64
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="z"></param>
        </member>
        <member name="M:Z0.z.fnmadd(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_fnmadd_ss (__m128 a, __m128 b, __m128 c) VFNMADDSS xmm, xmm, xmm/m32
            dst = -(x*y + z)
            </summary>
            <param name="x">The first operand</param>
            <param name="y">The second operand</param>
            <param name="z">The third operand</param>
        </member>
        <member name="M:Z0.z.fnmadd(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_fnmadd_sd (__m128d a, __m128d b, __m128d c) VFNMADDSD xmm, xmm, xmm/m64
            dst = -(x*y + z)
            </summary>
            <param name="x">The first operand</param>
            <param name="y">The second operand</param>
            <param name="z">The third operand</param>
        </member>
        <member name="M:Z0.z.div(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_div_ss (__m128 a, __m128 b) DIVSS xmm, xmm/m32
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.z.div(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
             __m128d _mm_div_sd (__m128d a, __m128d b) DIVSD xmm, xmm/m64
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.z.sub(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_sub_ss (__m128 a, __m128 b) SUBSS xmm, xmm/m32
            </summary>
            <param name="x">The left vectorized scalar</param>
            <param name="y">The right vectorized scalar</param>
        </member>
        <member name="M:Z0.z.sub(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_sub_sd (__m128d a, __m128d b) SUBSD xmm, xmm/m64
            </summary>
            <param name="x">The left vectorized scalar</param>
            <param name="y">The right vectorized scalar</param>
        </member>
        <member name="M:Z0.z.max(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_max_ss (__m128 a, __m128 b) MAXSS xmm, xmm/m32
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.z.max(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_max_sd (__m128d a, __m128d b) MAXSD xmm, xmm/m64
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.z.min(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
             __m128 _mm_min_ss (__m128 a, __m128 b) MINSS xmm, xmm/m32
            </summary>
            <param name="x">The left vectorized scalar</param>
            <param name="y">The right vectorized scalar</param>
        </member>
        <member name="M:Z0.z.min(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_min_sd (__m128d a, __m128d b) MINSD xmm, xmm/m64
            </summary>
            <param name="x">The left vectorized scalar</param>
            <param name="y">The right vectorized scalar</param>
        </member>
        <member name="M:Z0.z.eq(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
             int _mm_ucomieq_ss (__m128 a, __m128 b)UCOMISS xmm, xmm/m32
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.z.eq(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            int _mm_ucomieq_sd (__m128d a, __m128d b)UCOMISD xmm, xmm/m64
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.z.neq(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            int _mm_comineq_ss (__m128 a, __m128 b)COMISS xmm, xmm/m32
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.z.neq(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
             int _mm_comineq_sd (__m128d a, __m128d b)COMISD xmm, xmm/m64
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.z.gt(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            int _mm_comigt_ss (__m128 a, __m128 b)COMISS xmm, xmm/m32
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.z.gt(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            int _mm_comigt_sd (__m128d a, __m128d b)COMISD xmm, xmm/m64
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.z.gteq(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            int _mm_comige_ss (__m128 a, __m128 b)COMISS xmm, xmm/m32
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.z.gteq(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            int _mm_comige_sd (__m128d a, __m128d b)COMISD xmm, xmm/m64
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.z.ngt(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_cmpngt_ss (__m128 a, __m128 b)CMPSS xmm, xmm/m32, imm8(2)
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.z.ngt(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_cmpngt_sd (__m128d a, __m128d b)CMPSD xmm, xmm/m64, imm8(2)
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.z.lt(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            int _mm_comilt_ss (__m128 a, __m128 b)COMISS xmm, xmm/m32
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.z.lt(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            int _mm_comilt_sd (__m128d a, __m128d b)COMISD xmm, xmm/m64
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.z.nlt(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
             __m128 _mm_cmpnlt_ss (__m128 a, __m128 b) CMPSS xmm, xmm/m32, imm8(5)
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.z.nlt(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_cmpnlt_sd (__m128d a, __m128d b) CMPSD xmm, xmm/m64, imm8(5)
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.z.lteq(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
             int _mm_ucomile_ss (__m128 a, __m128 b) UCOMISS xmm, xmm/m32
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.z.lteq(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            int _mm_ucomile_sd (__m128d a, __m128d b)UCOMISD xmm, xmm/m64
            </summary>
            <param name="x"></param>
            <param name="y"></param>
        </member>
        <member name="M:Z0.z.cmp(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single},Z0.FpCmpMode)">
            <summary>
            __m128 _mm_cmp_ss (__m128 a, __m128 b, const int imm8) VCMPSD xmm, xmm, xmm/m64, imm8
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="mode"></param>
        </member>
        <member name="M:Z0.z.cmp(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double},Z0.FpCmpMode)">
            <summary>
            __m128d _mm_cmp_sd (__m128d a, __m128d b, const int imm8) VCMPSS xmm, xmm, xmm/m32, imm8
            </summary>
            <param name="x"></param>
            <param name="y"></param>
            <param name="mode"></param>
        </member>
        <member name="M:Z0.z.ceil(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_ceil_ss (__m128 a)ROUNDSD xmm, xmm/m128, imm8(10)
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:Z0.z.ceil(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_ceil_sd (__m128d a)ROUNDSD xmm, xmm/m128, imm8(10)
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:Z0.z.floor(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
             __m128 _mm_ceil_ss (__m128 a)ROUNDSD xmm, xmm/m128, imm8(10)
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:Z0.z.floor(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_ceil_sd (__m128d a)ROUNDSD xmm, xmm/m128, imm8(10)
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:Z0.z.rcp(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_rcp_ss (__m128 a) RCPSS xmm, xmm/m32
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.sqrt(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_sqrt_ss (__m128 a) SQRTSS xmm, xmm/m32
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:Z0.z.sqrt(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            _m128d _mm_sqrt_sd (__m128d a) SQRTSD xmm, xmm/64
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:Z0.z.rsqrt(System.Runtime.Intrinsics.Vector128{System.Single}@)">
            <summary>
            __m128 _mm_rsqrt_ss (__m128 a) RSQRTSS xmm, xmm/m32
            </summary>
            <param name="x"></param>
        </member>
        <member name="M:Z0.z.IsNaN(System.Single)">
            <summary>
            Returns true if a value is the NaN representative
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.IsNaN(System.Double)">
            <summary>
            Returns true if a value is the NaN representative
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.IsNaN(System.Runtime.Intrinsics.Vector128{System.Single},System.Byte)">
            <summary>
            Determines whether the first component is NaN
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.IsNaN(System.Runtime.Intrinsics.Vector128{System.Double},System.Byte)">
            <summary>
            Determines whether the first component is NaN
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vfirst``2(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>
            Extracts the first T-indexed component after converting the S-vector to a T-vector
            </summary>
            <param name="src">The source vector</param>
            <param name="index">The index of the component to extract</param>
            <typeparam name="T">The primal component type</typeparam>
        </member>
        <member name="M:Z0.z.vfirst``1(System.Runtime.Intrinsics.Vector128{``0}@)">
            <summary>
            Returns a reference to the leading cell
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vfirst``1(System.Runtime.Intrinsics.Vector256{``0}@)">
            <summary>
            Returns a reference to the leading cell
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vfirst``1(Z0.Vector512{``0}@)">
            <summary>
            Returns a reference to the leading cell
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vgather(Z0.N128,System.Int32@,System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
             __m128i _mm_i32gather_epi32 (int const* base_addr, __m128i vindex, const int scale) VPGATHERDD xmm, vm32x, xmm
            Loads a 128x32i vector from index-identified source cells
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The memory source</param>
            <param name="vidx">The index vector</param>
        </member>
        <member name="M:Z0.z.vgather(Z0.N128,System.UInt32@,System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            __m128i _mm256_i64gather_epi32 (int const* base_addr, __m256i vindex, const int scale) VPGATHERQD xmm, vm64y, xmm
            Loads a 128x32u vector from index-identified source cells
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The memory source</param>
            <param name="vidx">The index vector</param>
        </member>
        <member name="M:Z0.z.vgather(Z0.N128,System.Int64@,System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            __m128i _mm_i64gather_epi64 (__int64 const* base_addr, __m128i vindex, const int scale) VPGATHERQQ xmm, vm64x, xmm
            Loads a 128x64u vector from index-identified source cells
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The memory source</param>
            <param name="vidx">The index vector</param>
        </member>
        <member name="M:Z0.z.vgather(Z0.N128,System.UInt64@,System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m128i _mm_i64gather_epi64 (__int64 const* base_addr, __m128i vindex, const int scale) VPGATHERQQ xmm, vm64x, xmm
            Loads a 128x32u vector from index-identified source cells
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The memory source</param>
            <param name="vidx">The index vector</param>
        </member>
        <member name="M:Z0.z.vgather(Z0.N256,System.Int32@,System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_i32gather_epi32 (int const* base_addr, __m256i vindex, const int scale) VPGATHERDD ymm, vm32y, ymm
            Loads a 256x32i vector from index-identified source cells
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The memory source</param>
            <param name="vidx">The index vector</param>
        </member>
        <member name="M:Z0.z.vgather(Z0.N128,System.UInt32@,System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_i32gather_epi32(int const* base_addr, __m128i vindex, const int scale) VPGATHERDD xmm, vm32x, xmm
            Loads a 128x32u vector from from index-identified source cells
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The memory source</param>
            <param name="vidx">The index vector</param>
        </member>
        <member name="M:Z0.z.vgather(Z0.N256,System.UInt32@,System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_i32gather_epi32 (int const* base_addr, __m256i vindex, const int scale) VPGATHERDD ymm, vm32y, ymm
            Loads a 256x32u vector from index-identified source cells
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The memory source</param>
            <param name="vidx">The index vector</param>
        </member>
        <member name="M:Z0.z.vgather(Z0.N256,System.Int64@,System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            __m256i _mm256_i64gather_epi64 (__int64 const* base_addr, __m256i vindex, const int scale) VPGATHERQQ ymm, vm64y, ymm
            Loads a 256x64i vector from index-identified source cells
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The memory source</param>
            <param name="vidx">The index vector</param>
        </member>
        <member name="M:Z0.z.vgather(Z0.N256,System.UInt64@,System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            __m256i _mm256_i64gather_epi64 (__int64 const* base_addr, __m256i vindex, const int scale) VPGATHERQQ ymm, vm64y, ymm
            Loads a 256x64u vector from index-identified source cells
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The memory reference</param>
            <param name="vidx">The index vector</param>
        </member>
        <member name="M:Z0.z.vgather(Z0.N256,System.UInt64@,System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m256i _mm256_i32gather_epi64 (__int64 const* base_addr, __m128i vindex, const int scale) VPGATHERDQ ymm, vm32y, ymm
            Loads a 256x64u vector from index-identified source cells
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The memory source</param>
            <param name="vidx">The index vector</param>
        </member>
        <member name="M:Z0.z.vgather(Z0.N128,System.UInt16@,System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            Loads a 128x16u vector from index-identified source cells
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The memory source</param>
            <param name="vidx">The index vector</param>
        </member>
        <member name="M:Z0.z.vgather(Z0.N128,System.Int16@,System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            Loads a 128x16i vector from index-identified source cells
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The memory source</param>
            <param name="vidx">The index vector</param>
        </member>
        <member name="M:Z0.z.vgather(Z0.N128,System.SByte@,System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            Loads a 128x8u vector from index-identified source cells
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The memory source</param>
            <param name="vidx">The index vector</param>
        </member>
        <member name="M:Z0.z.vgather(Z0.N128,System.Byte@,System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            Loads a 128x8u vector from index-identified source cells
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The memory source</param>
            <param name="vidx">The index vector</param>
        </member>
        <member name="M:Z0.z.vgather(Z0.N256,System.Int64@,System.Runtime.Intrinsics.Vector256{System.Int64},System.Byte)">
            <summary>
             __m256i _mm256_i64gather_epi64 (__int64 const* base_addr, __m256i vindex, const int scale) VPGATHERQQ ymm, vm64y, ymm
            Loads a 256x64i vector from index-identified source cells
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The memory source</param>
            <param name="vidx">The index vector</param>
            <param name="scale">The amount by which to scale each index component value</param>
        </member>
        <member name="M:Z0.z.vgather(Z0.N256,System.UInt64@,System.Runtime.Intrinsics.Vector256{System.Int64},System.Byte)">
            <summary>
            __m256i _mm256_i64gather_epi64 (__int64 const* base_addr, __m256i vindex, const int scale) VPGATHERQQ ymm, vm64y, ymm
            Loads a 256x64u vector from index-identified source cells
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The memory source</param>
            <param name="vidx">The index vector</param>
            <param name="scale">The amount by which to scale each index component value</param>
            <remarks>Intel's description:
            Gather 64-bit integers from memory using 64-bit indices. 64-bit elements are loaded from addresses 
            starting at base_addr and offset by each 64-bit element in vindex (each index is scaled by the factor in scale). 
            Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.  
            FOR j := 0 to 3, i := j*64, m := j*64
                dst[i+63:i] := MEM[base_addr + SignExtend(vindex[m+63:m])*scale]
            </remarks>
        </member>
        <member name="M:Z0.z.vgather(Z0.N256,System.UInt64@,System.Runtime.Intrinsics.Vector128{System.Int32},System.Byte)">
            <summary>
            __m256i _mm256_i32gather_epi64 (__int64 const* base_addr, __m128i vindex, const int scale) VPGATHERDQ ymm, vm32y, ymm
            Loads a 256x64u vector from index-identified source cells
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The memory source</param>
            <param name="vidx">The index vector</param>
            <param name="scale">The amount by which to scale each index component value</param>
            <remarks>Intel's description:
            Gather 64-bit integers from memory using 32-bit indices. 64-bit elements are loaded from addresses 
            starting at base_addr and offset by each 32-bit element in vindex (each index is scaled by the factor in scale). 
            Gathered elements are merged into dst. scale should be 1, 2, 4 or 8.  
            FOR j := 0 to 3, i := j*64, m := j*32	
                dst[i+63:i] := MEM[base_addr + SignExtend(vindex[m+31:m])*scale]  
            </remarks>
        </member>
        <member name="M:Z0.z.vgt(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_cmpgt_epi8 (__m128i a, __m128i b) PCMPGTB xmm, xmm/m128
            Determines whether component values the left vector are larger than the
            corresponding components the right vector. When a left value is larger
            than a right value, the corresponding component the result vector
            will have all bits enabled; otherwise, all bits the component are disabled
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vgt(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_cmpgt_epi8 (__m128i a, __m128i b) PCMPGTB xmm, xmm/m128
            Determines whether component values the left vector are larger than the
            corresponding components the right vector. When a left value is larger
            than a right value, the corresponding component the result vector
            will have all bits enabled; otherwise, all bits the component are disabled
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vgt(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            Determines whether component values the left vector are larger than the
            corresponding components the right vector. When a left value is larger
            than a right value, the corresponding component the result vector
            will have all bits enabled; otherwise, all bits the component are disabled
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vgt(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            Determines whether component values the left vector are larger than the
            corresponding components the right vector. When a left value is larger
            than a right value, the corresponding component the result vector
            will have all bits enabled; otherwise, all bits the component are disabled
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vgt(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            Determines whether component values the left vector are larger than the
            corresponding components the right vector. When a left value is larger
            than a right value, the corresponding component the result vector
            will have all bits enabled; otherwise, all bits the component are disabled
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vgt(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            Determines whether component values the left vector are larger than the
            corresponding components the right vector. When a left value is larger
            than a right value, the corresponding component the result vector
            will have all bits enabled; otherwise, all bits the component are disabled
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vgt(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            Determines whether component values the left vector are larger than the
            corresponding components the right vector. When a left value is larger
            than a right value, the corresponding component the result vector
            will have all bits enabled; otherwise, all bits the component are disabled
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vgt(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            Determines whether component values the left vector are larger than the
            corresponding components the right vector. When a left value is larger
            than a right value, the corresponding component the result vector
            will have all bits enabled; otherwise, all bits the component are disabled
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vgt(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            __m256i _mm256_cmpgt_epi8 (__m256i a, __m256i b) VPCMPGTB ymm, ymm, ymm/m256
            Determines whether component values the left vector are larger than the
            corresponding components the right vector. When a left value is larger
            than a right value, the corresponding component the result vector
            will have all bits enabled; otherwise, all bits the component are disabled
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vgt(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_cmpgt_epi8 (__m256i a, __m256i b) VPCMPGTB ymm, ymm, ymm/m256
            Determines whether component values the left vector are larger than the
            corresponding components the right vector. When a left value is larger
            than a right value, the corresponding component the result vector
            will have all bits enabled; otherwise, all bits the component are disabled
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vgt(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            Determines whether component values the left vector are larger than the
            corresponding components the right vector. When a left value is larger
            than a right value, the corresponding component the result vector
            will have all bits enabled; otherwise, all bits the component are disabled
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vgt(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            Determines whether component values the left vector are larger than the
            corresponding components the right vector. When a left value is larger
            than a right value, the corresponding component the result vector
            will have all bits enabled; otherwise, all bits the component are disabled
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vgt(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_cmpgt_epi32 (__m256i a, __m256i b) VPCMPGTD ymm, ymm, ymm/m256
            Determines whether component values the left vector are larger than the
            corresponding components the right vector. When a left value is larger
            than a right value, the corresponding component the result vector
            will have all bits enabled; otherwise, all bits the component are disabled
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vgt(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_cmpgt_epi32 (__m256i a, __m256i b) VPCMPGTD ymm, ymm, ymm/m256
            Determines whether component values the left vector are larger than the
            corresponding components the right vector. When a left value is larger
            than a right value, the corresponding component the result vector
            will have all bits enabled; otherwise, all bits the component are disabled
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vgt(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
             __m256i _mm256_cmpgt_epi64 (__m256i a, __m256i b) VPCMPGTQ ymm, ymm, ymm/m256
            Determines whether component values the left vector are larger than the
            corresponding components the right vector. When a left value is larger
            than a right value, the corresponding component the result vector
            will have all bits enabled; otherwise, all bits the component are disabled
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vgt(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
             __m256i _mm256_cmpgt_epi64 (__m256i a, __m256i b) VPCMPGTQ ymm, ymm, ymm/m256
            Determines whether component values the left vector are larger than the
            corresponding components the right vector. When a left value is larger
            than a right value, the corresponding component the result vector
            will have all bits enabled; otherwise, all bits the component are disabled
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vhadd(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            Computes the horizontal sum of the source vectors
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vhadd(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            Computes the horizontal sum of the source vectors
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vhadd(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_hadd_epi16 (__m128i a, __m128i b) PHADDW xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vhadd(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_hadd_epi32 (__m128i a, __m128i b) PHADDD xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vhadd(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            Computes the horizontal sum of the source vectors
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vhadd(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_hadd_epi16 (__m256i a, __m256i b) VPHADDW ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vhadd(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            m256i _mm256_hadd_epi32 (__m256i a, __m256i b) VPHADDD ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vhadds(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
             __m128i _mm_hadds_epi16 (__m128i a, __m128i b) PHADDSW xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vhadds(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_hadds_epi16 (__m256i a, __m256i b) VPHADDSW ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vhash``4">
            <summary>
            Creates a 128-bit hash code predicated on four type parameters
            </summary>
            <typeparam name="A">The first type</typeparam>
            <typeparam name="B">The second type</typeparam>
            <typeparam name="C">The third type</typeparam>
            <typeparam name="D">The fourth type</typeparam>
        </member>
        <member name="M:Z0.z.vhi(System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            __m128i _mm256_extracti128_si256 (__m256i a, const int imm8) VEXTRACTI128 xmm,  ymm, imm8
            Extracts the hi 128-bit lane of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="pos">The index of the lane to extract</param>
        </member>
        <member name="M:Z0.z.vhi(System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m128i _mm256_extracti128_si256 (__m256i a, const int imm8) VEXTRACTI128 xmm,  ymm, imm8
            Extracts the hi 128-bit lane of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="pos">The index of the lane to extract</param>
        </member>
        <member name="M:Z0.z.vhi(System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            __m128i _mm256_extracti128_si256 (__m256i a, const int imm8) VEXTRACTI128 xmm,  ymm, imm8
            Extracts the hi 128-bit lane of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="pos">The index of the lane to extract</param>
        </member>
        <member name="M:Z0.z.vhi(System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m128i _mm256_extracti128_si256 (__m256i a, const int imm8) VEXTRACTI128 xmm,  ymm, imm8
            Extracts the hi 128-bit lane of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="pos">The index of the lane to extract</param>
        </member>
        <member name="M:Z0.z.vhi(System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m128i _mm256_extracti128_si256 (__m256i a, const int imm8) VEXTRACTI128 xmm,  ymm, imm8
            Extracts the hi 128-bit lane of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="pos">The index of the lane to extract</param>
        </member>
        <member name="M:Z0.z.vhi(System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            __m128i _mm256_extracti128_si256 (__m256i a, const int imm8) VEXTRACTI128 xmm,  ymm, imm8
            Extracts the hi 128-bit lane of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="pos">The index of the lane to extract</param>
        </member>
        <member name="M:Z0.z.vhi(System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m128i _mm256_extracti128_si256 (__m256i a, const int imm8) VEXTRACTI128 xmm,  ymm, imm8
            Extracts the hi 128-bit lane of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="pos">The index of the lane to extract</param>
        </member>
        <member name="M:Z0.z.vhi(System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            __m128i _mm256_extracti128_si256 (__m256i a, const int imm8) VEXTRACTI128 xmm,  ymm, imm8
            Extracts the hi 128-bit lane of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="pos">The index of the lane to extract</param>
        </member>
        <member name="M:Z0.z.vhi(System.Runtime.Intrinsics.Vector256{System.UInt64},System.UInt64@,System.UInt64@)">
            <summary>
            Extracts the upper 128-bit lane from the source vector to scalar targets
            </summary>
            <param name="src">The source vector</param>
            <param name="x0">Receiver for the lo part of the exracted lane</param>
            <param name="x1">Receiver for the hi part of the exracted lane</param>
        </member>
        <member name="M:Z0.z.vhi(System.Runtime.Intrinsics.Vector256{System.Byte},System.UInt64@,System.UInt64@)">
            <summary>
            Extracts the upper 128-bit lane from the source vector to scalar targets
            </summary>
            <param name="src">The source vector</param>
            <param name="x0">Receiver for the lo part of the exracted lane</param>
            <param name="x1">Receiver for the hi part of the exracted lane</param>
        </member>
        <member name="M:Z0.z.vhi(System.Runtime.Intrinsics.Vector256{System.UInt64},Z0.Pair{System.UInt64}@)">
            <summary>
            Extracts the upper 128-bit lane from the source vector to a pair
            </summary>
            <param name="src">The source vector</param>
            <param name="x0">Receiver for the lo part of the exracted lane</param>
            <param name="x1">Receiver for the hi part of the exracted lane</param>
        </member>
        <member name="M:Z0.z.vhsub(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_hsub_epi16 (__m128i a, __m128i b) PHSUBW xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vhsub(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_hsub_epi32 (__m128i a, __m128i b) PHSUBD xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vhsub(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_hsub_epi16 (__m256i a, __m256i b) VPHSUBW ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vhsub(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_hsub_epi32 (__m256i a, __m256i b) VPHSUBD ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vhsubs(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_hsubs_epi16 (__m128i a, __m128i b) PHSUBSW xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vhsubs(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
             __m256i _mm256_hsubs_epi16 (__m256i a, __m256i b) VPHSUBSW ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vimpl(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            Computes the material implication, x | ~y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vimpl(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            Computes the material implication, x | ~y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vimpl(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            Computes the material implication, x | ~y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vimpl(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            Computes the material implication, x | ~y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vimpl(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            Computes the material implication, x | ~y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vimpl(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            Computes the material implication, x | ~y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vimpl(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            Computes the material implication, x | ~y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vimpl(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            Computes the material implication, x | ~y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vimpl(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            Computes the material implication, x | ~y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vimpl(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            Computes the material implication, x | ~y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vimpl(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            Computes the material implication, x | ~y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vimpl(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            Computes the material implication, x | ~y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vimpl(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            Computes the material implication, x | ~y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vimpl(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            Computes the material implication, x | ~y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vimpl(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            Computes the material implication, x | ~y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vimpl(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            Computes the material implication, x | ~y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vinc(System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            Increments each component by 1
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vinc(System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            Increments each component by 1
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vinc(System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            Increments each component by 1
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vinc(System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            Increments each component by 1
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vinc(System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            Increments each component by 1
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vinc(System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            Increments each component by 1
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vinc(System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            Increments each component by 1
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vinc(System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            Increments each component by 1
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vinc(System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            Increments each component by 1
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vinc(System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            Increments each component by 1
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vinc(System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            Increments each component by 1
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vinc(System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            Increments each component by 1
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vinc(System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            Increments each component by 1
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vinc(System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            Increments each component by 1
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vinc(System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            Increments each component by 1
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vinc(System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            Increments each component by 1
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vinc``1(Z0.W128)">
            <summary>
            Creates a 128-bit vector with component values 0, 1, ... k - 1 where k is the length of the target vector
            </summary>
            <param name="w">The target vector width</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.z.vinc``1(Z0.W256)">
            <summary>
            Creates a 256-bit vector with component values 0, 1, ... k - 1 where k is the length of the target vector
            </summary>
            <param name="w">The target vector width</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.z.vinc``1(Z0.W512)">
            <summary>
            Creates a 512-bit vector with component values 0, 1, ... k - 1 where k is the length of the target vector
            </summary>
            <param name="w">The target vector width</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.z.vinflate(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.W16,Z0.N1)">
            <summary>
            16x8u -> 16x16u
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width selector</param>
            <param name="t">A target cell type representative</param>
        </member>
        <member name="M:Z0.z.vinflate(System.Runtime.Intrinsics.Vector256{System.Byte},Z0.W16)">
            <summary>
            32x8u -> 32x16u
            </summary>
            <param name="src">The source vector</param>
            <param name="lo">The first target vector</param>
            <param name="hi">The second target vector</param>
        </member>
        <member name="M:Z0.z.vinflate(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.W16)">
            <summary>
            16x8u -> 16x16u
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width selector</param>
            <param name="t">A target cell type representative</param>
        </member>
        <member name="M:Z0.z.vinflate(System.Runtime.Intrinsics.Vector128{System.Int16},Z0.W32)">
            <summary>
            8x16i -> 8x32i
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target vector width</param>
            <param name="t">A target component type representative</param>
        </member>
        <member name="M:Z0.z.vinflate(System.Runtime.Intrinsics.Vector128{System.UInt32},Z0.W64)">
            <summary>
            4x32u -> 4x64u
            </summary>
            <param name="src">The source vector</param>
            <param name="x0">The first target vector</param>
            <param name="x1">The second target vector</param>
        </member>
        <member name="M:Z0.z.vinflate(System.Runtime.Intrinsics.Vector128{System.Int32},Z0.W64)">
            <summary>
            4x32w -> 4x64w
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vinflate(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.W32)">
            <summary>
            16x8u -> 16x32u
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="t">A target component type representative</param>
        </member>
        <member name="M:Z0.z.vinflate(System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.W32)">
            <summary>
            8x16u -> 8x32u
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="w">The target vector width</param>
            <param name="t">A target component type representative</param>
        </member>
        <member name="M:Z0.z.vinflate(System.Runtime.Intrinsics.Vector128{System.SByte},Z0.W16,System.Int16)">
            <summary>
            16x8i -> 16x16i
            </summary>
            <param name="x">The source vector</param>
            <param name="lo">The target for the lower source elements</param>
            <param name="hi">The target for the upper source elements</param>
        </member>
        <member name="M:Z0.z.vinflate(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.N256,System.Int16)">
            <summary>
            16x8u -> 16x16u
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width selector</param>
            <param name="t">A target cell type representative</param>
        </member>
        <member name="M:Z0.z.vinflate(System.Runtime.Intrinsics.Vector128{System.SByte},Z0.N256,System.Int16)">
            <summary>
            16x8i -> 16x16i
            </summary>
            <param name="x">The source vector</param>
            <param name="lo">The target for the lower source elements</param>
            <param name="hi">The target for the upper source elements</param>
        </member>
        <member name="M:Z0.z.vinflate(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.N256,System.UInt16)">
            <summary>
            16x8u -> 16x16u
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width selector</param>
            <param name="t">A target cell type representative</param>
        </member>
        <member name="M:Z0.z.vinflate(System.Runtime.Intrinsics.Vector128{System.Int16},Z0.N256,System.Int32)">
            <summary>
            8x16i -> 8x32i
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target vector width</param>
            <param name="t">A target component type representative</param>
        </member>
        <member name="M:Z0.z.vinflate(System.Runtime.Intrinsics.Vector128{System.UInt32},Z0.N256,System.UInt64)">
            <summary>
            4x32u -> 4x64u
            </summary>
            <param name="src">The source vector</param>
            <param name="x0">The first target vector</param>
            <param name="x1">The second target vector</param>
        </member>
        <member name="M:Z0.z.vinflate(System.Runtime.Intrinsics.Vector128{System.Int32},Z0.N256,System.Int64)">
            <summary>
            4x32w -> 4x64w
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vinflate(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.N512,System.UInt32)">
            <summary>
            16x8u -> 16x32u
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="t">A target component type representative</param>
        </member>
        <member name="M:Z0.z.vinflate(System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.N256,System.UInt32)">
            <summary>
            8x16u -> 8x32u
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="w">The target vector width</param>
            <param name="t">A target component type representative</param>
        </member>
        <member name="M:Z0.z.vinflate(System.Runtime.Intrinsics.Vector256{System.UInt32},Z0.W64)">
            <summary>
            8x32u -> 8x64u
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vinflate(System.Runtime.Intrinsics.Vector256{System.Int32},Z0.W64)">
            <summary>
            8x32i -> 8x64i
            </summary>
            <param name="src">The source vector</param>
            <param name="lo">The target for the lower source elements</param>
            <param name="hi">The target for the upper source elements</param>
        </member>
        <member name="M:Z0.z.vinflate(System.Runtime.Intrinsics.Vector256{System.Byte},Z0.W32)">
            <summary>
            32x8u -> 32x32u
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="x1">A target cell type representative</param>
        </member>
        <member name="M:Z0.z.vinflate(System.Runtime.Intrinsics.Vector256{System.SByte},Z0.W32)">
            <summary>
            32x8i -> (8x32i, 8x32i, 8x32i, 8x32i)
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="x1">A target cell type representative</param>
        </member>
        <member name="M:Z0.z.vinflate(System.Runtime.Intrinsics.Vector256{System.SByte},Z0.W16)">
            <summary>
            32x8i -> 32x16i
            </summary>
            <param name="src">The source vector</param>
            <param name="x0">The first target vector</param>
            <param name="x1">The second target vector</param>
        </member>
        <member name="M:Z0.z.vinflate(System.Runtime.Intrinsics.Vector256{System.Int16},Z0.W32)">
            <summary>
            16x16i -> 16x32i
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target vector width</param>
            <param name="t">A target type representative</param>
        </member>
        <member name="M:Z0.z.vinflate(System.Runtime.Intrinsics.Vector256{System.UInt16},Z0.W32)">
            <summary>
            16x16u -> 16x32u
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target vector width</param>
            <param name="t">A target type representative</param>
        </member>
        <member name="M:Z0.z.vinflate(System.Runtime.Intrinsics.Vector256{System.Byte},Z0.N512,System.Int16)">
            <summary>
            32x8w -> 32x16i
            </summary>
            <param name="src">The source vector</param>
            <param name="lo">The first target vector</param>
            <param name="hi">The second target vector</param>
        </member>
        <member name="M:Z0.z.vinflate(System.Runtime.Intrinsics.Vector256{System.SByte},Z0.N512,System.Int16)">
            <summary>
            32x8i -> 32x16i
            </summary>
            <param name="src">The source vector</param>
            <param name="x0">The first target vector</param>
            <param name="x1">The second target vector</param>
        </member>
        <member name="M:Z0.z.vinflate(System.Runtime.Intrinsics.Vector256{System.Byte},Z0.N512,System.UInt16)">
            <summary>
            32x8u -> 32x16u
            </summary>
            <param name="src">The source vector</param>
            <param name="lo">The first target vector</param>
            <param name="hi">The second target vector</param>
        </member>
        <member name="M:Z0.z.vinflate(System.Runtime.Intrinsics.Vector256{System.Int16},Z0.N512,System.Int32)">
            <summary>
            16x16i -> 16x32i
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target vector width</param>
            <param name="t">A target type representative</param>
        </member>
        <member name="M:Z0.z.vinflate(System.Runtime.Intrinsics.Vector256{System.SByte},Z0.N1024,System.Int32)">
            <summary>
            32x8i -> (8x32i, 8x32i, 8x32i, 8x32i)
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="x1">A target cell type representative</param>
        </member>
        <member name="M:Z0.z.vinflate(System.Runtime.Intrinsics.Vector256{System.UInt32},Z0.N512,System.UInt64)">
            <summary>
            8x32u -> 8x64u
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vinflate(System.Runtime.Intrinsics.Vector256{System.Int32},Z0.N512,System.Int64)">
            <summary>
            8x32i -> 8x64i
            </summary>
            <param name="src">The source vector</param>
            <param name="lo">The target for the lower source elements</param>
            <param name="hi">The target for the upper source elements</param>
        </member>
        <member name="M:Z0.z.vinflate(System.Runtime.Intrinsics.Vector256{System.Byte},Z0.N1024,System.UInt32)">
            <summary>
            32x8u -> 32x32u
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="x1">A target cell type representative</param>
        </member>
        <member name="M:Z0.z.vinflate(System.Runtime.Intrinsics.Vector256{System.UInt16},Z0.N512,System.UInt32)">
            <summary>
            16x16u -> 16x32u
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target vector width</param>
            <param name="t">A target type representative</param>
        </member>
        <member name="M:Z0.z.vinsert(System.Byte,System.Runtime.Intrinsics.Vector128{System.Byte},System.Byte)">
            <summary>
            __m128i _mm_insert_epi8 (__m128i a, int i, const int imm8) PINSRB xmm, reg/m8, imm8
            Overwrites an identified component in the target vector with a specified value
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target vector</param>
            <param name="index">The 0-based index of the component to overwrite</param>
        </member>
        <member name="M:Z0.z.vinsert(System.SByte,System.Runtime.Intrinsics.Vector128{System.SByte},System.Byte)">
            <summary>
             __m128i _mm_insert_epi8 (__m128i a, int i, const int imm8) PINSRB xmm, reg/m8, imm8
            Overwrites an identified component in the target vector with a specified value
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target vector</param>
            <param name="index">The 0-based index of the component to overwrite</param>
        </member>
        <member name="M:Z0.z.vinsert(System.Int16,System.Runtime.Intrinsics.Vector128{System.Int16},System.Byte)">
            <summary>
            __m128i _mm_insert_epi16 (__m128i a, int i, int immediate) PINSRW xmm, reg/m16, imm8
            Overwrites an identified component in the target vector with a specified value
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target vector</param>
            <param name="index">The 0-based index of the component to overwrite</param>
        </member>
        <member name="M:Z0.z.vinsert(System.UInt16,System.Runtime.Intrinsics.Vector128{System.UInt16},System.Byte)">
            <summary>
            __m128i _mm_insert_epi16 (__m128i a, int i, int immediate) PINSRW xmm, reg/m16, imm8
            Overwrites an identified component in the target vector with a specified value
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target vector</param>
            <param name="index">The 0-based index of the component to overwrite</param>
        </member>
        <member name="M:Z0.z.vinsert(System.Int32,System.Runtime.Intrinsics.Vector128{System.Int32},System.Byte)">
            <summary>
            __m128i _mm_insert_epi32 (__m128i a, int i, const int imm8) PINSRD xmm, reg/m32, xmm8
            Overwrites an identified component in the target vector with a specified value
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target vector</param>
            <param name="index">The 0-based index of the component to overwrite</param>
        </member>
        <member name="M:Z0.z.vinsert(System.UInt32,System.Runtime.Intrinsics.Vector128{System.UInt32},System.Byte)">
            <summary>
            __m128i _mm_insert_epi32 (__m128i a, int i, const int imm8) PINSRD xmm, reg/m32, xmm8
            Overwrites an identified component in the target vector with a specified value
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target vector</param>
            <param name="index">The 0-based index of the component to overwrite</param>
        </member>
        <member name="M:Z0.z.vinsert(System.Int64,System.Runtime.Intrinsics.Vector128{System.Int64},System.Byte)">
            <summary>
            __m128i _mm_insert_epi64 (__m128i a, __int64 i, const int imm8) PINSRQ xmm, reg/m64,imm8
            Overwrites an identified component in the target vector with a specified value
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target vector</param>
            <param name="index">The 0-based index of the component to overwrite</param>
        </member>
        <member name="M:Z0.z.vinsert(System.UInt64,System.Runtime.Intrinsics.Vector128{System.UInt64},System.Byte)">
            <summary>
            _mm_insert_epi64:
            Overwrites an identified component in the target vector with a specified value
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target vector</param>
            <param name="index">The 0-based index of the component to overwrite</param>
        </member>
        <member name="M:Z0.z.vinsert(System.Byte,System.Runtime.Intrinsics.Vector128{System.Byte},Z0.BitState)">
            <summary>
            __m128i _mm_insert_epi8 (__m128i a, int i, const int imm8) PINSRB xmm, reg/m8, imm8
            Overwrites an identified component in the target vector with a specified value
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target vector</param>
            <param name="index">The 0-based index of the component to overwrite</param>
        </member>
        <member name="M:Z0.z.vinsert(System.SByte,System.Runtime.Intrinsics.Vector128{System.SByte},Z0.BitState)">
            <summary>
             __m128i _mm_insert_epi8 (__m128i a, int i, const int imm8)PINSRB xmm, reg/m8, imm8
            Overwrites an identified component in the target vector with a specified value
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target vector</param>
            <param name="index">The 0-based index of the component to overwrite</param>
        </member>
        <member name="M:Z0.z.vinsert(System.Int16,System.Runtime.Intrinsics.Vector128{System.Int16},Z0.BitState)">
            <summary>
            __m128i _mm_insert_epi16 (__m128i a, int i, int immediate) PINSRW xmm, reg/m16, imm8
            Overwrites an identified component in the target vector with a specified value
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target vector</param>
            <param name="index">The 0-based index of the component to overwrite</param>
        </member>
        <member name="M:Z0.z.vinsert(System.UInt16,System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.BitState)">
            <summary>
            __m128i _mm_insert_epi16 (__m128i a, int i, int immediate) PINSRW xmm, reg/m16, imm8
            Overwrites an identified component in the target vector with a specified value
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target vector</param>
            <param name="index">The 0-based index of the component to overwrite</param>
        </member>
        <member name="M:Z0.z.vinsert(System.Int32,System.Runtime.Intrinsics.Vector128{System.Int32},Z0.BitState)">
            <summary>
            __m128i _mm_insert_epi32 (__m128i a, int i, const int imm8) PINSRD xmm, reg/m32, xmm8
            Overwrites an identified component in the target vector with a specified value
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target vector</param>
            <param name="index">The 0-based index of the component to overwrite</param>
        </member>
        <member name="M:Z0.z.vinsert(System.UInt32,System.Runtime.Intrinsics.Vector128{System.UInt32},Z0.BitState)">
            <summary>
            __m128i _mm_insert_epi32 (__m128i a, int i, const int imm8) PINSRD xmm, reg/m32, xmm8
            Overwrites an identified component in the target vector with a specified value
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target vector</param>
            <param name="index">The 0-based index of the component to overwrite</param>
        </member>
        <member name="M:Z0.z.vinsert(System.Int64,System.Runtime.Intrinsics.Vector128{System.Int64},Z0.BitState)">
            <summary>
            __m128i _mm_insert_epi64 (__m128i a, __int64 i, const int imm8) PINSRQ xmm, reg/m64,imm8
            Overwrites an identified component in the target vector with a specified value
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target vector</param>
            <param name="index">The 0-based index of the component to overwrite</param>
        </member>
        <member name="M:Z0.z.vinsert(System.UInt64,System.Runtime.Intrinsics.Vector128{System.UInt64},Z0.BitState)">
            <summary>
            _mm_insert_epi64:
            Overwrites an identified component in the target vector with a specified value
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target vector</param>
            <param name="index">The 0-based index of the component to overwrite</param>
        </member>
        <member name="M:Z0.z.vinsert(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte},Z0.BitState)">
            <summary>
             __m256i _mm256_inserti128_si256 (__m256i a, __m128i b, const int imm8) VINSERTI128 ymm, ymm, xmm, imm8
            Overwrites a 128-bit lane in the target with the content of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="index">Identifies the lane in the target to overwrite, either 0 or 1 respectively
            identifing low or hi</param>
        </member>
        <member name="M:Z0.z.vinsert(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte},Z0.BitState)">
            <summary>
             __m256i _mm256_inserti128_si256 (__m256i a, __m128i b, const int imm8) VINSERTI128 ymm, ymm, xmm, imm8
            Overwrites a 128-bit lane in the target with the content of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="index">Identifies the lane in the target to overwrite, either 0 or 1 respectively
            identifing low or hi</param>
        </member>
        <member name="M:Z0.z.vinsert(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16},Z0.BitState)">
            <summary>
             __m256i _mm256_inserti128_si256 (__m256i a, __m128i b, const int imm8) VINSERTI128 ymm, ymm, xmm, imm8
            Overwrites a 128-bit lane in the target with the content of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="index">Identifies the lane in the target to overwrite, either 0 or 1 respectively
            identifing low or hi</param>
        </member>
        <member name="M:Z0.z.vinsert(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16},Z0.BitState)">
            <summary>
             __m256i _mm256_inserti128_si256 (__m256i a, __m128i b, const int imm8) VINSERTI128 ymm, ymm, xmm, imm8
            Overwrites a 128-bit lane in the target with the content of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="index">Identifies the lane in the target to overwrite, either 0 or 1 respectively
            identifing low or hi</param>
        </member>
        <member name="M:Z0.z.vinsert(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32},Z0.BitState)">
            <summary>
             __m256i _mm256_inserti128_si256 (__m256i a, __m128i b, const int imm8) VINSERTI128 ymm, ymm, xmm, imm8
            Overwrites a 128-bit lane in the target with the content of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="index">Identifies the lane in the target to overwrite, either 0 or 1 respectively
            identifing low or hi</param>
        </member>
        <member name="M:Z0.z.vinsert(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32},Z0.BitState)">
            <summary>
             __m256i _mm256_inserti128_si256 (__m256i a, __m128i b, const int imm8) VINSERTI128 ymm, ymm, xmm, imm8
            Overwrites a 128-bit lane in the target with the content of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="index">Identifies the lane in the target to overwrite, either 0 or 1 respectively
            identifing low or hi</param>
        </member>
        <member name="M:Z0.z.vinsert(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64},Z0.BitState)">
            <summary>
             __m256i _mm256_inserti128_si256 (__m256i a, __m128i b, const int imm8) VINSERTI128 ymm, ymm, xmm, imm8
            Overwrites a 128-bit lane in the target with the content of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="index">Identifies the lane in the target to overwrite, either 0 or 1 respectively
            identifing low or hi</param>
        </member>
        <member name="M:Z0.z.vinsert(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64},Z0.BitState)">
            <summary>
             __m256i _mm256_inserti128_si256 (__m256i a, __m128i b, const int imm8) VINSERTI128 ymm, ymm, xmm, imm8
            Overwrites a 128-bit lane in the target with the content of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="index">Identifies the lane in the target to overwrite, either 0 or 1 respectively
            identifing low or hi</param>
        </member>
        <member name="M:Z0.z.vinsert(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector256{System.Single},Z0.BitState)">
            <summary>
            _mm256_insertf128_ps: Overwrites a 128-bit lane in the target with the content of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="index">Identifies the lane the target to overwrite, either 0 or 1 respectively
            identifing low or hi</param>
        </member>
        <member name="M:Z0.z.vinsert(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector256{System.Double},Z0.BitState)">
            <summary>
            _mm256_insertf128_pd: Overwrites a 128-bit lane in the target with the content of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="index">Identifies the lane in the target to overwrite, either 0 or 1 respectively
            identifing low or hi</param>
        </member>
        <member name="M:Z0.z.vinsert``1(System.Runtime.Intrinsics.Vector128{``0},System.Runtime.Intrinsics.Vector256{``0},Z0.BitState)">
            <summary>
            Overwrites a 128-bit lane in the target with the content of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="index">Identifies the lane in the target to overwrite, either 0 or 1 respectively identifing low or hi</param>
        </member>
        <member name="M:Z0.z.vlane(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte},System.Byte)">
            <summary>
             __m256i _mm256_inserti128_si256 (__m256i a, __m128i b, const int imm8) VINSERTI128 ymm, ymm, xmm, imm8
            Overwrites a 128-bit lane in the target with the content of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="index">Identifies the lane in the target to overwrite, either 0 or 1 respectively identifying low or hi </param>
        </member>
        <member name="M:Z0.z.vlane(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16},System.Byte)">
            <summary>
             __m256i _mm256_inserti128_si256 (__m256i a, __m128i b, const int imm8) VINSERTI128 ymm, ymm, xmm, imm8
            Overwrites a 128-bit lane in the target with the content of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="index">Identifies the lane in the target to overwrite, either 0 or 1 respectively
            identifying low or hi</param>
        </member>
        <member name="M:Z0.z.vlane(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16},System.Byte)">
            <summary>
             __m256i _mm256_inserti128_si256 (__m256i a, __m128i b, const int imm8) VINSERTI128 ymm, ymm, xmm, imm8
            Overwrites a 128-bit lane in the target with the content of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="index">Identifies the lane in the target to overwrite, either 0 or 1 respectively
            identifying low or hi</param>
        </member>
        <member name="M:Z0.z.vlane(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32},System.Byte)">
            <summary>
             __m256i _mm256_inserti128_si256 (__m256i a, __m128i b, const int imm8) VINSERTI128 ymm, ymm, xmm, imm8
            Overwrites a 128-bit lane in the target with the content of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="index">Identifies the lane in the target to overwrite, either 0 or 1 respectively
            identifying low or hi</param>
        </member>
        <member name="M:Z0.z.vlane(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32},System.Byte)">
            <summary>
             __m256i _mm256_inserti128_si256 (__m256i a, __m128i b, const int imm8) VINSERTI128 ymm, ymm, xmm, imm8
            Overwrites a 128-bit lane in the target with the content of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="index">Identifies the lane in the target to overwrite, either 0 or 1 respectively
            identifying low or hi</param>
        </member>
        <member name="M:Z0.z.vlane(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64},System.Byte)">
            <summary>
             __m256i _mm256_inserti128_si256 (__m256i a, __m128i b, const int imm8) VINSERTI128 ymm, ymm, xmm, imm8
            Overwrites a 128-bit lane in the target with the content of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="index">Identifies the lane in the target to overwrite, either 0 or 1 respectively
            identifying low or hi</param>
        </member>
        <member name="M:Z0.z.vlane(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64},System.Byte)">
            <summary>
             __m256i _mm256_inserti128_si256 (__m256i a, __m128i b, const int imm8) VINSERTI128 ymm, ymm, xmm, imm8
            Overwrites a 128-bit lane in the target with the content of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="index">Identifies the lane in the target to overwrite, either 0 or 1 respectively
            identifying low or hi</param>
        </member>
        <member name="M:Z0.z.vlane(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector256{System.Single},System.Byte)">
            <summary>
            _mm256_insertf128_ps: Overwrites a 128-bit lane in the target with the content of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="index">Identifies the lane the target to overwrite, either 0 or 1 respectively
            identifying low or hi</param>
        </member>
        <member name="M:Z0.z.vlane(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector256{System.Double},System.Byte)">
            <summary>
            _mm256_insertf128_pd: Overwrites a 128-bit lane in the target with the content of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="index">Identifies the lane in the target to overwrite, either 0 or 1 respectively identifying low or hi </param>
        </member>
        <member name="M:Z0.z.vlanemerge``1">
            <summary>
            Creates a vector that describes a lo/hi lane merge permutation
            For example, if X = [A E B F | C G D H] then the lane merge pattern P will
            describe a permutation that has the following effect: permute(X,P) = [A B C D | E F G H]
            </summary>
            <typeparam name="T">The primal component type</typeparam>
        </member>
        <member name="M:Z0.z.vlo(System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            __m128i _mm256_extracti128_si256 (__m256i a, const int imm8) VEXTRACTI128 xmm,  ymm, imm8
            Extracts the lo 128-bit lane of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="pos">The index of the lane to extract</param>
        </member>
        <member name="M:Z0.z.vlo(System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m128i _mm256_extracti128_si256 (__m256i a, const int imm8) VEXTRACTI128 xmm,  ymm, imm8
            Extracts the lo 128-bit lane of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="pos">The index of the lane to extract</param>
        </member>
        <member name="M:Z0.z.vlo(System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m128i _mm256_extracti128_si256 (__m256i a, const int imm8) VEXTRACTI128 xmm,  ymm, imm8
            Extracts the lo 128-bit lane of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="pos">The index of the lane to extract</param>
        </member>
        <member name="M:Z0.z.vlo(System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            __m128i _mm256_extracti128_si256 (__m256i a, const int imm8) VEXTRACTI128 xmm,  ymm, imm8
            Extracts the lo 128-bit lane of the source vector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vlo(System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m128i _mm256_extracti128_si256 (__m256i a, const int imm8) VEXTRACTI128 xmm,  ymm, imm8
            Extracts the lo 128-bit lane of the source vector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vlo(System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m128i _mm256_extracti128_si256 (__m256i a, const int imm8) VEXTRACTI128 xmm,  ymm, imm8
            Extracts the lo 128-bit lane of the source vector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vlo(System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            __m128i _mm256_extracti128_si256 (__m256i a, const int imm8) VEXTRACTI128 xmm,  ymm, imm8
            Extracts the lo 128-bit lane of the source vector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vlo(System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            __m128i _mm256_extracti128_si256 (__m256i a, const int imm8) VEXTRACTI128 xmm,  ymm, imm8
            Extracts the lo 128-bit lane of the source vector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vlo(System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            _m128 _mm256_extractf128_ps (__m256 a, const int imm8)VEXTRACTF128 xmm/m128, ymm, imm8
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vlo(System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m128d _mm256_extractf128_pd (__m256d a, const int imm8)VEXTRACTF128 xmm/m128, ymm, imm8
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vlo(System.Runtime.Intrinsics.Vector256{System.UInt64},System.UInt64@,System.UInt64@)">
            <summary>
            Extracts the lower 128-bit lane from the source vector to scalar targets
            </summary>
            <param name="src">The source vector</param>
            <param name="x0">Receiver for the lo part of the exracted lane</param>
            <param name="x1">Receiver for the hi part of the exracted lane</param>
        </member>
        <member name="M:Z0.z.vlo(System.Runtime.Intrinsics.Vector256{System.Byte},System.UInt64@,System.UInt64@)">
            <summary>
            Extracts the lower 128-bit lane from the source vector to scalar targets
            </summary>
            <param name="src">The source vector</param>
            <param name="x0">Receiver for the lo part of the exracted lane</param>
            <param name="x1">Receiver for the hi part of the exracted lane</param>
        </member>
        <member name="M:Z0.z.vlo(System.Runtime.Intrinsics.Vector256{System.UInt64},Z0.Pair{System.UInt64}@)">
            <summary>
            Extracts the lower 128-bit lane from the source vector to a pair
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">Receiver for the lo part of the exracted lane</param>
        </member>
        <member name="M:Z0.z.vlo64``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>
            Extracts the lower 64 source bits
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.vlo256``1(Z0.Vector512{``0})">
            <summary>
            Extracts the lower 256-bit vector from the source
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.vload``1(Z0.SpanBlock128{``0}@)">
            <summary>
            Loads a 128-bit vector from the first 128-bit source block
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The component type</typeparam>
        </member>
        <member name="M:Z0.z.vload``1(Z0.SpanBlock256{``0}@)">
            <summary>
            Loads a 256-bit vector from the leading source block
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The component type</typeparam>
        </member>
        <member name="M:Z0.z.vload``1(Z0.SpanBlock512{``0}@)">
            <summary>
            Loads a 512-bit vector from the leading source block
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The component type</typeparam>
        </member>
        <member name="M:Z0.z.vload``1(Z0.SpanBlock128{``0}@,System.Int32)">
            <summary>
            Loads a block-identified 128-bit vector
            </summary>
            <param name="src">The source span</param>
            <param name="block">The block index</param>
            <typeparam name="T">The component type</typeparam>
        </member>
        <member name="M:Z0.z.vload``1(Z0.SpanBlock256{``0}@,System.Int32)">
            <summary>
            Loads a block-identified 256-bit vector
            </summary>
            <param name="src">The source span</param>
            <param name="block">The block index</param>
            <typeparam name="T">The component type</typeparam>
        </member>
        <member name="M:Z0.z.vload``1(Z0.SpanBlock512{``0}@,System.Int32)">
            <summary>
            Loads a block-identified 512-bit vector
            </summary>
            <param name="src">The source span</param>
            <param name="block">The block index</param>
            <typeparam name="T">The component type</typeparam>
        </member>
        <member name="M:Z0.z.vload``1(Z0.N128,System.ReadOnlySpan{System.Byte})">
            <summary>
            Loads a 128-bit pattern described by a readonly bytespan
            </summary>
            <param name="n">The vector width selector</param>
            <param name="src">The pattern data source</param>
            <typeparam name="T">The target vector component type</typeparam>
        </member>
        <member name="M:Z0.z.vload``1(Z0.N256,System.ReadOnlySpan{System.Byte})">
            <summary>
            Loads a 256-bit pattern described by a readonly bytespan
            </summary>
            <param name="n">The vector width selector</param>
            <param name="src">The pattern data source</param>
            <typeparam name="T">The target vector component type</typeparam>
        </member>
        <member name="M:Z0.z.vload``1(Z0.N512,System.ReadOnlySpan{System.Byte})">
            <summary>
            Loads a 512-bit pattern described by a readonly bytespan
            </summary>
            <param name="n">The vector width selector</param>
            <param name="src">The pattern data source</param>
            <typeparam name="T">The target vector component type</typeparam>
        </member>
        <member name="M:Z0.z.vload(Z0.W128,System.SByte@)">
            <summary>
            __m128i _mm_lddqu_si128 (__m128i const* mem_addr) LDDQU xmm, m128
            </summary>
            <param name="w">The width selector</param>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.z.vload(Z0.W128,System.Byte@)">
            <summary>
            __m128i _mm_lddqu_si128 (__m128i const* mem_addr) LDDQU xmm, m128
            </summary>
            <param name="w">The width selector</param>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.z.vload(Z0.W128,System.Int16@)">
            <summary>
            __m128i _mm_lddqu_si128 (__m128i const* mem_addr) LDDQU xmm, m128
            </summary>
            <param name="w">The width selector</param>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.z.vload(Z0.W128,System.UInt16@)">
            <summary>
            __m128i _mm_lddqu_si128 (__m128i const* mem_addr) LDDQU xmm, m128
            </summary>
            <param name="w">The width selector</param>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.z.vload(Z0.W128,System.Int32@)">
            <summary>
            __m128i _mm_lddqu_si128 (__m128i const* mem_addr) LDDQU xmm, m128
            </summary>
            <param name="w">The width selector</param>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.z.vload(Z0.W128,System.UInt32@)">
            <summary>
            __m128i _mm_lddqu_si128 (__m128i const* mem_addr) LDDQU xmm, m128
            </summary>
            <param name="w">The width selector</param>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.z.vload(Z0.W128,System.Int64@)">
            <summary>
            __m128i _mm_lddqu_si128 (__m128i const* mem_addr) LDDQU xmm, m128
            </summary>
            <param name="w">The width selector</param>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.z.vload(Z0.W128,System.UInt64@)">
            <summary>
            __m128i _mm_lddqu_si128 (__m128i const* mem_addr) LDDQU xmm, m128
            </summary>
            <param name="w">The width selector</param>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.z.vload(Z0.W256,System.SByte@)">
            <summary>
             __m256i _mm256_lddqu_si256 (__m256i const * mem_addr) VLDDQU ymm, m256
            </summary>
            <param name="w">The width selector</param>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.z.vload(Z0.W256,System.Byte@)">
            <summary>
             __m256i _mm256_lddqu_si256 (__m256i const * mem_addr) VLDDQU ymm, m256
            </summary>
            <param name="w">The width selector</param>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.z.vload(Z0.W256,System.Int16@)">
            <summary>
             __m256i _mm256_lddqu_si256 (__m256i const * mem_addr) VLDDQU ymm, m256
            </summary>
            <param name="w">The width selector</param>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.z.vload(Z0.W256,System.UInt16@)">
            <summary>
             __m256i _mm256_lddqu_si256 (__m256i const * mem_addr) VLDDQU ymm, m256
            </summary>
            <param name="w">The width selector</param>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.z.vload(Z0.W256,System.Int32@)">
            <summary>
             __m256i _mm256_lddqu_si256 (__m256i const * mem_addr) VLDDQU ymm, m256
            </summary>
            <param name="w">The width selector</param>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.z.vload(Z0.W256,System.UInt32@)">
            <summary>
             __m256i _mm256_lddqu_si256 (__m256i const * mem_addr) VLDDQU ymm, m256
            </summary>
            <param name="w">The width selector</param>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.z.vload(Z0.W256,System.Int64@)">
            <summary>
             __m256i _mm256_lddqu_si256 (__m256i const * mem_addr) VLDDQU ymm, m256
            </summary>
            <param name="w">The width selector</param>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.z.vload(Z0.W256,System.UInt64@)">
            <summary>
             __m256i _mm256_lddqu_si256 (__m256i const * mem_addr) VLDDQU ymm, m256
            </summary>
            <param name="w">The width selector</param>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.z.vload``1(Z0.W128,``0*)">
            <summary>
            Loads a 128-bit vector from a pointer-identified memory location
            </summary>
            <param name="w">The target vector width</param>
            <param name="pSrc">The source memory location</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vload``1(Z0.W256,``0*)">
            <summary>
            Loads a 256-bit vector from a pointer-identified memory location
            </summary>
            <param name="w">The target vector width</param>
            <param name="pSrc">The source memory location</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vload``1(Z0.W512,``0*)">
            <summary>
            Loads a 512-bit vector from a pointer-identified memory location
            </summary>
            <param name="w">The target vector width</param>
            <param name="pSrc">The source memory location</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vload``1(``0*,System.Runtime.Intrinsics.Vector128{``0}@)">
            <summary>
            Loads a 128-bit vector from a pointer-identified memory location
            </summary>
            <param name="pSrc">The source memory location</param>
            <param name="dst">The target vector</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vload``1(``0*,System.Runtime.Intrinsics.Vector256{``0}@)">
            <summary>
            Loads a 256-bit vector from a pointer-identified memory location
            </summary>
            <param name="pSrc">The source memory location</param>
            <param name="dst">The target vector</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vload``1(Z0.W128,``0@)">
            <summary>
            Loads a 128-bit vector from a readonly memory reference
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The memory reference</param>
            <typeparam name="T">The component type</typeparam>
        </member>
        <member name="M:Z0.z.vload``1(Z0.W256,``0@)">
            <summary>
            Loads a 256-bit vector from a readonly memory reference
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The memory reference</param>
            <typeparam name="T">The component type</typeparam>
        </member>
        <member name="M:Z0.z.vload``1(Z0.W512,``0@)">
            <summary>
            Loads a 512-bit vector from a readonly memory reference
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The memory reference</param>
            <typeparam name="T">The component type</typeparam>
        </member>
        <member name="M:Z0.z.vload``1(Z0.W128,``0@,System.Int32)">
            <summary>
            Loads a 128-bit vector from a readonly memory reference offset by a cell-relative offset
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The memory reference</param>
            <param name="offset">The memory reference</param>
            <typeparam name="T">The component type</typeparam>
        </member>
        <member name="M:Z0.z.vload``1(Z0.W256,``0@,System.Int32)">
            <summary>
            Loads a 256-bit vector from a readonly memory reference offset by a cell-relative offset
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The memory reference</param>
            <param name="offset">The memory reference</param>
            <typeparam name="T">The component type</typeparam>
        </member>
        <member name="M:Z0.z.vload``1(Z0.W512,``0@,System.Int32)">
            <summary>
            Loads a 256-bit vector from a readonly memory reference offset by a cell-relative offset
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The memory reference</param>
            <param name="offset">The memory reference</param>
            <typeparam name="T">The component type</typeparam>
        </member>
        <member name="M:Z0.z.vload``1(``0@,System.Runtime.Intrinsics.Vector128{``0}@)">
            <summary>
            Loads a 128-bit vector from a readonly memory reference
            </summary>
            <param name="src">The memory reference</param>
            <param name="dst">The target vector</param>
            <typeparam name="T">The component type</typeparam>
        </member>
        <member name="M:Z0.z.vload``1(``0@,System.Runtime.Intrinsics.Vector256{``0}@)">
            <summary>
            Loads a 256-bit vector from a readonly memory reference
            </summary>
            <param name="src">The memory reference</param>
            <param name="dst">The target vector</param>
            <typeparam name="T">The component type</typeparam>
        </member>
        <member name="M:Z0.z.vload``1(``0@,Z0.Vector512{``0}@)">
            <summary>
            Loads a 512-bit vector from a readonly memory reference
            </summary>
            <param name="src">The memory reference</param>
            <param name="dst">The target vector</param>
            <typeparam name="T">The component type</typeparam>
        </member>
        <member name="M:Z0.z.vload``1(Z0.W128,System.Span{``0})">
            <summary>
            Loads a 128-bit vector from the first 128 bits of the source
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The source span</param>
        </member>
        <member name="M:Z0.z.vload``1(Z0.W128,System.ReadOnlySpan{``0})">
            <summary>
            Loads a 128-bit vector from the first 128 bits of the source
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The source span</param>
        </member>
        <member name="M:Z0.z.vload``1(Z0.W256,System.Span{``0})">
            <summary>
            Loads a 256-bit vector from the first 256 bits of the source
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The source span</param>
        </member>
        <member name="M:Z0.z.vload``1(Z0.W512,System.Span{``0})">
            <summary>
            Loads a 512-bit vector from the first 512 bits of the source
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The source span</param>
        </member>
        <member name="M:Z0.z.vload``1(Z0.W128,System.Span{``0},System.Int32)">
            <summary>
            Loads a 128-bit vector beginning at a specified source cell offset
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The source span</param>
            <param name="offset">The position of the fist source element</param>
        </member>
        <member name="M:Z0.z.vload``1(Z0.W256,System.Span{``0},System.Int32)">
            <summary>
            Loads a 256-bit vector beginning at a specified source cell offset
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The source span</param>
            <param name="offset">The position of the fist source element</param>
        </member>
        <member name="M:Z0.z.vload``1(Z0.N512,System.Span{``0},System.Int32)">
            <summary>
            Loads a 256-bit vector beginning at a specified source cell offset
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The source span</param>
            <param name="offset">The position of the fist source element</param>
        </member>
        <member name="M:Z0.z.vload``1(Z0.N256,System.ReadOnlySpan{``0})">
            <summary>
            Loads a 256-bit vector from the first 256 bits of the source
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The source span</param>
        </member>
        <member name="M:Z0.z.vload``1(Z0.N512,System.ReadOnlySpan{``0})">
            <summary>
            Loads a 256-bit vector from the first 256 bits of the source
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The source span</param>
        </member>
        <member name="M:Z0.z.vload``1(Z0.N128,System.ReadOnlySpan{``0},System.Int32)">
            <summary>
            Loads a 128-bit vector beginning at a specified source cell offset
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The source span</param>
            <param name="offset">The position of the fist source element </param>
        </member>
        <member name="M:Z0.z.vload``1(Z0.N256,System.ReadOnlySpan{``0},System.Int32)">
            <summary>
            Loads a 256-bit vector beginning at a specified source cell offset
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The source span</param>
            <param name="offset">The position of the fist source element </param>
        </member>
        <member name="M:Z0.z.vload``1(Z0.N512,System.ReadOnlySpan{``0},System.Int32)">
            <summary>
            Loads a 512-bit vector beginning at a specified source cell offset
            </summary>
            <param name="w">The target vector width</param>
            <param name="src">The source span</param>
            <param name="offset">The position of the fist source element </param>
        </member>
        <member name="F:Z0.z.SignMask8">
            <summary>
            [10000000]
            </summary>
        </member>
        <member name="F:Z0.z.SignMask16">
            <summary>
            [10000000 00000000]
            </summary>
        </member>
        <member name="F:Z0.z.SignMask32">
            <summary>
            [10000000 00000000 00000000 00000000]
            </summary>
        </member>
        <member name="F:Z0.z.SignMask64">
            <summary>
            [10000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000]
            </summary>
        </member>
        <member name="M:Z0.z.vlt(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_cmplt_epi8 (__m128i a, __m128i b)PCMPGTB xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vlt(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_cmplt_epi8 (__m128i a, __m128i b)PCMPGTB xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vlt(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_cmplt_epi16 (__m128i a, __m128i b)PCMPGTW xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vlt(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_cmplt_epi16 (__m128i a, __m128i b)PCMPGTW xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vlt(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_vcmplt_epi32 (__m128i a, __m128i b)PCMPGTD xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vlt(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_vcmplt_epi32 (__m128i a, __m128i b)PCMPGTD xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vlt(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            __m256i _mm256_cmpgt_epi64 (__m256i a, __m256i b) VPCMPGTQ ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vlt(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m256i _mm256_cmpgt_epi64 (__m256i a, __m256i b) VPCMPGTQ ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vlt(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
             __m256i _mm256_cmpgt_epi8 (__m256i a, __m256i b) VPCMPGTB ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vlt(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
             __m256i _mm256_cmpgt_epi8 (__m256i a, __m256i b) VPCMPGTB ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vlt(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_cmpgt_epi16 (__m256i a, __m256i b)VPCMPGTW ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vlt(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            __m256i _mm256_cmpgt_epi16 (__m256i a, __m256i b) VPCMPGTW ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vlt(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_cmpgt_epi32 (__m256i a, __m256i b) VPCMPGTD ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vlt(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_cmpgt_epi32 (__m256i a, __m256i b) VPCMPGTD ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vlt(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            __m256i _mm256_cmpgt_epi64 (__m256i a, __m256i b) VPCMPGTQ ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vlt(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            __m256i _mm256_cmpgt_epi64 (__m256i a, __m256i b) VPCMPGTQ ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmul(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            Computes the full 16-bit product of corresponding left and right source components
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="lo">Receiver for the product of the lower components</param>
            <param name="hi">Receiver for the product of the upper components</param>
        </member>
        <member name="M:Z0.z.vmul(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            Computes the full 16-bit product of corresponding left and right source components
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="lo">Receiver for the product of the lower components</param>
            <param name="hi">Receiver for the product of the upper components</param>
        </member>
        <member name="M:Z0.z.vmul(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            Computes the full 32-bit product of corresponding left and right source components
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="lo">Receiver for the product of the lower components</param>
            <param name="hi">Receiver for the product of the upper components</param>
        </member>
        <member name="M:Z0.z.vmul(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            Computes the full 32-bit product of corresponding left and right source components
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="lo">Receiver for the product of the lower components</param>
            <param name="hi">Receiver for the product of the upper components</param>
        </member>
        <member name="M:Z0.z.vmul(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
             __m128i _mm_mul_epi32 (__m128i a, __m128i b) PMULDQ xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmul(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_mul_epu32 (__m128i a, __m128i b) PMULUDQ xmm, xmm/m128
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vmul(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            Computes the full 16-bit product of corresponding left and right source components
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="lo">Receiver for the product of the lower components</param>
            <param name="hi">Receiver for the product of the upper components</param>
        </member>
        <member name="M:Z0.z.vmul(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            Computes the full 16-bit product of corresponding left and right source components
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="lo">Receiver for the product of the lower components</param>
            <param name="hi">Receiver for the product of the upper components</param>
        </member>
        <member name="M:Z0.z.vmul(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            Computes the full 32-bit product of corresponding left and right source components
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmul(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            Computes the full 32-bit product of corresponding left and right source components
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmul(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_mul_epi32 (__m256i a, __m256i b) VPMULDQ ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vmul(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
             __m256i _mm256_mul_epu32 (__m256i a, __m256i b) VPMULUDQ ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vmul(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            Multiplies two two 256-bit/u64 vectors to yield a 256-bit/u64 vector; only provides reasonable
            results if there's no 64-bit overflow
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmakemask(System.UInt16)">
            <summary>
            Distributes each bit of the source to the hi bit of each byte in a 128-bit target vector
            </summary>
            <param name="src">The source bits</param>
        </member>
        <member name="M:Z0.z.vmakemask(System.UInt32)">
            <summary>
            Distributes each bit of the source to the hi bit of each byte a 256-bit target vector
            </summary>
            <param name="src">The source bits</param>
        </member>
        <member name="M:Z0.z.vmakemask(System.UInt16,System.Byte)">
            <summary>
            Distributes each source bit to an index-identified bit of each byte in a 128-bit target vector
            </summary>
            <param name="src">The source bits</param>
            <param name="index">The bit position index, an integer in the range [0,7]</param>
        </member>
        <member name="M:Z0.z.vmakemask(System.UInt32,System.Byte)">
            <summary>
            Distributes each bit of the source to to a specified bit of each byte in a 256-bit target vector
            </summary>
            <param name="src">The source bits</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector128{System.SByte},Z0.N0,Z0.W16)">
            <summary>
            __m128i _mm_cvtepi8_epi16 (__m128i a) PMOVSXBW xmm, xmm/m64
            8x8i -> 8x16i
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector128{System.SByte},Z0.N1,Z0.W16)">
            <summary>
            __m128i _mm_cvtepi8_epi16 (__m128i a) PMOVSXBW xmm, xmm/m64
            8x8i -> 8x16i
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector128{System.SByte},Z0.N0,Z0.W16,Z0.N1)">
            <summary>
            __m128i _mm_cvtepi8_epi16 (__m128i a) PMOVSXBW xmm, xmm/m64
            dst[i] = src[i], i = 1, ..., 7
            8x8i -> 8x16u
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
            <param name="i">Specifies a target sign extension</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector128{System.SByte},Z0.N1,Z0.W16,Z0.N1)">
            <summary>
            __m128i _mm_cvtepi8_epi16 (__m128i a) PMOVSXBW xmm, xmm/m64
            8x8i -> 8x16u
            dst[i] = src[i], i = 8, ..., 15
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
            <param name="i">Specifies a target sign extension</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector128{System.SByte},Z0.N0,Z0.W32)">
            <summary>
            __m256i _mm256_cvtepi8_epi32 (__m128i a) VPMOVSXBD ymm, xmm/m128
            8x8i -> 8x32i
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector128{System.SByte},Z0.N1,Z0.W32)">
            <summary>
            __m256i _mm256_cvtepi8_epi32 (__m128i a) VPMOVSXBD ymm, xmm/m128
            8x8i -> 8x32i
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.N0,Z0.W16,Z0.N1)">
            <summary>
            __m128i _mm_cvtepu8_epi16 (__m128i a) PMOVZXBW xmm, xmm/m64
            8x8u -> 8x16u
            src[i] -> dst[i], i = 0,.., 7
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
            <param name="i">Specifies a target sign extension</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.N1,Z0.W16,Z0.N1)">
            <summary>
            __m128i _mm_cvtepu8_epi16 (__m128i a) PMOVZXBW xmm, xmm/m64
            8x8u -> 8x16i
            src[i] -> dst[i], i = 8,.., 15
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
            <param name="i">Specifies a target sign extension</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.N0,Z0.W16)">
            <summary>
            __m128i _mm_cvtepu8_epi16 (__m128i a) PMOVZXBW xmm, xmm/m64
            8x8u -> 8x16u
            src[i] -> dst[i], i = 0,.., 7
            Zero extends 8 8-bit integers in the low 8 bytes of the source to 8 16-bit integers the target
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.N1,Z0.W16)">
            <summary>
            __m128i _mm_cvtepu8_epi16 (__m128i a) PMOVZXBW xmm, xmm/m64
            8x8u -> 8x16u
            src[i] -> dst[i], i = 0,.., 7
            Zero extends 8 8-bit integers in the hi 8 bytes of the source to 8 16-bit integers the target
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.N0,Z0.W32)">
            <summary>
             __m256i _mm256_cvtepu8_epi32 (__m128i a) VPMOVZXBD ymm, xmm
            Zero extends 8 8-bit integers from the low 8 bytes of the source to 8 32-bit integers in the target
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.N1,Z0.W32)">
            <summary>
             __m256i _mm256_cvtepu8_epi32 (__m128i a) VPMOVZXBD ymm, xmm
            Zero extends 8 8-bit integers from the low 8 bytes of the source to 8 32-bit integers in the target
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.N0,Z0.W32,Z0.N1)">
            <summary>
             __m256i _mm256_cvtepu8_epi32 (__m128i a) VPMOVZXBD ymm, xmm
            Zero extends 8 8-bit integers from the low 8 bytes of the source to 8 32-bit integers in the target
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
            <param name="i">Specifies a target sign extension</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.N1,Z0.W32,Z0.N1)">
            <summary>
             __m256i _mm256_cvtepu8_epi32 (__m128i a) VPMOVZXBD ymm, xmm
            Zero extends 8 8-bit integers from the low 8 bytes of the source to 8 32-bit integers in the target
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
            <param name="i">Specifies a target sign extension</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector128{System.Int16},Z0.N0,Z0.N32)">
            <summary>
            __m128i _mm_cvtepi16_epi32 (__m128i a) PMOVSXWD xmm, xmm/m64
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector128{System.Int16},Z0.N1,Z0.N32)">
            <summary>
            __m128i _mm_cvtepi16_epi32 (__m128i a) PMOVSXWD xmm, xmm/m64
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector128{System.Int16},Z0.N0,Z0.W64)">
            <summary>
            __m256i _mm256_cvtepi16_epi64 (__m128i a) VPMOVSXDQ ymm, xmm/m128
            4x16u -> 4x64u
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector128{System.Int16},Z0.N1,Z0.W64)">
            <summary>
            __m256i _mm256_cvtepi16_epi64 (__m128i a) VPMOVSXDQ ymm, xmm/m128
            4x16u -> 4x64u
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.N0,Z0.W32)">
            <summary>
            __m128i _mm_cvtepu16_epi32 (__m128i a)PMOVZXWD xmm, xmm/m64
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.N1,Z0.W32)">
            <summary>
            __m128i _mm_cvtepu16_epi32 (__m128i a)PMOVZXWD xmm, xmm/m64
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.N0,Z0.W64,Z0.N1)">
            <summary>
            __m256i _mm256_cvtepu16_epi64 (__m128i a) VPMOVZXWQ ymm, xmm
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
            <param name="i">Specifies a target sign extension</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.N1,Z0.W64,Z0.N1)">
            <summary>
            __m256i _mm256_cvtepu16_epi64 (__m128i a) VPMOVZXWQ ymm, xmm
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
            <param name="i">Specifies a target sign extension</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.N0,Z0.W64)">
            <summary>
            __m256i _mm256_cvtepu16_epi64 (__m128i a) VPMOVZXWQ ymm, xmm
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.N1,Z0.W64)">
            <summary>
            __m256i _mm256_cvtepu16_epi64 (__m128i a) VPMOVZXWQ ymm, xmm
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector128{System.UInt32},Z0.N0,Z0.W64,Z0.N1)">
            <summary>
            __m128i _mm_cvtepu32_epi64 (__m128i a) PMOVZXDQ xmm, xmm/m64
            2x32u -> 2x64i
            src[i] -> dst[i], i = 0, 2
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
            <param name="i">Specifies a target sign extension</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector128{System.UInt32},Z0.N1,Z0.W64,Z0.N1)">
            <summary>
            __m128i _mm_cvtepu32_epi64 (__m128i a) PMOVZXDQ xmm, xmm/m64
            2x32u -> 2x64i
            src[i] -> dst[i], i = 0, 2
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
            <param name="i">Specifies a target sign extension</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector128{System.UInt32},Z0.N0,Z0.W64)">
            <summary>
            __m128i _mm_cvtepu32_epi64 (__m128i a) PMOVZXDQ xmm, xmm/m64
            2x32u -> 2x64u
            src[i] -> dst[i], i = 0, 2
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector128{System.UInt32},Z0.N1,Z0.W64)">
            <summary>
            __m128i _mm_cvtepu32_epi64 (__m128i a) PMOVZXDQ xmm, xmm/m64
            2x32u -> 2x64u
            src[i] -> dst[i], i = 0, 2
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector256{System.SByte},Z0.N0,Z0.W16)">
            <summary>
            __m256i _mm256_cvtepi8_epi16 (__m128i a) VPMOVSXBW ymm, xmm/m128
            16x8u -> 16x16i
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector256{System.SByte},Z0.N1,Z0.W16)">
            <summary>
            __m256i _mm256_cvtepi8_epi16 (__m128i a) VPMOVSXBW ymm, xmm/m128
            16x8u -> 16x16i
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector256{System.Byte},Z0.N0,Z0.W16)">
            <summary>
            __m256i _mm256_cvtepu8_epi16 (__m128i a) VPMOVZXBW ymm, xmm
            16x8u -> 16x16u
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector256{System.Byte},Z0.N1,Z0.W16)">
            <summary>
            __m256i _mm256_cvtepu8_epi16 (__m128i a) VPMOVZXBW ymm, xmm
            16x8u -> 16x16u
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector256{System.Byte},Z0.N0,Z0.W16,Z0.N1)">
            <summary>
            __m256i _mm256_cvtepu8_epi16 (__m128i a) VPMOVZXBW ymm, xmm
            16x8u -> 16x16i
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
            <param name="i">Specifies a target sign extension</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector256{System.Byte},Z0.N1,Z0.W16,Z0.N1)">
            <summary>
            __m256i _mm256_cvtepu8_epi16 (__m128i a) VPMOVZXBW ymm, xmm
            16x8u -> 16x16i
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
            <param name="i">Specifies a target sign extension</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector256{System.Int16},Z0.N0,Z0.W32)">
            <summary>
            __m256i _mm256_cvtepi16_epi32 (__m128i a) VPMOVSXWD ymm, xmm/m128
            8x16i -> 8x32i
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector256{System.Int16},Z0.N1,Z0.W32)">
            <summary>
            __m256i _mm256_cvtepi16_epi32 (__m128i a) VPMOVSXWD ymm, xmm/m128
            8x16i -> 8x32i
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector256{System.UInt16},Z0.N0,Z0.W32)">
            <summary>
            __m256i _mm256_cvtepi16_epi32 (__m128i a) VPMOVSXWD ymm, xmm/m128
            8x16u -> 8x32u
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector256{System.UInt16},Z0.N1,Z0.W32)">
            <summary>
            __m256i _mm256_cvtepi16_epi32 (__m128i a) VPMOVSXWD ymm, xmm/m128
            8x16u -> 8x32u
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector256{System.Int32},Z0.N0,Z0.W64)">
            <summary>
            __m256i _mm256_cvtepi32_epi64 (__m128i a) VPMOVSXDQ ymm, xmm/m128
            4x32i -> 4x64i
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector256{System.Int32},Z0.N1,Z0.W64)">
            <summary>
            __m256i _mm256_cvtepi32_epi64 (__m128i a) VPMOVSXDQ ymm, xmm/m128
            4x32i -> 4x64i
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector256{System.UInt32},Z0.N0,Z0.W64)">
            <summary>
            __m256i _mm256_cvtepi32_epi64 (__m128i a) VPMOVSXDQ ymm, xmm/m128
            4x32u -> 4x64u
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmap(System.Runtime.Intrinsics.Vector256{System.UInt32},Z0.N1,Z0.W64)">
            <summary>
            __m256i _mm256_cvtepi32_epi64 (__m128i a) VPMOVSXDQ ymm, xmm/m128
            4x32u -> 4x64u
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The lane selector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmap``2(System.Runtime.Intrinsics.Vector128{``0},System.Runtime.Intrinsics.Vector128{``0},System.Func{``0,``0,``1})">
            <summary>
            Combines two 128-bit source vectors into a 128-bit target vector via a mapping function
            </summary>
            <param name="lhs">The left source vector</param>
            <param name="rhs">The right source vector</param>
            <param name="f">The mapping function</param>
            <typeparam name="S">The source primal type</typeparam>
            <typeparam name="T">The target primal type</typeparam>
        </member>
        <member name="M:Z0.z.vmap``2(System.Runtime.Intrinsics.Vector128{``0},System.Func{``0,``1})">
            <summary>
            Projects a 128-bit source vector into a 128-bit target vector via a mapping function
            </summary>
            <param name="src">The source vector</param>
            <param name="f">The mapping function</param>
            <typeparam name="S">The source primal type</typeparam>
            <typeparam name="T">The target primal type</typeparam>
        </member>
        <member name="M:Z0.z.vmap``2(System.Runtime.Intrinsics.Vector256{``0},System.Func{``0,``1})">
            <summary>
            Projects a source vector into a target vector via a mapping function
            </summary>
            <param name="src">The source vector</param>
            <param name="f">The mapping function</param>
            <typeparam name="S">The source primal type</typeparam>
            <typeparam name="T">The target primal type</typeparam>
        </member>
        <member name="M:Z0.z.vmap``2(System.Runtime.Intrinsics.Vector256{``0},System.Runtime.Intrinsics.Vector256{``0},System.Func{``0,``0,``1})">
            <summary>
            Combines two 128-bit source vectors into a 128-bit target vector via a mapping function
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
            <param name="f">The mapping function</param>
            <typeparam name="S">The source primal type</typeparam>
            <typeparam name="T">The target primal type</typeparam>
        </member>
        <member name="M:Z0.z.vmaphi(System.Runtime.Intrinsics.Vector128{System.SByte},Z0.N128,System.Int16)">
            <summary>
            __m128i _mm_cvtepi8_epi16 (__m128i a) PMOVSXBW xmm, xmm/m64
            8x8i -> 8x16i
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="k">The target cell kind selector</param>
        </member>
        <member name="M:Z0.z.vmaphi(System.Runtime.Intrinsics.Vector128{System.SByte},Z0.N128,System.UInt16)">
            <summary>
            __m128i _mm_cvtepi8_epi16 (__m128i a) PMOVSXBW xmm, xmm/m64
            8x8i -> 8x16u
            dst[i] = src[i], i = 8, ..., 15
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="k">The target cell kind selector</param>
        </member>
        <member name="M:Z0.z.vmaphi(System.Runtime.Intrinsics.Vector128{System.SByte},Z0.N256,System.Int32)">
            <summary>
            __m256i _mm256_cvtepi8_epi32 (__m128i a) VPMOVSXBD ymm, xmm/m128
            8x8i -> 8x32i
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="k">The target cell kind selector</param>
        </member>
        <member name="M:Z0.z.vmaphi(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.N128,System.Int16)">
            <summary>
            __m128i _mm_cvtepu8_epi16 (__m128i a) PMOVZXBW xmm, xmm/m64
            8x8u -> 8x16i
            src[i] -> dst[i], i = 8,.., 15
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="k">The target cell kind selector</param>
        </member>
        <member name="M:Z0.z.vmaphi(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.N128,System.UInt16)">
            <summary>
            __m128i _mm_cvtepu8_epi16 (__m128i a) PMOVZXBW xmm, xmm/m64
            8x8u -> 8x16u
            src[i] -> dst[i], i = 0,.., 7
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="k">The target cell kind selector</param>
        </member>
        <member name="M:Z0.z.vmaphi(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.N256,System.UInt32)">
            <summary>
             __m256i _mm256_cvtepu8_epi32 (__m128i a) VPMOVZXBD ymm, xmm
            Zero extends 8 8-bit integers from the low 8 bytes of the source to 8 32-bit integers in the target
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="k">The target cell kind selector</param>
        </member>
        <member name="M:Z0.z.vmaphi(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.N256,System.Int32)">
            <summary>
             __m256i _mm256_cvtepu8_epi32 (__m128i a) VPMOVZXBD ymm, xmm
            Zero extends 8 8-bit integers from the low 8 bytes of the source to 8 32-bit integers in the target
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="k">The target cell kind selector</param>
        </member>
        <member name="M:Z0.z.vmaphi(System.Runtime.Intrinsics.Vector128{System.Int16},Z0.N128,System.Int32)">
            <summary>
            __m128i _mm_cvtepi16_epi32 (__m128i a) PMOVSXWD xmm, xmm/m64
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="k">The target cell kind selector</param>
        </member>
        <member name="M:Z0.z.vmaphi(System.Runtime.Intrinsics.Vector128{System.Int16},Z0.N256,System.Int64)">
            <summary>
            __m256i _mm256_cvtepi16_epi64 (__m128i a) VPMOVSXDQ ymm, xmm/m128
            4x16u -> 4x64u
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="k">The target cell kind selector</param>
        </member>
        <member name="M:Z0.z.vmaphi(System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.N128,System.UInt32)">
            <summary>
            __m128i _mm_cvtepu16_epi32 (__m128i a)PMOVZXWD xmm, xmm/m64
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="k">The target cell kind selector</param>
        </member>
        <member name="M:Z0.z.vmaphi(System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.N256,System.Int64)">
            <summary>
            __m256i _mm256_cvtepu16_epi64 (__m128i a) VPMOVZXWQ ymm, xmm
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="k">The target cell kind selector</param>
        </member>
        <member name="M:Z0.z.vmaphi(System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.N256,System.UInt64)">
            <summary>
            __m256i _mm256_cvtepu16_epi64 (__m128i a) VPMOVZXWQ ymm, xmm
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="k">The target cell kind selector</param>
        </member>
        <member name="M:Z0.z.vmaphi(System.Runtime.Intrinsics.Vector128{System.UInt32},Z0.N128,System.Int64)">
            <summary>
            __m128i _mm_cvtepu32_epi64 (__m128i a) PMOVZXDQ xmm, xmm/m64
            2x32u -> 2x64i
            src[i] -> dst[i], i = 0, 2
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="k">The target cell kind selector</param>
        </member>
        <member name="M:Z0.z.vmaphi(System.Runtime.Intrinsics.Vector128{System.UInt32},Z0.N128,System.UInt64)">
            <summary>
            __m128i _mm_cvtepu32_epi64 (__m128i a) PMOVZXDQ xmm, xmm/m64
            2x32u -> 2x64u
            src[i] -> dst[i], i = 0, 2
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="k">The target cell kind selector</param>
        </member>
        <member name="M:Z0.z.vmaphi(System.Runtime.Intrinsics.Vector256{System.Byte},Z0.N256,System.UInt16)">
            <summary>
            __m256i _mm256_cvtepu8_epi16 (__m128i a) VPMOVZXBW ymm, xmm
            16x8u -> 16x16u
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="k">The target cell kind selector</param>
        </member>
        <member name="M:Z0.z.vmaphi(System.Runtime.Intrinsics.Vector256{System.Byte},Z0.N256,System.Int16)">
            <summary>
            __m256i _mm256_cvtepu8_epi16 (__m128i a) VPMOVZXBW ymm, xmm
            16x8u -> 16x16i
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="k">The target cell kind selector</param>
        </member>
        <member name="M:Z0.z.vmaphi(System.Runtime.Intrinsics.Vector256{System.Int16},Z0.N256,System.Int32)">
            <summary>
            __m256i _mm256_cvtepi16_epi32 (__m128i a) VPMOVSXWD ymm, xmm/m128
            8x16i -> 8x32i
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="k">The target cell kind selector</param>
        </member>
        <member name="M:Z0.z.vmaphi(System.Runtime.Intrinsics.Vector256{System.UInt16},Z0.N256,System.UInt32)">
            <summary>
            __m256i _mm256_cvtepi16_epi32 (__m128i a) VPMOVSXWD ymm, xmm/m128
            8x16u -> 8x32u
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="k">The target cell kind selector</param>
        </member>
        <member name="M:Z0.z.vmaphi(System.Runtime.Intrinsics.Vector256{System.Int32},Z0.N256,System.Int64)">
            <summary>
            __m256i _mm256_cvtepi32_epi64 (__m128i a) VPMOVSXDQ ymm, xmm/m128
            4x32i -> 4x64i
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="k">The target cell kind selector</param>
        </member>
        <member name="M:Z0.z.vmaphi(System.Runtime.Intrinsics.Vector256{System.UInt32},Z0.N256,System.UInt64)">
            <summary>
            __m256i _mm256_cvtepi32_epi64 (__m128i a) VPMOVSXDQ ymm, xmm/m128
            4x32u -> 4x64u
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
            <param name="k">The target cell kind selector</param>
        </member>
        <member name="M:Z0.z.vmaplo(System.Runtime.Intrinsics.Vector128{System.SByte},Z0.N128,System.Int16)">
            <summary>
            __m128i _mm_cvtepi8_epi16 (__m128i a) PMOVSXBW xmm, xmm/m64
            8x8i -> 8x16i
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vmaplo(System.Runtime.Intrinsics.Vector128{System.SByte},Z0.N128,System.UInt16)">
            <summary>
            __m128i _mm_cvtepi8_epi16 (__m128i a) PMOVSXBW xmm, xmm/m64
            dst[i] = src[i], i = 1, ..., 7
            8x8i -> 8x16u
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vmaplo(System.Runtime.Intrinsics.Vector128{System.SByte},Z0.N256,System.Int32)">
            <summary>
            __m256i _mm256_cvtepi8_epi32 (__m128i a) VPMOVSXBD ymm, xmm/m128
            8x8i -> 8x32i
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vmaplo(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.N128,System.Int16)">
            <summary>
            __m128i _mm_cvtepu8_epi16 (__m128i a) PMOVZXBW xmm, xmm/m64
            8x8u -> 8x16u
            src[i] -> dst[i], i = 0,.., 7
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vmaplo(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.N128,System.UInt16)">
            <summary>
            __m128i _mm_cvtepu8_epi16 (__m128i a) PMOVZXBW xmm, xmm/m64
            8x8u -> 8x16u
            src[i] -> dst[i], i = 0,.., 7
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vmaplo(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.N256,System.UInt32)">
            <summary>
             __m256i _mm256_cvtepu8_epi32 (__m128i a) VPMOVZXBD ymm, xmm
            Zero extends 8 8-bit integers from the low 8 bytes of the source to 8 32-bit integers in the target
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vmaplo(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.N256,System.Int32)">
            <summary>
             __m256i _mm256_cvtepu8_epi32 (__m128i a) VPMOVZXBD ymm, xmm
            Zero extends 8 8-bit integers from the low 8 bytes of the source to 8 32-bit integers in the target
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vmaplo(System.Runtime.Intrinsics.Vector128{System.Int16},Z0.N128,System.Int32)">
            <summary>
            __m128i _mm_cvtepi16_epi32 (__m128i a) PMOVSXWD xmm, xmm/m64
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vmaplo(System.Runtime.Intrinsics.Vector128{System.Int16},Z0.N256,System.Int64)">
            <summary>
            __m256i _mm256_cvtepi16_epi64 (__m128i a) VPMOVSXDQ ymm, xmm/m128
            4x16u -> 4x64u
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vmaplo(System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.N128,System.UInt32)">
            <summary>
            __m128i _mm_cvtepu16_epi32 (__m128i a)PMOVZXWD xmm, xmm/m64
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vmaplo(System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.N256,System.Int64)">
            <summary>
            __m256i _mm256_cvtepu16_epi64 (__m128i a) VPMOVZXWQ ymm, xmm
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vmaplo(System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.N256,System.UInt64)">
            <summary>
            __m256i _mm256_cvtepu16_epi64 (__m128i a) VPMOVZXWQ ymm, xmm
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vmaplo(System.Runtime.Intrinsics.Vector128{System.UInt32},Z0.N128,System.Int64)">
            <summary>
            __m128i _mm_cvtepu32_epi64 (__m128i a) PMOVZXDQ xmm, xmm/m64
            2x32u -> 2x64i
            src[i] -> dst[i], i = 0, 2
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vmaplo(System.Runtime.Intrinsics.Vector128{System.UInt32},Z0.N128,System.UInt64)">
            <summary>
            __m128i _mm_cvtepu32_epi64 (__m128i a) PMOVZXDQ xmm, xmm/m64
            2x32u -> 2x64u
            src[i] -> dst[i], i = 0, 2
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vmaplo(System.Runtime.Intrinsics.Vector256{System.SByte},Z0.N256,System.Int16)">
            <summary>
            __m256i _mm256_cvtepi8_epi16 (__m128i a) VPMOVSXBW ymm, xmm/m128
            16x8u -> 16x16i
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vmaphi(System.Runtime.Intrinsics.Vector256{System.SByte},Z0.N256,System.Int16)">
            <summary>
            __m256i _mm256_cvtepi8_epi16 (__m128i a) VPMOVSXBW ymm, xmm/m128
            16x8u -> 16x16i
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vmaplo(System.Runtime.Intrinsics.Vector256{System.Byte},Z0.N256,System.UInt16)">
            <summary>
            __m256i _mm256_cvtepu8_epi16 (__m128i a) VPMOVZXBW ymm, xmm
            16x8u -> 16x16u
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vmaplo(System.Runtime.Intrinsics.Vector256{System.Byte},Z0.N256,System.Int16)">
            <summary>
            __m256i _mm256_cvtepu8_epi16 (__m128i a) VPMOVZXBW ymm, xmm
            16x8u -> 16x16i
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vmaplo(System.Runtime.Intrinsics.Vector256{System.Int16},Z0.N256,System.Int32)">
            <summary>
            __m256i _mm256_cvtepi16_epi32 (__m128i a) VPMOVSXWD ymm, xmm/m128
            8x16i -> 8x32i
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vmaplo(System.Runtime.Intrinsics.Vector256{System.UInt16},Z0.N256,System.UInt32)">
            <summary>
            __m256i _mm256_cvtepi16_epi32 (__m128i a) VPMOVSXWD ymm, xmm/m128
            8x16u -> 8x32u
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vmaplo(System.Runtime.Intrinsics.Vector256{System.Int32},Z0.N256,System.Int64)">
            <summary>
            __m256i _mm256_cvtepi32_epi64 (__m128i a) VPMOVSXDQ ymm, xmm/m128
            4x32i -> 4x64i
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vmaplo(System.Runtime.Intrinsics.Vector256{System.UInt32},Z0.N256,System.UInt64)">
            <summary>
            __m256i _mm256_cvtepi32_epi64 (__m128i a) VPMOVSXDQ ymm, xmm/m128
            4x32u -> 4x64u
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vmaskgather(Z0.N128,System.Runtime.Intrinsics.Vector128{System.UInt32},System.UInt32@,System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_mask_i32gather_epi32 (__m128i src, int const* base_addr, __m128i vindex, __m128i mask, const int scale) VPGATHERDD xmm, vm32x, xmm
            </summary>
            <param name="n">The target vector width</param>
            <param name="vSrc">The vector-based source for target component data as controlled by the mask vector</param>
            <param name="mSrc">The memory-based source for target component data as controlled by the mask vector</param>
            <param name="vidx">The index vector</param>
            <param name="mask">The vector that determines whether target vector components are loaded from the vector or memory source</param>
            <remarks>Elements are copied from the source vector when the highest bit of the corresponding element in the mask vector is not set
            If, for example, all hi bits in the mask vector are set then the corresponding target element is loaded from the index-identified cell
            and this operation reduces to the coresponding maskless gather function
            </remarks>
        </member>
        <member name="M:Z0.z.vmaskgather(Z0.N128,System.Runtime.Intrinsics.Vector128{System.UInt64},System.UInt64@,System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m128i _mm_mask_i64gather_epi64 (__m128i src, __int64 const* base_addr, __m128i vindex, __m128i mask, const int scale) VPGATHERQQ xmm, vm64x, xmm
            </summary>
            <param name="w">The target vector width</param>
            <param name="vsrc">The vector-based source for target component data as controlled by the mask vector</param>
            <param name="mSrc">The memory-based source for target component data as controlled by the mask vector</param>
            <param name="vidx">The index vector</param>
            <param name="mask">The vector that determines whether target vector components are loaded from the vector or memory source</param>
        </member>
        <member name="M:Z0.z.vmaskgather(Z0.N128,System.Runtime.Intrinsics.Vector128{System.UInt64},System.UInt64@,System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m128i _mm_mask_i32gather_epi64 (__m128i src, __int64 const* base_addr, __m128i vindex, __m128i mask, const int scale) VPGATHERDQ xmm, vm32x, xmm
            </summary>
            <param name="w">The target vector width</param>
            <param name="vSrc">The vector-based source for target component data as controlled by the mask vector</param>
            <param name="mSrc">The memory-based source for target component data as controlled by the mask vector</param>
            <param name="vidx">The index vector</param>
            <param name="mask">The vector that determines whether target vector components are loaded from the vector or memory source</param>
        </member>
        <member name="M:Z0.z.vmaskgather(Z0.N128,System.Runtime.Intrinsics.Vector128{System.UInt32},System.UInt32@,System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_mask_i64gather_epi32 (__m128i src, int const* base_addr, __m128i vindex, __m128i mask, const int scale) VPGATHERQD xmm, vm64x, xmm
            </summary>
            <param name="w">The target vector width</param>
            <param name="vsrc">The vector-based source for target component data as controlled by the mask vector</param>
            <param name="mSrc">The memory-based source for target component data as controlled by the mask vector</param>
            <param name="vidx">The index vector</param>
            <param name="mask">The vector that determines whether target vector components are loaded from the vector or memory source</param>
        </member>
        <member name="M:Z0.z.vmaskgather(Z0.N128,System.Runtime.Intrinsics.Vector128{System.UInt32},System.UInt32@,System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm256_mask_i64gather_epi32 (__m128i src, int const* base_addr, __m256i vindex, __m128i mask, const int scale) VPGATHERQD xmm, vm32y, xmm
            </summary>
            <param name="w">The target vector width</param>
            <param name="vsrc">The vector-based source for target component data as controlled by the mask vector</param>
            <param name="mSrc">The memory-based source for target component data as controlled by the mask vector</param>
            <param name="vidx">The index vector</param>
            <param name="mask">The vector that determines whether target vector components are loaded from the vector or memory source</param>
        </member>
        <member name="M:Z0.z.vmaskgather(Z0.N256,System.Runtime.Intrinsics.Vector256{System.UInt32},System.UInt32@,System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
              __m256i _mm256_mask_i32gather_epi32 (__m256i src, int const* base_addr, __m256i vindex, __m256i mask, const int scale) VPGATHERDD ymm, vm32y, ymm
            </summary>
            <param name="w">The target vector width</param>
            <param name="vsrc">The vector-based source for target component data as controlled by the mask vector</param>
            <param name="mSrc">The memory-based source for target component data as controlled by the mask vector</param>
            <param name="vidx">The index vector</param>
            <param name="mask">The vector that determines whether target vector components are loaded from the vector or memory source</param>
        </member>
        <member name="M:Z0.z.vmaskgather(Z0.N256,System.Runtime.Intrinsics.Vector256{System.UInt64},System.UInt64@,System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            __m256i _mm256_mask_i64gather_epi64 (__m256i src, __int64 const* base_addr, __m256i vindex, __m256i mask, const int scale) VPGATHERQQ ymm, vm32y, ymm
            </summary>
            <param name="w">The target vector width</param>
            <param name="vsrc">The vector-based source for target component data as controlled by the mask vector</param>
            <param name="mSrc">The memory-based source for target component data as controlled by the mask vector</param>
            <param name="vidx">The index vector</param>
            <param name="mask">The vector that determines whether target vector components are loaded from the vector or memory source</param>
        </member>
        <member name="M:Z0.z.vmaskgather(Z0.N256,System.Runtime.Intrinsics.Vector256{System.UInt64},System.UInt64@,System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
             __m256i _mm256_mask_i32gather_epi64 (__m256i src, __int64 const* base_addr, __m128i vindex, __m256i mask, const int scale) VPGATHERDQ ymm, vm32y, ymm
            </summary>
            <param name="w">The target vector width</param>
            <param name="vsrc">The vector-based source for target component data as controlled by the mask vector</param>
            <param name="mSrc">The memory-based source for target component data as controlled by the mask vector</param>
            <param name="vidx">The index vector</param>
            <param name="mask">The vector that determines whether target vector components are loaded from the vector or memory source</param>
        </member>
        <member name="M:Z0.z.vmaskload(Z0.SpanBlock128{System.Int32}@,System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_maskload_epi32 (int const* mem_addr, __m128i mask) VPMASKMOVD xmm, xmm, m128
            </summary>
            <param name="src">The memory source</param>
            <param name="mask">Hi bit on selects the memory, otherwise set to zero</param>
        </member>
        <member name="M:Z0.z.vmaskload(Z0.SpanBlock128{System.UInt32}@,System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_maskload_epi32 (int const* mem_addr, __m128i mask) VPMASKMOVD xmm, xmm, m128
            </summary>
            <param name="src">The memory source</param>
            <param name="mask">Hi bit on selects the memory, otherwise set to zero</param>
        </member>
        <member name="M:Z0.z.vmaskload(Z0.SpanBlock256{System.Int32}@,System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_maskload_epi32 (int const* mem_addr, __m256i mask) VPMASKMOVD ymm, ymm, m256
            </summary>
            <param name="src">The memory source</param>
            <param name="mask">Hi bit on selects the memory, otherwise set to zero</param>
        </member>
        <member name="M:Z0.z.vmaskload(Z0.SpanBlock256{System.UInt32}@,System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_maskload_epi32 (int const* mem_addr, __m256i mask) VPMASKMOVD ymm, ymm, m256
            </summary>
            <param name="src">The memory source</param>
            <param name="mask">Hi bit on selects the memory, otherwise set to zero</param>
        </member>
        <member name="M:Z0.z.vmaskload(Z0.SpanBlock256{System.Int64}@,System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            __m256i _mm256_maskload_epi64 (__int64 const* mem_addr, __m256i mask) VPMASKMOVQ ymm, ymm, m256
            </summary>
            <param name="src">The memory source</param>
            <param name="mask">Hi bit on selects the memory, otherwise set to zero</param>
        </member>
        <member name="M:Z0.z.vmaskload(Z0.SpanBlock256{System.UInt64}@,System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            __m256i _mm256_maskload_epi64 (__int64 const* mem_addr, __m256i mask) VPMASKMOVQ ymm, ymm, m256
            </summary>
            <param name="src">The memory source</param>
            <param name="mask">Hi bit on selects the memory, otherwise set to zero</param>
        </member>
        <member name="M:Z0.z.vmaskstore8(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.Byte},Z0.SpanBlock128{System.Byte}@)">
            <summary>
            void _mm_maskmoveu_si128 (__m128i a, __m128i mask, char* mem_address) MASKMOVDQU xmm, xmm
            Conditionally stores 8-bit segments from the source vector to memory according to a vectorized mask
            where the hi bit of each corresponding 8-bit segment determines whether the source data is written
            If the hi bit is enabled, content is written, otherwise it is not
            </summary>
            <param name="src">The source vector</param>
            <param name="mask">The mask</param>
            <param name="dst">The target memory reference</param>
        </member>
        <member name="M:Z0.z.vmaskstore8(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte},Z0.SpanBlock128{System.Byte}@)">
            <summary>
            void _mm_maskmoveu_si128 (__m128i a, __m128i mask, char* mem_address) MASKMOVDQU xmm, xmm
            Conditionally stores 8-bit segments from the source vector to memory according to a vectorized mask
            where the hi bit of each corresponding 8-bit segment determines whether the source data is written
            If the hi bit is enabled, content is written, otherwise it is not
            </summary>
            <param name="src">The source vector</param>
            <param name="mask">The mask</param>
            <param name="dst">The target memory reference</param>
        </member>
        <member name="M:Z0.z.vmaskstore8(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Byte},Z0.SpanBlock128{System.Byte}@)">
            <summary>
            void _mm_maskmoveu_si128 (__m128i a, __m128i mask, char* mem_address) MASKMOVDQU xmm, xmm
            Conditionally stores 8-bit segments from the source vector to memory according to a vectorized mask
            where the hi bit of each corresponding 8-bit segment determines whether the source data is written
            If the hi bit is enabled, content is written, otherwise it is not
            </summary>
            <param name="src">The source vector</param>
            <param name="mask">The mask</param>
            <param name="dst">The target memory reference</param>
        </member>
        <member name="M:Z0.z.vmaskstore8(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.Byte},Z0.SpanBlock128{System.Byte}@)">
            <summary>
            void _mm_maskmoveu_si128 (__m128i a, __m128i mask, char* mem_address) MASKMOVDQU xmm, xmm
            Conditionally stores 8-bit segments from the source vector to memory according to a vectorized mask
            where the hi bit of each corresponding 8-bit segment determines whether the source data is written
            If the hi bit is enabled, content is written, otherwise it is not
            </summary>
            <param name="src">The source vector</param>
            <param name="mask">The mask</param>
            <param name="dst">The target memory reference</param>
        </member>
        <member name="M:Z0.z.vmaskstore8(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Byte},Z0.SpanBlock128{System.Byte}@)">
            <summary>
            void _mm_maskmoveu_si128 (__m128i a, __m128i mask, char* mem_address) MASKMOVDQU xmm, xmm
            Conditionally stores 8-bit segments from the source vector to memory according to a vectorized mask
            where the hi bit of each corresponding 8-bit segment determines whether the source data is written
            If the hi bit is enabled, content is written, otherwise it is not
            </summary>
            <param name="src">The source vector</param>
            <param name="mask">The mask</param>
            <param name="dst">The target memory reference</param>
        </member>
        <member name="M:Z0.z.vmaskstore8(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.Byte},Z0.SpanBlock128{System.Byte}@)">
            <summary>
            void _mm_maskmoveu_si128 (__m128i a, __m128i mask, char* mem_address) MASKMOVDQU xmm, xmm
            Conditionally stores 8-bit segments from the source vector to memory according to a vectorized mask
            where the hi bit of each corresponding 8-bit segment determines whether the source data is written
            If the hi bit is enabled, content is written, otherwise it is not
            </summary>
            <param name="src">The source vector</param>
            <param name="mask">The mask</param>
            <param name="dst">The target memory reference</param>
        </member>
        <member name="M:Z0.z.vmaskstore8(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Byte},Z0.SpanBlock128{System.Byte}@)">
            <summary>
            void _mm_maskmoveu_si128 (__m128i a, __m128i mask, char* mem_address) MASKMOVDQU xmm, xmm
            Conditionally stores 8-bit segments from the source vector to memory according to a vectorized mask
            where the hi bit of each corresponding 8-bit segment determines whether the source data is written
            If the hi bit is enabled, content is written, otherwise it is not
            </summary>
            <param name="src">The source vector</param>
            <param name="mask">The source content selector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vmaskstore8(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.Byte},Z0.SpanBlock128{System.Byte}@)">
            <summary>
            void _mm_maskmoveu_si128 (__m128i a, __m128i mask, char* mem_address) MASKMOVDQU xmm, xmm
            Conditionally stores 8-bit segments from the source vector to memory according to a vectorized mask
            where the hi bit of each corresponding 8-bit segment determines whether the source data is written
            If the hi bit is enabled, content is written, otherwise it is not
            </summary>
            <param name="src">The source vector</param>
            <param name="mask">The source content selector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vmaskstore8(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.Byte},Z0.SpanBlock256{System.Byte}@)">
            <summary>
            Conditionally stores 8-bit segments from the source vector to memory according to a vectorized mask
            where the hi bit of each corresponding 8-bit segment determines whether the source data is written
            If the hi bit is enabled, content is written, otherwise it is not
            </summary>
            <param name="src">The source vector</param>
            <param name="mask">The source content selector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vmaskstore8(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte},Z0.SpanBlock256{System.Byte}@)">
            <summary>
            Conditionally stores 8-bit segments from the source vector to memory according to a vectorized mask
            where the hi bit of each corresponding 8-bit segment determines whether the source data is written
            If the hi bit is enabled, content is written, otherwise it is not
            </summary>
            <param name="src">The source vector</param>
            <param name="mask">The source content selector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vmaskstore8(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Byte},Z0.SpanBlock256{System.Byte}@)">
            <summary>
            Conditionally stores 8-bit segments from the source vector to memory according to a vectorized mask
            where the hi bit of each corresponding 8-bit segment determines whether the source data is written
            If the hi bit is enabled, content is written, otherwise it is not
            </summary>
            <param name="src">The source vector</param>
            <param name="mask">The source content selector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vmaskstore8(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.Byte},Z0.SpanBlock256{System.Byte}@)">
            <summary>
            Conditionally stores 8-bit segments from the source vector to memory according to a vectorized mask
            where the hi bit of each corresponding 8-bit segment determines whether the source data is written
            If the hi bit is enabled, content is written, otherwise it is not
            </summary>
            <param name="src">The source vector</param>
            <param name="mask">The source content selector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vmaskstore8(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Byte},Z0.SpanBlock256{System.Byte}@)">
            <summary>
            Conditionally stores 8-bit segments from the source vector to memory according to a vectorized mask
            where the hi bit of each corresponding 8-bit segment determines whether the source data is written
            If the hi bit is enabled, content is written, otherwise it is not
            </summary>
            <param name="src">The source vector</param>
            <param name="mask">The source content selector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vmaskstore8(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.Byte},Z0.SpanBlock256{System.Byte}@)">
            <summary>
            Conditionally stores 8-bit segments from the source vector to memory according to a vectorized mask
            where the hi bit of each corresponding 8-bit segment determines whether the source data is written
            If the hi bit is enabled, content is written, otherwise it is not
            </summary>
            <param name="src">The source vector</param>
            <param name="mask">The source content selector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vmaskstore8(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Byte},Z0.SpanBlock256{System.Byte}@)">
            <summary>
            Conditionally stores 8-bit segments from the source vector to memory according to a vectorized mask
            where the hi bit of each corresponding 8-bit segment determines whether the source data is written
            If the hi bit is enabled, content is written, otherwise it is not
            </summary>
            <param name="src">The source vector</param>
            <param name="mask">The source content selector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vmaskstore8(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.Byte},Z0.SpanBlock256{System.Byte}@)">
            <summary>
            Conditionally stores 8-bit segments from the source vector to memory according to a vectorized mask
            where the hi bit of each corresponding 8-bit segment determines whether the source data is written
            If the hi bit is enabled, content is written, otherwise it is not
            </summary>
            <param name="src">The source vector</param>
            <param name="mask">The source content selector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vmaskstore32(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32},Z0.SpanBlock256{System.UInt32}@)">
            <summary>
            void _mm256_maskstore_epi32 (int* mem_addr, __m256i mask, __m256i a) VPMASKMOVD m256, ymm, ymm
            Conditionally stores 32-bit source vector segments to memory according to a vectorized mask
            where the hi bit of each corresponding section determines whether the source data is written
            If the hi bit is enabled, content is written, otherwise it is not
            </summary>
            <param name="src">The source vector</param>
            <param name="mask">The mask</param>
            <param name="dst">The memory reference</param>
        </member>
        <member name="M:Z0.z.vmaskstore32(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.UInt32},Z0.SpanBlock256{System.UInt32}@)">
            <summary>
            Conditionally stores 32-bit source vector segments to memory according to a vectorized mask
            where the hi bit of each corresponding component determines whether the source data is written
            If the hi bit is enabled, content is written, otherwise it is not
            </summary>
            <param name="src">The source vector</param>
            <param name="mask">The mask</param>
            <param name="dst">The target memory reference</param>
        </member>
        <member name="M:Z0.z.vmaskstore32(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt32},Z0.SpanBlock256{System.UInt32}@)">
            <summary>
            Conditionally stores 32-bit source vector segments to memory according to a vectorized mask
            where the hi bit of each corresponding component determines whether the source data is written
            If the hi bit is enabled, content is written, otherwise it is not
            </summary>
            <param name="src">The source vector</param>
            <param name="mask">The mask</param>
            <param name="dst">The target memory reference</param>
        </member>
        <member name="M:Z0.z.vmaskstore32(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt32},Z0.SpanBlock256{System.UInt32}@)">
            <summary>
            Conditionally stores 32-bit source vector segments to memory according to a vectorized mask
            </summary>
            <param name="src">The source vector</param>
            <param name="mask">The mask</param>
            <param name="dst">The target memory reference</param>
        </member>
        <member name="M:Z0.z.vmaskstore64(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.UInt64},Z0.SpanBlock256{System.UInt64}@)">
            <summary>
            void _mm256_maskstore_epi64 (__int64* mem_addr, __m256i mask, __m256i a) VPMASKMOVQ m256, ymm, ymm
            Conditionally stores 64-bit source vector segments to memory according to a vectorized mask
            </summary>
            <param name="src">The source vector</param>
            <param name="mask">The mask</param>
            <param name="dst">The target memory reference</param>
        </member>
        <member name="M:Z0.z.vmaskstore64(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt64},Z0.SpanBlock256{System.UInt64}@)">
            <summary>
            void _mm256_maskstore_epi64 (__int64* mem_addr, __m256i mask, __m256i a) VPMASKMOVQ m256, ymm, ymm
            Conditionally stores 64-bit source vector segments to memory according to a vectorized mask
            </summary>
            <param name="src">The source vector</param>
            <param name="mask">The mask</param>
            <param name="dst">The target memory reference</param>
        </member>
        <member name="M:Z0.z.vmaskstore64(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt64},Z0.SpanBlock256{System.UInt64}@)">
            <summary>
            void _mm256_maskstore_epi64 (__int64* mem_addr, __m256i mask, __m256i a) VPMASKMOVQ m256, ymm, ymm
            Conditionally stores 64-bit source vector segments to memory according to a vectorized mask
            </summary>
            <param name="src">The source vector</param>
            <param name="mask">The mask</param>
            <param name="dst">The target memory reference</param>
        </member>
        <member name="M:Z0.z.vmaskstore64(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64},Z0.SpanBlock256{System.UInt64}@)">
            <summary>
            void _mm256_maskstore_epi64 (__int64* mem_addr, __m256i mask, __m256i a) VPMASKMOVQ m256, ymm, ymm
            Conditionally stores source vector components to memory according to a vectorized mask
            where the hi bit of each corresponding component determines whether the source data is written
            If the hi bit is enabled, content is written, otherwise it is not
            </summary>
            <param name="src">The source vector</param>
            <param name="mask">The mask</param>
            <param name="dst">The target memory reference</param>
        </member>
        <member name="M:Z0.z.vmaskstore(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte},Z0.SpanBlock128{System.Byte}@)">
            <summary>
            void _mm_maskmoveu_si128 (__m128i a, __m128i mask, char* mem_address) MASKMOVDQU xmm, xmm
            Conditionally stores 8-bit segments from the source vector to memory according to a vectorized mask
            where the hi bit of each corresponding 8-bit segment determines whether the source data is written
            If the hi bit is enabled, content is written, otherwise it is not
            </summary>
            <param name="src">The source vector</param>
            <param name="mask">The mask</param>
            <param name="dst">The target block</param>
        </member>
        <member name="M:Z0.z.vmaskstore(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte},Z0.SpanBlock128{System.SByte}@)">
            <summary>
            void _mm_maskmoveu_si128 (__m128i a, __m128i mask, char* mem_address) MASKMOVDQU xmm, xmm
            Conditionally stores 8-bit segments from the source vector to memory according to a vectorized mask
            where the hi bit of each corresponding 8-bit segment determines whether the source data is written
            If the hi bit is enabled, content is written, otherwise it is not
            </summary>
            <param name="src">The source vector</param>
            <param name="mask">The mask</param>
            <param name="dst">The target block</param>
        </member>
        <member name="M:Z0.z.vmaskstore(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32},Z0.SpanBlock128{System.Int32}@)">
            <summary>
            void _mm_maskstore_epi32 (int* mem_addr, __m128i mask, __m128i a) VPMASKMOVD m128, xmm, xmm
            </summary>
            <param name="src">The source vector</param>
            <param name="mask">The mask</param>
            <param name="dst">The target memory reference</param>
        </member>
        <member name="M:Z0.z.vmaskstore(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32},Z0.SpanBlock128{System.UInt32}@)">
            <summary>
            void _mm_maskstore_epi32 (int* mem_addr, __m128i mask, __m128i a) VPMASKMOVD m128, xmm, xmm
            </summary>
            <param name="src">The source vector</param>
            <param name="mask">The mask</param>
            <param name="dst">The memory reference</param>
        </member>
        <member name="M:Z0.z.vmaskstore(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64},Z0.SpanBlock128{System.UInt64}@)">
            <summary>
            void _mm_maskstore_epi64 (__int64* mem_addr, __m128i mask, __m128i a) VPMASKMOVQ m128, xmm, xmm
            Conditionally stores source vector components to memory according to a vectorized mask
            where the hi bit of each corresponding component determines whether the source data is written
            If the hi bit is enabled, content is written, otherwise it is not
            </summary>
            <param name="src">The source vector</param>
            <param name="mask">The mask</param>
            <param name="dst">The target memory reference</param>
        </member>
        <member name="M:Z0.z.vmaskstore(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte},Z0.SpanBlock256{System.Byte}@)">
            <summary>
            Conditionally stores 8-bit components from the source vector to memory according to a vectorized mask
            where the hi bit of each corresponding 8-bit component determines whether the source data is written
            If the hi bit is enabled, content is written, otherwise it is not
            </summary>
            <param name="src">The source vector</param>
            <param name="mask">The source content selector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vmaskstore(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32},Z0.SpanBlock256{System.Int32}@)">
            <summary>
            void _mm256_maskstore_epi32 (int* mem_addr, __m256i mask, __m256i a) VPMASKMOVD m256, ymm, ymm
            Conditionally stores source vector components to memory according to a vectorized mask
            where the hi bit of each corresponding component determines whether the source data is written
            If the hi bit is enabled, content is written, otherwise it is not
            </summary>
            <param name="src">The source vector</param>
            <param name="mask">The mask</param>
            <param name="dst">The target memory reference</param>
        </member>
        <member name="M:Z0.z.vmaskstore(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32},Z0.SpanBlock256{System.UInt32}@)">
            <summary>
            void _mm256_maskstore_epi32 (int* mem_addr, __m256i mask, __m256i a) VPMASKMOVD m256, ymm, ymm
            Conditionally stores 32-bit source vector components to memory according to a vectorized mask
            where the hi bit of each corresponding component determines whether the source data is written
            If the hi bit is enabled, content is written, otherwise it is not
            </summary>
            <param name="src">The source vector</param>
            <param name="mask">The mask</param>
            <param name="dst">The memory reference</param>
        </member>
        <member name="M:Z0.z.vmaskstore(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64},Z0.SpanBlock256{System.Int64}@)">
            <summary>
            void _mm256_maskstore_epi64 (__int64* mem_addr, __m256i mask, __m256i a) VPMASKMOVQ m256, ymm, ymm
            Conditionally stores source vector components to memory according to a vectorized mask
            where the hi bit of each corresponding component determines whether the source data is written
            If the hi bit is enabled, content is written, otherwise it is not
            </summary>
            <param name="src">The source vector</param>
            <param name="mask">The mask</param>
            <param name="dst">The target memory reference</param>
        </member>
        <member name="M:Z0.z.vmaskstore(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64},Z0.SpanBlock256{System.UInt64}@)">
            <summary>
            void _mm256_maskstore_epi64 (__int64* mem_addr, __m256i mask, __m256i a) VPMASKMOVQ m256, ymm, ymm
            Conditionally stores source vector components to memory according to a vectorized mask
            where the hi bit of each corresponding component determines whether the source data is written
            If the hi bit is enabled, content is written, otherwise it is not
            </summary>
            <param name="src">The source vector</param>
            <param name="mask">The mask</param>
            <param name="dst">The target memory reference</param>
        </member>
        <member name="M:Z0.z.vmax(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_max_epu8 (__m128i a, __m128i b) PMAXUB xmm, xmm/m128
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vmax(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_max_epi8 (__m128i a, __m128i b) PMAXSB xmm, xmm/m128
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vmax(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
             __m128i _mm_max_epi16 (__m128i a, __m128i b) PMAXSW xmm, xmm/m128
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vmax(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_max_epu16 (__m128i a, __m128i b) PMAXUW xmm, xmm/m128
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vmax(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
             __m128i _mm_max_epi32 (__m128i a, __m128i b) PMAXSD xmm, xmm/m128
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vmax(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_max_epu32 (__m128i a, __m128i b) PMAXUD xmm, xmm/m128
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vmax(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            Computes the maximum values of corresponding components
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vmax(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            Computes the maximum values of corresponding components
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vmax(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_max_epu8 (__m256i a, __m256i b) VPMAXUB ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vmax(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
             __m256i _mm256_max_epi8 (__m256i a, __m256i b)VPMAXSB ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vmax(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_max_epi16 (__m256i a, __m256i b) VPMAXSW ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vmax(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            __m256i _mm256_max_epu16 (__m256i a, __m256i b) VPMAXUW ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vmax(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
             __m256i _mm256_max_epi32 (__m256i a, __m256i b) VPMAXSD ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vmax(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_max_epu32 (__m256i a, __m256i b) VPMAXUD ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vmax(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            Computes the maximum values of corresponding components
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vmax(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            Computes the maximum values of corresponding components
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vmerge``1(System.Runtime.Intrinsics.Vector128{``0},System.Runtime.Intrinsics.Vector128{``0},System.Func{``0,``0})">
            <summary>
            Combines two 128-bit source vectors into a 256-bit target vector via alternating application of a mapping function
            dst[j] = f(lhs[i])
            dst[j+1] = f(rhs[i])
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
            <param name="f">The mapping function</param>
            <typeparam name="S">The source primal type</typeparam>
            <typeparam name="T">The target primal type</typeparam>
        </member>
        <member name="M:Z0.z.vmerge(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            [A,B,C,D] x [E,F,G,H] -> [A,E,B,F,C,G,D,H]
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmerge(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            [A,B,C,D] x [E,F,G,H] -> [A,E,B,F,C,G,D,H]
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmerge(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            [A,B,C,D] x [E,F,G,H] -> [A,E,B,F,C,G,D,H]
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmerge(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            [A,B,C,D] x [E,F,G,H] -> [A,E,B,F,C,G,D,H]
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmerge(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            [A,B,C,D] x [E,F,G,H] -> [A,E,B,F,C,G,D,H]
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmerge(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            [A,B,C,D] x [E,F,G,H] -> [A,E,B,F,C,G,D,H]
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmerge(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            [A,B,C,D] x [E,F,G,H] -> [A,E,B,F,C,G,D,H]
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmerge(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            [A,B,C,D] x [E,F,G,H] -> [A,E,B,F,C,G,D,H]
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmergehi(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
             __m128i _mm_unpackhi_epi8 (__m128i a, __m128i b)PUNPCKHBW xmm, xmm/m128
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
        </member>
        <member name="M:Z0.z.vmergehi(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_unpackhi_epi8 (__m128i a, __m128i b)PUNPCKHBW xmm, xmm/m128
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
        </member>
        <member name="M:Z0.z.vmergehi(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_unpackhi_epi16 (__m128i a, __m128i b)PUNPCKHWD xmm, xmm/m128
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
        </member>
        <member name="M:Z0.z.vmergehi(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_unpackhi_epi16 (__m128i a, __m128i b) PUNPCKHWD xmm, xmm/m128
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
        </member>
        <member name="M:Z0.z.vmergehi(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
             __m128i _mm_unpackhi_epi32 (__m128i a, __m128i b) PUNPCKHDQ xmm, xmm/m128
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
        </member>
        <member name="M:Z0.z.vmergehi(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
             __m128i _mm_unpackhi_epi32 (__m128i a, __m128i b) PUNPCKHDQ xmm, xmm/m128
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
        </member>
        <member name="M:Z0.z.vmergehi(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            __m128i _mm_unpackhi_epi64 (__m128i a, __m128i b) PUNPCKHQDQ xmm, xmm/m128
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
        </member>
        <member name="M:Z0.z.vmergehi(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m128i _mm_unpackhi_epi64 (__m128i a, __m128i b)PUNPCKHQDQ xmm, xmm/m128
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
        </member>
        <member name="M:Z0.z.vmergehi(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            __m256i _mm256_unpackhi_epi8 (__m256i a, __m256i b) VPUNPCKHBW ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
        </member>
        <member name="M:Z0.z.vmergehi(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_unpackhi_epi8 (__m256i a, __m256i b) VPUNPCKHBW ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
        </member>
        <member name="M:Z0.z.vmergehi(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_unpackhi_epi16 (__m256i a, __m256i b) VPUNPCKHWD ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
        </member>
        <member name="M:Z0.z.vmergehi(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            __m256i _mm256_unpackhi_epi16 (__m256i a, __m256i b) VPUNPCKHWD ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
        </member>
        <member name="M:Z0.z.vmergehi(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_unpackhi_epi32 (__m256i a, __m256i b) VPUNPCKHDQ ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
        </member>
        <member name="M:Z0.z.vmergehi(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_unpackhi_epi32 (__m256i a, __m256i b) VPUNPCKHDQ ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
        </member>
        <member name="M:Z0.z.vmergehi(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            __m256i _mm256_unpackhi_epi64 (__m256i a, __m256i b) VPUNPCKHQDQ ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
        </member>
        <member name="M:Z0.z.vmergehi(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            __m256i _mm256_unpackhi_epi64 (__m256i a, __m256i b) VPUNPCKHQDQ ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
        </member>
        <member name="M:Z0.z.vmergelo(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_unpacklo_epi8 (__m128i a, __m128i b) PUNPCKLBW xmm, xmm/m128
            ([A,B,C,D], [E,F,G,H]) -> [A,E,B,F]
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
        </member>
        <member name="M:Z0.z.vmergelo(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_unpacklo_epi8 (__m128i a, __m128i b) PUNPCKLBW xmm, xmm/m128
            ([A,B,C,D], [E,F,G,H]) -> [A,E,B,F]
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
        </member>
        <member name="M:Z0.z.vmergelo(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_unpacklo_epi16 (__m128i a, __m128i b) PUNPCKLWD xmm, xmm/m128
            ([A,B,C,D], [E,F,G,H]) -> [A,E,B,F]
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
        </member>
        <member name="M:Z0.z.vmergelo(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_unpacklo_epi16 (__m128i a, __m128i b) PUNPCKLWD xmm, xmm/m128
            ([A,B,C,D], [E,F,G,H]) -> [A,E,B,F]
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
        </member>
        <member name="M:Z0.z.vmergelo(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_unpacklo_epi32 (__m128i a, __m128i b) PUNPCKLDQ xmm, xmm/m128
            ([A,B,C,D], [E,F,G,H]) -> [A,E,B,F]
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
        </member>
        <member name="M:Z0.z.vmergelo(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_unpacklo_epi32 (__m128i a, __m128i b) PUNPCKLDQ xmm, xmm/m128
            ([A,B,C,D], [E,F,G,H]) -> [A,E,B,F]
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
        </member>
        <member name="M:Z0.z.vmergelo(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
             __m128i _mm_unpacklo_epi64 (__m128i a, __m128i b) PUNPCKLQDQ xmm, xmm/m128
            ([A,B,C,D], [E,F,G,H]) -> [A,E,B,F]
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
        </member>
        <member name="M:Z0.z.vmergelo(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
             __m128i _mm_unpacklo_epi64 (__m128i a, __m128i b) PUNPCKLQDQ xmm, xmm/m128
            ([A,B,C,D], [E,F,G,H]) -> [A,E,B,F]
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
        </member>
        <member name="M:Z0.z.vmergelo(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            ([A,B,C,D], [E,F,G,H]) -> [A,E,B,F]
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
            <remarks>__m256i _mm256_unpacklo_epi8 (__m256i a, __m256i b) VPUNPCKLBW ymm, ymm, ymm/m256</remarks>
        </member>
        <member name="M:Z0.z.vmergelo(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            ([A,B,C,D], [E,F,G,H]) -> [A,E,B,F]
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
            <remarks>__m256i _mm256_unpacklo_epi8 (__m256i a, __m256i b) VPUNPCKLBW ymm, ymm, ymm/m256</remarks>
        </member>
        <member name="M:Z0.z.vmergelo(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            ([A,B,C,D], [E,F,G,H]) -> [A,E,B,F]
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
            <remarks>__m256i _mm256_unpacklo_epi16 (__m256i a, __m256i b) VPUNPCKLWD ymm, ymm, ymm/m256</remarks>
        </member>
        <member name="M:Z0.z.vmergelo(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            ([A,B,C,D], [E,F,G,H]) -> [A,E,B,F]
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
            <remarks>__m256i _mm256_unpacklo_epi16 (__m256i a, __m256i b) VPUNPCKLWD ymm, ymm, ymm/m256</remarks>
        </member>
        <member name="M:Z0.z.vmergelo(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            ([A,B,C,D], [E,F,G,H]) -> [A,E,B,F]
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
            <remarks>__m256i _mm256_unpacklo_epi32 (__m256i a, __m256i b) VPUNPCKLDQ ymm, ymm, ymm/m256</remarks>
        </member>
        <member name="M:Z0.z.vmergelo(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            ([A,B,C,D], [E,F,G,H]) -> [A,E,B,F]
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
            <remarks>__m256i _mm256_unpacklo_epi32 (__m256i a, __m256i b) VPUNPCKLDQ ymm, ymm, ymm/m256</remarks>
        </member>
        <member name="M:Z0.z.vmergelo(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            ([A,B,C,D], [E,F,G,H]) -> [A,E,B,F]
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
            <remarks>__m256i _mm256_unpacklo_epi64 (__m256i a, __m256i b) VPUNPCKLQDQ ymm, ymm, ymm/m256</remarks>
        </member>
        <member name="M:Z0.z.vmergelo(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            ([A,B,C,D], [E,F,G,H]) -> [A,E,B,F]
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
            <remarks> __m256i _mm256_unpacklo_epi64 (__m256i a, __m256i b) VPUNPCKLQDQ ymm, ymm, ymm/m256</remarks>
        </member>
        <member name="M:Z0.z.vmin(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_min_epu8 (__m128i a, __m128i b) PMINUB xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmin(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_min_epi8 (__m128i a, __m128i b) PMINSB xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmin(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_min_epi16 (__m128i a, __m128i b) PMINSW xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmin(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_min_epu16 (__m128i a, __m128i b) PMINUW xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmin(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_min_epu32 (__m128i a, __m128i b) PMINUD xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmin(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_min_epu32 (__m128i a, __m128i b) PMINUD xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmin(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            Computes the maximum values of corresponding components
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmin(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            Computes the maximum values of corresponding components
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmin(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_min_epu8 (__m256i a, __m256i b) VPMINUB ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vmin(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            __m256i _mm256_min_epi8 (__m256i a, __m256i b) VPMINSB ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vmin(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_min_epi16 (__m256i a, __m256i b) VPMINSW ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmin(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            __m256i _mm256_min_epu16 (__m256i a, __m256i b) VPMINUW ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmin(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_min_epi32 (__m256i a, __m256i b) VPMINSD ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmin(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_min_epu32 (__m256i a, __m256i b) VPMINUD ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmin(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            Computes the maximum values of corresponding components
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmin(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            Computes the maximum values of corresponding components
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmove8x16(System.Byte@)">
            <summary>
            VPMOVZXBW ymm, m128
            16x8u -> 16x16u
            Projects 16 unsigned 8-bit integers onto 16 unsigned 16-bit integers
            </summary>
            <param name="src">The input component source</param>
            <param name="n">The source component count</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmove(System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.W16,Z0.N3,Z0.N0)">
            <summary>
            src[3] -> r/m16
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target register width</param>
            <param name="i">The source component index</param>
            <param name="j">THe target component index</param>
        </member>
        <member name="M:Z0.z.vmove(System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.W16,Z0.N2,Z0.N0)">
            <summary>
            src[2] -> r/m16
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target register width</param>
            <param name="i">The source component index</param>
            <param name="j">THe target component index</param>
        </member>
        <member name="M:Z0.z.vmove(System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.W16,Z0.N1,Z0.N0)">
            <summary>
            src[1] -> r/m16
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target register width</param>
            <param name="i">The source component index</param>
            <param name="j">THe target component index</param>
        </member>
        <member name="M:Z0.z.vmove(System.Runtime.Intrinsics.Vector128{System.SByte},Z0.N8)">
            <summary>
            src[0..7] -> r/m8[0..31]
            int _mm_cvtsi128_si32 (__m128i a) MOVD reg/m32, xmm
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="t">A target type representative</param>
            <remarks>
            vmovupd xmm0,[rcx] |> vmovd eax,xmm0 |> movzx rax,al
            </remarks>
        </member>
        <member name="M:Z0.z.vmove(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.N8)">
            <summary>
            src[0..7] -> r/m8[0..31]
            int _mm_cvtsi128_si32 (__m128i a) MOVD reg/m32, xmm
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="t">A target type representative</param>
            <remarks>
            vmovupd xmm0,[rcx] |> vmovd eax,xmm0 |> movzx eax,al
            </remarks>
        </member>
        <member name="M:Z0.z.vmove(System.Runtime.Intrinsics.Vector128{System.Int16},Z0.N16)">
            <summary>
            src[0..15] -> r/m16[0..31]
            int _mm_cvtsi128_si32 (__m128i a)MOVD reg/m32, xmm
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="t">A target type representative</param>
            <remarks>
            vmovupd xmm0,[rcx] |> vmovd eax,xmm0 |> movsx rax,ax |>
            </remarks>
        </member>
        <member name="M:Z0.z.vmove(System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.W16)">
            <summary>
            src[0..15] -> r/m16[0..31]
            int _mm_cvtsi128_si32 (__m128i a)MOVD reg/m32, xmm
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="t">A target type representative</param>
            <remarks>
            vmovupd xmm0,[rcx] |> vmovd eax,xmm0 |> movsx eax,ax
            </remarks>
        </member>
        <member name="M:Z0.z.vmove(System.Runtime.Intrinsics.Vector128{System.Int32},Z0.N32)">
            <summary>
            src[0..31] -> r/m32[0..31]
            int _mm_cvtsi128_si32 (__m128i a) MOVD reg/m32, xmm
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="t">A target type representative</param>
            <remarks>
            vmovupd xmm0,[rcx] |> vmovd eax,xmm0
            </remarks>
        </member>
        <member name="M:Z0.z.vmove(System.Runtime.Intrinsics.Vector128{System.UInt32},Z0.N32)">
            <summary>
            src[0..31] -> r/m32[0..31]
            int _mm_cvtsi128_si32 (__m128i a) MOVD reg/m32, xmm
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width</param>
            <param name="t">A target type representative</param>
            <remarks>
            vmovupd xmm0,[rcx] |> vmovd eax,xmm0
            </remarks>
        </member>
        <member name="M:Z0.z.vmove(System.Runtime.Intrinsics.Vector128{System.Int64},Z0.N64)">
            <summary>
            src[0..64] -> r/m32[0..64]
            __int64 _mm_cvtsi128_si64 (__m128i a) MOVQ reg/m64, xmm
            Moves the lower half of the source vector to a 64-bit register
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width selector</param>
            <param name="t">A target type representative</param>
            <remarks>
            vmovupd xmm0,[rcx] |> vmovq rax,xmm0
            </remarks>
        </member>
        <member name="M:Z0.z.vmove(System.Runtime.Intrinsics.Vector128{System.UInt64},Z0.N64)">
            <summary>
            src[0..64] -> r/m32[0..64]
            __int64 _mm_cvtsi128_si64 (__m128i a) MOVQ reg/m64, xmm
            Moves the lower half of the source vector to a 64-bit register
            </summary>
            <param name="src">The source vector</param>
            <param name="w">The target width selector</param>
            <param name="t">A target type representative</param>
            <remarks>
            vmovupd xmm0,[rcx] |> vmovq rax,xmm0
            </remarks>
        </member>
        <member name="M:Z0.z.vmove(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            src[0..31] -> dst[0..64]
            __m128d _mm_cvtss_sd (__m128d a, __m128 b) CVTSS2SD xmm, xmm/m32
            Overwrites the lower half of the target vector with the value obtained by converting the
            least component of the source vector to a 64-bit integer
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vmove(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            src[0..31] -> dst[0..64]
            __m128d _mm_cvtss_sd (__m128d a, __m128 b) CVTSS2SD xmm, xmm/m32
            Overwrites the lower half of the target vector with the value obtained by converting the least component of the source vector to a 64-bit integer
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vmove(System.Byte@,Z0.N2,Z0.W64)">
            <summary>
            PMOVZXBQ xmm, m16
            2x8u -> 2x64u
            Projects 2 unsigned 8-bit values onto 2 unsigned 64-bit integers
            </summary>
            <param name="src">The input component source</param>
            <param name="n">The source component count</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmove(System.Byte@,Z0.N4,Z0.W32)">
            <summary>
            PMOVZXBD xmm, m32
            4x8u -> 4x32u
            Projects 4 unsigned 8-bit values onto 4 unsigned 32-bit values
            </summary>
            <param name="src">The input component source</param>
            <param name="n">The source component count</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmove(System.Byte@,Z0.N4,Z0.W64)">
            <summary>
            VPMOVZXBQ ymm, m32
            4x8u -> 4x64u
            Projects four unsigned 8-bit integers onto 4 unsigned 64-bit integers
            </summary>
            <param name="src">The input component source</param>
            <param name="n">The source component count</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmove(System.Byte@,Z0.N8,Z0.W16)">
            <summary>
            PMOVZXBW xmm, m64
            8x8u -> 8x16u
            Projects 8 8-bit unsigned integers onto 8 16-bit unsigned integers
            </summary>
            <param name="src">The input component source</param>
            <param name="n">The source component count</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmove(System.Byte@,Z0.N8,Z0.W32)">
            <summary>
            VPMOVZXBD ymm, m64
            8x8u -> 8x32u
            Projects 8 unsigned 8-bit integers onto 8 unsigned 32-bit integers
            </summary>
            <param name="src">The input component source</param>
            <param name="n">The source component count</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmove(System.Byte@,Z0.N16,Z0.W16)">
            <summary>
            VPMOVZXBW ymm, m128
            16x8u -> 16x16u
            Projects 16 unsigned 8-bit integers onto 16 unsigned 16-bit integers
            </summary>
            <param name="src">The input component source</param>
            <param name="n">The source component count</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmove(System.UInt16@,Z0.N2,Z0.W64)">
            <summary>
            PMOVZXWQ xmm, m32
            2x16u -> 2x64u
            Projects 2 unsigned 16-bit integers onto two unsigned 64-bit integers
            </summary>
            <param name="src">The input component source</param>
            <param name="n">The source component count</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmove(System.UInt16@,Z0.N4,Z0.W64)">
            <summary>
            VPMOVZXWQ ymm, m64
            4x16u -> 4x64u
            </summary>
            <param name="src">The input component source</param>
            <param name="n">The source component count</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmove(System.UInt16@,Z0.N4,Z0.W32)">
            <summary>
            PMOVSXWD xmm, m64
            4x16u -> 4x32u
            Projects 4 16-bit unsigned integers onto 4 32-bit unsigned integers
            </summary>
            <param name="src">The input component source</param>
            <param name="n">The source component count</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmove(System.UInt16@,Z0.N8,Z0.W32)">
            <summary>
            VPMOVZXWD ymm, m128
            8x16u -> 8x32u
            Projects 8 unsigned 16-bit integers onto 8 unsigned 32-bit integers
            </summary>
            <param name="src">The input component source</param>
            <param name="n">The source component count</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmove(System.Byte@,Z0.N2,Z0.W64,Z0.N1)">
            <summary>
            PMOVZXBQ xmm, m16
            2x8u -> 2x64i
            Projects two unsigned 8-bit integers onto 2 signed 64-bit integers
            </summary>
            <param name="src">The input component source</param>
            <param name="n">The source component count</param>
            <param name="w">The target component width</param>
            <param name="i">Signals a sign extension</param>
        </member>
        <member name="M:Z0.z.vmove(System.Byte@,Z0.N128,Z0.W32,Z0.N1)">
            <summary>
            PMOVZXBD xmm, m32
            4x8u -> 4x32i
            Projects four unsigned 8-bit integers onto 4 signed 32-bit integers
            </summary>
            <param name="src">The input component source</param>
            <param name="n">The source component count</param>
            <param name="w">The target component width</param>
            <param name="i">Signals a sign extension</param>
        </member>
        <member name="M:Z0.z.vmove(System.Byte@,Z0.W256,Z0.W64,Z0.N1)">
            <summary>
            VPMOVZXBQ ymm, m32
            4x8u -> 4x64i
            Projects four unsigned 8-bit integers onto 4 signed 64-bit integers
            </summary>
            <param name="src">The input component source</param>
            <param name="n">The source component count</param>
            <param name="w">The target component width</param>
            <param name="i">Signals a sign extension</param>
        </member>
        <member name="M:Z0.z.vmove(System.Byte@,Z0.N8,Z0.W16,Z0.N1)">
            <summary>
            PMOVZXBW xmm, m64
            8x8u -> 8x16u
            Projects 8 8-bit unsigned integers onto 8 signed 16-bit integers
            </summary>
            <param name="src">The input component source</param>
            <param name="n">The source component count</param>
            <param name="w">The target component width</param>
            <param name="i">Signals a sign extension</param>
        </member>
        <member name="M:Z0.z.vmove(System.Byte@,Z0.N16,Z0.W16,Z0.N1)">
            <summary>
            VPMOVZXBW ymm, m128
            16x8u -> 16x16i
            Projects 16 8-bit unsigned integers onto 16 signed 16-bit integers
            </summary>
            <param name="src">The input component source</param>
            <param name="n">The source component count</param>
            <param name="w">The target component width</param>
            <param name="i">Signals a sign extension</param>
        </member>
        <member name="M:Z0.z.vmove(System.Int16@,Z0.N2,Z0.W64)">
            <summary>
            PMOVSXWQ xmm, m32
            2x16i -> 2x64u
            Projects 2 16-bit signed integers onto 2 64-bit signed integers
            </summary>
            <param name="src">The input component source</param>
            <param name="n">The source component count</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmove(System.Int16@,Z0.N4,Z0.W32)">
            <summary>
            PMOVSXWD xmm, m64
            4x16i -> 4x32i
            Projects 4 16-bit signed integers onto 4 32-bit signed integers
            </summary>
            <param name="src">The input component source</param>
            <param name="n">The source component count</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmove(System.UInt16@,Z0.N2,Z0.W64,Z0.N1)">
            <summary>
            PMOVZXWQ xmm, m32
            Projects 2 unsigned 16-bit integers onto 2 signed 64-bit integers
            </summary>
            <param name="src">The input component source</param>
            <param name="n">The source component count</param>
            <param name="w">The target component width</param>
            <param name="i">Signals a sign extension</param>
        </member>
        <member name="M:Z0.z.vmove(System.Int32@,Z0.N2,Z0.W64)">
            <summary>
            PMOVSXDQ xmm, m64
            2x32i -> 2x64i
            Projects 2 signed 32-bit integers onto 2 signed 64-bit integers
            </summary>
            <param name="src">The input component source</param>
            <param name="n">The source component count</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmove(System.UInt16@,Z0.N16,Z0.W32)">
            <summary>
            VPMOVZXWD ymm, m128
            16x16u ->16x32u
            Projects 16 unsigned 16-bit integers onto 16 unsigned 32-bit integers
            </summary>
            <param name="src">The input component source</param>
            <param name="n">The source component count</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmove(System.Int16@,Z0.N16,Z0.W32)">
            <summary>
            VPMOVSXWD ymm, m128
            16x16u ->16x32u
            Projects 16 signed 16-bit integers onto 16 signed 32-bit integers
            </summary>
            <param name="src">The input component source</param>
            <param name="n">The source component count</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vmove(System.Byte@,Z0.N32,Z0.W16)">
            <summary>
            VPMOVZXBW ymm, m128
            32x8u -> 32x16u
            Projects 32 unsigned 8-bit integers onto 32 unsigned 16-bit integers
            </summary>
            <param name="src">The memory source</param>
            <param name="lo">The lo target</param>
            <param name="hi">The hi target</param>
        </member>
        <member name="M:Z0.z.vmove(System.UInt16@,Z0.N8,Z0.W64)">
            <summary>
            VPMOVZXWQ ymm, m64
            8x16u -> 8x64u
            Projects 8 unsigned 16-bit integers onto 8 unsigned 64-bit integers
            </summary>
            <param name="src">The blocked memory source</param>
            <param name="lo">The lower target</param>
            <param name="hi">The upper target</param>
        </member>
        <member name="M:Z0.z.vmove(System.UInt32@,Z0.N8,Z0.W64)">
            <summary>
            VPMOVZXDQ ymm, m128
            8x32u -> 8x64u
            Projects 8 unsigned 32-bit integers onto 8 unsigned 64-bit integers
            </summary>
            <param name="src">The blocked memory source</param>
            <param name="lo">The lower target</param>
            <param name="hi">The upper target</param>
        </member>
        <member name="M:Z0.z.vmuladj(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_maddubs_epi16 (__m128i a, __m128i b) PMADDUBSW xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmuladj(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            __m256i _mm256_maddubs_epi16 (__m256i a, __m256i b) VPMADDUBSW ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmuladj(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
             __m256i _mm256_madd_epi16 (__m256i a, __m256i b) VPMADDWD ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmulhi(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_mulhi_epu16 (__m128i a, __m128i b) PMULHUW xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmulhi(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_mulhi_epu16 (__m128i a, __m128i b) PMULHUW xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmulhi(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
             __m256i _mm256_mulhi_epu16 (__m256i a, __m256i b) VPMULHUW ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmulhi(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
             __m256i _mm256_mulhi_epu16 (__m256i a, __m256i b) VPMULHUW ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmulhrs(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_mulhrs_epi16 (__m128i a, __m128i b) PMULHRSW xmm, xmm/m128
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vmulhrs(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
             __m256i _mm256_mulhrs_epi16 (__m256i a, __m256i b) VPMULHRSW ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vmullo(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_mullo_epi16 (__m128i a, __m128i b) PMULLW xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmullo(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_mullo_epi16 (__m128i a, __m128i b) PMULLW xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmullo(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_mullo_epi32 (__m128i a, __m128i b) PMULLD xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmullo(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_mullo_epi32 (__m128i a, __m128i b) PMULLD xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmullo(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_mullo_epi16 (__m256i a, __m256i b) VPMULLW ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmullo(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            __m256i _mm256_mullo_epi16 (__m256i a, __m256i b)VPMULLW ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmullo(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_mullo_epi32 (__m256i a, __m256i b) VPMULLD ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vmullo(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_mullo_epi32 (__m256i a, __m256i b) VPMULLD ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vnor(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            Computes ~(x | y) for vectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vnor(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            Computes ~(x | y) for vectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vnor(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            Computes ~(x | y) for vectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vnor(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            Computes ~(x | y) for vectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vnor(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            Computes ~(x | y) for vectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vnor(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            Computes ~(x | y) for vectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vnor(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            Computes ~(x | y) for vectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vnor(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            Computes ~(x | y) for vectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vnor(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            Computes ~(x | y) for vectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vnor(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            Computes ~(x | y) for vectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vnor(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            Computes ~(x | y) for vectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vnor(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            Computes ~(x | y) for vectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vnor(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            Computes ~(x | y) for vectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vnor(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            Computes ~(x | y) for vectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vnor(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            Computes ~(x | y) for vectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vnor(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            Computes ~(x | y) for vectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vnor(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            Computes ~(x | y) for vectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vnor(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            Computes ~(x | y) for vectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vnor(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            Computes ~(x | y) for vectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vnor(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            Computes ~(x | y) for vectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnand(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnand(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnand(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnand(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnand(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnand(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnand(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnand(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnand(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnand(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnand(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnand(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnand(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnand(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnand(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnand(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnand(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnand(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnand(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnand(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})" -->
        <member name="M:Z0.z.vnegate(System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            Negates the source vector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vnegate(System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            Negates the source vector (Two's complement)
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vnegate(System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            Negates the source vector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vnegate(System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            Negates the source vector (Two's complement)
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vnegate(System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            Negates the source vector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vnegate(System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            Negates the source vector (Two's complement)
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vnegate(System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            Negates the source vector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vnegate(System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            Negates the source vector (Two's complement)
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vnegate(System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            Negates the source vector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vnegate(System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            Negates the source vector (Two's complement)
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vnegate(System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            Negates the source vector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vnegate(System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            Negates the source vector (Two's complement)
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vnegate(System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            Negates the source vector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vnegate(System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            Negates the source vector (Two's complement)
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vnegate(System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            Negates the source vector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vnegate(System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            Negates the source vector (Two's complement)
            </summary>
            <param name="src">The source vector</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnonimpl(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnonimpl(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnonimpl(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnonimpl(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnonimpl(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnonimpl(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnonimpl(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnonimpl(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnonimpl(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnonimpl(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnonimpl(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnonimpl(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnonimpl(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnonimpl(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnonimpl(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vnonimpl(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})" -->
        <member name="M:Z0.z.vnonz(System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            Returns true if the source vector is nonzero, false otherwise
            </summary>
            <param name="src">The vector to test</param>
        </member>
        <member name="M:Z0.z.vnonz(System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            Returns true if the source vector is nonzero, false otherwise
            </summary>
            <param name="src">The vector to test</param>
        </member>
        <member name="M:Z0.z.vnonz(System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            Returns true if the source vector is nonzero, false otherwise
            </summary>
            <param name="src">The vector to test</param>
        </member>
        <member name="M:Z0.z.vnonz(System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            Returns true if the source vector is nonzero, false otherwise
            </summary>
            <param name="src">The vector to test</param>
        </member>
        <member name="M:Z0.z.vnonz(System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            Returns true if the source vector is nonzero, false otherwise
            </summary>
            <param name="src">The vector to test</param>
        </member>
        <member name="M:Z0.z.vnonz(System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            Returns true if the source vector is nonzero, false otherwise
            </summary>
            <param name="src">The vector to test</param>
        </member>
        <member name="M:Z0.z.vnonz(System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            Returns true if the source vector is nonzero, false otherwise
            </summary>
            <param name="src">The vector to test</param>
        </member>
        <member name="M:Z0.z.vnonz(System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            Returns true if the source vector is nonzero, false otherwise
            </summary>
            <param name="src">The vector to test</param>
        </member>
        <member name="M:Z0.z.vnonz(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            Returns true if the source vector is nonzero, false otherwise
            </summary>
            <param name="src">The vector to test</param>
        </member>
        <member name="M:Z0.z.vnonz(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            Returns true if the source vector is nonzero, false otherwise
            </summary>
            <param name="src">The vector to test</param>
        </member>
        <member name="M:Z0.z.vnonz(System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            Returns true if the source vector is nonzero, false otherwise
            </summary>
            <param name="src">The vector to test</param>
        </member>
        <member name="M:Z0.z.vnonz(System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            Returns true if the source vector is nonzero, false otherwise
            </summary>
            <param name="src">The vector to test</param>
        </member>
        <member name="M:Z0.z.vnonz(System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            Returns true if the source vector is nonzero, false otherwise
            </summary>
            <param name="src">The vector to test</param>
        </member>
        <member name="M:Z0.z.vnonz(System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            Returns true if the source vector is nonzero, false otherwise
            </summary>
            <param name="src">The vector to test</param>
        </member>
        <member name="M:Z0.z.vnonz(System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            Returns true if the source vector is nonzero, false otherwise
            </summary>
            <param name="src">The vector to test</param>
        </member>
        <member name="M:Z0.z.vnonz(System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            Returns true if the source vector is nonzero, false otherwise
            </summary>
            <param name="src">The vector to test</param>
        </member>
        <member name="M:Z0.z.vnonz(System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            Returns true if the source vector is nonzero, false otherwise
            </summary>
            <param name="src">The vector to test</param>
        </member>
        <member name="M:Z0.z.vnonz(System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            Returns true if the source vector is nonzero, false otherwise
            </summary>
            <param name="src">The vector to test</param>
        </member>
        <member name="M:Z0.z.vnonz(System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            Returns true if the source vector is nonzero, false otherwise
            </summary>
            <param name="src">The vector to test</param>
        </member>
        <member name="M:Z0.z.vnonz(System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            Returns true if the source vector is nonzero, false otherwise
            </summary>
            <param name="src">The vector to test</param>
        </member>
        <member name="M:Z0.z.vnot(System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            Computes the bitwise negation of the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vnot(System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            Computes the bitwise negation of the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vnot(System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            Computes the bitwise negation of the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vnot(System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            Computes the bitwise negation of the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vnot(System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            Computes the bitwise negation of the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vnot(System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            Computes the bitwise negation of the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vnot(System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            Computes the bitwise negation of the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vnot(System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            Computes the bitwise negation of the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vnot(System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            Computes the bitwise negation of the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vnot(System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            Computes the bitwise negation of the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vnot(System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            Computes the bitwise negation of the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vnot(System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            Computes the bitwise negation of the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vnot(System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            Computes the bitwise negation of the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vnot(System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            Computes the bitwise negation of the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vnot(System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            Computes the bitwise negation of the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vnot(System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            Computes the bitwise negation of the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vones``1(Z0.N128,``0)">
            <summary>
            Creates a 128-bit vector with all bits enabled
            </summary>
            <param name="n">The vector width selector</param>
            <typeparam name="T">The primal component type</typeparam>
        </member>
        <member name="M:Z0.z.vones``1(Z0.N256,``0)">
            <summary>
            Creates a 256-bit vector with all bits enabled
            </summary>
            <param name="n">The vector width selector</param>
            <typeparam name="T">The primal component type</typeparam>
        </member>
        <member name="M:Z0.z.vones``1(Z0.N512,``0)">
            <summary>
            Creates a 512-bit vector with all bits enabled
            </summary>
            <param name="n">The vector width selector</param>
            <typeparam name="T">The primal component type</typeparam>
        </member>
        <member name="M:Z0.z.vor(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
             __m128i _mm_or_si128 (__m128i a, __m128i b)POR xmm, xmm/m128
            Computes the bitwise or between the source operands
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vor(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
             __m128i _mm_or_si128 (__m128i a, __m128i b)POR xmm, xmm/m128
            Computes the bitwise or between the source operands
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vor(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
             __m128i _mm_or_si128 (__m128i a, __m128i b)POR xmm, xmm/m128
            Computes the bitwise or between the source operands
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vor(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
             __m128i _mm_or_si128 (__m128i a, __m128i b)POR xmm, xmm/m128
            Computes the bitwise or between the source operands
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vor(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
             __m128i _mm_or_si128 (__m128i a, __m128i b)POR xmm, xmm/m128
            Computes the bitwise or between the source operands
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vor(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
             __m128i _mm_or_si128 (__m128i a, __m128i b)POR xmm, xmm/m128
            Computes the bitwise or between the source operands
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vor(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
             __m128i _mm_or_si128 (__m128i a, __m128i b)POR xmm, xmm/m128
            Computes the bitwise or between the source operands
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vor(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
             __m128i _mm_or_si128 (__m128i a, __m128i b)POR xmm, xmm/m128
            Computes the bitwise or between the source operands
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vor(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
             __m128i _mm_or_si128 (__m128i a, __m128i b)POR xmm, xmm/m128
            Computes the bitwise or between the source operands
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vor(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
             __m256i _mm256_or_si256 (__m256i a, __m256i b)VPOR ymm, ymm, ymm/m25
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vor(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
             __m256i _mm256_or_si256 (__m256i a, __m256i b)VPOR ymm, ymm, ymm/m25
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vor(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
             __m256i _mm256_or_si256 (__m256i a, __m256i b)VPOR ymm, ymm, ymm/m25
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vor(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
             __m256i _mm256_or_si256 (__m256i a, __m256i b)VPOR ymm, ymm, ymm/m25
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vor(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
             __m256i _mm256_or_si256 (__m256i a, __m256i b)VPOR ymm, ymm, ymm/m25
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vor(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
             __m256i _mm256_or_si256 (__m256i a, __m256i b)VPOR ymm, ymm, ymm/m25
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vor(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
             __m256i _mm256_or_si256 (__m256i a, __m256i b)VPOR ymm, ymm, ymm/m25
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vor(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_or_ps (__m128 a, __m128 b) ORPS xmm, xmm/m128
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vor(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_or_pd (__m128d a, __m128d b) ORPD xmm, xmm/m128
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vor(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_or_ps (__m256 a, __m256 b) VORPS ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vor(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_or_pd (__m256d a, __m256d b) VORPD ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vpackss(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
             __m128i _mm_packs_epi16 (__m128i a, __m128i b) PACKSSWB xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vpackss(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
             __m128i _mm_packs_epi16 (__m128i a, __m128i b) PACKSSWB xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vpackss(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_packs_epi32 (__m128i a, __m128i b) PACKSSDW xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vpackss(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_packs_epi32 (__m128i a, __m128i b) PACKSSDW xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vpackss(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_packs_epi16 (__m256i a, __m256i b) VPACKSSWB ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vpackss(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            __m256i _mm256_packs_epi16 (__m256i a, __m256i b) VPACKSSWB ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vpackss(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_packs_epi32 (__m256i a, __m256i b) VPACKSSDW ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vpackss(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_packs_epi32 (__m256i a, __m256i b) VPACKSSDW ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vpackus(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
             __m128i _mm_packus_epi16 (__m128i a, __m128i b) PACKUSWB xmm, xmm/m128
            (8x16w,8x16w) -> 16x8w
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vpackus(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
             <summary>
            __m128i _mm_packus_epi32 (__m128i a, __m128i b) PACKUSDW xmm, xmm/m128
             (4x32w,4x32w) -> 8x16w
             </summary>
             <param name="x">The left vector</param>
             <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vpackus(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_packus_epi16 (__m256i a, __m256i b) VPACKUSWB ymm, ymm, ymm/m256
            (16x8w,16x8w) -> 32x8w
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vpackus(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_packus_epi32 (__m256i a, __m256i b)VPACKUSDW ymm, ymm, ymm/m256
            (8x32w,8x32w) -> 16x16w
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vpackus(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
             __m128i _mm_packus_epi16 (__m128i a, __m128i b)PACKUSWB xmm, xmm/m128
            (8x16w,8x16w) -> 16x8w
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <remarks>See https://stackoverflow.com/questions/12118910/converting-float-vector-to-16-bit-int-without-saturating</remarks>
        </member>
        <member name="M:Z0.z.vpackus(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
             <summary>
            __m128i _mm_packus_epi32 (__m128i a, __m128i b) PACKUSDW xmm, xmm/m128
             (4x32w,4x32w) -> 8x16w
             </summary>
             <param name="x">The left vector</param>
             <param name="y">The right vector</param>
             <remarks>See https://stackoverflow.com/questions/12118910/converting-float-vector-to-16-bit-int-without-saturating</remarks>
        </member>
        <member name="M:Z0.z.vpackus(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            __m256i _mm256_packus_epi16 (__m256i a, __m256i b) VPACKUSWB ymm, ymm, ymm/m256
            (16x8w,16x8w) -> 32x8w
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vpackus(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_packus_epi32 (__m256i a, __m256i b) VPACKUSDW ymm, ymm, ymm/m256
            (8x32w,8x32w) -> 16x16w
            [0, 1, 2, 3, 8, 9, 10, 11, 4, 5, 6, 7, 12, 13, 14, 15]
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.packusHi(Z0.N128,Z0.N32,Z0.N16)">
            <summary>
            Produces the hi shuffle spec for packing (128x32, 128x32) -> 128x16
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The source cell width selector</param>
            <param name="dst">The target cell width selector</param>
        </member>
        <member name="M:Z0.z.packusHi(Z0.N128,Z0.N16,Z0.N8)">
            <summary>
            Produces the hi shuffle spec for packing (128x16,128x16) -> 128x8
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The source cell width selector</param>
            <param name="dst">The target cell width selector</param>
        </member>
        <member name="M:Z0.z.vpackushi(Z0.N256,Z0.N32,Z0.N16)">
            <summary>
            Retrieves the hi shuffle spec for packing 256x32x2 -> 256x16
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The source cell width selector</param>
            <param name="dst">The target cell width selector</param>
        </member>
        <member name="M:Z0.z.packusLo(Z0.N128,Z0.N32,Z0.N16)">
            <summary>
            Produces the lo shuffle spec for packing (128x32, 128x32) -> 128x16
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The source cell width selector</param>
            <param name="dst">The target cell width selector</param>
        </member>
        <member name="M:Z0.z.packusLo(Z0.N128,Z0.N16,Z0.N8)">
            <summary>
            Produces the lo shuffle spec for packing (128x16,128x16) -> 128x8
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The source cell width selector</param>
            <param name="dst">The target cell width selector</param>
        </member>
        <member name="M:Z0.z.vpackuslo(Z0.N256,Z0.N32,Z0.N16)">
            <summary>
            Retrieves the lo shuffle spec for packing 256x32x2 -> 256x16
            </summary>
            <param name="w">The vector width selector</param>
            <param name="src">The source cell width selector</param>
            <param name="dst">The target cell width selector</param>
        </member>
        <member name="M:Z0.z.vpart30x8x3(System.UInt32)">
            <summary>
            Partitions the first 30 bits of a 32-bit source into 30 bytes, each with an effective width of 3
            </summary>
            <param name="src">The source value</param>
            <param name="dst">A target span of sufficient length</param>
        </member>
        <member name="M:Z0.z.vpart32x8x1(System.UInt32)">
            <summary>
            Partitions a 32-bit source value into 32 8-bit pieces each with an effective width of q
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.vparts(Z0.W128,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Defines a 128-bit vector by explicit component specification, from least -> most significant
            </summary>
            <param name="w">The vector width selector</param>
        </member>
        <member name="M:Z0.z.vparts(Z0.W128i,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte)">
            <summary>
            Defines a 128-bit vector by explicit component specification, from least -> most significant
            </summary>
            <param name="w">The vector width selector</param>
        </member>
        <member name="M:Z0.z.vparts(Z0.W128i,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16)">
            <summary>
            Defines a 128-bit vector by explicit component specification, from least -> most significant
            </summary>
            <param name="w">The vector width selector</param>
        </member>
        <member name="M:Z0.z.vparts(Z0.W128,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Defines a 128-bit vector by explicit component specification, from least -> most significant
            </summary>
            <param name="w">The vector width selector</param>
        </member>
        <member name="M:Z0.z.vparts(Z0.W128,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Defines a 128-bit vector by explicit component specification, from least -> most significant
            </summary>
            <param name="w">The vector width selector</param>
        </member>
        <member name="M:Z0.z.vparts(Z0.W128i,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Defines a 128-bit vector by explicit component specification, from least -> most significant
            </summary>
            <param name="w">The vector width selector</param>
        </member>
        <member name="M:Z0.z.vparts(Z0.W256i,System.Int64,System.Int64)">
            <summary>
            Defines a 128-bit vector by explicit component specification, from least -> most significant
            </summary>
            <param name="w">The vector width selector</param>
        </member>
        <member name="M:Z0.z.vparts(System.UInt64,System.UInt64)">
            <summary>
            Defines a 128-bit vector by explicit component specification, from least -> most significant
            </summary>
            <param name="w">The vector width selector</param>
        </member>
        <member name="M:Z0.z.vparts(Z0.W128,System.UInt64,System.UInt64)">
            <summary>
            Defines a 128-bit vector by explicit component specification, from least -> most significant
            </summary>
            <param name="w">The vector width selector</param>
        </member>
        <member name="M:Z0.z.vparts(Z0.W128,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Defines a 128-bit vector by explicit component specification, from least -> most significant
            </summary>
            <param name="w">The vector width selector</param>
        </member>
        <member name="M:Z0.z.vparts(Z0.W128,System.Double,System.Double)">
            <summary>
            Defines a 128-bit vector by explicit component specification, from least -> most significant
            </summary>
            <param name="w">The vector width selector</param>
        </member>
        <member name="M:Z0.z.vparts(Z0.W256,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Defines a 256-bit vector by explicit component specification, from least -> most significant
            </summary>
            <param name="w">The vector width selector</param>
        </member>
        <member name="M:Z0.z.vparts(Z0.W256i,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte,System.SByte)">
            <summary>
            Defines a 256-bit vector by explicit component specification, from least -> most significant
            </summary>
            <param name="w">The vector width selector</param>
        </member>
        <member name="M:Z0.z.vparts(Z0.W256,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Defines a 256-bit vector by explicit component specification, from least -> most significant
            </summary>
            <param name="w">The vector width selector</param>
        </member>
        <member name="M:Z0.z.vparts(Z0.W256i,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16)">
            <summary>
            Defines a 256-bit vector by explicit component specification, from least -> most significant
            </summary>
            <param name="w">The vector width selector</param>
        </member>
        <member name="M:Z0.z.vparts(Z0.W256i,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Defines a 256-bit vector by explicit component specification, from least -> most significant
            </summary>
            <param name="w">The vector width selector</param>
        </member>
        <member name="M:Z0.z.vparts(System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Defines a 256-bit vector by explicit component specification, from least -> most significant
            </summary>
            <param name="w">The vector width selector</param>
        </member>
        <member name="M:Z0.z.vparts(Z0.W256,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Defines a 256-bit vector by explicit component specification, from least -> most significant
            </summary>
            <param name="w">The vector width selector</param>
        </member>
        <member name="M:Z0.z.vparts(Z0.W256i,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Defines a 256-bit vector by explicit component specification, from least -> most significant
            </summary>
            <param name="w">The vector width selector</param>
        </member>
        <member name="M:Z0.z.vparts(Z0.W256,System.UInt64,System.UInt64,System.UInt64,System.UInt64)">
            <summary>
            Defines a 256-bit vector by explicit component specification, from least -> most significant
            </summary>
            <param name="w">The vector width selector</param>
        </member>
        <member name="M:Z0.z.vparts(Z0.W256,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Defines a 256-bit vector by explicit component specification, from least -> most significant
            </summary>
            <param name="w">The vector width selector</param>
        </member>
        <member name="M:Z0.z.vparts(Z0.W256,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Defines a 256-bit vector by explicit component specification, from least -> most significant
            </summary>
            <param name="w">The vector width selector</param>
        </member>
        <member name="M:Z0.z.vparts(Z0.W512i,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16,System.Int16)">
            <summary>
            Defines a 512-bit vector by explicit component specification, from least -> most significant
            </summary>
            <param name="w">The vector width selector</param>
        </member>
        <member name="M:Z0.z.vparts(Z0.W512,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Defines a 512-bit vector by explicit component specification, from least -> most significant
            </summary>
            <param name="w">The vector width selector</param>
        </member>
        <member name="M:Z0.z.vparts(Z0.W512i,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Defines a 512-bit vector by explicit component specification, from least -> most significant
            </summary>
            <param name="w">The vector width selector</param>
        </member>
        <member name="M:Z0.z.vparts(Z0.W512,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32,System.UInt32)">
            <summary>
            Defines a 512-bit vector by explicit component specification, from least -> most significant
            </summary>
            <param name="w">The vector width selector</param>
        </member>
        <member name="M:Z0.z.vparts(Z0.W512i,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64,System.Int64)">
            <summary>
            Defines a 512-bit vector by explicit component specification, from least -> most significant
            </summary>
            <param name="w">The vector width selector</param>
        </member>
        <member name="M:Z0.z.vparts(Z0.W512,System.UInt64,System.UInt64,System.UInt64,System.UInt64,System.UInt64,System.UInt64,System.UInt64,System.UInt64)">
            <summary>
            Defines a 512-bit vector by explicit component specification, from least -> most significant
            </summary>
            <param name="w">The vector width selector</param>
        </member>
        <member name="M:Z0.z.vparts(Z0.W512,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single,System.Single)">
            <summary>
            Defines a 512-bit vector by explicit component specification, from least -> most significant
            </summary>
            <param name="w">The vector width selector</param>
        </member>
        <member name="M:Z0.z.vparts(Z0.W512,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double,System.Double)">
            <summary>
            Defines a 512-bit vector by explicit component specification, from least -> most significant
            </summary>
            <param name="w">The vector width selector</param>
        </member>
        <member name="M:Z0.z.vperm16x8(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_shuffle_epi8 (__m128i a, __m128i b) PSHUFB xmm, xmm/m128
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vperm16x8(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_shuffle_epi8 (__m128i a, __m128i b) PSHUFB xmm, xmm/m128
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vperm16x8(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_shuffle_epi8 (__m128i a, __m128i b) PSHUFB xmm, xmm/m128
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vperm16x8(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_shuffle_epi8 (__m128i a, __m128i b) PSHUFB xmm, xmm/m128
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vperm16x8(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_shuffle_epi8 (__m128i a, __m128i b) PSHUFB xmm, xmm/m128
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vperm16x8(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_shuffle_epi8 (__m128i a, __m128i b) PSHUFB xmm, xmm/m128
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vperm16x8(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_shuffle_epi8 (__m128i a, __m128i b) PSHUFB xmm, xmm/m128
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vperm16x8(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_shuffle_epi8 (__m128i a, __m128i b) PSHUFB xmm, xmm/m128
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vperm16x8(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_shuffle_epi8 (__m256i a, __m256i b) VPSHUFB ymm, ymm, ymm/m256
            </summary>
            <param name="src">The source vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vperm16x8(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_shuffle_epi8 (__m256i a, __m256i b) VPSHUFB ymm, ymm, ymm/m256
            </summary>
            <param name="src">The source vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vperm16x8(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_shuffle_epi8 (__m256i a, __m256i b) VPSHUFB ymm, ymm, ymm/m256
            </summary>
            <param name="src">The source vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vperm16x8(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_shuffle_epi8 (__m256i a, __m256i b) VPSHUFB ymm, ymm, ymm/m256
            </summary>
            <param name="src">The source vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vperm16x8(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_shuffle_epi8 (__m256i a, __m256i b) VPSHUFB ymm, ymm, ymm/m256
            </summary>
            <param name="src">The source vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vperm16x8(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_shuffle_epi8 (__m256i a, __m256i b) VPSHUFB ymm, ymm, ymm/m256
            </summary>
            <param name="src">The source vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vperm16x8(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_shuffle_epi8 (__m256i a, __m256i b) VPSHUFB ymm, ymm, ymm/m256
            </summary>
            <param name="src">The source vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vperm16x8(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_shuffle_epi8 (__m256i a, __m256i b) VPSHUFB ymm, ymm, ymm/m256
            </summary>
            <param name="src">The source vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vperm2x128(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte},Z0.Perm2x4)">
            <summary>
            __m256i _mm256_permute2x128_si256 (__m256i a, __m256i b, const int imm8) VPERM2I128 ymm, ymm, ymm/m256, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The permutation spec</param>
        </member>
        <member name="M:Z0.z.vperm2x128(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte},Z0.Perm2x4)">
            <summary>
            __m256i _mm256_permute2x128_si256 (__m256i a, __m256i b, const int imm8) VPERM2I128 ymm, ymm, ymm/m256, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The permutation spec</param>
        </member>
        <member name="M:Z0.z.vperm2x128(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16},Z0.Perm2x4)">
            <summary>
            __m256i _mm256_permute2x128_si256 (__m256i a, __m256i b, const int imm8) VPERM2I128 ymm, ymm, ymm/m256, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The permutation spec</param>
        </member>
        <member name="M:Z0.z.vperm2x128(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16},Z0.Perm2x4)">
            <summary>
            __m256i _mm256_permute2x128_si256 (__m256i a, __m256i b, const int imm8) VPERM2I128 ymm, ymm, ymm/m256, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The permutation spec</param>
        </member>
        <member name="M:Z0.z.vperm2x128(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32},Z0.Perm2x4)">
            <summary>
            __m256i _mm256_permute2x128_si256 (__m256i a, __m256i b, const int imm8) VPERM2I128 ymm, ymm, ymm/m256, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The permutation spec</param>
        </member>
        <member name="M:Z0.z.vperm2x128(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32},Z0.Perm2x4)">
            <summary>
            __m256i _mm256_permute2x128_si256 (__m256i a, __m256i b, const int imm8) VPERM2I128 ymm, ymm, ymm/m256, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The permutation spec</param>
        </member>
        <member name="M:Z0.z.vperm2x128(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64},Z0.Perm2x4)">
            <summary>
            __m256i _mm256_permute2x128_si256 (__m256i a, __m256i b, const int imm8) VPERM2I128 ymm, ymm, ymm/m256, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The permutation spec</param>
        </member>
        <member name="M:Z0.z.vperm2x128(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64},Z0.Perm2x4)">
            <summary>
            __m256i _mm256_permute2x128_si256 (__m256i a, __m256i b, const int imm8) VPERM2I128 ymm, ymm, ymm/m256, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The permutation spec</param>
        </member>
        <member name="M:Z0.z.vperm2x128(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single},Z0.Perm2x4)">
            <summary>
            __m256 _mm256_permute2f128_ps (__m256 a, __m256 b, int imm8) VPERM2F128 ymm, ymm, ymm/m256, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The permutation spec</param>
        </member>
        <member name="M:Z0.z.vperm2x128(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double},Z0.Perm2x4)">
            <summary>
            __m256d _mm256_permute2f128_pd (__m256d a, __m256d b, int imm8) VPERM2F128 ymm, ymm, ymm/m256, imm8
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="spec">The permutation spec</param>
        </member>
        <member name="M:Z0.z.vperm4x16(System.Runtime.Intrinsics.Vector128{System.Int16},Z0.Perm4L,Z0.Perm4L)">
            <summary>
            Permutes the lower four elements of the source vector with the lo mask and the upper four elements with the hi mask
            </summary>
            <param name="src">The source vector</param>
            <param name="lo">The lo spec</param>
            <param name="hi">The hi spec</param>
        </member>
        <member name="M:Z0.z.vperm4x16(System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.Perm4L,Z0.Perm4L)">
            <summary>
            Shuffles the first four elements of the source vector with the lo mask and the last four elements with the hi mask
            </summary>
            <param name="src">The content vector</param>
            <param name="lo">The lo mask</param>
            <param name="hi">The hi mask</param>
        </member>
        <member name="M:Z0.z.vperm4x32(System.Runtime.Intrinsics.Vector128{System.UInt32},Z0.Perm4L)">
            <summary>
            __m128i _mm_shuffle_epi32 (__m128i a, int immediate) PSHUFD xmm, xmm/m128, imm8
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vperm4x32(System.Runtime.Intrinsics.Vector128{System.Int32},Z0.Perm4L)">
            <summary>
            __m128i _mm_shuffle_epi32 (__m128i a, int immediate)PSHUFD xmm, xmm/m128, imm8
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vperm4x32(System.Runtime.Intrinsics.Vector256{System.Int32},Z0.Perm4L)">
            <summary>
             __m256i _mm256_shuffle_epi32 (__m256i a, const int imm8) VPSHUFD ymm, ymm/m256, imm8
             shuffles signed 32-bit integers in the source vector within 128-bit lanes
             </summary>
             <param name="src">The content vector</param>
             <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vperm4x32(System.Runtime.Intrinsics.Vector256{System.UInt32},Z0.Perm4L)">
            <summary>
             __m256i _mm256_shuffle_epi32 (__m256i a, const int imm8) VPSHUFD ymm, ymm/m256, imm8
             Shuffles 32-bit source segments within 128-bit lanes
             </summary>
             <param name="src">The content vector</param>
             <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vperm4x64(System.Runtime.Intrinsics.Vector256{System.SByte},Z0.Perm4L)">
            <summary>
            __m256i _mm256_permute4x64_epi64 (__m256i a, const int imm8) VPERMQ ymm, ymm/m256, imm8
            Permutes vector content across lanes at 64-bit granularity
            </summary>
            <param name="x">The source vector</param>
            <param name="spec">The perm spec</param>
        </member>
        <member name="M:Z0.z.vperm4x64(System.Runtime.Intrinsics.Vector256{System.Byte},Z0.Perm4L)">
            <summary>
            __m256i _mm256_permute4x64_epi64 (__m256i a, const int imm8) VPERMQ ymm, ymm/m256, imm8
            Permutes vector content across lanes at 64-bit granularity
            </summary>
            <param name="x">The source vector</param>
            <param name="spec">The perm spec</param>
        </member>
        <member name="M:Z0.z.vperm4x64(System.Runtime.Intrinsics.Vector256{System.Int16},Z0.Perm4L)">
            <summary>
            __m256i _mm256_permute4x64_epi64 (__m256i a, const int imm8) VPERMQ ymm, ymm/m256, imm8
            Permutes vector content across lanes at 64-bit granularity
            </summary>
            <param name="x">The source vector</param>
            <param name="spec">The perm spec</param>
        </member>
        <member name="M:Z0.z.vperm4x64(System.Runtime.Intrinsics.Vector256{System.UInt16},Z0.Perm4L)">
            <summary>
            __m256i _mm256_permute4x64_epi64 (__m256i a, const int imm8) VPERMQ ymm, ymm/m256, imm8
            Permutes vector content across lanes at 64-bit granularity
            </summary>
            <param name="x">The source vector</param>
            <param name="spec">The perm spec</param>
        </member>
        <member name="M:Z0.z.vperm4x64(System.Runtime.Intrinsics.Vector256{System.Int32},Z0.Perm4L)">
            <summary>
            __m256i _mm256_permute4x64_epi64 (__m256i a, const int imm8)VPERMQ ymm, ymm/m256, imm8
            Permutes vector content across lanes at 64-bit granularity
            </summary>
            <param name="x">The source vector</param>
            <param name="spec">The perm spec</param>
        </member>
        <member name="M:Z0.z.vperm4x64(System.Runtime.Intrinsics.Vector256{System.UInt32},Z0.Perm4L)">
            <summary>
            __m256i _mm256_permute4x64_epi64 (__m256i a, const int imm8) VPERMQ ymm, ymm/m256, imm8
            Permutes vector content across lanes at 64-bit granularity
            </summary>
            <param name="x">The source vector</param>
            <param name="spec">The control byte</param>
        </member>
        <member name="M:Z0.z.vperm4x64(System.Runtime.Intrinsics.Vector256{System.UInt64},Z0.Perm4L)">
            <summary>
            __m256i _mm256_permute4x64_epi64 (__m256i a, const int imm8) VPERMQ ymm, ymm/m256, imm8
            Permutes vector content across lanes at 64-bit granularity
            </summary>
            <param name="x">The source vector</param>
            <param name="spec">The control byte</param>
        </member>
        <member name="M:Z0.z.vperm4x64(System.Runtime.Intrinsics.Vector256{System.Int64},Z0.Perm4L)">
            <summary>
            __m256i _mm256_permute4x64_epi64 (__m256i a, const int imm8) VPERMQ ymm, ymm/m256, imm8
            Permutes vector content across lanes at 64-bit granularity
            </summary>
            <param name="x">The source vector</param>
            <param name="spec">The control byte</param>
        </member>
        <member name="M:Z0.z.vperm4x64(System.Runtime.Intrinsics.Vector256{System.Double},Z0.Perm4L)">
            <summary>
            __m256d _mm256_permute4x64_pd (__m256d a, const int imm8) VPERMPD ymm, ymm/m256, imm8
            Permutes vector content across lanes at 64-bit granularity
            </summary>
            <param name="src">The source vector</param>
            <param name="spec">The permutation spec</param>
        </member>
        <member name="M:Z0.z.vperm8x32(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_permutevar8x32_epi32 (__m256i a, __m256i idx) VPERMD ymm, ymm/m256, ymm
            Applies a cross-lane permutation over 8 32-bit source vector segments
            </summary>
            <param name="src">The source vector</param>
            <param name="spec">The perm spec</param>
        </member>
        <member name="M:Z0.z.vperm8x32(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_permutevar8x32_epi32 (__m256i a, __m256i idx) VPERMD ymm, ymm/m256, ymm
            Applies a cross-lane permutation over 8 32-bit source vector segments
            </summary>
            <param name="src">The source vector</param>
            <param name="spec">The perm spec</param>
        </member>
        <member name="M:Z0.z.vperm8x32(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_permutevar8x32_epi32 (__m256i a, __m256i idx) VPERMD ymm, ymm/m256, ymm
            Applies a cross-lane permutation over 8 32-bit source vector segments
            </summary>
            <param name="src">The source vector</param>
            <param name="spec">The perm spec</param>
        </member>
        <member name="M:Z0.z.vperm8x32(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_permutevar8x32_epi32 (__m256i a, __m256i idx) VPERMD ymm, ymm/m256, ymm
            Applies a cross-lane permutation over 8 32-bit source vector segments
            </summary>
            <param name="src">The source vector</param>
            <param name="spec">The perm spec</param>
        </member>
        <member name="M:Z0.z.vperm8x32(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_permutevar8x32_epi32 (__m256i a, __m256i idx)VPERMD ymm, ymm/m256, ymm
            Applies a cross-lane permutation over 8 32-bit source vector segments
            </summary>
            <param name="src">The source vector</param>
            <param name="spec">The perm spec</param>
        </member>
        <member name="M:Z0.z.vperm8x32(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_permutevar8x32_epi32 (__m256i a, __m256i idx)VPERMD ymm, ymm/m256, ymm
            Applies a cross-lane permutation over 8 32-bit source vector segments
            </summary>
            <param name="src">The source vector</param>
            <param name="spec">The perm spec</param>
        </member>
        <member name="M:Z0.z.vperm8x32(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_permutevar8x32_epi32 (__m256i a, __m256i idx) VPERMD ymm, ymm/m256, ymm
            Applies a cross-lane permutation over 8 32-bit source vector segments
            </summary>
            <param name="src">The source vector</param>
            <param name="spec">The perm spec</param>
        </member>
        <member name="M:Z0.z.vperm8x32(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_permutevar8x32_epi32 (__m256i a, __m256i idx) VPERMD ymm, ymm/m256, ymm
            Applies a cross-lane permutation over 8 32-bit source vector segments
            </summary>
            <param name="src">The source vector</param>
            <param name="spec">The perm spec</param>
        </member>
        <member name="M:Z0.z.vperm8x32(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            Permutes components in the source vector across lanes as specified by the control vector
            __m256 _mm256_permutevar8x32_ps (__m256 a, __m256i idx) VPERMPS ymm, ymm/m256, ymm
            </summary>
            <param name="src">The source vector</param>
            <param name="spec">The control vector</param>
        </member>
        <member name="M:Z0.z.vperm8x32(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256 _mm256_permutevar8x32_ps (__m256 a, __m256i idx)VPERMPS ymm, ymm/m256, ymm
            </summary>
            <param name="src">The source vector</param>
            <param name="spec">The perm spec</param>
        </member>
        <member name="M:Z0.z.vpermhi4x16(System.Runtime.Intrinsics.Vector128{System.Int16},Z0.Perm4L)">
            <summary>
             __m128i _mm_shufflehi_epi16 (__m128i a, int immediate) PSHUFHW xmm, xmm/m128, imm8
            </summary>
             <param name="src">The source vector</param>
             <param name="spec">The permutation spec</param>
        </member>
        <member name="M:Z0.z.vpermhi4x16(System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.Perm4L)">
            <summary>
            __m128i _mm_shufflehi_epi16 (__m128i a, int immediate) PSHUFHW xmm, xmm/m128, imm8
            Shuffles the upper half of a vector as specified by a permutation while leaving the lower half unchanged
            </summary>
            <param name="src">The source vector</param>
            <param name="spec">The permutation spec</param>
        </member>
        <member name="M:Z0.z.vpermhi4x16(System.Runtime.Intrinsics.Vector256{System.Int16},Z0.Perm4L)">
            <summary>
            __m256i _mm256_shufflehi_epi16 (__m256i a, const int imm8) VPSHUFHW ymm, ymm/m256,imm8
            </summary>
            <param name="src">The source vector</param>
            <param name="spec">The permutation spec</param>
        </member>
        <member name="M:Z0.z.vpermhi4x16(System.Runtime.Intrinsics.Vector256{System.UInt16},Z0.Perm4L)">
            <summary>
            __m256i _mm256_shufflehi_epi16 (__m256i a, const int imm8) VPSHUFHW ymm, ymm/m256, imm8
            </summary>
            <param name="src">The source vector</param>
            <param name="spec">The permutation spec</param>
        </member>
        <member name="M:Z0.z.vpermlo4x16(System.Runtime.Intrinsics.Vector128{System.Int16},Z0.Perm4L)">
            <summary>
            __m128i _mm_shufflelo_epi16 (__m128i a, int control) PSHUFLW xmm, xmm/m128, imm8
            Shuffles the lower half of a vector as specified by a permutation while leaving the upper half unchanged
            </summary>
            <param name="src">The source vector</param>
            <param name="spec">The permutation spec</param>
        </member>
        <member name="M:Z0.z.vpermlo4x16(System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.Perm4L)">
            <summary>
            __m128i _mm_shufflelo_epi16 (__m128i a, int control) PSHUFLW xmm, xmm/m128, imm8
            Shuffles the lower half of a vector as specified by a permutation while leaving the upper half unchanged
            </summary>
            <param name="src">The source vector</param>
            <param name="spec">The permutation spec</param>
        </member>
        <member name="M:Z0.z.vpermlo4x16(System.Runtime.Intrinsics.Vector256{System.Int16},Z0.Perm4L)">
            <summary>
            __m256i _mm256_shufflelo_epi16 (__m256i a, const int imm8) VPSHUFLW ymm, ymm/m256, imm8
            </summary>
            <param name="src">The source vector</param>
            <param name="spec">The permutation spec</param>
        </member>
        <member name="M:Z0.z.vpermlo4x16(System.Runtime.Intrinsics.Vector256{System.UInt16},Z0.Perm4L)">
            <summary>
            __m256i _mm256_shufflelo_epi16 (__m256i a, const int imm8) VPSHUFLW ymm, ymm/m256,imm8
            </summary>
            <param name="src">The source vector</param>
            <param name="spec">The permutation spec</param>
        </member>
        <member name="M:Z0.z.vread``1(System.Runtime.Intrinsics.Vector128{System.Byte}@)">
            <summary>
            Presents a readonly reference to 128-bit vector as a readonly T-reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target reference type</typeparam>
        </member>
        <member name="M:Z0.z.vread``1(System.Runtime.Intrinsics.Vector128{System.SByte}@)">
            <summary>
            Presents a readonly reference to 128-bit vector as a readonly T-reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target reference type</typeparam>
        </member>
        <member name="M:Z0.z.vread``1(System.Runtime.Intrinsics.Vector128{System.Int16}@)">
            <summary>
            Presents a readonly reference to 128-bit vector as a readonly T-reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target reference type</typeparam>
        </member>
        <member name="M:Z0.z.vread``1(System.Runtime.Intrinsics.Vector128{System.UInt16}@)">
            <summary>
            Presents a readonly reference to 128-bit vector as a readonly T-reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target reference type</typeparam>
        </member>
        <member name="M:Z0.z.vread``1(System.Runtime.Intrinsics.Vector128{System.Int32}@)">
            <summary>
            Presents a readonly reference to 128-bit vector as a readonly T-reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target reference type</typeparam>
        </member>
        <member name="M:Z0.z.vread``1(System.Runtime.Intrinsics.Vector128{System.UInt32}@)">
            <summary>
            Presents a readonly reference to 128-bit vector as a readonly T-reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target reference type</typeparam>
        </member>
        <member name="M:Z0.z.vread``1(System.Runtime.Intrinsics.Vector128{System.Int64}@)">
            <summary>
            Presents a readonly reference to 128-bit vector as a readonly T-reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target reference type</typeparam>
        </member>
        <member name="M:Z0.z.vread``1(System.Runtime.Intrinsics.Vector128{System.UInt64}@)">
            <summary>
            Presents a readonly reference to 128-bit vector as a readonly T-reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target reference type</typeparam>
        </member>
        <member name="M:Z0.z.vread``1(System.Runtime.Intrinsics.Vector128{System.Single}@)">
            <summary>
            Presents a readonly reference to 128-bit vector as a readonly T-reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target reference type</typeparam>
        </member>
        <member name="M:Z0.z.vread``1(System.Runtime.Intrinsics.Vector128{System.Double}@)">
            <summary>
            Presents a readonly reference to 128-bit vector as a readonly T-reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target reference type</typeparam>
        </member>
        <member name="M:Z0.z.vread``1(System.Runtime.Intrinsics.Vector256{System.Byte}@)">
            <summary>
            Presents a readonly reference to 256-bit vector as a readonly T-reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target reference type</typeparam>
        </member>
        <member name="M:Z0.z.vread``1(System.Runtime.Intrinsics.Vector256{System.SByte}@)">
            <summary>
            Presents a readonly reference to 256-bit vector as a readonly T-reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target reference type</typeparam>
        </member>
        <member name="M:Z0.z.vread``1(System.Runtime.Intrinsics.Vector256{System.Int16}@)">
            <summary>
            Presents a readonly reference to 256-bit vector as a readonly T-reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target reference type</typeparam>
        </member>
        <member name="M:Z0.z.vread``1(System.Runtime.Intrinsics.Vector256{System.UInt16}@)">
            <summary>
            Presents a readonly reference to 256-bit vector as a readonly T-reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target reference type</typeparam>
        </member>
        <member name="M:Z0.z.vread``1(System.Runtime.Intrinsics.Vector256{System.Int32}@)">
            <summary>
            Presents a readonly reference to 256-bit vector as a readonly T-reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target reference type</typeparam>
        </member>
        <member name="M:Z0.z.vread``1(System.Runtime.Intrinsics.Vector256{System.UInt32}@)">
            <summary>
            Presents a readonly reference to 256-bit vector as a readonly T-reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target reference type</typeparam>
        </member>
        <member name="M:Z0.z.vread``1(System.Runtime.Intrinsics.Vector256{System.Int64}@)">
            <summary>
            Presents a readonly reference to 256-bit vector as a readonly T-reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target reference type</typeparam>
        </member>
        <member name="M:Z0.z.vread``1(System.Runtime.Intrinsics.Vector256{System.UInt64}@)">
            <summary>
            Presents a readonly reference to 256-bit vector as a readonly T-reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target reference type</typeparam>
        </member>
        <member name="M:Z0.z.vread``1(System.Runtime.Intrinsics.Vector256{System.Single}@)">
            <summary>
            Presents a readonly reference to 256-bit vector as a readonly T-reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target reference type</typeparam>
        </member>
        <member name="M:Z0.z.vread``1(System.Runtime.Intrinsics.Vector256{System.Double}@)">
            <summary>
            Presents a readonly reference to 256-bit vector as a readonly T-reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target reference type</typeparam>
        </member>
        <member name="M:Z0.z.vread``1(Z0.Vector512{System.Byte}@)">
            <summary>
            Presents a readonly reference to 512-bit vector as a readonly T-reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target reference type</typeparam>
        </member>
        <member name="M:Z0.z.vread``1(Z0.Vector512{System.SByte}@)">
            <summary>
            Presents a readonly reference to 512-bit vector as a readonly T-reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target reference type</typeparam>
        </member>
        <member name="M:Z0.z.vread``1(Z0.Vector512{System.Int16}@)">
            <summary>
            Presents a readonly reference to 512-bit vector as a readonly T-reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target reference type</typeparam>
        </member>
        <member name="M:Z0.z.vread``1(Z0.Vector512{System.UInt16}@)">
            <summary>
            Presents a readonly reference to 512-bit vector as a readonly T-reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target reference type</typeparam>
        </member>
        <member name="M:Z0.z.vread``1(Z0.Vector512{System.Int32}@)">
            <summary>
            Presents a readonly reference to 512-bit vector as a readonly T-reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target reference type</typeparam>
        </member>
        <member name="M:Z0.z.vread``1(Z0.Vector512{System.UInt32}@)">
            <summary>
            Presents a readonly reference to 512-bit vector as a readonly T-reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target reference type</typeparam>
        </member>
        <member name="M:Z0.z.vread``1(Z0.Vector512{System.Int64}@)">
            <summary>
            Presents a readonly reference to 512-bit vector as a readonly T-reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target reference type</typeparam>
        </member>
        <member name="M:Z0.z.vread``1(Z0.Vector512{System.UInt64}@)">
            <summary>
            Presents a readonly reference to 512-bit vector as a readonly T-reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target reference type</typeparam>
        </member>
        <member name="M:Z0.z.vread``1(Z0.Vector512{System.Single}@)">
            <summary>
            Presents a readonly reference to 512-bit vector as a readonly T-reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target reference type</typeparam>
        </member>
        <member name="M:Z0.z.vread``1(Z0.Vector512{System.Double}@)">
            <summary>
            Presents a readonly reference to 512-bit vector as a readonly T-reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target reference type</typeparam>
        </member>
        <member name="M:Z0.z.vread``1(System.Runtime.Intrinsics.Vector128{``0}@)">
            <summary>
            Returns a readonly reference to the leading component of the source
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.z.vread``1(System.Runtime.Intrinsics.Vector256{``0}@)">
            <summary>
            Returns a readonly reference to the leading component of the source
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.z.vread``1(Z0.Vector512{``0}@)">
            <summary>
            Returns a readonly reference to the leading component of the source
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.z.vread``2(System.Runtime.Intrinsics.Vector128{``0}@)">
            <summary>
            Presents a readonly reference to 128-bit S-vector as a readonly T-reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="S">The vector cell type</typeparam>
            <typeparam name="T">The target cell type</typeparam>
        </member>
        <member name="M:Z0.z.vread``2(System.Runtime.Intrinsics.Vector256{``0}@)">
            <summary>
            Presents a readonly reference to 256-bit S-vector as a readonly T-reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="S">The vector cell type</typeparam>
            <typeparam name="T">The target cell type</typeparam>
        </member>
        <member name="M:Z0.z.vread``2(Z0.Vector512{``0}@)">
            <summary>
            Presents a readonly reference to 512-bit S-vector as a readonly T-reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="S">The vector cell type</typeparam>
            <typeparam name="T">The target cell type</typeparam>
        </member>
        <member name="M:Z0.z.vref``1(System.Runtime.Intrinsics.Vector128{``0}@)">
            <summary>
            Returns a reference to the leading component of the source
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.z.vref``1(System.Runtime.Intrinsics.Vector256{``0}@)">
            <summary>
            Returns a reference to the leading component of the source
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.z.vref``1(Z0.Vector512{``0}@)">
            <summary>
            Returns a reference to the leading component of the source
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.z.vreverse(System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            Reverses the source vector components
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vreverse(System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            Reverses the source vector components
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vreverse(System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            Reverses the source vector components
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vreverse(System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            Reverses the source vector components
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vreverse(System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            Reverses the source vector components
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vreverse(System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            Reverses the source vector components
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vreverse(System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            Reverses the source vector components
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vreverse(System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            Reverses the source vector components
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vreverse(System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            Reverses the source vector components
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vreverse(System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            Reverses the source vector components
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vreverse(System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            Reverses the source vector components
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vreverse(System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            Reverses the source vector components
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vreverse(System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            Reverses the source vector components
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vreverse(System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            Reverses the source vector components
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vreverse(System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            Reverses the source vector components
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vrotl(System.Runtime.Intrinsics.Vector128{System.Byte},System.Byte)">
            <summary>
            Rotates each component the source vector leftwards by a specified bitcount
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The magnitude of the rotation</param>
        </member>
        <member name="M:Z0.z.vrotl(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Byte)">
            <summary>
            Rotates each component the source vector leftwards by a specified bitcount
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The magnitude of the rotation</param>
        </member>
        <member name="M:Z0.z.vrotl(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Byte)">
            <summary>
            Rotates each component the source vector leftwards by a specified bitcount
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The magnitude of the rotation</param>
        </member>
        <member name="M:Z0.z.vrotl(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Byte)">
            <summary>
            Rotates each component the source vector leftwards by a specified bitcount
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The magnitude of the rotation</param>
        </member>
        <member name="M:Z0.z.vrotl(System.Runtime.Intrinsics.Vector256{System.Byte},System.Byte)">
            <summary>
            Rotates each component the source vector leftwards by a specified bitcount
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The magnitude of the rotation</param>
        </member>
        <member name="M:Z0.z.vrotl(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Byte)">
            <summary>
            Rotates each component the source vector leftwards by a specified bitcount
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The magnitude of the rotation</param>
        </member>
        <member name="M:Z0.z.vrotl(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Byte)">
            <summary>
            Rotates each component the source vector leftwards by a specified bitcount
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The magnitude of the rotation</param>
        </member>
        <member name="M:Z0.z.vrotl(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Byte)">
            <summary>
            Rotates each component the source vector leftwards by a specified bitcount
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The magnitude of the rotation</param>
        </member>
        <member name="M:Z0.z.vrotlv(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            Rotates each component the source vector leftwards by the corresponding component in the shift spec
            </summary>
            <param name="src">The source vector</param>
            <param name="counts">The variable shift spec</param>
        </member>
        <member name="M:Z0.z.vrotlv(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            Rotates each component the source vector leftwards by the corresponding component in the shift spec
            </summary>
            <param name="src">The source vector</param>
            <param name="counts">The variable shift spec</param>
        </member>
        <member name="M:Z0.z.vrotlv(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            Rotates each component the source vector leftwards by the corresponding component in the shift spec
            </summary>
            <param name="src">The source vector</param>
            <param name="counts">The variable shift spec</param>
        </member>
        <member name="M:Z0.z.vrotlv(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            Rotates each component the source vector leftwards by the corresponding component in the shift spec
            </summary>
            <param name="src">The source vector</param>
            <param name="counts">The variable shift spec</param>
        </member>
        <member name="M:Z0.z.vrotlx(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Byte)">
            <summary>
            Rotates the full 128 bits of a vector leftward a bit-level resolution
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The number of bits to rotate</param>
        </member>
        <member name="M:Z0.z.vrotlx(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Byte)">
            <summary>
            Rotates each 128 lane leftward a bit-level resolution
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The number of bits to rotate</param>
        </member>
        <member name="P:Z0.z.RotL8_128x8u">
            <summary>
            Shuffle pattern that, when applied, rotates 128 bits of content leftward by 8 bits
            </summary>
        </member>
        <member name="P:Z0.z.RotL16_128x8u">
            <summary>
            Shuffle pattern that, when applied, rotates 128 bits of content leftward by 16 bits
            </summary>
        </member>
        <member name="P:Z0.z.RotL24_128x8u">
            <summary>
            Shuffle pattern that, when applied, rotates 128 bits of content leftward by 24 bits
            </summary>
        </member>
        <member name="P:Z0.z.RotL32_128x8u">
            <summary>
            Shuffle pattern that, when applied, rotates 128 bits of content leftward by 32 bits
            </summary>
        </member>
        <member name="P:Z0.z.RotL40_128x8u">
            <summary>
            Shuffle pattern that, when applied, rotates 128 bits of content leftward by 40 bits
            </summary>
        </member>
        <member name="P:Z0.z.RotL48_128x8u">
            <summary>
            Shuffle pattern that, when applied, rotates 128 bits of content leftward by 40 bits
            </summary>
        </member>
        <member name="M:Z0.z.vrotr(System.Runtime.Intrinsics.Vector128{System.Byte},System.Byte)">
            <summary>
            Rotates each component the source vector rightwards by a constant count
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The magnitude of the rotation</param>
        </member>
        <member name="M:Z0.z.vrotr(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Byte)">
            <summary>
            Rotates each component the source vector rightwards by a constant count
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The magnitude of the rotation</param>
        </member>
        <member name="M:Z0.z.vrotr(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Byte)">
            <summary>
            Rotates each component the source vector rightwards by a constant count
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The magnitude of the rotation</param>
        </member>
        <member name="M:Z0.z.vrotr(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Byte)">
            <summary>
            Rotates each component the source vector rightwards by a constant count
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The magnitude of the rotation</param>
        </member>
        <member name="M:Z0.z.vrotr(System.Runtime.Intrinsics.Vector256{System.Byte},System.Byte)">
            <summary>
            Rotates each component the source vector rightwards by a specified count
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The magnitude of the rotation</param>
        </member>
        <member name="M:Z0.z.vrotr(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Byte)">
            <summary>
            Rotates each component the source vector rightwards by a specified count
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The magnitude of the rotation</param>
        </member>
        <member name="M:Z0.z.vrotr(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Byte)">
            <summary>
            Rotates each component the source vector rightwards by a constant count
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The magnitude of the rotation</param>
        </member>
        <member name="M:Z0.z.vrotr(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Byte)">
            <summary>
            Rotates each component the source vector rightwards by a constant count
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The magnitude of the rotation</param>
        </member>
        <member name="M:Z0.z.vrotrv(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            Rotates each component the source vector rightwards by the corresponding component in the shift spec
            </summary>
            <param name="src">The source vector</param>
            <param name="counts">The variable shift spec</param>
        </member>
        <member name="M:Z0.z.vrotrv(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            Rotates each component the source vector rightwards by the corresponding component in the shift spec
            </summary>
            <param name="src">The source vector</param>
            <param name="counts">The variable shift spec</param>
        </member>
        <member name="M:Z0.z.vrotrv(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            Rotates each component the source vector rightwards by the corresponding component in the shift spec
            </summary>
            <param name="src">The source vector</param>
            <param name="counts">The variable shift spec</param>
        </member>
        <member name="M:Z0.z.vrotrv(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            Rotates each component the source vector rightwards by the corresponding component in the shift spec
            </summary>
            <param name="src">The source vector</param>
            <param name="counts">The variable shift spec</param>
        </member>
        <member name="M:Z0.z.vrotrx(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Byte)">
            <summary>
            Rotates the full 128 bits of a vector rightward a bit-level resolution
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The number of bits to rotate</param>
        </member>
        <member name="M:Z0.z.vrotrx(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Byte)">
            <summary>
            Rotates each 128 bit lane rightward a bit-level resolution
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The number of bits to rotate</param>
        </member>
        <member name="M:Z0.z.vrotlx(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.N8)">
            <summary>
            Rotates the full 128-bit vector content leftward by 8 bits
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The count selector</param>
        </member>
        <member name="M:Z0.z.vrotlx(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.N16)">
            <summary>
            Rotates the full 128-bit vector content leftward by 16 bits
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The count selector</param>
        </member>
        <member name="M:Z0.z.vrotlx(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.N24)">
            <summary>
            Rotates the full 128-bit vector content leftward by 24 bits
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The count selector</param>
        </member>
        <member name="M:Z0.z.vrotlx(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.N32)">
            <summary>
            Rotates the full 128-bit vector content leftward by 32 bits
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The count selector</param>
        </member>
        <member name="M:Z0.z.vrotrx(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.N8)">
            <summary>
            Rotates the full 128-bit vector content rightward by 8 bits
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The count selector</param>
        </member>
        <member name="M:Z0.z.vrotrx(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.N16)">
            <summary>
            Rotates the full 128-bit vector content rightward by 16 bits
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The count selector</param>
        </member>
        <member name="M:Z0.z.vrotrx(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.N24)">
            <summary>
            Rotates the full 128-bit vector content rightward by 24 bits
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The count selector</param>
        </member>
        <member name="M:Z0.z.vrotrx(System.Runtime.Intrinsics.Vector128{System.Byte},Z0.N32)">
            <summary>
            Rotates the full 128-bit vector content rightward by 32 bits
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The count selector</param>
        </member>
        <member name="M:Z0.z.vsad(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
             __m128i _mm_sad_epu8 (__m128i a, __m128i b) PSADBW xmm, xmm/m128
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
        </member>
        <member name="M:Z0.z.vsad(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_sad_epu8 (__m256i a, __m256i b) VPSADBW ymm, ymm, ymm/m256
            Computes the absolute differences of packed unsigned 8-bit integers in a and b,
            then horizontally sums each consecutive 8 differences to produce four
            unsigned 16-bit integers, and pack these unsigned 16-bit integers in the low
            16 bits of 64-bit elements in dst.
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
        </member>
        <member name="M:Z0.z.vsave(System.Runtime.Intrinsics.Vector128{System.SByte},System.SByte@)">
            <summary>
            Stores vector content to a memory location
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vsave(System.Runtime.Intrinsics.Vector128{System.Byte},System.Byte@)">
            <summary>
            Stores vector content to a memory location
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vsave(System.Runtime.Intrinsics.Vector128{System.Int16},System.Int16@)">
            <summary>
            Stores vector content to a memory location
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vsave(System.Runtime.Intrinsics.Vector128{System.UInt16},System.UInt16@)">
            <summary>
            Stores vector content to a memory location
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vsave(System.Runtime.Intrinsics.Vector128{System.Int32},System.Int32@)">
            <summary>
            Stores vector content to a memory location
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vsave(System.Runtime.Intrinsics.Vector128{System.UInt32},System.UInt32@)">
            <summary>
            Stores vector content to a memory location
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vsave(System.Runtime.Intrinsics.Vector128{System.Int64},System.Int64@)">
            <summary>
            Stores vector content to a memory location
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vsave(System.Runtime.Intrinsics.Vector128{System.UInt64},System.UInt64@)">
            <summary>
            Stores vector content to a memory location
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vsave(System.Runtime.Intrinsics.Vector128{System.Single},System.Single@)">
            <summary>
            Stores vector content to a memory location
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vsave(System.Runtime.Intrinsics.Vector128{System.Double},System.Double@)">
            <summary>
            Stores vector content to a memory location
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vsave(System.Runtime.Intrinsics.Vector256{System.SByte},System.SByte@)">
            <summary>
            Stores vector content to a memory location
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vsave(System.Runtime.Intrinsics.Vector256{System.Byte},System.Byte@)">
            <summary>
            Stores vector content to a memory location
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vstore(System.Runtime.Intrinsics.Vector256{System.Int16},System.Int16@)">
            <summary>
            Stores vector content to a memory location
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vsave(System.Runtime.Intrinsics.Vector256{System.UInt16},System.UInt16@)">
            <summary>
            Stores vector content to a memory location
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vstore(System.Runtime.Intrinsics.Vector256{System.Int32},System.Int32@)">
            <summary>
            Stores vector content to a memory location
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vstore(System.Runtime.Intrinsics.Vector256{System.UInt32},System.UInt32@)">
             <summary>
             Stores vector content to a memory location
             </summary>
             <param name="src">The source vector</param>
             <param name="dst">The target memory</param>
            <intrinsic>void _mm256_storeu_si256 (__m256i * mem_addr, __m256i a) MOVDQU m256, ymm</intrinsic>
        </member>
        <member name="M:Z0.z.vstore(System.Runtime.Intrinsics.Vector256{System.Int64},System.Int64@)">
             <summary>
             Stores vector content to a memory location
             </summary>
             <param name="src">The source vector</param>
             <param name="dst">The target memory</param>
            <intrinsic>void _mm256_storeu_si256 (__m256i * mem_addr, __m256i a) MOVDQU m256, ymm</intrinsic>
        </member>
        <member name="M:Z0.z.vstore(System.Runtime.Intrinsics.Vector256{System.UInt64},System.UInt64@)">
             <summary>
             Stores vector content to a memory location
             </summary>
             <param name="src">The source vector</param>
             <param name="dst">The target memory</param>
            <intrinsic>void _mm256_storeu_si256 (__m256i * mem_addr, __m256i a) MOVDQU m256, ymm</intrinsic>
        </member>
        <member name="M:Z0.z.vstore(System.Runtime.Intrinsics.Vector256{System.Single},System.Single@)">
             <summary>
             Stores vector content to a memory location
             </summary>
             <param name="src">The source vector</param>
             <param name="dst">The target memory</param>
            <intrinsic>void _mm256_storeu_ps (float * mem_addr, __m256 a) MOVUPS m256, ymm</intrinsic>
        </member>
        <member name="M:Z0.z.vstore(System.Runtime.Intrinsics.Vector256{System.Double},System.Double@)">
             <summary>
             Stores vector content to a memory location
             </summary>
             <param name="src">The source vector</param>
             <param name="dst">The target memory</param>
            <intrinsic>void _mm256_storeu_pd (double * mem_addr, __m256d a) MOVUPD m256, ymm</intrinsic>
        </member>
        <member name="M:Z0.z.vsave(System.Runtime.Intrinsics.Vector128{System.SByte},System.SByte@,System.Int32)">
            <summary>
            Stores vector content to a memory location
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vstore(System.Runtime.Intrinsics.Vector128{System.Byte},System.Byte@,System.Int32)">
            <summary>
            Stores vector content to a memory location
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vsave(System.Runtime.Intrinsics.Vector128{System.Int16},System.Int16@,System.Int32)">
            <summary>
            Stores vector content to a memory location
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vsave(System.Runtime.Intrinsics.Vector128{System.UInt16},System.UInt16@,System.Int32)">
            <summary>
            Stores vector content to a memory location
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vsave(System.Runtime.Intrinsics.Vector128{System.Int32},System.Int32@,System.Int32)">
            <summary>
            Stores vector content to a memory location
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vstore(System.Runtime.Intrinsics.Vector128{System.UInt32},System.UInt32@,System.Int32)">
            <summary>
            Stores vector content to a memory location
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vsave(System.Runtime.Intrinsics.Vector128{System.Int64},System.Int64@,System.Int32)">
            <summary>
            Stores vector content to a memory location
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vstore(System.Runtime.Intrinsics.Vector128{System.UInt64},System.UInt64@,System.Int32)">
            <summary>
            Stores vector content to a memory location
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vsave(System.Runtime.Intrinsics.Vector128{System.Single},System.Single@,System.Int32)">
            <summary>
            Stores vector content to a memory location
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vsave(System.Runtime.Intrinsics.Vector128{System.Double},System.Double@,System.Int32)">
            <summary>
            Stores vector content to a memory location
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vsave(System.Runtime.Intrinsics.Vector256{System.SByte},System.SByte@,System.Int32)">
            <summary>
            Stores vector content to a memory location
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vsave(System.Runtime.Intrinsics.Vector256{System.Byte},System.Byte@,System.Int32)">
            <summary>
            Stores vector content to a memory location
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vsave(System.Runtime.Intrinsics.Vector256{System.Int16},System.Int16@,System.Int32)">
            <summary>
            Stores vector content to a memory location
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vsave(System.Runtime.Intrinsics.Vector256{System.UInt16},System.UInt16@,System.Int32)">
            <summary>
            Stores vector content to a memory location
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vsave(System.Runtime.Intrinsics.Vector256{System.Int32},System.Int32@,System.Int32)">
            <summary>
            Stores vector content to a memory location
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.z.vsave(System.Runtime.Intrinsics.Vector256{System.UInt32},System.UInt32@,System.Int32)">
             <summary>
             Stores vector content to a memory location
             </summary>
             <param name="src">The source vector</param>
             <param name="dst">The target memory</param>
            <intrinsic>void _mm256_storeu_si256 (__m256i * mem_addr, __m256i a) MOVDQU m256, ymm</intrinsic>
        </member>
        <member name="M:Z0.z.vsave(System.Runtime.Intrinsics.Vector256{System.Int64},System.Int64@,System.Int32)">
             <summary>
             Stores vector content to a memory location
             </summary>
             <param name="src">The source vector</param>
             <param name="dst">The target memory</param>
            <intrinsic>void _mm256_storeu_si256 (__m256i * mem_addr, __m256i a) MOVDQU m256, ymm</intrinsic>
        </member>
        <member name="M:Z0.z.vsave(System.Runtime.Intrinsics.Vector256{System.UInt64},System.UInt64@,System.Int32)">
             <summary>
             Stores vector content to a memory location
             </summary>
             <param name="src">The source vector</param>
             <param name="dst">The target memory</param>
            <intrinsic>void _mm256_storeu_si256 (__m256i * mem_addr, __m256i a) MOVDQU m256, ymm</intrinsic>
        </member>
        <member name="M:Z0.z.vsave(System.Runtime.Intrinsics.Vector256{System.Single},System.Single@,System.Int32)">
             <summary>
             Stores vector content to a memory location
             </summary>
             <param name="src">The source vector</param>
             <param name="dst">The target memory</param>
            <intrinsic>void _mm256_storeu_ps (float * mem_addr, __m256 a) MOVUPS m256, ymm</intrinsic>
        </member>
        <member name="M:Z0.z.vsave(System.Runtime.Intrinsics.Vector256{System.Double},System.Double@,System.Int32)">
             <summary>
             Stores vector content to a memory location
             </summary>
             <param name="src">The source vector</param>
             <param name="dst">The target memory</param>
            <intrinsic>void _mm256_storeu_pd (double * mem_addr, __m256d a) MOVUPD m256, ymm</intrinsic>
        </member>
        <member name="M:Z0.z.vsave``1(System.Runtime.Intrinsics.Vector128{``0},``0@,System.Int32)">
            <summary>
            Stores the source vector to a reference cell
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target reference</param>
            <param name="offset">The target offset</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.z.vsave``1(System.Runtime.Intrinsics.Vector256{``0},``0@,System.Int32)">
            <summary>
            Stores the source vector to a reference cell
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target reference</param>
            <param name="offset">The target offset</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.z.vsave``1(System.Runtime.Intrinsics.Vector128{``0},System.Span{``0})">
            <summary>
            Stores vector content to the front of a span
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target block</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vsave``1(System.Runtime.Intrinsics.Vector256{``0},System.Span{``0})">
            <summary>
            Stores vector content to the front of a span
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target block</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vsave``1(System.Runtime.Intrinsics.Vector128{``0},System.Span{``0},System.Int32)">
            <summary>
            Stores vector content to a span
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target block</param>
            <param name="offset">The target offset at which storage should begin</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vsave``1(System.Runtime.Intrinsics.Vector256{``0},System.Span{``0},System.Int32)">
            <summary>
            Stores vector content to a span
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target block</param>
            <param name="offset">The target offset at which storage should begin</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vsave``1(Z0.Vector512{``0},System.Span{``0},System.Int32)">
            <summary>
            Stores vector content to a span
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target block</param>
            <param name="offset">The target offset at which storage should begin</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vscalar(Z0.W128,System.SByte)">
            <summary>
            Loads a scalar into the first component of a 128-bit vector
            </summary>
            <param name="a">The scalar to load</param>
        </member>
        <member name="M:Z0.z.vscalar(Z0.W128,System.Byte)">
            <summary>
            Loads a scalar into the first component of a 128-bit vector
            </summary>
            <param name="a">The scalar to load</param>
        </member>
        <member name="M:Z0.z.vscalar(Z0.W128,System.Int16)">
            <summary>
            Loads a scalar into the first component of a 128-bit vector
            </summary>
            <param name="a">The scalar to load</param>
        </member>
        <member name="M:Z0.z.vscalar(Z0.W128,System.UInt16)">
            <summary>
            Loads a scalar into the first component of a 128-bit vector
            </summary>
            <param name="a">The scalar to load</param>
        </member>
        <member name="M:Z0.z.vscalar(Z0.W128,System.Int32)">
            <summary>
            Loads a scalar into the first component of a 128-bit vector
            </summary>
            <param name="a">The source value</param>
        </member>
        <member name="M:Z0.z.vscalar(Z0.W128,System.UInt32)">
            <summary>
            Loads a scalar into the first component of a 128-bit vector
            </summary>
            <param name="a">The source value</param>
        </member>
        <member name="M:Z0.z.vscalar(Z0.W128,System.Int64)">
            <summary>
            Loads a scalar into the first component of a 128-bit vector
            </summary>
            <param name="a">The source value</param>
        </member>
        <member name="M:Z0.z.vscalar(Z0.W128,System.UInt64)">
            <summary>
            Loads a scalar into the first component of a 128-bit vector
            </summary>
            <param name="a">The source value</param>
        </member>
        <member name="M:Z0.z.vscalar(Z0.W128,System.Single)">
            <summary>
            Loads a scalar into the first component of a 256-bit vector
            </summary>
            <param name="a">The source value</param>
        </member>
        <member name="M:Z0.z.vscalar(Z0.W128,System.Double)">
            <summary>
            Loads a scalar into the first component of a 256-bit vector
            </summary>
            <param name="a">The source value</param>
        </member>
        <member name="M:Z0.z.vscalar(Z0.W256,System.SByte)">
            <summary>
            Loads a scalar into the first component of a 128-bit vector
            </summary>
            <param name="a">The scalar to load</param>
        </member>
        <member name="M:Z0.z.vscalar(Z0.W256,System.Byte)">
            <summary>
            Loads a scalar into the first component of a 256-bit vector
            </summary>
            <param name="a">The scalar to load</param>
        </member>
        <member name="M:Z0.z.vscalar(Z0.W256,System.Int16)">
            <summary>
            Loads a scalar into the first component of a 256-bit vector
            </summary>
            <param name="a">The scalar to load</param>
        </member>
        <member name="M:Z0.z.vscalar(Z0.W256,System.UInt16)">
            <summary>
            Loads a scalar into the first component of a 256-bit vector
            </summary>
            <param name="a">The scalar to load</param>
        </member>
        <member name="M:Z0.z.vscalar(Z0.W256,System.Int32)">
            <summary>
            Loads a scalar into the first component of a 256-bit vector
            </summary>
            <param name="a">The source value</param>
        </member>
        <member name="M:Z0.z.vscalar(Z0.W256,System.UInt32)">
            <summary>
            Loads a scalar into the first component of a 256-bit vector
            </summary>
            <param name="a">The source value</param>
        </member>
        <member name="M:Z0.z.vscalar(Z0.W256,System.Int64)">
            <summary>
            Loads a scalar into the first component of a 256-bit vector
            </summary>
            <param name="a">The source value</param>
        </member>
        <member name="M:Z0.z.vscalar(Z0.W256,System.UInt64)">
            <summary>
            Loads a scalar into the first component of a 256-bit vector
            </summary>
            <param name="a">The source value</param>
        </member>
        <member name="M:Z0.z.vscalar(Z0.W256,System.Single)">
            <summary>
            Loads a scalar into the first component of a 256-bit vector
            </summary>
            <param name="a">The source value</param>
        </member>
        <member name="M:Z0.z.vscalar(Z0.W256,System.Double)">
            <summary>
            Loads a scalar into the first component of a 256-bit vector
            </summary>
            <param name="a">The source value</param>
        </member>
        <member name="M:Z0.z.vscalar``1(Z0.W128,``0)">
            <summary>
            Loads a scalar into the first component of a 128-bit vector
            </summary>
            <param name="w">The width of the target vector</param>
            <param name="a">The scalar to load</param>
        </member>
        <member name="M:Z0.z.vscalar``1(Z0.W256,``0)">
            <summary>
            Loads a scalar into the first component of a 256-bit vector
            </summary>
            <param name="a">The scalar to load</param>
        </member>
        <member name="M:Z0.z.vshi(System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            Creates a scalar vector from the upper 64 bits of the source vector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vshi(System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            Creates a scalar vector from the upper 64 bits of the source vector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vshi(System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            Creates a scalar vector from the upper 64 bits of the source vector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vshi(System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            Creates a scalar vector from the upper 64 bits of the source vector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vshi(System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            Creates a scalar vector from the upper 64 bits of the source vector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vshi(System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            Creates a scalar vector from the upper 64 bits of the source vector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vshi(System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            Creates a scalar vector from the upper 64 bits of the source vector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vshi(System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            Creates a scalar vector from the upper 64 bits of the source vector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vshuf16x8(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_shuffle_epi8 (__m128i a, __m128i b) PSHUFB xmm, xmm/m128
            Shuffles source vector components within 128-bit lanes as specified by the corresponding component in the shuffle spec
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshuf16x8(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_shuffle_epi8 (__m128i a, __m128i b) PSHUFB xmm, xmm/m128
            For each component of the shuffle spec: 
            testbit(spec[i],7) == 1 => dst[i] = 0
            testbit(spec[i],7) == 0 => dst[i] = src[i]
            spec[i] = j := 0 | 1 | ... | 15 => dst[j] = src[i]
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshuf16x8(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_shuffle_epi8 (__m128i a, __m128i b) PSHUFB xmm, xmm/m128
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshuf16x8(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_shuffle_epi8 (__m128i a, __m128i b) PSHUFB xmm, xmm/m128
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshuf16x8(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_shuffle_epi8 (__m128i a, __m128i b) PSHUFB xmm, xmm/m128
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshuf16x8(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_shuffle_epi8 (__m128i a, __m128i b) PSHUFB xmm, xmm/m128
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshuf16x8(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_shuffle_epi8 (__m128i a, __m128i b) PSHUFB xmm, xmm/m128
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshuf16x8(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_shuffle_epi8 (__m128i a, __m128i b) PSHUFB xmm, xmm/m128
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshuf16x8(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            __m256i _mm256_shuffle_epi8 (__m256i a, __m256i b) VPSHUFB ymm, ymm, ymm/m256
            Shuffles source vector components within 128-bit lanes as specified by the corresponding component in the shuffle spec
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshuf16x8(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
             __m256i _mm256_shuffle_epi8 (__m256i a, __m256i b) VPSHUFB ymm, ymm, ymm/m256
             Shuffles source vector components within 128-bit lanes as specified by the corresponding component in the shuffle spec
            </summary>
             <param name="src">The content vector</param>
             <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshuf16x8(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
             __m256i _mm256_shuffle_epi8 (__m256i a, __m256i b) VPSHUFB ymm, ymm, ymm/m256
             Shuffles source vector components within 128-bit lanes as specified by the corresponding component in the shuffle spec
            </summary>
             <param name="src">The content vector</param>
             <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshuf16x8(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
             __m256i _mm256_shuffle_epi8 (__m256i a, __m256i b) VPSHUFB ymm, ymm, ymm/m256
             Shuffles source vector components within 128-bit lanes as specified by the corresponding component in the shuffle spec
            </summary>
             <param name="src">The content vector</param>
             <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshuf16x8(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
             __m256i _mm256_shuffle_epi8 (__m256i a, __m256i b) VPSHUFB ymm, ymm, ymm/m256
             Shuffles source vector components within 128-bit lanes as specified by the corresponding component in the shuffle spec
            </summary>
             <param name="src">The content vector</param>
             <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshuf16x8(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
             __m256i _mm256_shuffle_epi8 (__m256i a, __m256i b) VPSHUFB ymm, ymm, ymm/m256
             Shuffles source vector components within 128-bit lanes as specified by the corresponding component in the shuffle spec
            </summary>
             <param name="src">The content vector</param>
             <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshuf16x8(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
             __m256i _mm256_shuffle_epi8 (__m256i a, __m256i b) VPSHUFB ymm, ymm, ymm/m256
             Shuffles source vector components within 128-bit lanes as specified by the corresponding component in the shuffle spec
            </summary>
             <param name="src">The content vector</param>
             <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshuf16x8(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
             __m256i _mm256_shuffle_epi8 (__m256i a, __m256i b) VPSHUFB ymm, ymm, ymm/m256
             Shuffles source vector components within 128-bit lanes as specified by the corresponding component in the shuffle spec
            </summary>
             <param name="src">The content vector</param>
             <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshuf2x64(System.Runtime.Intrinsics.Vector128{System.Int32},System.Byte)">
            <summary>
            __m128i _mm_shuffle_epi32 (__m128i a, int immediate) PSHUFD xmm, xmm/m128, imm8
            </summary>
            <param name="src">The source vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshuf32x8(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            Rearranges the source vector according to the indices specified in the control vector dst[i] = src[spec[i]]
            </summary>
            <param name="src">The source vector</param>
            <param name="spec">The control vector that defines the permutation</param>
            <remarks>Approach follows https://stackoverflow.com/questions/30669556/shuffle-elements-of-m256i-vector/30669632#30669632</remarks>
        </member>
        <member name="M:Z0.z.vshufhi4x16(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Byte)">
            <summary>
            __m128i _mm_shufflehi_epi16 (__m128i a, int immediate) PSHUFHW xmm, xmm/m128, imm8
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshuflo4x16(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Byte)">
            <summary>
            __m128i _mm_shufflelo_epi16 (__m128i a, int control) PSHUFLW xmm, xmm/m128, imm8
            </summary>
        </member>
        <member name="M:Z0.z.vshufhi4x16(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Byte)">
            <summary>
            __m256i _mm256_shufflehi_epi16 (__m256i a, const int imm8)VPSHUFHW ymm, ymm/m256, imm8
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshufhi4x16(System.Runtime.Intrinsics.Vector256{System.Int16},System.Byte)">
            <summary>
            __m256i _mm256_shufflehi_epi16 (__m256i a, const int imm8)VPSHUFHW ymm, ymm/m256, imm8
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshuflo4x16(System.Runtime.Intrinsics.Vector256{System.Int16},System.Byte)">
            <summary>
            __m256i _mm256_shufflelo_epi16 (__m256i a, const int imm8)VPSHUFLW ymm, ymm/m256, imm8
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshuflo4x16(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Byte)">
            <summary>
            __m256i _mm256_shufflelo_epi16 (__m256i a, const int imm8)VPSHUFLW ymm, ymm/m256, imm8
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshufhi4x16(System.Runtime.Intrinsics.Vector128{System.Int16},System.Byte)">
            <summary>
            __m128i _mm_shufflehi_epi16 (__m128i a, int immediate) PSHUFHW xmm, xmm/m128, imm8
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshuflo4x16(System.Runtime.Intrinsics.Vector128{System.Int16},System.Byte)">
            <summary>
            __m128i _mm_shufflelo_epi16 (__m128i a, int control) PSHUFLW xmm, xmm/m128, imm8
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshufhi4x16(System.Runtime.Intrinsics.Vector128{System.Int16},Z0.Arrange4L)">
            <summary>
            __m128i _mm_shufflehi_epi16 (__m128i a, int immediate) PSHUFHW xmm, xmm/m128, imm8
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshufhi4x16(System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.Arrange4L)">
            <summary>
            __m128i _mm_shufflehi_epi16 (__m128i a, int control) PSHUFHW xmm, xmm/m128, imm8
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshuflo4x16(System.Runtime.Intrinsics.Vector128{System.Int16},Z0.Arrange4L)">
            <summary>
            __m128i _mm_shufflelo_epi16 (__m128i a, int control) PSHUFLW xmm, xmm/m128, imm8
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshuflo4x16(System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.Arrange4L)">
            <summary>
            __m128i _mm_shufflelo_epi16 (__m128i a, int control) PSHUFLW xmm, xmm/m128, imm8
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshuf4x16(System.Runtime.Intrinsics.Vector128{System.Int16},Z0.Arrange4L,Z0.Arrange4L)">
            <summary>
            Shuffles the first four elements of the content vector with the lo mask and the last four elements with the hi mask
            </summary>
            <param name="src">The content vector</param>
            <param name="lo">The lo mask</param>
            <param name="hi">The hi mask</param>
        </member>
        <member name="M:Z0.z.vshuf4x16(System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.Arrange4L,Z0.Arrange4L)">
            <summary>
            Shuffles the first four elements of the content vector with the lo mask and the last four elements with the hi mask
            </summary>
            <param name="src">The content vector</param>
            <param name="lo">The lo mask</param>
            <param name="hi">The hi mask</param>
        </member>
        <member name="M:Z0.z.vshufhi4x16(System.Runtime.Intrinsics.Vector256{System.UInt16},Z0.Arrange4L)">
            <summary>
            __m256i _mm256_shufflehi_epi16 (__m256i a, const int imm8)VPSHUFHW ymm, ymm/m256, imm8
            Shuffles the hi 64 bits of each 128-bit lane as determined by the shuffle spec and leaves
            the lo 64 bits of each 128-bit lane unchanged
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshufhi4x16(System.Runtime.Intrinsics.Vector256{System.Int16},Z0.Arrange4L)">
            <summary>
            __m256i _mm256_shufflehi_epi16 (__m256i a, const int imm8)VPSHUFHW ymm, ymm/m256, imm8
            Shuffles the hi 64 bits of each 128-bit lane as determined by the shuffle spec and leaves
            the lo 64 bits of each 128-bit lane unchanged
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshuflo4x16(System.Runtime.Intrinsics.Vector256{System.Int16},Z0.Arrange4L)">
            <summary>
            __m256i _mm256_shufflelo_epi16 (__m256i a, const int imm8)VPSHUFLW ymm, ymm/m256, imm8
            Shuffles the lo 64 bits of each 128-bit lane as determined by the shuffle spec and leaves
            the hi 64 bits of each 128-bit lane unchanged
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshuflo4x16(System.Runtime.Intrinsics.Vector256{System.UInt16},Z0.Arrange4L)">
            <summary>
            __m256i _mm256_shufflelo_epi16 (__m256i a, const int imm8)VPSHUFLW ymm, ymm/m256, imm8
            Shuffles the lo 64 bits of each 128-bit lane as determined by the shuffle spec and leaves the hi 64 bits of each 128-bit lane unchanged
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshuf4x16(System.Runtime.Intrinsics.Vector256{System.Int16},Z0.Arrange4L,Z0.Arrange4L)">
            <summary>
            Shuffles lo/hi parts of each 128-bit lane as respectively determined by the shuffle specs
            </summary>
            <param name="src">The content vector</param>
            <param name="lo">The lo mask</param>
            <param name="hi">The hi mask</param>
        </member>
        <member name="M:Z0.z.vshuf4x16(System.Runtime.Intrinsics.Vector256{System.UInt16},Z0.Arrange4L,Z0.Arrange4L)">
            <summary>
            Shuffles lo/hi parts of each 128-bit lane as respectively determined by the shuffle specs
            </summary>
            <param name="src">The content vector</param>
            <param name="lo">The lo mask</param>
            <param name="hi">The hi mask</param>
        </member>
        <member name="M:Z0.z.vshuf4x32(System.Runtime.Intrinsics.Vector128{System.Int32},System.Byte)">
            <summary>
            __m128i _mm_shuffle_epi32 (__m128i a, int immediate) PSHUFD xmm, xmm/m128, imm8
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshuf4x32(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Byte)">
            <summary>
            __m128i _mm_shuffle_epi32 (__m128i a, int immediate) PSHUFD xmm, xmm/m128, imm8
            </summary>
            <param name="src">The content vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshuf4x32(System.Runtime.Intrinsics.Vector256{System.Int32},System.Byte)">
            <summary>
             __m256i _mm256_shuffle_epi32 (__m256i a, const int imm8) VPSHUFD ymm, ymm/m256, imm8
             shuffles 32-bit integers in the source vector within 128-bit lanes
             </summary>
             <param name="src">The content vector</param>
             <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshuf4x32(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Byte)">
            <summary>
             __m256i _mm256_shuffle_epi32 (__m256i a, const int imm8) VPSHUFD ymm, ymm/m256, imm8
             shuffles 32-bit integers in the source vector within 128-bit lanes
             </summary>
             <param name="src">The content vector</param>
             <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshuf4x32(System.Runtime.Intrinsics.Vector128{System.Int32},Z0.Arrange4L)">
            <summary>
            __m128i _mm_shuffle_epi32 (__m128i a, int immediate)PSHUFD xmm, xmm/m128, imm8
            </summary>
            <param name="src">The source vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshuf4x32(System.Runtime.Intrinsics.Vector128{System.UInt32},Z0.Arrange4L)">
            <summary>
            __m128i _mm_shuffle_epi32 (__m128i a, int immediate)PSHUFD xmm, xmm/m128, imm8
            </summary>
            <param name="src">The source vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshuf4x32(System.Runtime.Intrinsics.Vector256{System.Int32},Z0.Arrange4L)">
            <summary>
            __m256i _mm256_shuffle_epi32 (__m256i a, const int imm8)VPSHUFD ymm, ymm/m256, imm8
            </summary>
            <param name="src">The source vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vshuf4x32(System.Runtime.Intrinsics.Vector256{System.UInt32},Z0.Arrange4L)">
            <summary>
            __m256i _mm256_shuffle_epi32 (__m256i a, const int imm8)VPSHUFD ymm, ymm/m256, imm8
            </summary>
            <param name="src">The source vector</param>
            <param name="spec">The shuffle spec</param>
        </member>
        <member name="M:Z0.z.vsign(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
             __m128i _mm_sign_epi8 (__m128i a, __m128i b) PSIGNB xmm, xmm/m128
            Negates target vector elements if the corresponding element in the match vector is negative;
            If the corresponding component in the match vector is zero, the target vector component is set to zero
            </summary>
            <param name="dst">The target vector</param>
            <param name="match">The match vector</param>
        </member>
        <member name="M:Z0.z.vsign(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
             __m128i _mm_sign_epi16 (__m128i a, __m128i b) PSIGNW xmm, xmm/m128
            Negates target vector elements if the corresponding element in the match vector is negative;
            If the corresponding component in the match vector is zero, the target vector component is set to zero
            </summary>
            <param name="dst">The target vector</param>
            <param name="match">The match vector</param>
        </member>
        <member name="M:Z0.z.vsign(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
             __m128i _mm_sign_epi32 (__m128i a, __m128i b) PSIGND xmm, xmm/m128
            Negates target vector elements if the corresponding element in the match vector is negative;
            If the corresponding component in the match vector is zero, the target vector component is set to zero
            </summary>
            <param name="dst">The target vector</param>
            <param name="match">The match vector</param>
        </member>
        <member name="M:Z0.z.vsign(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            __m256i _mm256_sign_epi8 (__m256i a, __m256i b) VPSIGNB ymm, ymm, ymm/m256
            Negates target vector elements if the corresponding element in the match vector is negative;
            If the corresponding component in the match vector is zero, the target vector component is set to zero
            </summary>
            <param name="dst">The target vector</param>
            <param name="match">The match vector</param>
        </member>
        <member name="M:Z0.z.vsign(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_sign_epi16 (__m256i a, __m256i b) VPSIGNW ymm, ymm, ymm/m256
            Negates target vector elements if the corresponding element in the match vector is negative;
            If the corresponding component in the match vector is zero, the target vector component is set to zero
            </summary>
            <param name="dst">The target vector</param>
            <param name="match">The match vector</param>
        </member>
        <member name="M:Z0.z.vsign(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_sign_epi32 (__m256i a, __m256i b) VPSIGND ymm, ymm, ymm/m256
            Negates target vector elements if the corresponding element in the match vector is negative;
            If the corresponding component in the match vector is zero, the target vector component is set to zero
            </summary>
            <param name="dst">The target vector</param>
            <param name="match">The match vector</param>
        </member>
        <member name="M:Z0.z.vsll(System.Runtime.Intrinsics.Vector128{System.Byte},System.Byte)">
            <summary>
            Defines the unfortunately missing _mm_slli_epi8 that shifts each vector component leftward by a common number of bits
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The number of bits to count left</param>
        </member>
        <member name="M:Z0.z.vsll(System.Runtime.Intrinsics.Vector128{System.SByte},System.Byte)">
            <summary>
            Shifts each component in the source vector leftwards by a specified number of bits
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The number of bits to count each component</param>
        </member>
        <member name="M:Z0.z.vsll(System.Runtime.Intrinsics.Vector128{System.Int16},System.Byte)">
            <summary>
            __m128i _mm_slli_epi16 (__m128i a, int immediate) PSLLW xmm, imm8
            Shifts each component of the source vector leftwards by a common number of bits
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The number of bits to count</param>
        </member>
        <member name="M:Z0.z.vsll(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Byte)">
            <summary>
            __m128i _mm_slli_epi16 (__m128i a, int immediate) PSLLW xmm, imm8
            Shifts each component of the source vector leftwards by a common number of bits
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The number of bits to count</param>
        </member>
        <member name="M:Z0.z.vsll(System.Runtime.Intrinsics.Vector128{System.Int32},System.Byte)">
            <summary>
            __m128i _mm_slli_epi32 (__m128i a, int immediate) PSLLD xmm, imm8
            Shifts each component of the source vector leftwards by a common number of bits
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The number of bits to count</param>
        </member>
        <member name="M:Z0.z.vsll(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Byte)">
            <summary>
            __m128i _mm_slli_epi32 (__m128i a, int immediate) PSLLD xmm, imm8
            Shifts each component of the source vector leftwards by a common number of bits
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The number of bits to count</param>
        </member>
        <member name="M:Z0.z.vsll(System.Runtime.Intrinsics.Vector128{System.Int64},System.Byte)">
            <summary>
            __m128i _mm_slli_epi64 (__m128i a, int immediate) PSLLQ xmm, imm8
            Shifts each component of the source vector leftwards by a common number of bits
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The number of bits to count</param>
        </member>
        <member name="M:Z0.z.vsll(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Byte)">
            <summary>
            __m128i _mm_slli_epi64 (__m128i a, int immediate) PSLLQ xmm, imm8
            Shifts each component of the source vector leftwards by a common number of bits
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The number of bits to count</param>
        </member>
        <member name="M:Z0.z.vsll(System.Runtime.Intrinsics.Vector256{System.SByte},System.Byte)">
            <summary>
            Shifts each component in the source vector leftwards by a specified number of bits
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The number of bits to count each component</param>
        </member>
        <member name="M:Z0.z.vsll(System.Runtime.Intrinsics.Vector256{System.Byte},System.Byte)">
            <summary>
            Defines the unfortunately missing _mm256_slli_epi16 that shifts each vector component
            leftward by a common number of bits
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The number of bits to count left</param>
        </member>
        <member name="M:Z0.z.vsll(System.Runtime.Intrinsics.Vector256{System.Int16},System.Byte)">
            <summary>
            __m256i _mm256_slli_epi16 (__m256i a, int imm8) VPSLLW ymm, ymm, imm8
            Shifts each component of the source vector leftwards by a common number of bits
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The number of bits to count</param>
        </member>
        <member name="M:Z0.z.vsll(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Byte)">
            <summary>
            __m256i _mm256_slli_epi16 (__m256i a, int imm8) VPSLLW ymm, ymm, imm8
            Shifts each component of the source vector leftwards by a common number of bits
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The number of bits to count</param>
        </member>
        <member name="M:Z0.z.vsll(System.Runtime.Intrinsics.Vector256{System.Int32},System.Byte)">
            <summary>
            __m256i _mm256_slli_epi32 (__m256i a, int imm8) VPSLLD ymm, ymm, imm8
            Shifts each component of the source vector leftwards by a common number of bits
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The number of bits to count</param>
        </member>
        <member name="M:Z0.z.vsll(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Byte)">
            <summary>
            __m256i _mm256_slli_epi32 (__m256i a, int imm8) VPSLLD ymm, ymm, imm8
            Shifts each component of the source vector leftwards by a common number of bits
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The number of bits to count</param>
        </member>
        <member name="M:Z0.z.vsll(System.Runtime.Intrinsics.Vector256{System.Int64},System.Byte)">
            <summary>
            __m256i _mm256_slli_epi64 (__m256i a, int imm8) VPSLLQ ymm, ymm, imm8
            Shifts each component of the source vector leftwards by a common number of bits
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The number of bits to count</param>
        </member>
        <member name="M:Z0.z.vsll(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Byte)">
            <summary>
            __m256i _mm256_slli_epi64 (__m256i a, int imm8) VPSLLQ ymm, ymm, imm8
            Shifts each component of the source vector leftwards by a common number of bits
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The number of bits to count</param>
        </member>
        <member name="M:Z0.z.vmsb``1(Z0.N128,Z0.N8,System.Byte,``0)">
            <summary>
            The f most significant bits of each 8 bits are enabled
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">A value in the range [2,7] that defines the bit density</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.z.vmsb``1(Z0.N256,Z0.N8,System.Byte,``0)">
            <summary>
            Creates a mask where f most significant bits of each 8 bits are enabled
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">A value in the range [2,7] that defines the bit density</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.z.vsllr(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            Shifts each source vector component leftwards by an amount specified in the first component of the offset vector
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsllr(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            Shifts each source vector component leftwards by an amount specified in the first component of the offset vector
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsllr(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
             __m128i _mm_sll_epi16 (__m128i a, __m128i count) PSRLW xmm, xmm/m128
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsllr(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_sll_epi16 (__m128i a, __m128i count) PSRLW xmm, xmm/m128
            Shifts each source vector component leftwards by an amount specified in the first component of the offset vector
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsllr(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_sll_epi16 (__m128i a, __m128i count) PSRLW xmm, xmm/m128
            Shifts each source vector component leftwards by an amount specified in the first component of the offset vector
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsllr(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_sll_epi32 (__m128i a, __m128i count) PSRLD xmm, xmm/m128
            Shifts each source vector component leftwards by an amount specified in the first component of the offset vector
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsllr(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            __m128i _mm_sll_epi64 (__m128i a, __m128i count) PSRLQ xmm, xmm/m128
            Shifts each source vector component leftwards by an amount specified in the first component of the offset vector
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsllr(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m128i _mm_sll_epi64 (__m128i a, __m128i count) PSRLQ xmm, xmm/m128
            Shifts each source vector component leftwards by an amount specified in the first component of the offset vector
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsllr(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            Shifts each source vector component leftwards by an amount specified in the first component of the offset vector
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsllr(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            Shifts each source vector component leftwards by an amount specified in the first component of the offset vector
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsllr(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m256i _mm256_sll_epi16 (__m256i a, __m128i count) VPSRLW ymm, ymm, xmm/m128
            Shifts each source vector component leftwards by an amount specified in the first component of the offset vector
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsllr(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m256i _mm256_sll_epi16 (__m256i a, __m128i count) VPSRLW ymm, ymm, xmm/m128
            Shifts each source vector component leftwards by an amount specified in the first component of the offset vector
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsllr(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
             __m256i _mm256_sll_epi32 (__m256i a, __m128i count) VPSRLD ymm, ymm, xmm/m128
            Shifts each source vector component leftwards by an amount specified in the first component of the offset vector
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsllr(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
             __m256i _mm256_sll_epi32 (__m256i a, __m128i count) VPSRLD ymm, ymm, xmm/m128
            Shifts each source vector component leftwards by an amount specified in the first component of the offset vector
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsllr(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            __m256i _mm256_sll_epi64 (__m256i a, __m128i count) VPSRLQ ymm, ymm, xmm/m128
            Shifts each source vector component leftwards by an amount specified in the first component of the offset vector
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsllr(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m256i _mm256_sll_epi64 (__m256i a, __m128i count) VPSRLQ ymm, ymm, xmm/m128
            Shifts each source vector component leftwards by an amount specified in the first component of the offset vector
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsllr(System.Runtime.Intrinsics.Vector128{System.SByte},System.SByte)">
            <summary>
            Promotes the offset scalar to a vector and applies the register-based right shift operator
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset amount</param>
        </member>
        <member name="M:Z0.z.vsllr(System.Runtime.Intrinsics.Vector128{System.Byte},System.Byte)">
            <summary>
            Promotes the offset scalar to a vector and applies the register-based right shift operator
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset amount</param>
        </member>
        <member name="M:Z0.z.vsllr(System.Runtime.Intrinsics.Vector128{System.Int16},System.Int16)">
            <summary>
            Promotes the offset scalar to a vector and applies the register-based right shift operator
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset amount</param>
        </member>
        <member name="M:Z0.z.vsllr(System.Runtime.Intrinsics.Vector128{System.UInt16},System.UInt16)">
            <summary>
            Promotes the offset scalar to a vector and applies the register-based right shift operator
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset amount</param>
        </member>
        <member name="M:Z0.z.vsllr(System.Runtime.Intrinsics.Vector128{System.Int32},System.Int32)">
            <summary>
            Promotes the offset scalar to a vector and applies the register-based right shift operator
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset amount</param>
        </member>
        <member name="M:Z0.z.vsllr(System.Runtime.Intrinsics.Vector128{System.UInt32},System.UInt32)">
            <summary>
            Promotes the offset scalar to a vector and applies the register-based right shift operator
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset amount</param>
        </member>
        <member name="M:Z0.z.vsllr(System.Runtime.Intrinsics.Vector128{System.Int64},System.Int64)">
            <summary>
            Promotes the offset scalar to a vector and applies the register-based right shift operator
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset amount</param>
        </member>
        <member name="M:Z0.z.vsllr(System.Runtime.Intrinsics.Vector128{System.UInt64},System.UInt64)">
            <summary>
            Promotes the offset scalar to a vector and applies the register-based right shift operator
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset amount</param>
        </member>
        <member name="M:Z0.z.vsllr(System.Runtime.Intrinsics.Vector256{System.SByte},System.SByte)">
            <summary>
            Promotes the offset scalar to a vector and applies the register-based right shift operator
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset amount</param>
        </member>
        <member name="M:Z0.z.vsllr(System.Runtime.Intrinsics.Vector256{System.Byte},System.Byte)">
            <summary>
            Promotes the offset scalar to a vector and applies the register-based right shift operator
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset amount</param>
        </member>
        <member name="M:Z0.z.vsllr(System.Runtime.Intrinsics.Vector256{System.Int16},System.Int16)">
            <summary>
            Promotes the offset scalar to a vector and applies the register-based right shift operator
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset amount</param>
        </member>
        <member name="M:Z0.z.vsllr(System.Runtime.Intrinsics.Vector256{System.UInt16},System.UInt16)">
            <summary>
            Promotes the offset scalar to a vector and applies the register-based right shift operator
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset amount</param>
        </member>
        <member name="M:Z0.z.vsllr(System.Runtime.Intrinsics.Vector256{System.Int32},System.Int32)">
            <summary>
            Promotes the offset scalar to a vector and applies the register-based right shift operator
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset amount</param>
        </member>
        <member name="M:Z0.z.vsllr(System.Runtime.Intrinsics.Vector256{System.UInt32},System.UInt32)">
            <summary>
            Promotes the offset scalar to a vector and applies the register-based right shift operator
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset amount</param>
        </member>
        <member name="M:Z0.z.vsllr(System.Runtime.Intrinsics.Vector256{System.Int64},System.Int64)">
            <summary>
            Promotes the offset scalar to a vector and applies the register-based right shift operator
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset amount</param>
        </member>
        <member name="M:Z0.z.vsllr(System.Runtime.Intrinsics.Vector256{System.UInt64},System.UInt64)">
            <summary>
            Promotes the offset scalar to a vector and applies the register-based right shift operator
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset amount</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vsllv(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vsllv(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})" -->
        <member name="M:Z0.z.vsllv(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            Computes z[i] := x[i] >> s[i] for i = 0..7
            </summary>
            <param name="src">The source vector</param>
            <param name="counts">The offset vector</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vsllv(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vsllv(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vsllv(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vsllv(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vsllv(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})" -->
        <member name="M:Z0.z.vsllv(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            Computes z[i] := x[i] >> s[i] for i = 0..31
            </summary>
            <param name="src">The source vector</param>
            <param name="counts">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsllv(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            Computes z[i] := x[i] >> s[i] for i = 0..31
            </summary>
            <param name="src">The source vector</param>
            <param name="counts">The offset vector</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vsllv(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vsllv(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vsllv(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vsllv(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vsllv(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vsllv(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})" -->
        <member name="M:Z0.z.vsllx(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Byte)">
            <summary>
            Shifts the entire 128-bit vector leftwards at bit-level resolution
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The number of bits the shift leftward</param>
            <remarks>Taken from http://programming.sirrida.de</remarks>
        </member>
        <member name="M:Z0.z.vsllx(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Byte)">
            <summary>
            Shifts each 128-bit lane leftwards at bit-level resolution
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The number of bits the shift leftward</param>
            <remarks>Taken from http://programming.sirrida.de</remarks>
        </member>
        <member name="M:Z0.z.vspan``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>
            Allocates a span into which vector content is stored
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The component type</typeparam>
        </member>
        <member name="M:Z0.z.vspan``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>
            Allocates and deposits vector content to a span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The component type</typeparam>
        </member>
        <member name="M:Z0.z.vspan``1(Z0.Vector512{``0})">
            <summary>
            Allocates and deposits vector content to a span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The component type</typeparam>
        </member>
        <member name="M:Z0.z.vsrav(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            _mm_srav_epi32, avx2, shift-right variable arithmetic:
            Applies a rightward arithmetic shift each source vector component as
            specified by the amount the corresponding control vector component
            </summary>
            <param name="src">The source vector</param>
            <param name="counts">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsrav(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            _mm256_srav_epi32, avx2, shift-right variable arithmetic:
            Applies a rightward arithmetic shift each source vector component as
            specified by the amount the corresponding control vector component
            </summary>
            <param name="src">The source vector</param>
            <param name="counts">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsrl(System.Runtime.Intrinsics.Vector128{System.Byte},System.Byte)">
            <summary>
            Shifts each each component rightward by a specified bitcount
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The bitcount</param>
        </member>
        <member name="M:Z0.z.vsrl(System.Runtime.Intrinsics.Vector128{System.SByte},System.Byte)">
            <summary>
            Shifts each each component rightward by a specified bitcount
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The bitcount</param>
        </member>
        <member name="M:Z0.z.vsrl(System.Runtime.Intrinsics.Vector128{System.Int16},System.Byte)">
            <summary>
            __m128i _mm_srli_epi16 (__m128i a, int immediate) PSRLW xmm, imm8
            Shifts each each component rightward by a specified bitcount
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The bitcount</param>
        </member>
        <member name="M:Z0.z.vsrl(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Byte)">
            <summary>
             __m128i _mm_srli_epi16 (__m128i a, int immediate) PSRLW xmm, imm8
            Shifts each each component rightward by a specified bitcount
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The bitcount</param>
        </member>
        <member name="M:Z0.z.vsrl(System.Runtime.Intrinsics.Vector128{System.Int32},System.Byte)">
            <summary>
            __m128i _mm_srli_epi32 (__m128i a, int immediate) PSRLD xmm, imm8
            Shifts each each component rightward by a specified bitcount
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The bitcount</param>
        </member>
        <member name="M:Z0.z.vsrl(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Byte)">
            <summary>
            __m128i _mm_srli_epi32 (__m128i a, int immediate) PSRLD xmm, imm8
            Shifts each each component rightward by a specified bitcount
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The bitcount</param>
        </member>
        <member name="M:Z0.z.vsrl(System.Runtime.Intrinsics.Vector128{System.Int64},System.Byte)">
            <summary>
            __m128i _mm_srli_epi64 (__m128i a, int immediate) PSRLQ xmm, imm8
            Shifts each each component rightward by a specified bitcount
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The bitcount</param>
        </member>
        <member name="M:Z0.z.vsrl(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Byte)">
            <summary>
            __m128i _mm_srli_epi64 (__m128i a, int immediate) PSRLQ xmm, imm8
            Shifts each each component rightward by a specified bitcount
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The bitcount</param>
        </member>
        <member name="M:Z0.z.vsrl(System.Runtime.Intrinsics.Vector256{System.SByte},System.Byte)">
            <summary>
            Shifts each each component rightward by a specified bitcount
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The bitcount</param>
        </member>
        <member name="M:Z0.z.vsrl(System.Runtime.Intrinsics.Vector256{System.Byte},System.Byte)">
            <summary>
            Shifts each each component rightward by a specified bitcount
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The bitcount</param>
        </member>
        <member name="M:Z0.z.vsrl(System.Runtime.Intrinsics.Vector256{System.Int16},System.Byte)">
            <summary>
            __m256i _mm256_srli_epi16 (__m256i a, int imm8) VPSRLW ymm, ymm, imm8
            Shifts each each component rightward by a specified bitcount
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The bitcount</param>
        </member>
        <member name="M:Z0.z.vsrl(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Byte)">
            <summary>
            __m256i _mm256_srli_epi16 (__m256i a, int imm8) VPSRLW ymm, ymm, imm8
            Shifts each each component rightward by a specified bitcount
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The bitcount</param>
        </member>
        <member name="M:Z0.z.vsrl(System.Runtime.Intrinsics.Vector256{System.Int32},System.Byte)">
            <summary>
            __m256i _mm256_srli_epi32 (__m256i a, int imm8) VPSRLD ymm, ymm, imm8
            Shifts each each component rightward by a specified bitcount
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The bitcount</param>
        </member>
        <member name="M:Z0.z.vsrl(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Byte)">
            <summary>
            __m256i _mm256_srli_epi32 (__m256i a, int imm8) VPSRLD ymm, ymm, imm8
            Shifts each each component rightward by a specified bitcount
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The bitcount</param>
        </member>
        <member name="M:Z0.z.vsrl(System.Runtime.Intrinsics.Vector256{System.Int64},System.Byte)">
            <summary>
            __m256i _mm256_srli_epi64 (__m256i a, int imm8) VPSRLQ ymm, ymm, imm8
            Shifts each each component rightward by a specified bitcount
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The bitcount</param>
        </member>
        <member name="M:Z0.z.vsrl(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Byte)">
            <summary>
            __m256i _mm256_srli_epi64 (__m256i a, int imm8) VPSRLQ ymm, ymm, imm8
            Shifts each each component rightward by a specified bitcount
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The bitcount</param>
        </member>
        <member name="M:Z0.z.vlsb``1(Z0.N128,Z0.N8,System.Byte,``0)">
            <summary>
            The f least significant bits of each 8 bit segment are enabled
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">A value in the range [2,7] that defines the bit density</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.z.vlsb``1(Z0.N256,Z0.N8,System.Byte,``0)">
            <summary>
            The f least significant bits of each 8 bit segment are enabled
            </summary>
            <param name="w">The target vector width</param>
            <param name="f">The repetition frequency</param>
            <param name="d">A value in the range [2,7] that defines the bit density</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.z.vsrlr(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            Shifts each source vector component rightwards by an amount specified in the first component of the offset vector
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsrlr(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            Shifts each source vector component rightwards by an amount specified in the first component of the offset vector
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsrlr(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
             __m128i _mm_srl_epi16 (__m128i a, __m128i count) PSRLW xmm, xmm/m128
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsrlr(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_srl_epi16 (__m128i a, __m128i count) PSRLW xmm, xmm/m128
            Shifts each source vector component rightwards by an amount specified in the first component of the offset vector
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsrlr(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_srl_epi16 (__m128i a, __m128i count) PSRLW xmm, xmm/m128
            Shifts each source vector component rightwards by an amount specified in the first component of the offset vector
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsrlr(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_srl_epi32 (__m128i a, __m128i count) PSRLD xmm, xmm/m128
            Shifts each source vector component rightwards by an amount specified in the first component of the offset vector
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsrlr(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            __m128i _mm_srl_epi64 (__m128i a, __m128i count) PSRLQ xmm, xmm/m128
            Shifts each source vector component rightwards by an amount specified in the first component of the offset vector
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsrlr(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m128i _mm_srl_epi64 (__m128i a, __m128i count) PSRLQ xmm, xmm/m128
            Shifts each source vector component rightwards by an amount specified in the first component of the offset vector
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsrlr(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            Shifts each source vector component rightwards by an amount specified in the first component of the offset vector
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsrlr(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            Shifts each source vector component rightwards by an amount specified in the first component of the offset vector
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsrlr(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m256i _mm256_srl_epi16 (__m256i a, __m128i count)VPSRLW ymm, ymm, xmm/m128
            Shifts each source vector component rightwards by an amount specified in the first component of the offset vector
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsrlr(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m256i _mm256_srl_epi16 (__m256i a, __m128i count)VPSRLW ymm, ymm, xmm/m128
            Shifts each source vector component rightwards by an amount specified in the first component of the offset vector
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsrlr(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
             __m256i _mm256_srl_epi32 (__m256i a, __m128i count) VPSRLD ymm, ymm, xmm/m128
            Shifts each source vector component rightwards by an amount specified in the first component of the offset vector
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsrlr(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
             __m256i _mm256_srl_epi32 (__m256i a, __m128i count) VPSRLD ymm, ymm, xmm/m128
            Shifts each source vector component rightwards by an amount specified in the first component of the offset vector
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsrlr(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            __m256i _mm256_srl_epi64 (__m256i a, __m128i count) VPSRLQ ymm, ymm, xmm/m128
            Shifts each source vector component rightwards by an amount specified in the first component of the offset vector
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsrlr(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m256i _mm256_srl_epi64 (__m256i a, __m128i count) VPSRLQ ymm, ymm, xmm/m128
            Shifts each source vector component rightwards by an amount specified in the first component of the offset vector
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsrlr(System.Runtime.Intrinsics.Vector128{System.SByte},System.SByte)">
            <summary>
            Promotes the offset scalar to a vector and applies the register-based right shift operator
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset amount</param>
        </member>
        <member name="M:Z0.z.vsrlr(System.Runtime.Intrinsics.Vector128{System.Byte},System.Byte)">
            <summary>
            Promotes the offset scalar to a vector and applies the register-based right shift operator
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset amount</param>
        </member>
        <member name="M:Z0.z.vsrlr(System.Runtime.Intrinsics.Vector128{System.Int16},System.Int16)">
            <summary>
            Promotes the offset scalar to a vector and applies the register-based right shift operator
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset amount</param>
        </member>
        <member name="M:Z0.z.vsrlr(System.Runtime.Intrinsics.Vector128{System.UInt16},System.UInt16)">
            <summary>
            Promotes the offset scalar to a vector and applies the register-based right shift operator
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset amount</param>
        </member>
        <member name="M:Z0.z.vsrlr(System.Runtime.Intrinsics.Vector128{System.Int32},System.Int32)">
            <summary>
            Promotes the offset scalar to a vector and applies the register-based right shift operator
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset amount</param>
        </member>
        <member name="M:Z0.z.vsrlr(System.Runtime.Intrinsics.Vector128{System.UInt32},System.UInt32)">
            <summary>
            Promotes the offset scalar to a vector and applies the register-based right shift operator
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset amount</param>
        </member>
        <member name="M:Z0.z.vsrlr(System.Runtime.Intrinsics.Vector128{System.Int64},System.Int64)">
            <summary>
            Promotes the offset scalar to a vector and applies the register-based right shift operator
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset amount</param>
        </member>
        <member name="M:Z0.z.vsrlr(System.Runtime.Intrinsics.Vector128{System.UInt64},System.UInt64)">
            <summary>
            Promotes the offset scalar to a vector and applies the register-based right shift operator
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset amount</param>
        </member>
        <member name="M:Z0.z.vsrlr(System.Runtime.Intrinsics.Vector256{System.SByte},System.SByte)">
            <summary>
            Promotes the offset scalar to a vector and applies the register-based right shift operator
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset amount</param>
        </member>
        <member name="M:Z0.z.vsrlr(System.Runtime.Intrinsics.Vector256{System.Byte},System.Byte)">
            <summary>
            Promotes the offset scalar to a vector and applies the register-based right shift operator
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset amount</param>
        </member>
        <member name="M:Z0.z.vsrlr(System.Runtime.Intrinsics.Vector256{System.Int16},System.Int16)">
            <summary>
            Promotes the offset scalar to a vector and applies the register-based right shift operator
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset amount</param>
        </member>
        <member name="M:Z0.z.vsrlr(System.Runtime.Intrinsics.Vector256{System.UInt16},System.UInt16)">
            <summary>
            Promotes the offset scalar to a vector and applies the register-based right shift operator
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset amount</param>
        </member>
        <member name="M:Z0.z.vsrlr(System.Runtime.Intrinsics.Vector256{System.Int32},System.Int32)">
            <summary>
            Promotes the offset scalar to a vector and applies the register-based right shift operator
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset amount</param>
        </member>
        <member name="M:Z0.z.vsrlr(System.Runtime.Intrinsics.Vector256{System.UInt32},System.UInt32)">
            <summary>
            Promotes the offset scalar to a vector and applies the register-based right shift operator
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset amount</param>
        </member>
        <member name="M:Z0.z.vsrlr(System.Runtime.Intrinsics.Vector256{System.Int64},System.Int64)">
            <summary>
            Promotes the offset scalar to a vector and applies the register-based right shift operator
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset amount</param>
        </member>
        <member name="M:Z0.z.vsrlr(System.Runtime.Intrinsics.Vector256{System.UInt64},System.UInt64)">
            <summary>
            Promotes the offset scalar to a vector and applies the register-based right shift operator
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The offset amount</param>
        </member>
        <member name="M:Z0.z.vsrlv(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            Computes z[i] := x[i] >> s[i] for i = 0..15
            </summary>
            <param name="src">The source vector</param>
            <param name="counts">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsrlv(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            Computes z[i] := x[i] >> s[i] for i = 0..15
            </summary>
            <param name="src">The source vector</param>
            <param name="counts">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsrlv(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            Computes z[i] := x[i] >> s[i] for i = 0..7
            </summary>
            <param name="src">The source vector</param>
            <param name="counts">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsrlv(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            Computes z[i] := x[i] >> s[i] for i = 0..7
            </summary>
            <param name="src">The source vector</param>
            <param name="counts">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsrlv(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
             __m128i _mm_srlv_epi32 (__m128i a, __m128i count) VPSRLVD xmm, xmm, xmm/m128
            Computes z[i] := x[i] >> offsets[i] for i = 0...3
            </summary>
            <param name="x">The source vector</param>
            <param name="counts">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsrlv(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_srlv_epi32 (__m128i a, __m128i count) VPSRLVD xmm, xmm, xmm/m128
            Computes z[i] := x[i] >> offsets[i] for i = 0...3
            </summary>
            <param name="x">The source vector</param>
            <param name="counts">The offsets offset vector</param>
        </member>
        <member name="M:Z0.z.vsrlv(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            __m128i _mm_srlv_epi64 (__m128i a, __m128i count) VPSRLVQ xmm, xmm, xmm/m128
            Computes z[i] := x[i] >> offsets[i] for i = 0,1
            </summary>
            <param name="x">The source vector</param>
            <param name="counts">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsrlv(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m128i _mm_srlv_epi64 (__m128i a, __m128i count) VPSRLVQ xmm, xmm, xmm/m128
            Computes z[i] := x[i] >> offsets[i] for i = 0,1
            </summary>
            <param name="x">The source vector</param>
            <param name="counts">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsrlv(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            Computes z[i] := x[i] >> s[i] for i = 0..31
            </summary>
            <param name="src">The source vector</param>
            <param name="counts">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsrlv(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            Computes z[i] := x[i] >> s[i] for i = 0..31
            </summary>
            <param name="src">The source vector</param>
            <param name="counts">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsrlv(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            Computes z[i] := x[i] >> s[i] for i = 0..15
            </summary>
            <param name="src">The source vector</param>
            <param name="counts">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsrlv(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            Computes z[i] := x[i] >> s[i] for i = 0..15
            </summary>
            <param name="src">The source vector</param>
            <param name="counts">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsrlv(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            __m256i _mm256_srlv_epi32 (__m256i a, __m256i count) VPSRLVD ymm, ymm, ymm/m256
            Computes z[i] := x[i] >> offsets[i] for i = 0...7
            </summary>
            <param name="x">The source vector</param>
            <param name="counts">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsrlv(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            __m256i _mm256_srlv_epi32 (__m256i a, __m256i count) VPSRLVD ymm, ymm, ymm/m256
            Computes z[i] := x[i] >> offsets[i] for i = 0...7
            </summary>
            <param name="x">The source vector</param>
            <param name="counts">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsrlv(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            __m256i _mm256_srlv_epi64 (__m256i a, __m256i count) VPSRLVQ ymm, ymm, ymm/m256
            Computes z[i] := x[i] >> offsets[i] for i = 0...3
            </summary>
            <param name="x">The source vector</param>
            <param name="counts">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsrlv(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
             __m256i _mm256_srlv_epi64 (__m256i a, __m256i count) VPSRLVQ ymm, ymm, ymm/m256
            Computes z[i] := x[i] >> offsets[i] for i = 0...3
            </summary>
            <param name="x">The source vector</param>
            <param name="counts">The offset vector</param>
        </member>
        <member name="M:Z0.z.vsrlx(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Byte)">
            <summary>
            Shifts the entire 128-bit vector rightwards at bit-level resolution
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The number of bits to shift rightward</param>
            <remarks>Taken from http://programming.sirrida.de</remarks>
        </member>
        <member name="M:Z0.z.vsrlx(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Byte)">
            <summary>
            Shifts each 128-bit lane rightwards at bit-level resolution
            </summary>
            <param name="src">The source vector</param>
            <param name="count">The number of bits to shift rightward</param>
            <remarks>Taken from http://programming.sirrida.de</remarks>
        </member>
        <member name="M:Z0.z.vstore``1(System.Runtime.Intrinsics.Vector128{``0},Z0.SpanBlock128{``0}@)">
            <summary>
            Stores the source vector to the head of a blocked container
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target block</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vstore``1(System.Runtime.Intrinsics.Vector128{``0},Z0.SpanBlock128{``0}@,System.Int32)">
            <summary>
            Stores the source vector to a specified block in a blocked container
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target block</param>
            <param name="block">The 0-based block index at which storage should begin</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.z.vstore``1(System.Runtime.Intrinsics.Vector256{``0},Z0.SpanBlock256{``0}@)">
            <summary>
            Stores the source vector to a blocked container
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target block</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.z.vstore``1(Z0.Vector512{``0},Z0.SpanBlock512{``0}@)">
            <summary>
            Stores the source vector to a blocked container
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target block</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.z.vstore``1(System.Runtime.Intrinsics.Vector256{``0},Z0.SpanBlock256{``0}@,System.Int32)">
            <summary>
            Stores the source vector to a specified block in a blocked container
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target block</param>
            <param name="block">The 0-based block index at which storage should begin</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.z.vstore``1(Z0.Vector512{``0},Z0.SpanBlock512{``0}@,System.Int32)">
            <summary>
            Stores the source vector to a specified block in a blocked container
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target block</param>
            <param name="block">The 0-based block index at which storage should begin</param>
            <typeparam name="T">The vector component type</typeparam>
        </member>
        <member name="M:Z0.z.vstream(System.Runtime.Intrinsics.Vector128{System.SByte},System.SByte@)">
            <summary>
            _mm_stream_si128 (__m128i* mem_addr, __m128i a) MOVNTDQ m128, xmm
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The storage target</param>
        </member>
        <member name="M:Z0.z.vstream(System.Runtime.Intrinsics.Vector128{System.Byte},System.Byte@)">
            <summary>
            _mm_stream_si128 (__m128i* mem_addr, __m128i a) MOVNTDQ m128, xmm
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The storage target</param>
        </member>
        <member name="M:Z0.z.vstream(System.Runtime.Intrinsics.Vector128{System.Int16},System.Int16@)">
            <summary>
            _mm_stream_si128 (__m128i* mem_addr, __m128i a) MOVNTDQ m128, xmm
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The storage target</param>
        </member>
        <member name="M:Z0.z.vstream(System.Runtime.Intrinsics.Vector128{System.UInt16},System.UInt16@)">
            <summary>
            _mm_stream_si128 (__m128i* mem_addr, __m128i a) MOVNTDQ m128, xmm
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The storage target</param>
        </member>
        <member name="M:Z0.z.vstream(System.Runtime.Intrinsics.Vector128{System.Int32},System.Int32@)">
            <summary>
            _mm_stream_si128 (__m128i* mem_addr, __m128i a) MOVNTDQ m128, xmm
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The storage target</param>
        </member>
        <member name="M:Z0.z.vstream(System.Runtime.Intrinsics.Vector128{System.UInt32},System.UInt32@)">
            <summary>
            _mm_stream_si128 (__m128i* mem_addr, __m128i a) MOVNTDQ m128, xmm
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The storage target</param>
        </member>
        <member name="M:Z0.z.vstream(System.Runtime.Intrinsics.Vector128{System.Int64},System.Int64@)">
            <summary>
            _mm_stream_si128 (__m128i* mem_addr, __m128i a) MOVNTDQ m128, xmm
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The storage target</param>
        </member>
        <member name="M:Z0.z.vstream(System.Runtime.Intrinsics.Vector128{System.UInt64},System.UInt64@)">
            <summary>
            _mm_stream_si128 (__m128i* mem_addr, __m128i a) MOVNTDQ m128, xmm
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The storage target</param>
        </member>
        <member name="M:Z0.z.vstream(System.Runtime.Intrinsics.Vector128{System.Single},System.Single@)">
            <summary>
            void _mm_stream_ps (float* mem_addr, __m128 a) MOVNTPS m128, xmm
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The storage target</param>
        </member>
        <member name="M:Z0.z.vstream(System.Runtime.Intrinsics.Vector128{System.Double},System.Double@)">
            <summary>
            void _mm_stream_pd (double* mem_addr, __m128d a) MOVNTPD m128, xmm
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The storage target</param>
        </member>
        <member name="M:Z0.z.vstream(System.Runtime.Intrinsics.Vector256{System.SByte},System.SByte@)">
            <summary>
            void _mm256_stream_si256 (__m256i * mem_addr, __m256i a) VMOVNTDQ m256, ymm
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The storage target</param>
        </member>
        <member name="M:Z0.z.vstream(System.Runtime.Intrinsics.Vector256{System.Byte},System.Byte@)">
            <summary>
            void _mm256_stream_si256 (__m256i * mem_addr, __m256i a) VMOVNTDQ m256, ymm
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The storage target</param>
        </member>
        <member name="M:Z0.z.vstream(System.Runtime.Intrinsics.Vector256{System.Int16},System.Int16@)">
            <summary>
            void _mm256_stream_si256 (__m256i * mem_addr, __m256i a) VMOVNTDQ m256, ymm
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The storage target</param>
        </member>
        <member name="M:Z0.z.vstream(System.Runtime.Intrinsics.Vector256{System.UInt16},System.UInt16@)">
            <summary>
            void _mm256_stream_si256 (__m256i * mem_addr, __m256i a) VMOVNTDQ m256, ymm
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The storage target</param>
        </member>
        <member name="M:Z0.z.vstream(System.Runtime.Intrinsics.Vector256{System.Int32},System.Int32@)">
            <summary>
            void _mm256_stream_si256 (__m256i * mem_addr, __m256i a) VMOVNTDQ m256, ymm
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The storage target</param>
        </member>
        <member name="M:Z0.z.vstream(System.Runtime.Intrinsics.Vector256{System.UInt32},System.UInt32@)">
            <summary>
            void _mm256_stream_si256 (__m256i * mem_addr, __m256i a) VMOVNTDQ m256, ymm
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The storage target</param>
        </member>
        <member name="M:Z0.z.vstream(System.Runtime.Intrinsics.Vector256{System.Int64},System.Int64@)">
            <summary>
            void _mm256_stream_si256 (__m256i * mem_addr, __m256i a) VMOVNTDQ m256, ymm
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The storage target</param>
        </member>
        <member name="M:Z0.z.vstream(System.Runtime.Intrinsics.Vector256{System.UInt64},System.UInt64@)">
            <summary>
            void _mm256_stream_si256 (__m256i * mem_addr, __m256i a) VMOVNTDQ m256, ymm
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The storage target</param>
        </member>
        <member name="M:Z0.z.vstream(System.Runtime.Intrinsics.Vector256{System.Single},System.Single@)">
            <summary>
            void _mm256_stream_ps (float * mem_addr, __m256 a) MOVNTPS m256, ymm
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The storage target</param>
        </member>
        <member name="M:Z0.z.vstream(System.Runtime.Intrinsics.Vector256{System.Double},System.Double@)">
            <summary>
            void _mm256_stream_pd (double * mem_addr, __m256d a) MOVNTPD m256, ymm
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The storage target</param>
        </member>
        <member name="M:Z0.z.vsub(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_sub_epi8 (__m128i a, __m128i b) PSUBB xmm, xmm/m128
            Subtracts the right vector from the left
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vsub(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
             __m128i _mm_sub_epi8 (__m128i a, __m128i b) PSUBB xmm, xmm/m128
            Subtracts the right vector from the left
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vsub(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_sub_epi16 (__m128i a, __m128i b) PSUBW xmm, xmm/m128
            Subtracts the right vector from the left
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vsub(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_sub_epi16 (__m128i a, __m128i b) PSUBW xmm, xmm/m128
            Subtracts the right vector from the left
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vsub(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            __m128i _mm_sub_epi32 (__m128i a, __m128i b) PSUBD xmm, xmm/m12
            Subtracts the right vector from the left
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vsub(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            __m128i _mm_sub_epi32 (__m128i a, __m128i b) PSUBD xmm, xmm/m128
            Subtracts the right vector from the left
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vsub(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            __m128i _mm_sub_epi64 (__m128i a, __m128i b) PSUBQ xmm, xmm/m128
            Subtracts the right vector from the left
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vsub(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            __m128i _mm_sub_epi64 (__m128i a, __m128i b) PSUBQ xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vsub(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            __m256i _mm256_sub_epi8 (__m256i a, __m256i b) VPSUBB ymm, ymm, ymm/m256
            Subtracts the right vector from the left
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vsub(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            __m256i _mm256_sub_epi8 (__m256i a, __m256i b) VPSUBB ymm, ymm, ymm/m256
            Subtracts the right vector from the left
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vsub(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_sub_epi16 (__m256i a, __m256i b) VPSUBW ymm, ymm, ymm/m256
            Subtracts the right vector from the left
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vsub(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            __m256i _mm256_sub_epi16 (__m256i a, __m256i b) VPSUBW ymm, ymm, ymm/m256
            Subtracts the right vector from the left
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vsub(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
             __m256i _mm256_sub_epi32 (__m256i a, __m256i b) VPSUBD ymm, ymm, ymm/m256
            Subtracts the right vector from the left
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vsub(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
             __m256i _mm256_sub_epi32 (__m256i a, __m256i b) VPSUBD ymm, ymm, ymm/m256
            Subtracts the right vector from the left
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vsub(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            __m256i _mm256_sub_epi64 (__m256i a, __m256i b) VPSUBQ ymm, ymm, ymm/m256
            Subtracts the right vector from the left
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vsub(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            __m256i _mm256_sub_epi64 (__m256i a, __m256i b) VPSUBQ ymm, ymm, ymm/m256
            Subtracts the right vector from the left
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vsubs(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            __m128i _mm_subs_epu8 (__m128i a, __m128i b) PSUBUSB xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vsubs(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            __m128i _mm_subs_epi8 (__m128i a, __m128i b) PSUBSB xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vsubs(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            __m128i _mm_subs_epi16 (__m128i a, __m128i b) PSUBSW xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vsubs(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            __m128i _mm_subs_epi16 (__m128i a, __m128i b) PSUBSW xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vsubs(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
             __m256i _mm256_subs_epu8 (__m256i a, __m256i b) VPSUBUSB ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vsubs(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
             __m256i _mm256_subs_epi8 (__m256i a, __m256i b) VPSUBSB ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vsubs(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            __m256i _mm256_subs_epi16 (__m256i a, __m256i b) VPSUBSW ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vsubs(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            __m256i _mm256_subs_epu16 (__m256i a, __m256i b) VPSUBUSW ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vswaphl(System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            Swaps the source vectors' hi/lo 128-bit lanes
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vswaphl(System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            Swaps hi/lo 128-bit lanes
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vswaphl(System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            Swaps hi/lo 128-bit lanes
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vswaphl(System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            Swaps hi/lo 128-bit lanes
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vswaphl(System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            Swaps hi/lo 128-bit lanes
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vswaphl(System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            Swaps hi/lo 128-bit lanes
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vswaphl(System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            Swaps hi/lo 128-bit lanes
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vswaphl(System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            Swaps hi/lo 128-bit lanes
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vswaphl(System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            Swaps 64-bit hi/lo segments of the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vswaphl(System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            Swaps 64-bit hi/lo segments of the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vswaphl(System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            Swaps 64-bit hi/lo segments of the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vswaphl(System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            Swaps 64-bit hi/lo segments of the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vswaphl(System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            Swaps 64-bit hi/lo segments of the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vswaphl(System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            Swaps 64-bit hi/lo segments of the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vswaphl(System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            Swaps 64-bit hi/lo segments of the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vswaphl(System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            Swaps 64-bit hi/lo segments of the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.z.vtranspose(System.Runtime.Intrinsics.Vector128{System.UInt32}@,System.Runtime.Intrinsics.Vector128{System.UInt32}@,System.Runtime.Intrinsics.Vector128{System.UInt32}@,System.Runtime.Intrinsics.Vector128{System.UInt32}@)">
            <summary>
            Transposes a 4x4 matrix of unsigned integers, adapted from MSVC intrinsic headers
            </summary>
            <param name="row0">The first row</param>
            <param name="row1">The second row</param>
            <param name="row2">The third row</param>
            <param name="row3">The fourth row</param>
        </member>
        <member name="M:Z0.z.vtakemask(System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            _mm_movemask_epi8 (__m128i a) PMOVMSKB reg, xmm
            Constructs an integer from the most significant bit of each source vector component
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vtakemask(System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            _mm_movemask_epi8 (__m128i a) PMOVMSKB reg, xmm
            Constructs an integer from the most significant bit of each source vector component
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vtakemask(System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            _mm_movemask_epi8 (__m128i a) PMOVMSKB reg, xmm
            Constructs an integer from the most significant bit of each source vector component
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vtakemask(System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            _mm_movemask_epi8 (__m128i a) PMOVMSKB reg, xmm
            Constructs an integer from the most significant bit of each source vector component
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vtakemask(System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            int _mm256_movemask_epi8 (__m256i a) VPMOVMSKB reg, ymm
            Constructs an integer from the most significant bit of each 8-bit source vector segment
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vtakemask(System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            int _mm256_movemask_epi8 (__m256i a) VPMOVMSKB reg, ymm
            Constructs an integer from the most significant bit of each 8-bit source vector segment
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vtakemask(System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            int _mm256_movemask_epi8 (__m256i a) VPMOVMSKB reg, ymm
            Constructs an integer from the most significant bit of each 8-bit source vector segment
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vtakemask(System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            int _mm256_movemask_epi8 (__m256i a) VPMOVMSKB reg, ymm
            Constructs an integer from the most significant bit of each 8-bit source vector segment
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vtakemask(System.Runtime.Intrinsics.Vector128{System.Byte},System.Byte)">
            <summary>
            Creates a 32-bit mask from each byte at a byte-relative bit index
            </summary>
            <param name="src">The source vector</param>
            <param name="index">An integer between 0 and 7</param>
        </member>
        <member name="M:Z0.z.vtakemask(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Byte)">
            <summary>
            Creates a 32-bit mask from each byte at a byte-relative bit index
            </summary>
            <param name="src">The source vector</param>
            <param name="index">An integer between 0 and 7</param>
        </member>
        <member name="M:Z0.z.vtakemask(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Byte)">
            <summary>
            Creates a 32-bit mask from each byte at a byte-relative bit index
            </summary>
            <param name="src">The source vector</param>
            <param name="index">An integer between 0 and 7</param>
        </member>
        <member name="M:Z0.z.vtakemask(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Byte)">
            <summary>
            Creates a 32-bit mask from each byte at a byte-relative bit index
            </summary>
            <param name="src">The source vector</param>
            <param name="index">An integer between 0 and 7</param>
        </member>
        <member name="M:Z0.z.vtakemask(System.Runtime.Intrinsics.Vector256{System.Byte},System.Byte)">
            <summary>
            Creates a 32-bit mask from each byte at a byte-relative bit index
            </summary>
            <param name="src">The source vector</param>
            <param name="index">An integer between 0 and 7</param>
        </member>
        <member name="M:Z0.z.vtakemask(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Byte)">
            <summary>
            Creates a 32-bit mask from each byte at a byte-relative bit index
            </summary>
            <param name="src">The source vector</param>
            <param name="index">An integer between 0 and 7</param>
        </member>
        <member name="M:Z0.z.vtakemask(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Byte)">
            <summary>
            Creates a 32-bit mask from each byte at a byte-relative bit index
            </summary>
            <param name="src">The source vector</param>
            <param name="index">An integer between 0 and 7</param>
        </member>
        <member name="M:Z0.z.vtakemask(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Byte)">
            <summary>
            Creates a 32-bit mask from each byte at a byte-relative bit index
            </summary>
            <param name="src">The source vector</param>
            <param name="index">An integer between 0 and 7</param>
        </member>
        <member name="M:Z0.z.vtakemask``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>
            _mm_movemask_epi8 (__m128i a) PMOVMSKB reg, xmm
            Creates a 16-bit mask from the most significant bit of each byte in the source vector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vtakemask``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>
            int _mm256_movemask_epi8 (__m256i a) VPMOVMSKB reg, ymm
            Creates a 32-bit mask from the most significant bit of each byte in the source vector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vtakemask``1(System.Runtime.Intrinsics.Vector128{``0},System.Byte)">
            <summary>
            Creates a 16-bit mask from each byte in the source vector at a byte-relative bit index
            </summary>
            <param name="src">The source vector</param>
            <param name="index">An integer between 0 and 7</param>
        </member>
        <member name="M:Z0.z.vtakemask``1(System.Runtime.Intrinsics.Vector256{``0},System.Byte)">
            <summary>
            Creates a 32-bit mask from each byte in the source vector at a byte-relative bit index
            </summary>
            <param name="src">The source vector</param>
            <param name="index">An integer between 0 and 7</param>
        </member>
        <member name="M:Z0.z.vtakemask``1(System.Runtime.Intrinsics.Vector128{``0},Z0.HexDigit)">
            <summary>
            Creates a 16-bit mask from each byte in the source vector at a byte-relative bit index
            </summary>
            <param name="src">The source vector</param>
            <param name="index">An integer between 0 and 7</param>
        </member>
        <member name="M:Z0.z.vtestc(System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            int _mm_testc_si128 (__m128i a, __m128i b) PTEST xmm, xmm/m128
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vtestc(System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            int _mm_testc_si128 (__m128i a, __m128i b) PTEST xmm, xmm/m128
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vtestc(System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            int _mm_testc_si128 (__m128i a, __m128i b) PTEST xmm, xmm/m128
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vtestc(System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            int _mm_testc_si128 (__m128i a, __m128i b) PTEST xmm, xmm/m128
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vtestc(System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            int _mm_testc_si128 (__m128i a, __m128i b) PTEST xmm, xmm/m128
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vtestc(System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            int _mm_testc_si128 (__m128i a, __m128i b) PTEST xmm, xmm/m128
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.z.vtestc(System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            int _mm_testc_si128 (__m128i a, __m128i b) PTEST xmm, xmm/m128
            </summary>
            <param name="src">The source vector</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vtestc(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})" -->
        <member name="M:Z0.z.vtestc(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            int _mm_testc_si128 (__m128i a, __m128i b) PTEST xmm, xmm/m128
            Returns true if all mask-identified source bits are on
            </summary>
            <param name="src">The source bits</param>
            <param name="mask">Specifies the bits the source to test</param>
        </member>
        <member name="M:Z0.z.vtestc(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            int _mm_testc_si128 (__m128i a, __m128i b) PTEST xmm, xmm/m128
            Returns true if all mask-identified source bits are on
            </summary>
            <param name="src">The source bits</param>
            <param name="mask">Specifies the bits the source to test</param>
        </member>
        <member name="M:Z0.z.vtestc(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            int _mm_testc_si128 (__m128i a, __m128i b) PTEST xmm, xmm/m128
            Returns true if all mask-identified source bits are on
            </summary>
            <param name="src">The source bits</param>
            <param name="mask">Specifies the bits the source to test</param>
        </member>
        <member name="M:Z0.z.vtestc(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            int _mm_testc_si128 (__m128i a, __m128i b) PTEST xmm, xmm/m128
            Returns true if all mask-identified source bits are on
            </summary>
            <param name="src">The source bits</param>
            <param name="mask">Specifies the bits the source to test</param>
        </member>
        <member name="M:Z0.z.vtestc(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            int _mm_testc_si128 (__m128i a, __m128i b) PTEST xmm, xmm/m128
            Returns true if all mask-identified source bits are on
            </summary>
            <param name="src">The source bits</param>
            <param name="mask">Specifies the bits the source to test</param>
        </member>
        <member name="M:Z0.z.vtestc(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            int _mm_testc_si128 (__m128i a, __m128i b) PTEST xmm, xmm/m128
            Returns true if all mask-identified source bits are on
            </summary>
            <param name="src">The source bits</param>
            <param name="mask">Specifies the bits the source to test</param>
        </member>
        <member name="M:Z0.z.vtestc(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            int _mm_testc_si128 (__m128i a, __m128i b) PTEST xmm, xmm/m128
            Returns true if all mask-identified source bits are on
            </summary>
            <param name="src">The source bits</param>
            <param name="mask">Specifies the bits the source to test</param>
        </member>
        <member name="M:Z0.z.vtestc(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            int _mm256_testc_si256 (__m256i a, __m256i b) VPTEST ymm, ymm/m256
            Returns true if all mask-identified source bits are on
            </summary>
            <param name="src">The source bits</param>
            <param name="mask">Specifies the bits the source to test</param>
        </member>
        <member name="M:Z0.z.vtestc(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            int _mm256_testc_si256 (__m256i a, __m256i b) VPTEST ymm, ymm/m256
            Returns true if all mask-identified source bits are on
            </summary>
            <param name="src">The source bits</param>
            <param name="mask">Specifies the bits the source to test</param>
        </member>
        <member name="M:Z0.z.vtestc(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            int _mm256_testc_si256 (__m256i a, __m256i b) VPTEST ymm, ymm/m256
            Returns true if all mask-identified source bits are on
            </summary>
            <param name="src">The source bits</param>
            <param name="mask">Specifies the bits the source to test</param>
        </member>
        <member name="M:Z0.z.vtestc(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            int _mm256_testc_si256 (__m256i a, __m256i b) VPTEST ymm, ymm/m256
            Returns true if all mask-identified source bits are on
            </summary>
            <param name="src">The source bits</param>
            <param name="mask">Specifies the bits the source to test</param>
        </member>
        <member name="M:Z0.z.vtestc(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            int _mm256_testc_si256 (__m256i a, __m256i b) VPTEST ymm, ymm/m256
            Returns true if all mask-identified source bits are on
            </summary>
            <param name="src">The source bits</param>
            <param name="mask">Specifies the bits the source to test</param>
        </member>
        <member name="M:Z0.z.vtestc(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            int _mm256_testc_si256 (__m256i a, __m256i b) VPTEST ymm, ymm/m256
            Returns true if all mask-identified source bits are on
            </summary>
            <param name="src">The source bits</param>
            <param name="mask">Specifies the bits the source to test</param>
        </member>
        <member name="M:Z0.z.vtestc(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            int _mm256_testc_si256 (__m256i a, __m256i b) VPTEST ymm, ymm/m256
            Returns true if all mask-identified source bits are on
            </summary>
            <param name="src">The source bits</param>
            <param name="mask">Specifies the bits the source to test</param>
        </member>
        <member name="M:Z0.z.vtestc(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            _mm256_testc_si256
            Returns true if all mask-identified source bits are on
            </summary>
            <param name="src">The source bits</param>
            <param name="mask">Specifies the bits the source to test</param>
        </member>
        <member name="M:Z0.z.vtestc(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            int _mm_testc_ps (__m128 a, __m128 b) VTESTPS xmm, xmm/m128
            Determines whether mask-specified source bits are all on
            </summary>
            <param name="src">The source bits</param>
            <param name="mask">Specifies the bits in the source to test</param>
        </member>
        <member name="M:Z0.z.vtestc(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            int _mm_testc_pd (__m128d a, __m128d b) VTESTPD xmm, xmm/m128
            Determines whether mask-specified source bits are all on
            </summary>
            <param name="src">The source bits</param>
            <param name="mask">Specifies the bits in the source to test</param>
        </member>
        <member name="M:Z0.z.vtestc(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            int _mm256_testc_ps (__m256 a, __m256 b) VTESTPS ymm, ymm/m256
            Determines whether mask-specified source bits are all on
            </summary>
            <param name="src">The source bits</param>
            <param name="mask">Specifies the bits in the source to test</param>
        </member>
        <member name="M:Z0.z.vtestc(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            int _mm256_testc_pd (__m256d a, __m256d b) VTESTPS ymm, ymm/m256
            Determines whether mask-specified source bits are all on
            </summary>
            <param name="src">The source bits</param>
            <param name="mask">Specifies the bits in the source to test</param>
        </member>
        <member name="M:Z0.z.vtestz(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            int _mm_testz_si128 (__m128i a, __m128i b) PTEST xmm, xmm/m128
            Returns true if all mask-identified source bits are off
            </summary>
            <param name="src">The bit source</param>
            <param name="mask">The mask</param>
        </member>
        <member name="M:Z0.z.vtestz(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            int _mm_testz_si128 (__m128i a, __m128i b) PTEST xmm, xmm/m128
            Returns true if all mask-identified source bits are off
            </summary>
            <param name="src">The bit source</param>
            <param name="mask">The mask</param>
        </member>
        <member name="M:Z0.z.vtestz(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            int _mm_testz_si128 (__m128i a, __m128i b) PTEST xmm, xmm/m128
            Returns true if all mask-identified source bits are off
            </summary>
            <param name="src">The bit source</param>
            <param name="mask">The mask</param>
        </member>
        <member name="M:Z0.z.vtestz(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            int _mm_testz_si128 (__m128i a, __m128i b) PTEST xmm, xmm/m128
            Returns true if all mask-identified source bits are off
            </summary>
            <param name="src">The bit source</param>
            <param name="mask">The mask</param>
        </member>
        <member name="M:Z0.z.vtestz(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            int _mm_testz_si128 (__m128i a, __m128i b) PTEST xmm, xmm/m128
            Returns true if all mask-identified source bits are off
            </summary>
            <param name="src">The bit source</param>
            <param name="mask">The mask</param>
        </member>
        <member name="M:Z0.z.vtestz(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            int _mm_testz_si128 (__m128i a, __m128i b) PTEST xmm, xmm/m128
            Returns true if all mask-identified source bits are off
            </summary>
            <param name="src">The bit source</param>
            <param name="mask">The mask</param>
        </member>
        <member name="M:Z0.z.vtestz(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            int _mm_testz_si128 (__m128i a, __m128i b) PTEST xmm, xmm/m128
            Returns true if all mask-identified source bits are off
            </summary>
            <param name="src">The bit source</param>
            <param name="mask">The mask</param>
        </member>
        <member name="M:Z0.z.vtestz(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            int _mm_testz_si128 (__m128i a, __m128i b) PTEST xmm, xmm/m128
            Returns true if all mask-identified source bits are off
            </summary>
            <param name="src">The bit source</param>
            <param name="mask">The mask</param>
        </member>
        <member name="M:Z0.z.vtestz(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            int _mm256_testz_si256 (__m256i a, __m256i b) VPTEST ymm, ymm/m256
            Returns true if all mask-identified source bits are off
            </summary>
            <param name="src">The bit source</param>
            <param name="mask">The mask</param>
        </member>
        <member name="M:Z0.z.vtestz(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            int _mm256_testz_si256 (__m256i a, __m256i b) VPTEST ymm, ymm/m256
            Returns true if all mask-identified source bits are off
            </summary>
            <param name="src">The bit source</param>
            <param name="mask">The mask</param>
        </member>
        <member name="M:Z0.z.vtestz(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            int _mm256_testz_si256 (__m256i a, __m256i b) VPTEST ymm, ymm/m256
            Returns true if all mask-identified source bits are off
            </summary>
            <param name="src">The bit source</param>
            <param name="mask">The mask</param>
        </member>
        <member name="M:Z0.z.vtestz(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            int _mm256_testz_si256 (__m256i a, __m256i b) VPTEST ymm, ymm/m256
            Returns true if all mask-identified source bits are off
            </summary>
            <param name="src">The bit source</param>
            <param name="mask">The mask</param>
        </member>
        <member name="M:Z0.z.vtestz(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            int _mm256_testz_si256 (__m256i a, __m256i b) VPTEST ymm, ymm/m256
            Returns true if all mask-identified source bits are off
            </summary>
            <param name="src">The bit source</param>
            <param name="mask">The mask</param>
        </member>
        <member name="M:Z0.z.vtestz(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            int _mm256_testz_si256 (__m256i a, __m256i b) VPTEST ymm, ymm/m256
            Returns true if all mask-identified source bits are off
            </summary>
            <param name="src">The bit source</param>
            <param name="mask">The mask</param>
        </member>
        <member name="M:Z0.z.vtestz(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            int _mm256_testz_si256 (__m256i a, __m256i b) VPTEST ymm, ymm/m256
            Returns true if all mask-identified source bits are off
            </summary>
            <param name="src">The bit source</param>
            <param name="mask">The mask</param>
        </member>
        <member name="M:Z0.z.vtestz(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            int _mm256_testz_si256 (__m256i a, __m256i b) VPTEST ymm, ymm/m256
            Returns true if all mask-identified source bits are off
            </summary>
            <param name="src">The bit source</param>
            <param name="mask">The mask</param>
        </member>
        <member name="M:Z0.z.vtestz(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            int _mm256_testz_ps (__m256 a, __m256 b) VTESTPS ymm, ymm/m256
            Determines whether all mask-specified source bits are off
            </summary>
            <param name="src">The bit source</param>
            <param name="mask">The mask</param>
        </member>
        <member name="M:Z0.z.vtestz(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            int _mm256_testz_pd (__m256d a, __m256d b) VTESTPD ymm, ymm/m256
            Determines whether all mask-specified source bits are off
            </summary>
            <param name="src">The bit source</param>
            <param name="mask">The mask</param>
        </member>
        <member name="M:Z0.z.vtestz(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            int _mm_testz_ps (__m128 a, __m128 b) VTESTPS xmm, xmm/m128
            Determines whether all mask-specified source bits are off
            </summary>
            <param name="src">The bit source</param>
            <param name="mask">The mask</param>
        </member>
        <member name="M:Z0.z.vtestz(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            int _mm_testz_pd (__m128d a, __m128d b) VTESTPD xmm, xmm/m128
            Determines whether all mask-specified source bits are off
            </summary>
            <param name="src">The bit source</param>
            <param name="mask">The mask</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vtestznc(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})" -->
        <member name="M:Z0.z.vtestznc(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            int _mm_testnzc_si128 (__m128i a, __m128i b) PTEST xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vtestznc(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            int _mm_testnzc_si128 (__m128i a, __m128i b)PTEST xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vtestznc(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            int _mm_testnzc_si128 (__m128i a, __m128i b)PTEST xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vtestznc(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            int _mm_testnzc_si128 (__m128i a, __m128i b)PTEST xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vtestznc(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            int _mm_testnzc_si128 (__m128i a, __m128i b)PTEST xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vtestznc(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            int _mm_testnzc_si128 (__m128i a, __m128i b)PTEST xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vtestznc(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            int _mm_testnzc_si128 (__m128i a, __m128i b)PTEST xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vtestznc(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            int _mm_testnzc_ps (__m128 a, __m128 b) VTESTPS xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vtestznc(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            int _mm_testnzc_pd (__m128d a, __m128d b) VTESTPD xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vtestznc(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            int _mm_testnzc_si128 (__m128i a, __m128i b) PTEST xmm, xmm/m128
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vtestznc(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            int _mm256_testnzc_si256 (__m256i a, __m256i b) VPTEST ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vtestznc(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            int _mm256_testnzc_si256 (__m256i a, __m256i b) VPTEST ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vtestznc(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            int _mm256_testnzc_si256 (__m256i a, __m256i b) VPTEST ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vtestznc(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            int _mm256_testnzc_si256 (__m256i a, __m256i b) VPTEST ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vtestznc(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            int _mm256_testnzc_si256 (__m256i a, __m256i b) VPTEST ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vtestznc(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            int _mm256_testnzc_si256 (__m256i a, __m256i b) VPTEST ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vtestznc(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            int _mm256_testnzc_si256 (__m256i a, __m256i b) VPTEST ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vtestznc(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            int _mm256_testnzc_ps (__m256 a, __m256 b) VTESTPS ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vtestznc(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            int _mm256_testnzc_pd (__m256d a, __m256d b)VTESTPD ymm, ymm/m256
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.z.vunits``1(Z0.N128,``0)">
            <summary>
            Creates a 128-bit vector where each component is of unit value
            </summary>
            <param name="w">The vector width selector</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.vunits``1(Z0.N256,``0)">
            <summary>
            Creates a 256-bit vector where each component is of unit value
            </summary>
            <param name="w">The vector width selector</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.vunpacklo(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_unpacklo_ps (__m128 a, __m128 b) UNPCKLPS xmm, xmm/m128
            Creates a 128-bit vector where the lower 64 bits are taken from the
            lower 64 bits of the first source vector and the higher 64 bits are taken
            from the lower 64 bits of the second source vector
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
        </member>
        <member name="M:Z0.z.vunpacklo(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_unpacklo_pd (__m128d a, __m128d b) UNPCKLPD xmm, xmm/m128
            Creates a 128-bit vector where the lower 64 bits are taken from the
            lower 64 bits of the first source vector and the higher 64 bits are taken
            from the lower 64 bits of the second source vector
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
        </member>
        <member name="M:Z0.z.vunpacklo(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_unpacklo_ps (__m256 a, __m256 b) VUNPCKLPS ymm, ymm, ymm/m256
            Creates a 256-bit vector where the lower 128 bits are taken from the
            lower 128 bits of the first source vector and the higher 128 bits are taken
            from the lower 128 bits of the second source vector
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
        </member>
        <member name="M:Z0.z.vunpacklo(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            __m256d _mm256_unpacklo_pd (__m256d a, __m256d b) VUNPCKLPD ymm, ymm, ymm/m256
            Creates a 256-bit vector where the lower 128 bits are taken from the
            lower 128 bits of the first source vector and the higher 128 bits are taken
            from the lower 128 bits of the second source vector
            </summary>
            <param name="x">The left source vector</param>
            <param name="y">The right source vector</param>
        </member>
        <member name="M:Z0.z.vxor1(System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            Computes the bitwise XOR between operands
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxor1(System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            Computes the bitwise XOR between operands
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxor1(System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            Computes the bitwise XOR between operands
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxor1(System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            Computes the bitwise XOR between operands
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxnor(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            Computes the bitwise XOR between operands
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxnor(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            Computes the bitwise XOR between operands
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxnor(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            Computes the bitwise XOR between operands
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxnor(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            Computes the bitwise XOR between operands
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxor(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            Computes the bitwise XOR between operands
            __m128i _mm_xor_si128 (__m128i a, __m128i b) PXOR xmm, xmm/m128
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxor(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            Computes the bitwise XOR between operands
            __m128i _mm_xor_si128 (__m128i a, __m128i b) PXOR xmm, xmm/m128
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxor(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            Computes the bitwise XOR between operands
            __m128i _mm_xor_si128 (__m128i a, __m128i b) PXOR xmm, xmm/m128
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxor(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            Computes the bitwise XOR between operands
            __m128i _mm_xor_si128 (__m128i a, __m128i b) PXOR xmm, xmm/m128
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxor(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            Computes the bitwise XOR between operands
            __m128i _mm_xor_si128 (__m128i a, __m128i b) PXOR xmm, xmm/m128
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxor(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            Computes the bitwise XOR between operands
            __m128i _mm_xor_si128 (__m128i a, __m128i b) PXOR xmm, xmm/m128
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxor(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            Computes the bitwise XOR between operands
            __m128i _mm_xor_si128 (__m128i a, __m128i b) PXOR xmm, xmm/m128
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxor(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            Computes the bitwise XOR between operands
            __m128i _mm_xor_si128 (__m128i a, __m128i b) PXOR xmm, xmm/m128
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxor(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            Computes the bitwise XOR between operands
            __m256i _mm256_xor_si256 (__m256i a, __m256i b) VPXOR ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxor(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            Computes the bitwise XOR between operands
            __m256i _mm256_xor_si256 (__m256i a, __m256i b) VPXOR ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxor(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            Computes the bitwise XOR between operands
            __m256i _mm256_xor_si256 (__m256i a, __m256i b) VPXOR ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxor(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            Computes the bitwise XOR between operands
            __m256i _mm256_xor_si256 (__m256i a, __m256i b) VPXOR ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxor(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            Computes the bitwise XOR between operands
            __m256i _mm256_xor_si256 (__m256i a, __m256i b) VPXOR ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxor(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            Computes the bitwise XOR between operands
            __m256i _mm256_xor_si256 (__m256i a, __m256i b) VPXOR ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxor(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            Computes the bitwise XOR between operands
            __m256i _mm256_xor_si256 (__m256i a, __m256i b) VPXOR ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxor(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            Computes the bitwise XOR between operands
            __m256i _mm256_xor_si256 (__m256i a, __m256i b) VPXOR ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxor(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            __m128 _mm_xor_ps (__m128 a, __m128 b) XORPS xmm, xmm/m128
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
        </member>
        <member name="M:Z0.z.vxor(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            __m128d _mm_xor_pd (__m128d a, __m128d b) XORPD xmm, xmm/m128
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
        </member>
        <member name="M:Z0.z.vxor(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            __m256 _mm256_xor_ps (__m256 a, __m256 b) VXORPS ymm, ymm, ymm/m256
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
        </member>
        <member name="M:Z0.z.vxor(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
             __m256 _mm256_xor_ps (__m256 a, __m256 b) VXORPS ymm, ymm, ymm/m256
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
        </member>
        <member name="M:Z0.z.vxor(System.Runtime.Intrinsics.Vector128{System.Single}@,System.Runtime.Intrinsics.Vector128{System.Single}@)">
            <summary>
            Computes the bitwise XOR between operands
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxor(System.Runtime.Intrinsics.Vector128{System.Double}@,System.Runtime.Intrinsics.Vector128{System.Double}@)">
            <summary>
            Computes the bitwise XOR between operands
            __m128d _mm_xor_pd (__m128d a, __m128d b) XORPD xmm, xmm/m128
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxor(System.Runtime.Intrinsics.Vector256{System.Single}@,System.Runtime.Intrinsics.Vector256{System.Single}@)">
            <summary>
            Computes the bitwise XOR between operands
            __m256 _mm256_xor_ps (__m256 a, __m256 b) VXORPS ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxor(System.Runtime.Intrinsics.Vector256{System.Double}@,System.Runtime.Intrinsics.Vector256{System.Double}@)">
            <summary>
            Computes the bitwise XOR between operands
            __m256d _mm256_xor_pd (__m256d a, __m256d b) VXORPS ymm, ymm, ymm/m256
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxornot(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            Computes x ^ ~y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxornot(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            Computes x ^ ~y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxornot(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            Computes x ^ ~y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxornot(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            Computes x ^ ~y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxornot(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            Computes x ^ ~y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxornot(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            Computes x ^ ~y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxornot(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            Computes x ^ ~y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxornot(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            Computes x ^ ~y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxornot(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            Computes x ^ ~y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxornot(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            Computes x ^ ~y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxornot(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            Computes x ^ ~y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxornot(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            Computes x ^ ~y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxornot(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            Computes x ^ ~y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxornot(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            Computes x ^ ~y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxornot(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            Computes x ^ ~y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxornot(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            Computes x ^ ~y for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxornot(System.Runtime.Intrinsics.Vector128{System.Single},System.Runtime.Intrinsics.Vector128{System.Single})">
            <summary>
            Computes XOR(x,NOT(y)) for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxornot(System.Runtime.Intrinsics.Vector128{System.Double},System.Runtime.Intrinsics.Vector128{System.Double})">
            <summary>
            Computes XOR(x,NOT(y)) for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxornot(System.Runtime.Intrinsics.Vector256{System.Single},System.Runtime.Intrinsics.Vector256{System.Single})">
            <summary>
            Computes XOR(x,NOT(y)) for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxornot(System.Runtime.Intrinsics.Vector256{System.Double},System.Runtime.Intrinsics.Vector256{System.Double})">
            <summary>
            Computes XOR(x,NOT(y)) for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vxorsl(System.Runtime.Intrinsics.Vector128{System.Byte},System.Byte)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vxorsl(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Byte)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vxorsl(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Byte)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vxorsl(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Byte)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vxorsl(System.Runtime.Intrinsics.Vector256{System.Byte},System.Byte)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vxorsl(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Byte)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vxorsl(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Byte)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vxorsl(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Byte)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vxorslv(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vxorslv(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vxorslv(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vxorslv(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})" -->
        <member name="M:Z0.z.vxorsr(System.Runtime.Intrinsics.Vector128{System.Byte},System.Byte)">
            <summary>
            Computes x^(x >> count)
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The amount by which to count each component</param>
        </member>
        <member name="M:Z0.z.vxorsr(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Byte)">
            <summary>
            Computes x^(x >> count)
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The amount by which to count each component</param>
        </member>
        <member name="M:Z0.z.vxorsr(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Byte)">
            <summary>
            Computes x^(x >> count)
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The amount by which to count each component</param>
        </member>
        <member name="M:Z0.z.vxorsr(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Byte)">
            <summary>
            Computes x^(x >> count)
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The amount by which to count each component</param>
        </member>
        <member name="M:Z0.z.vxorsr(System.Runtime.Intrinsics.Vector256{System.Byte},System.Byte)">
            <summary>
            Computes x^(x >> count)
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The amount by which to count each component</param>
        </member>
        <member name="M:Z0.z.vxorsr(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Byte)">
            <summary>
            Computes x^(x >> count)
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The amount by which to count each component</param>
        </member>
        <member name="M:Z0.z.vxorsr(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Byte)">
            <summary>
            Computes x^(x >> count)
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The amount by which to count each component</param>
        </member>
        <member name="M:Z0.z.vxorsr(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Byte)">
            <summary>
            Computes x^(x >> count)
            </summary>
            <param name="x">The source vector</param>
            <param name="count">The amount by which to count each component</param>
        </member>
        <member name="M:Z0.z.vxorsrv(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            Computes x^(x >> counts)
            </summary>
            <param name="x">The source vector</param>
            <param name="count">Specifies the count count for each corresponding component</param>
        </member>
        <member name="M:Z0.z.vxorsrv(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            Computes x^(x >> counts)
            </summary>
            <param name="x">The source vector</param>
            <param name="counts">Specifies the count count for each corresponding component</param>
        </member>
        <member name="M:Z0.z.vxorsrv(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            Computes x^(x >> counts)
            </summary>
            <param name="x">The source vector</param>
            <param name="counts">Specifies the count count for each corresponding component</param>
        </member>
        <member name="M:Z0.z.vxorsrv(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            Computes x^(x >> counts)
            </summary>
            <param name="x">The source vector</param>
            <param name="counts">Specifies the count count for each corresponding component</param>
        </member>
        <member name="M:Z0.z.vxnor(System.Runtime.Intrinsics.Vector128{System.SByte},System.Runtime.Intrinsics.Vector128{System.SByte})">
            <summary>
            Computes ~ (x ^ y) for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxnor(System.Runtime.Intrinsics.Vector128{System.Byte},System.Runtime.Intrinsics.Vector128{System.Byte})">
            <summary>
            Computes ~ (x ^ y) for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxnor(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16})">
            <summary>
            Computes ~ (x ^ y) for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxnor(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16})">
            <summary>
            Computes ~ (x ^ y) for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxnor(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32})">
            <summary>
            Computes ~ (x ^ y) for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxnor(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32})">
            <summary>
            Computes ~ (x ^ y) for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxnor(System.Runtime.Intrinsics.Vector128{System.Int64},System.Runtime.Intrinsics.Vector128{System.Int64})">
            <summary>
            Computes ~ (x ^ y) for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxnor(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64})">
            <summary>
            Computes ~ (x ^ y) for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxnor(System.Runtime.Intrinsics.Vector256{System.Byte},System.Runtime.Intrinsics.Vector256{System.Byte})">
            <summary>
            Computes ~ (x ^ y) for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxnor(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16})">
            <summary>
            Computes ~ (x ^ y) for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxnor(System.Runtime.Intrinsics.Vector256{System.SByte},System.Runtime.Intrinsics.Vector256{System.SByte})">
            <summary>
            Computes ~ (x ^ y) for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxnor(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16})">
            <summary>
            Computes the bitwise XOR between operands
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxnor(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32})">
            <summary>
            Computes ~ (x ^ y) for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxnor(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32})">
            <summary>
            Computes ~ (x ^ y) for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxnor(System.Runtime.Intrinsics.Vector256{System.Int64},System.Runtime.Intrinsics.Vector256{System.Int64})">
            <summary>
            Computes ~ (x ^ y) for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vxnor(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64})">
            <summary>
            Computes ~ (x ^ y) for vectors x and y
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.z.vzero``1(Z0.W128,``0)">
            <summary>
            Returns a 128-bit vector with all bits disabled
            </summary>
            <param name="w">The bitness selector</param>
            <typeparam name="T">The primal component type</typeparam>
        </member>
        <member name="M:Z0.z.vzero``1(Z0.W256,``0)">
            <summary>
            Returns a 256-bit vector with all bits disabled
            </summary>
            <param name="w">The bitness selector</param>
            <typeparam name="T">The primal component type</typeparam>
        </member>
        <member name="M:Z0.z.vzero``1(Z0.W512,``0)">
            <summary>
            Returns a 512-bit vector with all bits disabled
            </summary>
            <param name="w">The bitness selector</param>
            <typeparam name="T">The primal component type</typeparam>
        </member>
        <member name="M:Z0.z.vzip(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16},Z0.W8)">
            <summary>
            (8x16i,8x16i) -> 16x8i
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vzip(System.Runtime.Intrinsics.Vector128{System.Int16},System.Runtime.Intrinsics.Vector128{System.Int16},Z0.W8,Z0.N0)">
            <summary>
            (8x16i,8x16i) -> 16x8u
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="w">The target component width</param>
            <param name="z">Specifies a zero-extended target</param>
        </member>
        <member name="M:Z0.z.vzip(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16},Z0.W8)">
            <summary>
            (16x16i,16x16i) -> 32x8i
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vzip(System.Runtime.Intrinsics.Vector128{System.UInt16},System.Runtime.Intrinsics.Vector128{System.UInt16},Z0.W8)">
            <summary>
            (8x16u,8x16u) -> 16x8u
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vzip(System.Runtime.Intrinsics.Vector256{System.UInt16},System.Runtime.Intrinsics.Vector256{System.UInt16},Z0.W8)">
            <summary>
            (16x16u,16x16u) -> 32x8u
            </summary>
            <param name="x">The first source vector</param>
            <param name="y">The second source vector</param>
            <param name="dst">The target vector</param>
        </member>
        <member name="M:Z0.z.vzip(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32},Z0.W16)">
            <summary>
            (4x32i,4x32i) -> 8x16i
            </summary>
            <param name="x">The first source vector</param>
            <param name="y">The second source vector</param>
            <param name="w">The target vector width</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.z.vzip(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32},Z0.W16)" -->
        <member name="M:Z0.z.vzip(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32},Z0.W16)">
            <summary>
            (4x32u,4x32u) -> 8x16u
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vzip(System.Runtime.Intrinsics.Vector128{System.Int32},System.Runtime.Intrinsics.Vector128{System.Int32},Z0.W16,Z0.N0)">
             <summary>
            __m128i _mm_packus_epi32 (__m128i a, __m128i b)PACKUSDW xmm, xmm/m128 
             (4x32w,4x32w) -> 8x16w
             </summary>
             <param name="x">The left vector</param>
             <param name="y">The right vector</param>
             <param name="w">The target component width</param>
             <param name="w">Specifies a zero-extended target</param>
        </member>
        <member name="M:Z0.z.vzip(System.Runtime.Intrinsics.Vector256{System.Int16},System.Runtime.Intrinsics.Vector256{System.Int16},Z0.N8,Z0.N0)">
            <summary>
            __m256i _mm256_packus_epi16 (__m256i a, __m256i b)VPACKUSWB ymm, ymm, ymm/m256
            (16x8w,16x8w) -> 32x8w
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="w">The target component width</param>
            <param name="w">Specifies a zero-extended target</param>
        </member>
        <member name="M:Z0.z.vzip(System.Runtime.Intrinsics.Vector256{System.Int32},System.Runtime.Intrinsics.Vector256{System.Int32},Z0.N16,Z0.N0)">
            <summary>
            __m256i _mm256_packus_epi32 (__m256i a, __m256i b)VPACKUSDW ymm, ymm, ymm/m256
            (8x32w,8x32w) -> 16x16w
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="w">The target component width</param>
            <param name="w">Specifies a zero-extended target</param>
        </member>
        <member name="M:Z0.z.vzip(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32},Z0.W16)">
            <summary>
            (8x32w,8x32w) -> 16x16w
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="w">The target component width</param>
            <remarks>The vpackus intrinsic emits a vector in the following form: 
            [0, 1, 2, 3, 8, 9, 10, 11, 4, 5, 6, 7, 12, 13, 14, 15]
            To make use of the result, it must be permuted to a more reasonable order, 
            [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
            </remarks>
        </member>
        <member name="M:Z0.z.vzip(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32},Z0.W8)">
            <summary>
            (8x32u, 8x32u) -> 16x8u
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vzip(System.Runtime.Intrinsics.Vector128{System.UInt64},System.Runtime.Intrinsics.Vector128{System.UInt64},Z0.W32)">
            <summary>
            (2x64w,2x64w) -> 4x32w
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vzip(System.Runtime.Intrinsics.Vector256{System.UInt64},System.Runtime.Intrinsics.Vector256{System.UInt64},Z0.W32)">
            <summary>
            (4x64w,4x64w) -> 8x32w
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vzip(System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32},System.Runtime.Intrinsics.Vector128{System.UInt32},Z0.W8)">
            <summary>
            (4x32u,4x32u,4x32u,4x32u) -> 16x8u
            </summary>
            <param name="x0">The first source vector</param>
            <param name="x1">The second source vector</param>
            <param name="x2">The third source vector</param>
            <param name="x3">The fourth source vector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.vzip(System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32},System.Runtime.Intrinsics.Vector256{System.UInt32},Z0.W8)">
            <summary>
            (8x32u,8x32u,8x32u,8x32u) -> 32x8w
            </summary>
            <param name="x0">The first source vector</param>
            <param name="x1">The second source vector</param>
            <param name="x2">The third source vector</param>
            <param name="x3">The fourth source vector</param>
            <param name="w">The target component width</param>
        </member>
        <member name="M:Z0.z.as``2(``0@)">
            <summary>
            Presents an S-cell as a T-cell
            </summary>
            <param name="src">The source cell</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.z.as``2(``0@,``1@)">
            <summary>
            Presents an S-cell as a T-cell
            </summary>
            <param name="src">The source cell</param>
            <param name="src">The target cell</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.z.as``2(System.Runtime.Intrinsics.Vector128{``0}@,``1)">
            <summary>
            Reinterprets a vector over S-cells as a vector over T-cells
            </summary>
            <param name="x">The source vector</param>
            <param name="t">A target cell type representative</param>
            <typeparam name="S">The source cell type</typeparam>
            <typeparam name="T">The target cell type</typeparam>
        </member>
        <member name="M:Z0.z.as``2(System.Runtime.Intrinsics.Vector256{``0}@,``1)">
            <summary>
            Reinterprets a vector over S-cells as a vector over T-cells
            </summary>
            <param name="x">The source vector</param>
            <param name="t">A target cell type representative</param>
            <typeparam name="S">The source cell type</typeparam>
            <typeparam name="T">The target cell type</typeparam>
        </member>
        <member name="M:Z0.z.byte(System.Boolean)">
            <summary>
            Forcefully coerces a <see cref='T:System.Boolean'/> to a <see cref='T:System.Byte'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.char(System.Boolean)">
            <summary>
            Reimagines a boolean value as a character value
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.const``1(``0@,System.UInt32)">
            <summary>
            Captures a sized readonly parametric reference
            </summary>
            <param name="src">The source reference</param>
            <param name="count">The cell count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.cost``1(System.ReadOnlySpan{``0})">
            <summary>
            Captures a sized readonly parametric reference to source span content
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.const(System.String)">
            <summary>
            Captures a readonly character reference to source string content
            </summary>
            <param name="src">The source string</param>
        </member>
        <member name="M:Z0.z.delegate``1(System.IntPtr)">
            <summary>
            Forms a delagate from a function pointer
            </summary>
            <param name="pFunc"></param>
            <typeparam name="D">The target delegate type</typeparam>
        </member>
        <member name="M:Z0.z.enum``1(System.SByte)">
            <summary>
            Presents a <see cref='T:System.SByte'/> as an enumeration value
            </summary>
            <param name="src">The enum source value</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.z.enum``1(System.Byte@)">
            <summary>
            Presents a <see cref='T:System.Byte'/> as and enum value
            </summary>
            <param name="src">The enum source value</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.z.enum``1(System.UInt32)">
            <summary>
            Presents a <see cref='T:System.UInt32'/> as an enumeration value
            </summary>
            <param name="src">The enum source value</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="M:Z0.z.if``1(``0,System.Func{``0,System.Boolean},System.Func{``0,``0})">
            <summary>
            Applies a function to a source if a predicate evaluated over the source is true, otherwise returns the source as-is
            </summary>
            <typeparam name="T">The function input/output type</typeparam>
            <param name="criterion">The criterion on which to branch</param>
            <param name="src">The value to supply to the chosen function</param>
            <param name="true">The function to evaluate when the criterion is true</param>
        </member>
        <member name="M:Z0.z.int(System.Boolean)">
            <summary>
            Forcefully coerces a <see cref='T:System.Boolean'/> to a <see cref='T:System.Int32'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.int(System.Single)">
            <summary>
            Forcefully coerces a <see cref='T:System.Single'/> to a <see cref='T:System.Int32'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.long(System.Boolean)">
            <summary>
            Converts a <see cref='T:System.Boolean'/> to a <see cref='T:System.Int64'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.null``1(``0)">
            <summary>
            Returns true if the source is null
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.notnull``1(``0)">
            <summary>
            Returns true if the source is non-null
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.readonly``1(System.Span{``0})">
            <summary>
            Reflects the immutable self
            </summary>
            <param name="src">The self</param>
            <typeparam name="T">The self cell type</typeparam>
        </member>
        <member name="M:Z0.z.readonly``1(``0[])">
            <summary>
            Reflects the content of an array as a readonly span
            </summary>
            <param name="src">The source array</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.readonly``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Constructs a span from a (presumeably finite) sequence selection
            </summary>
            <param name="src">The source sequence</param>
            <param name="offset">The number of elements to skip from the head of the sequence</param>
            <param name="length">The number of elements to take from the sequence</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.z.ref``1(Z0.W8,``0@)">
            <summary>
            Presents a T-reference as a byte reference and effects mov rax,rdx for all T
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The source type</typeparam>
            <remarks>For all T, effects: mov rax,rdx</remarks>
        </member>
        <member name="M:Z0.z.ref``1(Z0.W16,``0@)">
            <summary>
            Presents a T-reference as a byte reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The source type</typeparam>
            <remarks>For all T, effects: mov rax,rdx</remarks>
        </member>
        <member name="M:Z0.z.ref``1(Z0.W32,``0@)">
            <summary>
            Presents a T-reference as a byte reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The source type</typeparam>
            <remarks>For all T, effects: mov rax,rdx</remarks>
        </member>
        <member name="M:Z0.z.ref``1(Z0.W64,``0@)">
            <summary>
            Presents a T-reference as a uint64 reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The source type</typeparam>
            <remarks>For all T, effects: mov rax,rdx</remarks>
        </member>
        <member name="M:Z0.z.ref(System.String)">
            <summary>
            Creates a reference to a string
            </summary>
            <param name="src">The source string</param>
        </member>
        <member name="M:Z0.z.ref(System.String,System.UInt32)">
            <summary>
            Creates a reference to a string that includes 32 bits of arbitrary data
            </summary>
            <param name="src">The source string</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.z.ref(Z0.StringRef@)" -->
        <member name="M:Z0.z.ref``1(``0*)">
            <summary>
            Presents a pointer as a reference
            </summary>
            <param name="ptr">The source pointer</param>
            <typeparam name="T">The reference type</typeparam>
            <remarks>For all T, effects: mov rax,rcx</remarks>
        </member>
        <member name="M:Z0.z.ref``1(System.Void*)">
            <summary>
            Presents a void pointer as a reference
            </summary>
            <param name="pSrc">The source pointer</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.z.ref``1(Z0.MemoryAddress)">
            <summary>
            Returns a reference to an identified location
            </summary>
            <param name="src">The source address</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.z.ref``2(``0*)">
            <summary>
            Presents an S-pointer as a T-reference
            </summary>
            <param name="pSrc">The source pointer</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.z.sbyte(System.Boolean)">
            <summary>
            Converts a <see cref='T:System.Boolean'/> to a <see cref='T:System.SByte'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.short(System.Boolean)">
            <summary>
            Forcefully coerces a <see cref='T:System.Boolean'/> to a <see cref='T:System.Int16'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.Try``1(System.Func{``0},System.Action{System.Exception})">
            <summary>
            Evaluates a function within a try block and returns the value of the computation if
            successful; otherwise, returns None and invokes an error handler if supplied
            </summary>
            <typeparam name="T">The result type</typeparam>
            <param name="f">The function to evaluate</param>
        </member>
        <member name="M:Z0.z.Try``1(System.Func{Z0.Option{``0}},System.Action{System.Exception})">
            <summary>
            Evaluates a function within a try block and returns the value of the computation if
            successful; otherwise, returns None together with the reported exception
            </summary>
            <param name="f">The function to evaluate</param>
            <typeparam name="T">The function result type, if successful</typeparam>
        </member>
        <member name="M:Z0.z.Try(System.Action,System.Action{System.Exception})">
            <summary>
            Invokes an action within a try block and, upon error, calls the handler if specified.
            If no handler is specified, the exception message is emitted to stderr
            </summary>
            <param name="f">The action to invoke</param>
            <param name="onerror">The error handler to call, if specified</param>
        </member>
        <member name="M:Z0.z.Try``2(``0,System.Func{``0,``1},System.Action{``0,System.Exception})">
            <summary>
            Evaluates a function within a try block and returns the value of the computation if successful.
            Otherwise, returns None together with the reported exception
            </summary>
            <typeparam name="X">The input type</typeparam>
            <typeparam name="Y">The output type</typeparam>
            <param name="x">The input value</param>
            <param name="f">The function to evaluate</param>
        </member>
        <member name="M:Z0.z.uint(System.Boolean)">
            <summary>
            Converts a <see cref='T:System.Boolean'/> to a <see cref='T:System.UInt32'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.ulong(System.Boolean)">
            <summary>
            Converts a <see cref='T:System.Boolean'/> to a <see cref='T:System.UInt64'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.ulong(System.Double)">
            <summary>
            Converts a <see cref='T:System.Double'/> to a <see cref='T:System.UInt64'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.ulong(System.Decimal)">
            <summary>
            Converts a <see cref='T:System.Decimal'/> to a <see cref='T:System.UInt64'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.ushort(System.Boolean)">
            <summary>
            Converts a <see cref='T:System.Boolean'/> to a <see cref='T:System.UInt16'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.add8``1(``0@,System.UInt32)">
            <summary>
            Adds a specified byte count to a reference
            </summary>
            <param name="src">The source reference</param>
            <param name="count">The number of bytes to add</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.z.add8``1(``0@)">
            <summary>
            Adds a an offset of 1 byte to a reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.z.add``1(``0@,Z0.N1)">
            <summary>
            Adds a an offset of 1 byte to a reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.z.add``1(``0@,Z0.N2)">
            <summary>
            Adds a an offset of 2 bytes to a reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.z.add``1(``0@,Z0.N3)">
            <summary>
            Adds a an offset of 3 bytes to a reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.z.add``1(``0@,Z0.N4)">
            <summary>
            Adds a an offset of 4 bytes to a reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.z.add``1(``0@,Z0.N5)">
            <summary>
            Adds a an offset of 5 bytes to a reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.z.add``1(``0@,Z0.N6)">
            <summary>
            Adds a an offset of 6 bytes to a reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.z.add``1(``0@,Z0.N7)">
            <summary>
            Adds a an offset of 7 bytes to a reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.z.address(System.Type)">
            <summary>
            Derives the address of a <see cref='T:System.Type'/> from the value of its <see cref='P:System.Type.TypeHandle' />
            </summary>
            <param name="src">The source type</param>
        </member>
        <member name="M:Z0.z.address(System.UInt64)">
            <summary>
            Presents a uint64 as an address
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.address(Z0.StringRef@)">
            <summary>
            Extracts the address captured by a <see cref='T:Z0.StringRef'/>
            </summary>
            <param name="src">The source reference</param>
        </member>
        <member name="M:Z0.z.address(Z0.Ref)">
            <summary>
            Defines an address predicated on the leading source cell
            </summary>
            <param name="src">The data source</param>
        </member>
        <member name="M:Z0.z.address(System.String)">
            <summary>
            Returns the address of the first character in the source string
            </summary>
            <param name="src">The source string</param>
        </member>
        <member name="M:Z0.z.address``1(``0@)">
            <summary>
            Determines the address of a reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.address``1(``0[])">
            <summary>
            Determines the address of the leading source cell
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.address``1(``0[],System.Int32)">
            <summary>
            Determines the address of a cell in an array
            </summary>
            <param name="src">The source array</param>
            <param name="index">The cell index</param>
            <typeparam name="T">The stored type</typeparam>
        </member>
        <member name="M:Z0.z.apply``1(System.ReadOnlySpan{``0},Z0.UnaryOp{``0},System.Span{``0})">
            <summary>
            Applies a unary operator to an input sequence and deposits the result to a caller-supplied target
            </summary>
            <param name="src">The source</param>
            <param name="f">The operator</param>
            <typeparam name="T">The operand type</typeparam>        
        </member>
        <member name="M:Z0.z.apply``1(System.ReadOnlySpan{``0},System.ReadOnlySpan{``0},Z0.BinaryOp{``0},System.Span{``0})">
            <summary>
            Projects a pair of source spans to target span via a binary operator
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
            <param name="f">The operator</param>
            <typeparam name="T">The operand type</typeparam>        
        </member>
        <member name="M:Z0.z.array``1(System.Span{``0})">
            <summary>
            Produces an array from a span
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Z0.z.array``1(System.Collections.Generic.List{``0})">
            <summary>
            Produces an array from a list
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The item type</typeparam>
        </member>
        <member name="M:Z0.z.atomic(System.Int32@)">
            <summary>
            Atomically increments a value in-place
            </summary>
            <param name="src">The value to increment in-place</param>
        </member>
        <member name="M:Z0.z.atomic(System.Int64@)">
            <summary>
            Atomically increments a value in-place
            </summary>
            <param name="src">The value to increment in-place</param>
        </member>
        <member name="M:Z0.z.between(System.UInt64,System.UInt64,System.UInt64)">
            <summary>
            Determines whether a test point is within an interval defined by inclusive lower/upper bounds
            </summary>
            <param name="test">The point to test</param>
            <param name="min">The inclusive lower bound</param>
            <param name="max">The inclusive upper bound</param>
        </member>
        <member name="M:Z0.z.bind``2(Z0.Option{``0},System.Func{``0,Z0.Option{``1}})">
            <summary>
            Implements the canonical bind operation
            </summary>
            <typeparam name="X">The source domain type</typeparam>
            <typeparam name="Y">The target domain type</typeparam>
            <param name="x">The point in the monadic space over X</param>
            <param name="f">The function to apply to effect the bind</param>
        </member>
        <member name="M:Z0.z.bitwidth``1(Z0.W8,``0)">
            <summary>
            Computes the bit-width of a parametrically-identified type
            </summary>
            <param name="w">The result width selector</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.bitwidth``1(Z0.W16,``0)">
            <summary>
            Computes the bit-width of a parametrically-identified type
            </summary>
            <param name="w">The result width selector</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.bitwidth``1(Z0.W32,``0)">
            <summary>
            Computes the bit-width of a parametrically-identified type
            </summary>
            <param name="w">The result width selector</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.bitwidth``1(Z0.W64,``0)">
            <summary>
            Computes the bit-width of a parametrically-identified type
            </summary>
            <param name="w">The result width selector</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.bitsize``1">
            <summary>
            Computes the bit-width of a parametrically-identified type
            </summary>
            <param name="w">The result width selector</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.bitstate(System.Boolean)">
            <summary>
            Converts a <see cref='T:System.Boolean' /> to a <see cref='T:Z0.BitState' />
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.bitstream``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a bistream over a T-stream
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.blocklength``1(Z0.W8)">
            <summary>
            Computes the number of cells that comprise a single 8-bit block
            </summary>
            <param name="w">The block width selector</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.blocklength``1(Z0.W16)">
            <summary>
            Computes the number of cells that comprise a single 16-bit block
            </summary>
            <param name="w">The block width selector</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.blocklength``1(Z0.W32)">
            <summary>
            Computes the number of cells that comprise a single 32-bit block
            </summary>
            <param name="w">The block width selector</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.blocklength``1(Z0.W64)">
            <summary>
            Computes the number of cells that comprise a single 64-bit block
            </summary>
            <param name="w">The block width selector</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.blocklength``1(Z0.W128)">
            <summary>
            Computes the number of cells that comprise a single 128-bit block
            </summary>
            <param name="w">The block width selector</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.blocklength``1(Z0.W256)">
            <summary>
            Computes the number of elements that comprise a 256-bit block
            </summary>
            <param name="w">The block width selector</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.blocklength``1(Z0.W512)">
            <summary>
            Computes the number of elements that comprise a 512-bit block
            </summary>
            <param name="w">The block width selector</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.blocklength``2">
            <summary>
            Computes the number of T-cells that comprise an N-block
            </summary>
            <param name="w">The block width representative</param>
            <param name="t">The cell type representative</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.blockref``1(Z0.SpanBlock8{``0}@,System.Int32)">
            <summary>
            Returns a reference to the leading cell of an index-identified block
            </summary>
            <param name="src">The blocked container</param>
            <param name="index">The block index, a number in the range 0..k-1 where k is the total number of covered blocks</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.blockref``1(Z0.SpanBlock16{``0}@,System.Int32)">
            <summary>
            Returns a reference to the leading cell of an index-identified block
            </summary>
            <param name="src">The blocked container</param>
            <param name="index">The block index, a number in the range 0..k-1 where k is the total number of covered blocks</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.blockref``1(Z0.SpanBlock32{``0}@,System.Int32)">
            <summary>
            Returns a reference to the leading cell of an index-identified block
            </summary>
            <param name="src">The blocked container</param>
            <param name="index">The block index, a number in the range 0..k-1 where k is the total number of covered blocks</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.blockref``1(Z0.SpanBlock64{``0}@,System.Int32)">
            <summary>
            Returns a reference to the leading cell of an index-identified block
            </summary>
            <param name="src">The blocked container</param>
            <param name="index">The block index, a number in the range 0..k-1 where k is the total number of covered blocks</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.blockref``1(Z0.SpanBlock128{``0}@,System.Int32)">
            <summary>
            Returns a reference to the leading cell of an index-identified block
            </summary>
            <param name="src">The blocked container</param>
            <param name="index">The block index, a number in the range 0..k-1 where k is the total number of covered blocks</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.blockref``1(Z0.SpanBlock256{``0}@,System.Int32)">
            <summary>
            Returns a reference to the leading cell of an index-identified block
            </summary>
            <param name="src">The blocked container</param>
            <param name="index">The block index, a number in the range 0..k-1 where k is the total number of covered blocks</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.blockref``1(Z0.SpanBlock512{``0}@,System.Int32)">
            <summary>
            Returns a reference to the leading cell of an index-identified block
            </summary>
            <param name="src">The blocked container</param>
            <param name="index">The block index, a number in the range 0..k-1 where k is the total number of covered blocks</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.box(System.Int16,Z0.NumericKind)">
            <summary>
            Converts a numeric source value to a boxed numeric value of specified kind
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target kind</param>
        </member>
        <member name="M:Z0.z.box(System.UInt16,Z0.NumericKind)">
            <summary>
            Converts a numeric source value to a boxed numeric value of specified kind
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target kind</param>
        </member>
        <member name="M:Z0.z.box(System.Single,Z0.NumericKind)">
            <summary>
            Converts a numeric source value to a boxed numeric value of specified kind
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target kind</param>
        </member>
        <member name="M:Z0.z.box(System.Int32,Z0.NumericKind)">
            <summary>
            Converts a numeric source value to a boxed numeric value of specified kind
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target kind</param>
        </member>
        <member name="M:Z0.z.box(System.UInt32,Z0.NumericKind)">
            <summary>
            Converts a numeric source value to a boxed numeric value of specified kind
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target kind</param>
        </member>
        <member name="M:Z0.z.box(System.Double,Z0.NumericKind)">
            <summary>
            Converts a numeric source value to a boxed numeric value of specified kind
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target kind</param>
        </member>
        <member name="M:Z0.z.box(System.Int64,Z0.NumericKind)">
            <summary>
            Converts a numeric source value to a boxed numeric value of specified kind
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target kind</param>
        </member>
        <member name="M:Z0.z.box(System.UInt64,Z0.NumericKind)">
            <summary>
            Converts a numeric source value to a boxed numeric value of specified kind
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target kind</param>
        </member>
        <member name="M:Z0.z.box(System.SByte,Z0.NumericKind)">
            <summary>
            Converts a numeric source value to a boxed numeric value of specified kind
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target kind</param>
        </member>
        <member name="M:Z0.z.box(System.Byte,Z0.NumericKind)">
            <summary>
            Converts a numeric source value to a boxed numeric value of specified kind
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target kind</param>
        </member>
        <member name="M:Z0.z.ifNotNull``2(``0,System.Func{``0,``1},``1)">
            <summary>
            Evaluates a function over a value if the value is not null; otherwise, returns the default result value
            </summary>
            <typeparam name="X">The operand type</typeparam>
            <typeparam name="Y">The return type</typeparam>
            <param name="x">The operand</param>
            <param name="f1">The function to potentially evaluate</param>
        </member>
        <member name="M:Z0.z.branch``2(``0,System.Func{``0,System.Boolean},System.Func{``0,``1},System.Func{``0,``1})">
            <summary>
            Executes one of two functions depending on the evaluation criterion
            </summary>
            <param name="x">The value to supply to the predicate and one of the handlers</param>
            <param name="bool">The predicate to evalue to determine which function will map the value</param>
            <param name="true">The function to evaluate when the criterion is true</param>
            <param name="false">The function to evaluate when the criterion is false</param>
            <typeparam name="X">The function input type</typeparam>
            <typeparam name="Y">The function output type</typeparam>
        </member>
        <member name="M:Z0.z.branch(System.Boolean,System.Action,System.Action)">
            <summary>
            Executes one action if a condition is true and another should it be false
            </summary>
            <param name="condition">Specifies whether some condition is true</param>
            <param name="true">The action to invoke when condition is true</param>
            <param name="false">The action to invoke when condition is false</param>
        </member>
        <member name="M:Z0.z.broadcast(System.UInt16,Z0.N32)">
            <summary>
            Replicates a 16-bit source over a 32-bit target
            </summary>
            <param name="src">The source value</param>
            <param name="w">The target width</param>
        </member>
        <member name="M:Z0.z.broadcast(System.Byte,Z0.N64)">
            <summary>
            Replicates an 8-bit source over a 64-bit target
            </summary>
            <param name="src">The source value</param>
            <param name="w">The target width</param>
        </member>
        <member name="M:Z0.z.broadcast(System.UInt16,Z0.N64)">
            <summary>
            Replicates a 16-bit source over a 64-bit target
            </summary>
            <param name="src">The source value</param>
            <param name="w">The target width</param>
        </member>
        <member name="M:Z0.z.broadcast(System.UInt32,Z0.N64)">
            <summary>
            Replicates a 32-bit source over a 64-bit target
            </summary>
            <param name="src">The source value</param>
            <param name="w">The target width</param>
        </member>
        <member name="M:Z0.z.bytehash``1(``0)">
            <summary>
            Calculates a hash code for structured content and returns the content along with the calculated hash
            </summary>
            <param name="src">The source content</param>
            <typeparam name="C">The content type</typeparam>
        </member>
        <member name="M:Z0.z.bytes``1(``0@)">
            <summary>
            Presents a generic value as a bytespan
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The source value type</typeparam>
        </member>
        <member name="M:Z0.z.bytes``1(System.Span{``0})">
            <summary>
            Presents a span of generic values as bytespan
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source cell type</typeparam>
        </member>
        <member name="M:Z0.z.bytes``1(System.ReadOnlySpan{``0})">
            <summary>
            Presents a readonly span over T-cells as a readonly bytespan
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The source cell type</typeparam>
        </member>
        <member name="M:Z0.z.bytes``1(System.Span{``0},System.Int32)">
            <summary>
            Presents a selected segment of T-cells from a source span as a readonly bytespan
            </summary>
            <param name="src">The source span</param>
            <param name="offset">The source offset</param>
            <param name="length">The source length</param>
            <typeparam name="T">The source cell type</typeparam>
        </member>
        <member name="M:Z0.z.bytes``1(System.Span{``0},System.Int32,System.Int32)">
            <summary>
            Converts a specified number of source elements to bytes
            </summary>
            <param name="src">The data source</param>
            <param name="offset">The source offset</param>
            <param name="count">The number of source elements to convert</param>
            <typeparam name="T">The source element type</typeparam>
        </member>
        <member name="M:Z0.z.bytes``1(System.Span{``0},System.Int32,System.Nullable{System.Int32})">
            <summary>
            Converts a specified number of source elements to bytes
            </summary>
            <param name="src">The data source</param>
            <param name="offset">The source offset</param>
            <param name="count">The number of source elements to convert</param>
            <typeparam name="T">The source element type</typeparam>
        </member>
        <member name="M:Z0.z.bytes``1(System.ReadOnlySpan{``0},System.Int32,System.Int32)">
            <summary>
            Converts a specified number of source elements to bytes
            </summary>
            <param name="src">The data source</param>
            <param name="offset">The source offset</param>
            <param name="count">The number of source elements to convert</param>
            <typeparam name="T">The source element type</typeparam>
        </member>
        <member name="M:Z0.z.bytes``1(System.ReadOnlySpan{``0},System.Int32)">
            <summary>
            Presents a selected segment of a readonly span over T-cells as a readonly bytespan
            </summary>
            <param name="src">The source span</param>
            <param name="offset">The source offset</param>
            <param name="length">The source length</param>
            <typeparam name="T">The source cell type</typeparam>
        </member>
        <member name="M:Z0.z.c16``1(``0@)">
            <summary>
            Presents a parametric reference as a <see cref='T:System.Char'/> reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.c16``1(``0@,System.Int32)">
            <summary>
            Adds a char-measured offset to a parametric reference and presents the result as a <see cref='T:System.Char'/> reference
            </summary>
            <param name="src">The source reference</param>
            <param name="offset">The offset count, measured in characters</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.cell``1(System.ReadOnlySpan{System.Byte})">
            <summary>
            Reads a generic value from the head of a source span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The value type</typeparam>
        </member>
        <member name="M:Z0.z.cell``1(System.ReadOnlySpan{System.Byte},System.Int32)">
            <summary>
            Reads a generic value beginning at a specified offset
            </summary>
            <param name="src">The source span</param>
            <param name="offset">The index at which span consumption should begin</param>
            <typeparam name="T">The value type</typeparam>
        </member>
        <member name="M:Z0.z.cell``1(System.Span{System.Byte})">
            <summary>
            Reads a generic value from the head of a source span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The value type</typeparam>
        </member>
        <member name="M:Z0.z.cell``1(System.Span{System.Byte},System.UInt32)">
            <summary>
            Reads an unmanaged generic value from a bytespan beginning at a specified offset
            </summary>
            <param name="src">The source value</param>
            <param name="offset">The source array offset</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.concat``1(``0[],``0[])">
            <summary>
            Concatentates two arrays
            </summary>
            <param name="left">The first array</param>
            <param name="right">The second array</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.concat(System.Byte[],System.Byte[])">
            <summary>
            Concatentates two byte arrays
            </summary>
            <param name="left">The first array</param>
            <param name="right">The second array</param>
        </member>
        <member name="M:Z0.z.concat``1(``0[][])">
            <summary>
            Concatenates a sequence of parameter arrays
            </summary>
            <param name="src">The source arrays</param>
        </member>
        <member name="M:Z0.z.convert``2(System.ReadOnlySpan{``0}@,System.Span{``1}@)">
            <summary>
            Applies the unconditional numeric conversion S -> T for each source element
            </summary>
            <param name="src">The source span</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.z.convert``2(System.Span{``0})">
            <summary>
            Applies the unconditional conversion S -> T for each source element
            </summary>
            <param name="src">The source span</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.z.convert``2(System.ReadOnlySpan{``0})">
            <summary>
            Converts values in the source to values of the target type
            </summary>
            <param name="src">The source values</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.z.convert``1(System.ReadOnlySpan{System.SByte},System.Span{``0})">
            <summary>
            Transforms values from a source span to an allocated target span with cells of parametric numeric kind
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The target numeric kind</typeparam>
        </member>
        <member name="M:Z0.z.convert``1(System.ReadOnlySpan{System.Byte},System.Span{``0})">
            <summary>
            Transforms values from a source span to an allocated target span with cells of parametric numeric kind
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The target numeric kind</typeparam>
        </member>
        <member name="M:Z0.z.convert``1(System.ReadOnlySpan{System.Int16},System.Span{``0})">
            <summary>
            Transforms values from a source span to an allocated target span with cells of parametric numeric kind
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The target numeric kind</typeparam>
        </member>
        <member name="M:Z0.z.convert``1(System.ReadOnlySpan{System.UInt16},System.Span{``0})">
            <summary>
            Transforms values from a source span to an allocated target span with cells of parametric numeric kind
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The target numeric kind</typeparam>
        </member>
        <member name="M:Z0.z.convert``1(System.ReadOnlySpan{System.Int32},System.Span{``0})">
            <summary>
            Transforms values from a source span to an allocated target span with cells of parametric numeric kind
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The target numeric kind</typeparam>
        </member>
        <member name="M:Z0.z.convert``1(System.ReadOnlySpan{System.UInt32},System.Span{``0})">
            <summary>
            Transforms values from a source span to an allocated target span with cells of parametric numeric kind
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The target numeric kind</typeparam>
        </member>
        <member name="M:Z0.z.convert``1(System.ReadOnlySpan{System.Int64},System.Span{``0})">
            <summary>
            Transforms values from a source span to an allocated target span with cells of parametric numeric kind
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The target numeric kind</typeparam>
        </member>
        <member name="M:Z0.z.convert``1(System.ReadOnlySpan{System.Single},System.Span{``0})">
            <summary>
            Transforms values from a source span to an allocated target span with cells of parametric numeric kind
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The target numeric kind</typeparam>
        </member>
        <member name="M:Z0.z.convert``1(System.ReadOnlySpan{System.Double},System.Span{``0})">
            <summary>
            Transforms values from a source span to an allocated target span with cells of parametric numeric kind
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The target numeric kind</typeparam>
        </member>
        <member name="M:Z0.z.convert``1(System.ReadOnlySpan{System.SByte})">
            <summary>
            Transforms values from a source span to an allocated target span with cells of parametric numeric kind
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The target numeric kind</typeparam>
        </member>
        <member name="M:Z0.z.convert``1(System.ReadOnlySpan{System.Byte})">
            <summary>
            Transforms values from a source span to an allocated target span with cells of parametric numeric kind
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The target numeric kind</typeparam>
        </member>
        <member name="M:Z0.z.convert``1(System.ReadOnlySpan{System.Int16})">
            <summary>
            Transforms values from a source span to an allocated target span with cells of parametric numeric kind
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The target numeric kind</typeparam>
        </member>
        <member name="M:Z0.z.convert``1(System.ReadOnlySpan{System.UInt16})">
            <summary>
            Transforms values from a source span to an allocated target span with cells of parametric numeric kind
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The target numeric kind</typeparam>
        </member>
        <member name="M:Z0.z.transform``1(System.ReadOnlySpan{System.Int32})">
            <summary>
            Transforms values from a source span to an allocated target span with cells of parametric numeric kind
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The target numeric kind</typeparam>
        </member>
        <member name="M:Z0.z.convert``1(System.ReadOnlySpan{System.UInt32})">
            <summary>
            Transforms values from a source span to an allocated target span with cells of parametric numeric kind
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The target numeric kind</typeparam>
        </member>
        <member name="M:Z0.z.convert``1(System.ReadOnlySpan{System.Int64})">
            <summary>
            Transforms values from a source span to an allocated target span with cells of parametric numeric kind
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The target numeric kind</typeparam>
        </member>
        <member name="M:Z0.z.convert``1(System.ReadOnlySpan{System.UInt64})">
            <summary>
            Transforms values from a source span to an allocated target span with cells of parametric numeric kind
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The target numeric kind</typeparam>
        </member>
        <member name="M:Z0.z.convert``1(System.ReadOnlySpan{System.Single})">
            <summary>
            Transforms values from a source span to an allocated target span with cells of parametric numeric kind
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The target numeric kind</typeparam>
        </member>
        <member name="M:Z0.z.convert``1(System.ReadOnlySpan{System.Double})">
            <summary>
            Transforms values from a source span to an allocated target span with cells of parametric numeric kind
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The target numeric kind</typeparam>
        </member>
        <member name="M:Z0.z.convert``1(System.Span{System.SByte})">
            <summary>
            Transforms values from a source span to an allocated target span with cells of parametric numeric kind
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The target numeric kind</typeparam>
        </member>
        <member name="M:Z0.z.convert``1(System.Span{System.Byte})">
            <summary>
            Transforms values from a source span to an allocated target span with cells of parametric numeric kind
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The target numeric kind</typeparam>
        </member>
        <member name="M:Z0.z.convert``1(System.Span{System.Int16})">
            <summary>
            Transforms values from a source span to an allocated target span with cells of parametric numeric kind
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The target numeric kind</typeparam>
        </member>
        <member name="M:Z0.z.convert``1(System.Span{System.UInt16})">
            <summary>
            Transforms values from a source span to an allocated target span with cells of parametric numeric kind
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The target numeric kind</typeparam>
        </member>
        <member name="M:Z0.z.convert``1(System.Span{System.Int32})">
            <summary>
            Transforms values from a source span to an allocated target span with cells of parametric numeric kind
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The target numeric kind</typeparam>
        </member>
        <member name="M:Z0.z.convert``1(System.Span{System.UInt32})">
            <summary>
            Transforms values from a source span to an allocated target span with cells of parametric numeric kind
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The target numeric kind</typeparam>
        </member>
        <member name="M:Z0.z.transform``1(System.Span{System.Int64})">
            <summary>
            Transforms values from a source span to an allocated target span with cells of parametric numeric kind
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The target numeric kind</typeparam>
        </member>
        <member name="M:Z0.z.convert``1(System.Span{System.UInt64})">
            <summary>
            Transforms values from a source span to an allocated target span with cells of parametric numeric kind
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The target numeric kind</typeparam>
        </member>
        <member name="M:Z0.z.convert``1(System.Span{System.Single})">
            <summary>
            Transforms values from a source span to an allocated target span with cells of parametric numeric kind
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The target numeric kind</typeparam>
        </member>
        <member name="M:Z0.z.convert``1(System.Span{System.Double})">
            <summary>
            Transforms values from a source span to an allocated target span with cells of parametric numeric kind
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The target numeric kind</typeparam>
        </member>
        <member name="M:Z0.z.copy``1(``0@,System.Void*)">
            <summary>
            Copies a reference-identified cell to a pointer-identified target
            </summary>
            <param name="src">The data source</param>
            <param name="pDst">The target</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.copy``1(``0@,``0*)">
            <summary>
            Copies a reference-identified cell to a pointer-identified target
            </summary>
            <param name="src">The data source</param>
            <param name="pDst">The target</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.copy``2(``0@,``1@,System.UInt32,System.UInt32)">
            <summary>
            Copies a specified number of source values to the target and returns the count of copied bytes
            </summary>
            <param name="src">The source reference</param>
            <param name="srcCount">The number of source values to copy</param>
            <param name="dst">The target reference</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.z.copy``2(System.ReadOnlySpan{``0},System.UInt32,System.UInt32,System.Span{``1},System.UInt32)">
            <summary>
            Copies a specified number source cells to the target and returns the count of copied bytes
            </summary>
            <param name="src">The data source</param>
            <param name="start">The source start index</param>
            <param name="count">The source cell count</param>
            <param name="dst">The data target</param>
            <param name="offset">The target offset</param>
            <typeparam name="S">The source cell type</typeparam>
            <typeparam name="T">The target cell type</typeparam>
        </member>
        <member name="M:Z0.z.copy``2(System.Span{``0},System.UInt32,System.UInt32,System.Span{``1},System.UInt32)">
            <summary>
            Copies a specified number source cells to the target and returns the count of copied bytes
            </summary>
            <param name="src">The data source</param>
            <param name="start">The source start index</param>
            <param name="count">The source cell count</param>
            <param name="dst">The data target</param>
            <param name="offset">The target offset</param>
            <typeparam name="S">The source cell type</typeparam>
            <typeparam name="T">The target cell type</typeparam>
        </member>
        <member name="M:Z0.z.count``1(Z0.SegRef@)">
            <summary>
            Computes the whole number of T-cells identified by a reference
            </summary>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.counter(System.Boolean)">
            <summary>
            Allocates and optionally starts a system counter
            </summary>
        </member>
        <member name="M:Z0.z.cover``1(Z0.MemoryAddress,System.UInt32)">
            <summary>
            Covers T-parametric content beginning at a specified address with a span
            </summary>
            <param name="address">The source address</param>
            <param name="count">The number of cells to cover</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.cover(Z0.MemoryAddress,System.UInt32)">
            <summary>
            Covers content beginning at a specified address with a bytespan
            </summary>
            <param name="location">The source address</param>
            <param name="size">The number of bytes to cover</param>
        </member>
        <member name="M:Z0.z.delay(System.TimeSpan)">
            <summary>
            Returns after specified duration has elapsed
            </summary>
            <param name="duration">The time to wait before returning</param>
        </member>
        <member name="M:Z0.z.delayAsync(System.TimeSpan)">
            <summary>
            Introduces an asynchronous delay
            </summary>
            <param name="duration">The length of the delay to introduce</param>
        </member>
        <member name="M:Z0.z.dict``2">
            <summary>
            Initializes an empty dictionary
            </summary>
            <typeparam name="K">The key type</typeparam>
            <typeparam name="V">The vale type</typeparam>
        </member>
        <member name="M:Z0.z.dict``2(``0,``1)">
            <summary>
            Initializes an empty dictionary
            </summary>
            <param name="kRep">A key representative used only for type inference</param>
            <param name="vRep">A value representative used only for type inference</param>
            <typeparam name="K">The key type</typeparam>
            <typeparam name="V">The vale type</typeparam>
        </member>
        <member name="M:Z0.z.dict``2(System.Int32,``0,``1)">
            <summary>
            Initializes an empty dictionary with a specified capacity
            </summary>
            <param name="capacity">The initial capacity</param>
            <param name="kRep">A key representative used only for type inference</param>
            <param name="vRep">A value representative used only for type inference</param>
            <typeparam name="K">The key type</typeparam>
            <typeparam name="V">The vale type</typeparam>
        </member>
        <member name="M:Z0.z.dict``2(System.Action{Z0.KeyedValue{``0,``1}},System.ValueTuple{``0,``1}[])">
            <summary>
            Creates a dictionary, excluding any duplicates, and invokes a caller-supplied action for each encountered duplicate
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <typeparam name="K">The key type</typeparam>
            <typeparam name="V">The vale type</typeparam>
        </member>
        <member name="M:Z0.z.dict``2(System.ValueTuple{``0,``1}[])">
            <summary>
            Creates a dictionary, throwing an exception if a duplicate key is encountered
            </summary>
            <param name="key"></param>
            <param name="value"></param>
            <typeparam name="K">The key type</typeparam>
            <typeparam name="V">The vale type</typeparam>
        </member>
        <member name="M:Z0.z.edit(Z0.StringRef@)">
            <summary>
            Reveals the character data identified by a string reference as a mutable span
            </summary>
            <param name="src">The source reference</param>
        </member>
        <member name="M:Z0.z.edit``1(``0@)">
            <summary>
            Transforms a readonly T-cell into an editable T-cell
            </summary>
            <param name="src">The source cell</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.edit(System.String)">
            <summary>
            Are you sure you want to do this?
            </summary>
            <param name="src">The immutable, and possibly interned string that were are going to modify</param>
        </member>
        <member name="M:Z0.z.edit``1(System.ReadOnlySpan{``0})">
            <summary>
            Covers the content of a readonly span with an editable span
            </summary>
            <param name="src">The memory source</param>
            <param name="count">The number of source cells to read</param>
            <typeparam name="T">The cell type</typeparam>
            <returns>Obviously, this trick could be particularly dangerous</returns>
        </member>
        <member name="M:Z0.z.edit``2(``0@)">
            <summary>
            Transforms a readonly S-cell into an editable T-cell
            </summary>
            <param name="src">The source cell</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.z.edit``2(``0@,``1@)">
            <summary>
            Transforms a readonly S-cell into an editable T-cell
            </summary>
            <param name="src">The source cell</param>
            <param name="dst">The target cell</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.z.fail``1(System.Exception,``0)">
            <summary>
            Creates an undesirable computation outcome
            </summary>
            <param name="e">The exception that caused the outcome to achieve an undesirable state</param>
            <param name="data">A payload value, if any</param>
            <typeparam name="T">The result payload type</typeparam>
        </member>
        <member name="M:Z0.z.fail``1(System.String)">
            <summary>
            Creates an undesirable computation outcome
            </summary>
            <param name="e">The exception that caused the outcome to achieve an undesirable state</param>
            <param name="data">A payload value, if any</param>
            <typeparam name="T">The result payload type</typeparam>
        </member>
        <member name="M:Z0.z.where``1(System.ReadOnlySpan{``0},System.Func{``0,System.Boolean})">
            <summary>
            Allocates and populates a new array by filtering the source array with a specified predicate 
            </summary>
            <param name="src">The soruce array</param>
            <param name="f">The predicate</param>
            <typeparam name="T">The array element type</typeparam>
        </member>
        <member name="M:Z0.z.first``1(Z0.W8,System.ReadOnlySpan{``0})">
            <summary>
            Presents the span head as a readonly reference to an unsigned 8-bit integer
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.first``1(Z0.W16,System.ReadOnlySpan{``0})">
            <summary>
            Presents the span head as a readonly reference to an unsigned 16-bit integer
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.first``1(Z0.W32,System.ReadOnlySpan{``0})">
            <summary>
            Presents the span head as a readonly reference to an unsigned 32-bit integer
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.first``1(Z0.W64,System.ReadOnlySpan{``0})">
            <summary>
            Presents the span head as a readonly reference to an unsigned 64-bit integer
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.first``1(Z0.W8,System.Span{``0})">
            <summary>
            Presents the span head as a reference to an unsigned 8-bit integer
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.first``1(Z0.W16,System.Span{``0})">
            <summary>
            Presents the span head as a reference to an unsigned 16-bit integer
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.first``1(Z0.W32,System.Span{``0})">
            <summary>
            Presents the span head as a reference to an unsigned 32-bit integer
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.first``1(Z0.W64,System.Span{``0})">
            <summary>
            Presents the span head as a reference to an unsigned 64-bit integer
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.first16``1(System.Span{``0})">
            <summary>
            Presents the span head as a reference to an unsigned 16-bit integer
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.first16``1(System.ReadOnlySpan{``0})">
            <summary>
            Presents the span head as a readonly reference to an unsigned 16-bit integer
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.first32``1(System.Span{``0})">
            <summary>
            Presents the bytespan head as a reference to an unsigned 32-bit integer
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.first32``1(System.ReadOnlySpan{``0})">
            <summary>
            Presents the span head as a readonly reference to an unsigned 32-bit integer
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.first32i(System.ReadOnlySpan{System.Byte})">
            <summary>
            Presents the span head as a reference to a signed 32-bit integer
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.first64``1(System.Span{``0})">
            <summary>
            Presents the span head as a reference to an unsigned 64-bit integer
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.first64``1(System.ReadOnlySpan{``0})">
            <summary>
            Presents the span head as a readonly reference to an unsigned 64-bit integer
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.first64i(System.ReadOnlySpan{System.Byte})">
            <summary>
            Presents the span head as a reference to a signed 64-bit integer
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.first8``1(System.Span{``0})">
            <summary>
            Presents the bytespan head as a reference to an unsigned 8-bit integer
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.first8``1(System.ReadOnlySpan{``0})">
            <summary>
            Presents the span head as a readonly reference to an unsigned 8-bit integer
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.flow``2(``0@,``1@)">
            <summary>
            Creates a <see cref='T:Z0.DataFlow`2'/> from a specified source to a specified target;
            </summary>
            <param name="src">The source</param>
            <param name="dst">The target</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.z.fmap``2(System.Func{``0,``1})">
            <summary>
            Defines the canonical option functor F:Option[A] -> Option[B] induced by a non-monadic dual f:A->B
            </summary>
            <param name="f">A non-monadic projector</param>
            <typeparam name="A">The source type</typeparam>
            <typeparam name="B">The target type</typeparam>
        </member>
        <member name="M:Z0.z.force``2(``0)">
            <summary>
            If possible, applies the conversion S -> T
            </summary>
            <param name="src">The source value</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.z.force``1(System.SByte)">
            <summary>
            Unconditionally converts the source value to a value of parametric numeric type
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The numeric type</typeparam>
        </member>
        <member name="M:Z0.z.force``1(System.Byte)">
            <summary>
            Unconditionally converts the source value to a value of parametric numeric type
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The numeric type</typeparam>
        </member>
        <member name="M:Z0.z.force``1(System.UInt16)">
            <summary>
            If possible, applies the conversion ushort -> T
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.z.force``1(System.Int16)">
            <summary>
            If possible, applies the conversion short -> T
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.z.force``1(System.Int32)">
            <summary>
            If possible, applies the conversion int -> T
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.z.force``1(System.UInt32)">
            <summary>
            If possible, applies the conversion uint -> T
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.z.force``1(System.Int64)">
            <summary>
            If possible, applies the conversion long -> T
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.z.force``1(System.UInt64)">
            <summary>
            If possible, applies the conversion ulong -> T
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.z.force``1(System.Single)">
            <summary>
            If possible, applies the conversion float -> T
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.z.force``1(System.Double)">
            <summary>
            If possible, applies the conversion double -> T
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.z.force``1(System.Char)">
            <summary>
            If possible, applies the conversion char -> T
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.z.fptr(System.Delegate)">
            <summary>
            Given an untyped delegate, yields a funcion pointer invocable from unmanaged code
            </summary>
            <param name="src">The source delegate</param>
            <typeparam name="D">The delegate type</typeparam>
        </member>
        <member name="M:Z0.z.fptr``1(``0)">
            <summary>
            Given a delegate, yields a funcion pointer invocable from unmanaged code
            </summary>
            <param name="src">The source delegate</param>
            <typeparam name="D">The delegate type</typeparam>
        </member>
        <member name="M:Z0.z.generic``1(System.Runtime.Intrinsics.Vector128{System.SByte}@)">
            <summary>
            Reinterprets the source vector as a vector over parametric T-cells
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The target type</typeparam>
            <remarks>This operation should be dissolved when the method is closed over a concrete type
            and should not impact instruction generation</remarks>
        </member>
        <member name="M:Z0.z.generic``1(System.Runtime.Intrinsics.Vector128{System.Byte}@)">
            <summary>
            Reinterprets the source vector as a vector over parametric T-cells
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The target type</typeparam>
            <remarks>This operation should be dissolved when the method is closed over a concrete type
            and should not impact instruction generation</remarks>
        </member>
        <member name="M:Z0.z.generic``1(System.Runtime.Intrinsics.Vector128{System.Int16}@)">
            <summary>
            Reinterprets the source vector as a vector over parametric T-cells
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The target type</typeparam>
            <remarks>This operation should be dissolved when the method is closed over a concrete type
            and should not impact instruction generation</remarks>
        </member>
        <member name="M:Z0.z.generic``1(System.Runtime.Intrinsics.Vector128{System.UInt16}@)">
            <summary>
            Reinterprets the source vector as a vector over parametric T-cells
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The target type</typeparam>
            <remarks>This operation should be dissolved when the method is closed over a concrete type
            and should not impact instruction generation</remarks>
        </member>
        <member name="M:Z0.z.generic``1(System.Runtime.Intrinsics.Vector128{System.Int32}@)">
            <summary>
            Reinterprets the source vector as a vector over parametric T-cells
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The target type</typeparam>
            <remarks>This operation should be dissolved when the method is closed over a concrete type
            and should not impact instruction generation</remarks>
        </member>
        <member name="M:Z0.z.generic``1(System.Runtime.Intrinsics.Vector128{System.UInt32}@)">
            <summary>
            Reinterprets the source vector as a vector over parametric T-cells
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The target type</typeparam>
            <remarks>This operation should be dissolved when the method is closed over a concrete type
            and should not impact instruction generation</remarks>
        </member>
        <member name="M:Z0.z.generic``1(System.Runtime.Intrinsics.Vector128{System.Int64}@)">
            <summary>
            Reinterprets the source vector as a vector over parametric T-cells
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The target type</typeparam>
            <remarks>This operation should be dissolved when the method is closed over a concrete type
            and should not impact instruction generation</remarks>
        </member>
        <member name="M:Z0.z.generic``1(System.Runtime.Intrinsics.Vector128{System.UInt64}@)">
            <summary>
            Reinterprets the source vector as a vector over parametric T-cells
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The target type</typeparam>
            <remarks>This operation should be dissolved when the method is closed over a concrete type
            and should not impact instruction generation</remarks>
        </member>
        <member name="M:Z0.z.generic``1(System.Runtime.Intrinsics.Vector128{System.Single}@)">
            <summary>
            Reinterprets the source vector as a vector over parametric T-cells
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The target type</typeparam>
            <remarks>This operation should be dissolved when the method is closed over a concrete type
            and should not impact instruction generation</remarks>
        </member>
        <member name="M:Z0.z.generic``1(System.Runtime.Intrinsics.Vector128{System.Double}@)">
            <summary>
            Reinterprets the source vector as a vector over parametric T-cells
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The target type</typeparam>
            <remarks>This operation should be dissolved when the method is closed over a concrete type
            and should not impact instruction generation</remarks>
        </member>
        <member name="M:Z0.z.generic``1(System.Runtime.Intrinsics.Vector256{System.SByte}@)">
            <summary>
            Reinterprets the source vector as a vector over parametric T-cells
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The target type</typeparam>
            <remarks>This operation should be dissolved when the method is closed over a concrete type
            and should not impact instruction generation</remarks>
        </member>
        <member name="M:Z0.z.generic``1(System.Runtime.Intrinsics.Vector256{System.Byte}@)">
            <summary>
            Reinterprets the source vector as a vector over parametric T-cells
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The target type</typeparam>
            <remarks>This operation should be dissolved when the method is closed over a concrete type
            and should not impact instruction generation</remarks>
        </member>
        <member name="M:Z0.z.generic``1(System.Runtime.Intrinsics.Vector256{System.Int16}@)">
            <summary>
            Reinterprets the source vector as a vector over parametric T-cells
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The target type</typeparam>
            <remarks>This operation should be dissolved when the method is closed over a concrete type
            and should not impact instruction generation</remarks>
        </member>
        <member name="M:Z0.z.generic``1(System.Runtime.Intrinsics.Vector256{System.UInt16}@)">
            <summary>
            Reinterprets the source vector as a vector over parametric T-cells
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The target type</typeparam>
            <remarks>This operation should be dissolved when the method is closed over a concrete type
            and should not impact instruction generation</remarks>
        </member>
        <member name="M:Z0.z.generic``1(System.Runtime.Intrinsics.Vector256{System.Int32}@)">
            <summary>
            Reinterprets the source vector as a vector over parametric T-cells
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The target type</typeparam>
            <remarks>This operation should be dissolved when the method is closed over a concrete type
            and should not impact instruction generation</remarks>
        </member>
        <member name="M:Z0.z.generic``1(System.Runtime.Intrinsics.Vector256{System.UInt32}@)">
            <summary>
            Reinterprets the source vector as a vector over parametric T-cells
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The target type</typeparam>
            <remarks>This operation should be dissolved when the method is closed over a concrete type
            and should not impact instruction generation</remarks>
        </member>
        <member name="M:Z0.z.generic``1(System.Runtime.Intrinsics.Vector256{System.Int64}@)">
            <summary>
            Reinterprets the source vector as a vector over parametric T-cells
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The target type</typeparam>
            <remarks>This operation should be dissolved when the method is closed over a concrete type
            and should not impact instruction generation</remarks>
        </member>
        <member name="M:Z0.z.generic``1(System.Runtime.Intrinsics.Vector256{System.UInt64}@)">
            <summary>
            Reinterprets the source vector as a vector over parametric T-cells
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The target type</typeparam>
            <remarks>This operation should be dissolved when the method is closed over a concrete type
            and should not impact instruction generation</remarks>
        </member>
        <member name="M:Z0.z.generic``1(System.Runtime.Intrinsics.Vector256{System.Single}@)">
            <summary>
            Reinterprets the source vector as a vector over parametric T-cells
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The target type</typeparam>
            <remarks>This operation should be dissolved when the method is closed over a concrete type
            and should not impact instruction generation</remarks>
        </member>
        <member name="M:Z0.z.generic``1(System.Runtime.Intrinsics.Vector256{System.Double}@)">
            <summary>
            Reinterprets the source vector as a vector over parametric T-cells
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The target type</typeparam>
            <remarks>This operation should be dissolved when the method is closed over a concrete type
            and should not impact instruction generation</remarks>
        </member>
        <member name="M:Z0.z.generic``1(Z0.Vector512{System.SByte}@)">
            <summary>
            Reinterprets the source vector as a vector over parametric T-cells
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The target type</typeparam>
            <remarks>This operation should be dissolved when the method is closed over a concrete type
            and should not impact instruction generation</remarks>
        </member>
        <member name="M:Z0.z.generic``1(Z0.Vector512{System.Byte}@)">
            <summary>
            Reinterprets the source vector as a vector over parametric T-cells
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The target type</typeparam>
            <remarks>This operation should be dissolved when the method is closed over a concrete type
            and should not impact instruction generation</remarks>
        </member>
        <member name="M:Z0.z.generic``1(Z0.Vector512{System.Int16}@)">
            <summary>
            Reinterprets the source vector as a vector over parametric T-cells
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The target type</typeparam>
            <remarks>This operation should be dissolved when the method is closed over a concrete type
            and should not impact instruction generation</remarks>
        </member>
        <member name="M:Z0.z.generic``1(Z0.Vector512{System.UInt16}@)">
            <summary>
            Reinterprets the source vector as a vector over parametric T-cells
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The target type</typeparam>
            <remarks>This operation should be dissolved when the method is closed over a concrete type
            and should not impact instruction generation</remarks>
        </member>
        <member name="M:Z0.z.generic``1(Z0.Vector512{System.Int32}@)">
            <summary>
            Reinterprets the source vector as a vector over parametric T-cells
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The target type</typeparam>
            <remarks>This operation should be dissolved when the method is closed over a concrete type
            and should not impact instruction generation</remarks>
        </member>
        <member name="M:Z0.z.generic``1(Z0.Vector512{System.UInt32}@)">
            <summary>
            Reinterprets the source vector as a vector over parametric T-cells
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The target type</typeparam>
            <remarks>This operation should be dissolved when the method is closed over a concrete type
            and should not impact instruction generation</remarks>
        </member>
        <member name="M:Z0.z.generic``1(Z0.Vector512{System.Int64}@)">
            <summary>
            Reinterprets the source vector as a vector over parametric T-cells
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The target type</typeparam>
            <remarks>This operation should be dissolved when the method is closed over a concrete type
            and should not impact instruction generation</remarks>
        </member>
        <member name="M:Z0.z.generic``1(Z0.Vector512{System.UInt64}@)">
            <summary>
            Reinterprets the source vector as a vector over parametric T-cells
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The target type</typeparam>
            <remarks>This operation should be dissolved when the method is closed over a concrete type
            and should not impact instruction generation</remarks>
        </member>
        <member name="M:Z0.z.generic``1(Z0.Vector512{System.Single}@)">
            <summary>
            Reinterprets the source vector as a vector over parametric T-cells
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The target type</typeparam>
            <remarks>This operation should be dissolved when the method is closed over a concrete type
            and should not impact instruction generation</remarks>
        </member>
        <member name="M:Z0.z.generic``1(Z0.Vector512{System.Double}@)">
            <summary>
            Reinterprets the source vector as a vector over parametric T-cells
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The target type</typeparam>
            <remarks>This operation should be dissolved when the method is closed over a concrete type
            and should not impact instruction generation</remarks>
        </member>
        <member name="M:Z0.z.gptr``1(``0@,System.Int32)">
            <summary>
            Presents a readonly reference to an unmanaged value as a pointer displaced
            by a specified element offset
            </summary>
            <param name="src">The memory reference</param>
            <param name="offset">The number of elements to skip</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.z.gptr``2(``0@)">
            <summary>
            Presents a generic reference r:T as a generic pointer p:T
            </summary>
            <param name="r">The memory reference</param>
            <typeparam name="T">The source reference type</typeparam>
            <typeparam name="P">The target pointer type</typeparam>
        </member>
        <member name="M:Z0.z.handle(System.Type)">
            <summary>
            Queries a specified type for its handle
            </summary>
        </member>
        <member name="M:Z0.z.handle``1">
            <summary>
            Queries a parametrically identified type for its handle
            </summary>
            <typeparam name="T">The type to query</typeparam>
        </member>
        <member name="F:Z0.z.K">
            <summary>
            Computes the FNV-1a hash of the source sequence
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <param name="src">The data source</param>
            <remarks>Adapted from the .Net core type System.Reflection.Internal.Hash</remarks>
        </member>
        <member name="M:Z0.z.hash(System.Type,System.Type)">
            <summary>
            Creates a 64-bit hash code predicated on two types
            </summary>
            <typeparam name="S">The first type</typeparam>
            <typeparam name="T">The second type</typeparam>
        </member>
        <member name="M:Z0.z.hash(System.Type,System.Type,System.Type)">
            <summary>
            Creates a 64-bit hash code predicated on three types
            </summary>
            <typeparam name="S">The first type</typeparam>
            <typeparam name="T">The second type</typeparam>
        </member>
        <member name="M:Z0.z.hash64``2(``0,``1)">
            <summary>
            Creates a 64-bit hashcode over a pair
            </summary>
            <param name="x">The first member</param>
            <param name="y">The second member</param>
            <typeparam name="X">The first member type</typeparam>
            <typeparam name="Y">The second member type</typeparam>
        </member>
        <member name="M:Z0.z.hash``1">
            <summary>
            Creates a 32-bit hash code predicated on a type parameter
            </summary>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.hash``2">
            <summary>
            Creates a 64-bit hash code predicated on two type parameters
            </summary>
            <typeparam name="S">The first type</typeparam>
            <typeparam name="T">The second type</typeparam>
        </member>
        <member name="M:Z0.z.hash``1(``0)">
            <summary>
            Computes hash codes for unmanaged system primitives
            </summary>
            <param name="src">The primal value</param>
            <typeparam name="T">The primitive type</typeparam>
        </member>
        <member name="M:Z0.z.hash``1(``0,``0)">
            <summary>
            Computes a combined hash code for a pair
            </summary>
            <typeparam name="T">The primitive type</typeparam>
        </member>
        <member name="M:Z0.z.hash(System.SByte)">
            <summary>
            Creates an unsigned hash code
            </summary>
            <param name="x">The source value</param>
        </member>
        <member name="M:Z0.z.hash(System.Byte)">
            <summary>
            Creates an unsigned hash code
            </summary>
            <param name="x">The source value</param>
        </member>
        <member name="M:Z0.z.hash(System.Int16)">
            <summary>
            Creates an unsigned hash code
            </summary>
            <param name="x">The source value</param>
            <remarks>Adapted from the .Net core type System.Reflection.Internal.Hash</remarks>
        </member>
        <member name="M:Z0.z.hash(System.UInt16)">
            <summary>
            Creates an unsigned hash code
            </summary>
            <param name="x">The source value</param>
            <remarks>Adapted from the .Net core type System.Reflection.Internal.Hash</remarks>
        </member>
        <member name="M:Z0.z.hash(System.Int32)">
            <summary>
            Creates an unsigned hash code
            </summary>
            <param name="x">The source value</param>
            <remarks>Adapted from the .Net core type System.Reflection.Internal.Hash</remarks>
        </member>
        <member name="M:Z0.z.hash(System.UInt32)">
            <summary>
            Creates an unsigned hash code
            </summary>
            <param name="x">The source value</param>
            <remarks>Adapted from the .Net core type System.Reflection.Internal.Hash</remarks>
        </member>
        <member name="M:Z0.z.hash(System.UInt64)">
            <summary>
            Creates an unsigned hash code
            </summary>
            <param name="x">The source value</param>
            <remarks>Adapted from the .Net core type System.Reflection.Internal.Hash</remarks>
        </member>
        <member name="M:Z0.z.hash(System.Int64)">
            <summary>
            Creates an unsigned hash code
            </summary>
            <param name="x">The source value</param>
            <remarks>Adapted from the .Net core type System.Reflection.Internal.Hash</remarks>
        </member>
        <member name="M:Z0.z.hash(System.Char)">
            <summary>
            Creates an unsigned hash code
            </summary>
            <param name="x">The source value</param>
            <remarks>Adapted from the .Net core type System.Reflection.Internal.Hash</remarks>
        </member>
        <member name="M:Z0.z.hash(System.Single)">
            <summary>
            Creates an unsigned hash code
            </summary>
            <param name="x">The source value</param>
            <remarks>Adapted from the .Net core type System.Reflection.Internal.Hash</remarks>
        </member>
        <member name="M:Z0.z.hash(System.Double)">
            <summary>
            Creates an unsigned hash code
            </summary>
            <param name="x">The source value</param>
            <remarks>Adapted from the .Net core type System.Reflection.Internal.Hash</remarks>
        </member>
        <member name="M:Z0.z.hash(System.Decimal)">
            <summary>
            Creates an unsigned hash code
            </summary>
            <param name="x">The source value</param>
            <remarks>Adapted from the .Net core type System.Reflection.Internal.Hash</remarks>
        </member>
        <member name="M:Z0.z.hash(System.Boolean)">
            <summary>
            Creates an unsigned hash code
            </summary>
            <param name="x">The source value</param>
            <remarks>Adapted from the .Net core type System.Reflection.Internal.Hash</remarks>
        </member>
        <member name="M:Z0.z.hash(System.UInt32,System.UInt32)">
            <summary>
            Calculates a combined hash for 2 unsigned 32-bit integers
            </summary>
            <param name="x">The left source</param>
            <param name="y">The right source</param>
            <remarks>Adapted from the .Net core type System.Reflection.Internal.Hash</remarks>
        </member>
        <member name="M:Z0.z.hash(System.SByte,System.SByte)">
            <summary>
            Creates a combined/unsigned hash code
            </summary>
            <param name="x">The left source</param>
            <param name="y">The right source</param>
            <remarks>Adapted from the .Net core type System.Reflection.Internal.Hash</remarks>
        </member>
        <member name="M:Z0.z.hash(System.Byte,System.Byte)">
            <summary>
            Creates a combined/unsigned hash code
            </summary>
            <param name="x">The left source</param>
            <param name="y">The right source</param>
            <remarks>Adapted from the .Net core type System.Reflection.Internal.Hash</remarks>
        </member>
        <member name="M:Z0.z.hash(System.Int16,System.Int16)">
            <summary>
            Creates a combined/unsigned hash code
            </summary>
            <param name="x">The left source</param>
            <param name="y">The right source</param>
            <remarks>Adapted from the .Net core type System.Reflection.Internal.Hash</remarks>
        </member>
        <member name="M:Z0.z.hash(System.UInt16,System.UInt16)">
            <summary>
            Creates a combined/unsigned hash code
            </summary>
            <param name="x">The left source</param>
            <param name="y">The right source</param>
            <remarks>Adapted from the .Net core type System.Reflection.Internal.Hash</remarks>
        </member>
        <member name="M:Z0.z.hash(System.Int32,System.Int32)">
            <summary>
            Creates a combined/unsigned hash code
            </summary>
            <param name="x">The left source</param>
            <param name="y">The right source</param>
            <remarks>Adapted from the .Net core type System.Reflection.Internal.Hash</remarks>
        </member>
        <member name="M:Z0.z.hash(System.UInt64,System.UInt64)">
            <summary>
            Creates a combined/unsigned hash code
            </summary>
            <param name="x">The left source</param>
            <param name="y">The right source</param>
            <remarks>Adapted from the .Net core type System.Reflection.Internal.Hash</remarks>
        </member>
        <member name="M:Z0.z.hash(System.Int64,System.Int64)">
            <summary>
            Creates a combined/unsigned hash code
            </summary>
            <param name="x">The left source</param>
            <param name="y">The right source</param>
            <remarks>Adapted from the .Net core type System.Reflection.Internal.Hash</remarks>
        </member>
        <member name="M:Z0.z.hash(System.Single,System.Single)">
            <summary>
            Creates a combined/unsigned hash code
            </summary>
            <param name="x">The left source</param>
            <param name="y">The right source</param>
            <remarks>Adapted from the .Net core type System.Reflection.Internal.Hash</remarks>
        </member>
        <member name="M:Z0.z.hash(System.Double,System.Double)">
            <summary>
            Creates a combined/unsigned hash code
            </summary>
            <param name="x">The left source</param>
            <param name="y">The right source</param>
            <remarks>Adapted from the .Net core type System.Reflection.Internal.Hash</remarks>
        </member>
        <member name="M:Z0.z.hash(System.Decimal,System.Decimal)">
            <summary>
            Creates a combined/unsigned hash code
            </summary>
            <param name="x">The left source</param>
            <param name="y">The right source</param>
            <remarks>Adapted from the .Net core type System.Reflection.Internal.Hash</remarks>
        </member>
        <member name="M:Z0.z.hashset``1(``0[])">
            <summary>
            Constructs an array from a parameter array
            </summary>
            <param name="src">The source array</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.z.head``1(``0[])">
            <summary>
            Returns a reference to the head of a readonly span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.i16``1(``0@)">
            <summary>
            Presents a T-references as a <see cref='T:System.Int16'/> reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.i32``1(``0@)">
            <summary>
            Presents a T-references as a <see cref='T:System.Int32'/> reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.i64``1(``0@)">
            <summary>
            Presents a T-references as a <see cref='T:System.Int64'/> reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.i8``1(``0@)">
            <summary>
            Presents a T-references as a <see cref='T:System.SByte'/> reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.ifempty(System.String,System.String)">
            <summary>
            Returns the replacement text if the source text is blank := {null | empty}
            </summary>
            <param name="test">The subject string</param>
            <param name="replace">The replacement value if blank</param>
        </member>
        <member name="M:Z0.z.ifnone``2(``0,System.Func{``1},System.Func{``0,``1})">
            <summary>
            Transforms an input, branching on nullity evaluation
            </summary>
            <param name="x">The input</param>
            <param name="null">The emitter to invoke if the input is null</param>
            <param name="else">The function to invoke if the input is not null</param>
            <typeparam name="X">The input type</typeparam>
            <typeparam name="Y">The output type</typeparam>
        </member>
        <member name="M:Z0.z.ifnone``2(System.Nullable{``0},System.Func{``1},System.Func{``0,``1})">
            <summary>
            Transforms an input value, branching on nullity evaluation
            </summary>
            <param name="x">The input</param>
            <param name="null">The emitter to invoke if the input is null</param>
            <param name="else">The optional function to invoke if the input is not null; if no
            function is provided, the default target type value will be returned</param>
            <typeparam name="X">The input type</typeparam>
            <typeparam name="Y">The output type</typeparam>
        </member>
        <member name="M:Z0.z.ifsome``1(``0,System.Action{``0})">
            <summary>
            Invokes an action if the supplied value is not null
            </summary>
            <typeparam name="V">The value type</typeparam>
            <param name="x">The potentially null value</param>
            <param name="f">The action to invoke if possible</param>
        </member>
        <member name="M:Z0.z.ifsome``1(System.Nullable{``0},System.Action{``0})">
            <summary>
            Invokes an action if the supplied value is not null
            </summary>
            <typeparam name="V">The value type</typeparam>
            <param name="x">The potentially null value</param>
            <param name="f">The action to invoke if possible</param>
        </member>
        <member name="M:Z0.z.ihash(System.SByte)">
            <summary>
            Creates a signed hash code
            </summary>
            <param name="x">The source value</param>
        </member>
        <member name="M:Z0.z.ihash(System.Byte)">
            <summary>
            Creates a signed hash code
            </summary>
            <param name="x">The source value</param>
        </member>
        <member name="M:Z0.z.ihash(System.Int16)">
            <summary>
            Creates a signed hash code
            </summary>
            <param name="x">The source value</param>
            <remarks>Adapted from the .Net core type System.Reflection.Internal.Hash</remarks>
        </member>
        <member name="M:Z0.z.ihash(System.UInt16)">
            <summary>
            Creates a signed hash code
            </summary>
            <param name="x">The source value</param>
            <remarks>Adapted from the .Net core type System.Reflection.Internal.Hash</remarks>
        </member>
        <member name="M:Z0.z.ihash(System.Int32)">
            <summary>
            Creates a signed hash code
            </summary>
            <param name="x">The source value</param>
            <remarks>Adapted from the .Net core type System.Reflection.Internal.Hash</remarks>
        </member>
        <member name="M:Z0.z.ihash(System.UInt32)">
            <summary>
            Creates a signed hash code
            </summary>
            <param name="x">The source value</param>
            <remarks>Adapted from the .Net core type System.Reflection.Internal.Hash</remarks>
        </member>
        <member name="M:Z0.z.ihash(System.UInt64)">
            <summary>
            Creates a signed hash code
            </summary>
            <param name="x">The source value</param>
            <remarks>Adapted from the .Net core type System.Reflection.Internal.Hash</remarks>
        </member>
        <member name="M:Z0.z.ihash(System.Int64)">
            <summary>
            Creates a signed hash code
            </summary>
            <param name="x">The source value</param>
            <remarks>Adapted from the .Net core type System.Reflection.Internal.Hash</remarks>
        </member>
        <member name="M:Z0.z.ihash(System.Char)">
            <summary>
            Creates a signed hash code
            </summary>
            <param name="x">The source value</param>
            <remarks>Adapted from the .Net core type System.Reflection.Internal.Hash</remarks>
        </member>
        <member name="M:Z0.z.ihash(System.Single)">
            <summary>
            Creates a signed hash code
            </summary>
            <param name="x">The source value</param>
            <remarks>Adapted from the .Net core type System.Reflection.Internal.Hash</remarks>
        </member>
        <member name="M:Z0.z.ihash(System.Double)">
            <summary>
            Creates a signed hash code
            </summary>
            <param name="x">The source value</param>
            <remarks>Adapted from the .Net core type System.Reflection.Internal.Hash</remarks>
        </member>
        <member name="M:Z0.z.ihash(System.Decimal)">
            <summary>
            Creates a signed hash code
            </summary>
            <param name="x">The source value</param>
            <remarks>Adapted from the .Net core type System.Reflection.Internal.Hash</remarks>
        </member>
        <member name="M:Z0.z.ihash(System.Boolean)">
            <summary>
            Creates a signed hash code
            </summary>
            <param name="x">The source value</param>
            <remarks>Adapted from the .Net core type System.Reflection.Internal.Hash</remarks>
        </member>
        <member name="M:Z0.z.iter``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0},System.Boolean)">
            <summary>
            Iterates over the supplied items, invoking a receiver for each
            </summary>
            <param name="src">The source items</param>
            <param name="f">The receiver</param>
            <typeparam name="T">The item type</typeparam>
        </member>
        <member name="M:Z0.z.iter``2(System.ReadOnlySpan{``0},System.ReadOnlySpan{``1},System.Action{``0,``1})">
            <summary>
            Iterates a pair of readonly spans in tandem, invoking a caller-supplied action for each cell pair
            </summary>
            <param name="x">The first operand</param>
            <param name="y">The second operand</param>
            <param name="f">The action to invoke</param>
            <typeparam name="S">The cell type of the first operand</typeparam>
            <typeparam name="T">The cell type of the second operand</typeparam>
        </member>
        <member name="M:Z0.z.iter``2(System.Span{``0},System.Span{``1},System.Action{``0,``1})">
            <summary>
            Iterates a pair of spans in tandem, invoking a caller-supplied action for each cell pair
            </summary>
            <param name="x">The first operand</param>
            <param name="y">The second operand</param>
            <param name="f">The action to invoke</param>
            <typeparam name="S">The cell type of the first operand</typeparam>
            <typeparam name="T">The cell type of the second operand</typeparam>
        </member>
        <member name="M:Z0.z.iteri(System.Int32,System.Int32,System.Action{System.Int32})">
            <summary>
            Applies an action to the sequence of integers min,min+1,...,max - 1
            </summary>
            <param name="min">The inclusive lower bound of the sequence</param>
            <param name="max">The non-inclusive upper bound of the sequence
            over intergers over which iteration will occur</param>
            <param name="f">The action to be applied to each  value</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.z.iteri(System.Int32,System.Action{System.Int32})" -->
        <member name="M:Z0.z.iteri``1(System.ReadOnlySpan{``0},System.Action{System.Byte,``0})">
            <summary>
            Appplies an action for each element in a source span
            </summary>
            <param name="src">The source span</param>
            <param name="f">The receiver</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.z.iteri``1(System.ReadOnlySpan{``0},System.Action{System.Int64,``0})">
            <summary>
            Appplies an action for each element in a source span
            </summary>
            <param name="src">The source span</param>
            <param name="f">The receiver</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.z.iteri``1(System.ReadOnlySpan{``0},System.Action{System.UInt64,``0})">
            <summary>
            Appplies an action for each element in a source span
            </summary>
            <param name="src">The source span</param>
            <param name="f">The receiver</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.z.key``2(``0,``1)">
            <summary>
            Creates a unmanaged K-discriminated key over a T-identifier
            </summary>
            <param name="kind"></param>
            <param name="id"></param>
            <typeparam name="K"></typeparam>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Z0.z.kvp``2(``0,``1)">
            <summary>
            Creates a kvp
            </summary>
            <param name="key">The key</param>
            <param name="value">The value</param>
            <typeparam name="K">The key type</typeparam>
            <typeparam name="V">The value type</typeparam>
        </member>
        <member name="M:Z0.z.length``2(System.ReadOnlySpan{``0},System.ReadOnlySpan{``1})">
            <summary>
            Computs min(x.Length,y.Length)
            </summary>
            <param name="x">The first span</param>
            <param name="y">The second span</param>
            <typeparam name="S">The first span cell type</typeparam>
            <typeparam name="T">The second span cell type</typeparam>
        </member>
        <member name="M:Z0.z.length``2(System.ReadOnlySpan{``0},System.Span{``1})">
            <summary>
            Computs min(x.Length,y.Length)
            </summary>
            <param name="x">The first span</param>
            <param name="y">The second span</param>
            <typeparam name="S">The first span cell type</typeparam>
            <typeparam name="T">The second span cell type</typeparam>
        </member>
        <member name="M:Z0.z.length``2(System.Span{``0},System.ReadOnlySpan{``1})">
            <summary>
            Computs min(x.Length,y.Length)
            </summary>
            <param name="x">The first span</param>
            <param name="y">The second span</param>
            <typeparam name="S">The first span cell type</typeparam>
            <typeparam name="T">The second span cell type</typeparam>
        </member>
        <member name="M:Z0.z.length``2(System.Span{``0},System.Span{``1})">
            <summary>
            Computs min(x.Length,y.Length)
            </summary>
            <param name="x">The first span</param>
            <param name="y">The second span</param>
            <typeparam name="S">The first span cell type</typeparam>
            <typeparam name="T">The second span cell type</typeparam>
        </member>
        <member name="M:Z0.z.length``2(Z0.SpanBlock128{``0}@,Z0.SpanBlock128{``1}@)">
            <summary>
            Returns the length of equal-length blocks; otherwise raises an error
            </summary>
            <param name="lhs">The left span</param>
            <param name="rhs">The right span</param>
        </member>
        <member name="M:Z0.z.length``2(Z0.SpanBlock256{``0}@,Z0.SpanBlock256{``1}@)">
            <summary>
            Returns the length of equal-length blocks; otherwise raises an error
            </summary>
            <param name="lhs">The left span</param>
            <param name="rhs">The right span</param>
        </member>
        <member name="M:Z0.z.length``2(Z0.SpanBlock512{``0}@,Z0.SpanBlock512{``1}@)">
            <summary>
            Returns the length of equal-length blocks; otherwise raises an error
            </summary>
            <param name="lhs">The left span</param>
            <param name="rhs">The right span</param>
        </member>
        <member name="M:Z0.z.liberate(System.ReadOnlySpan{System.Char})">
            <summary>
            Can this ever be a good way to solve your problem?
            </summary>
            <param name="src">The buffer to let it be what it wants</param>
        </member>
        <member name="M:Z0.z.list``1(System.Int32)">
            <summary>
            Creates a list with specified capacity
            </summary>
            <param name="capacity">The list capacity</param>
            <typeparam name="T">The item type</typeparam>
        </member>
        <member name="M:Z0.z.list``1(System.UInt32)">
            <summary>
            Creates a list with specified capacity
            </summary>
            <param name="capacity">The list capacity</param>
            <typeparam name="T">The item type</typeparam>
        </member>
        <member name="M:Z0.z.literal``1(System.Byte@,``0)">
            <summary>
            Envisions a u8 value as a value of an enum of like primal kind
            </summary>
            <param name="tVal">The source value</param>
            <param name="eRep">A representative enum value, used only for type inference</param>
            <typeparam name="E">The enum target type of primal u8-kind</typeparam>
        </member>
        <member name="M:Z0.z.literal``1(System.SByte@,``0)">
            <summary>
            Envisions an i8 value as a value of an enum of like primal kind
            </summary>
            <param name="tVal">The source value</param>
            <param name="eRep">A representative enum value, used only for type inference</param>
            <typeparam name="E">The enum target type of primal i8-kind</typeparam>
        </member>
        <member name="M:Z0.z.literal``1(System.Int16@,``0)">
            <summary>
            Envisions an i16 value as a value of an enum of like primal kind
            </summary>
            <param name="tVal">The source value</param>
            <param name="eRep">A representative enum value, used only for type inference</param>
            <typeparam name="E">The enum target type of primal i16-kind</typeparam>
        </member>
        <member name="M:Z0.z.literal``1(System.UInt16@,``0)">
            <summary>
            Envisions a u16 value as a value of an enum of like primal kind
            </summary>
            <param name="tVal">The source value</param>
            <param name="eRep">A representative enum value, used only for type inference</param>
            <typeparam name="E">The enum target type of primal u16-kind</typeparam>
        </member>
        <member name="M:Z0.z.literal``1(System.Char@,``0)">
            <summary>
            Envisions a c16 value as a value of an enum of like u16 kind
            </summary>
            <param name="tVal">The source value</param>
            <param name="eRep">A representative enum value, used only for type inference</param>
            <typeparam name="E">The enum target type of primal u16-kind</typeparam>
        </member>
        <member name="M:Z0.z.literal``1(System.Int32@,``0)">
            <summary>
            Envisions an i32 value as a value of an enum of like primal kind
            </summary>
            <param name="tVal">The source value</param>
            <param name="eRep">A representative enum value, used only for type inference</param>
            <typeparam name="E">The enum target type of primal i32-kind</typeparam>
        </member>
        <member name="M:Z0.z.literal``1(System.UInt32@,``0)">
            <summary>
            Envisions a u32 value as a value of an enum of like primal kind
            </summary>
            <param name="tVal">The source value</param>
            <param name="eRep">A representative enum value, used only for type inference</param>
            <typeparam name="E">The enum target type of primal u32-kind</typeparam>
        </member>
        <member name="M:Z0.z.literal``1(System.Int64@,``0)">
            <summary>
            Envisions an i64 value as a value of an enum of like primal kind
            </summary>
            <param name="tVal">The source value</param>
            <param name="eRep">A representative enum value, used only for type inference</param>
            <typeparam name="E">The enum target type of primal i64-kind</typeparam>
        </member>
        <member name="M:Z0.z.literal``1(System.UInt64@,``0)">
            <summary>
            Envisions a u64 value as a value of an enum of like primal kind
            </summary>
            <param name="tVal">The source value</param>
            <param name="eRep">A representative enum value, used only for type inference</param>
            <typeparam name="E">The enum target type of primal u64-kind</typeparam>
        </member>
        <member name="M:Z0.z.eVal``2(``0@,``1)">
            <summary>
            Reads an E-value from an enum of primal T-kind
            </summary>
            <param name="tVal">The integral value</param>
            <param name="eRep">A representative enum value, used only for type inference</param>
            <typeparam name="E">The enum type</typeparam>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.z.lo64(System.Int32)">
            <summary>
            Produces a sequence of n enabled bits, starting from index 0 and extending to index n - 1
            </summary>
            <typeparam name="N">The enabled bit count type</typeparam>
        </member>
        <member name="M:Z0.z.lomask(System.Byte)">
            <summary>
            unsigned int _blsmsk_u32 (unsigned int a) BLSMSK reg, reg/m32
            Logically equivalent to the composite operation (src-1) ^ src that enables the lower bits of the source up to and including the least set bit
            </summary>
            <param name="src">The bit source</param>
        </member>
        <member name="M:Z0.z.lomask(System.UInt16)">
            <summary>
            unsigned int _blsmsk_u32 (unsigned int a) BLSMSK reg, reg/m32
            Logically equivalent to the composite operation (src-1) ^ src that enables the lower bits of the source up to and including the least set bit
            </summary>
            <param name="src">The bit source</param>
        </member>
        <member name="M:Z0.z.lomask(System.UInt32)">
            <summary>
            unsigned int _blsmsk_u32 (unsigned int a) BLSMSK reg, reg/m32
            Logically equivalent to the composite operation (src-1) ^ src that enables the lower bits of the source up to and including the least set bit
            </summary>
            <param name="src">The bit source</param>
        </member>
        <member name="M:Z0.z.lomask(System.UInt64)">
            <summary>
            unsigned __int64 _blsmsk_u64 (unsigned __int64 a) BLSMSK reg, reg/m6
            Logically equivalent to the composite operation (src-1) ^ src that enables the lower bits of the source up to and including the least set bit
            </summary>
            <param name="src">The bit source</param>
        </member>
        <member name="M:Z0.z.lomask``1(``0)">
            <summary>
            Logically equivalent to the composite operation (src-1) ^ src that enables the 
            lower bits of the source up to and including the least set bit
            </summary>
            <param name="src">The bit source</param>
        </member>
        <member name="M:Z0.z.mapi``2(System.Collections.Generic.IEnumerable{``0},System.Func{System.Int32,``0,``1})">
            <summary>
            Applies the supplied function to each element in the input sequence to produce a list
            </summary>
            <typeparam name="X">The input sequence item type</typeparam>
            <typeparam name="S">The output sequence item type</typeparam>
            <param name="seq">The sequence to transform</param>
            <param name="f">The transformation function</param>
        </member>
        <member name="M:Z0.z.map``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Applies a function to an input sequence to yield a transformed output sequence
            </summary>
            <param name="src">The source sequence</param>
            <param name="f">The projector</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.z.map``2(System.Nullable{``0},System.Func{``0,``1},System.Func{``1})">
            <summary>
            Projects a source value, if non-null, onto a target value; otherwise, returns value raised by a caller-supplied emitter
            </summary>
            <param name="src">The source value</param>
            <param name="some">The projector</param>
            <param name="none">The alternative emitter</param>
            <typeparam name="S">The source value type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.z.map``2(System.Nullable{``0},System.Func{``0,``1})">
            <summary>
            Projects a source value, if non-null, onto a target value; otherwise, returns the target's default value
            </summary>
            <param name="src">The source value</param>
            <param name="f">The projector</param>
            <typeparam name="S">The source value type</typeparam>
            <typeparam name="T">The target value type</typeparam>
        </member>
        <member name="M:Z0.z.map``2(System.ReadOnlySpan{``0},System.Func{``0,``1},System.Span{``1})">
            <summary>
            Projects a source span to target span via a supplied transformation
            </summary>
            <param name="src">The source</param>
            <param name="f">The transformation</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.z.map``3(System.ReadOnlySpan{``0},System.ReadOnlySpan{``1},System.Func{``0,``1,``2},System.Span{``2})">
            <summary>
            Iterates a pair of readonly spans in tandem, invoking a function for each cell pair
            and deposits the result in a caller-supplied target
            </summary>
            <param name="x">The first operand</param>
            <param name="y">The second operand</param>
            <param name="f">The action to invoke</param>
            <typeparam name="S">The cell type of the first operand</typeparam>
            <typeparam name="T">The cell type of the second operand</typeparam>
        </member>
        <member name="M:Z0.z.map``3(System.ReadOnlySpan{``0},System.ReadOnlySpan{``1},System.Func{``0,``1,``2})">
            <summary>
            Iterates a pair of readonly spans in tandem, invoking a function for each cell pair,
            and deposits the result to an allocated target that is returned
            </summary>
            <param name="x">The first operand</param>
            <param name="y">The second operand</param>
            <param name="f">The action to invoke</param>
            <typeparam name="S">The cell type of the first operand</typeparam>
            <typeparam name="T">The cell type of the second operand</typeparam>
        </member>
        <member name="M:Z0.z.mapi``2(System.ReadOnlySpan{``0},System.Func{System.Int32,``0,``1},System.Span{``1})">
            <summary>
            Maps the elements of a source span to a target span
            </summary>
            <param name="src">The source span</param>
            <param name="f">The mapping function</param>
            <param name="dst">The target span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.z.memref(Z0.MemoryAddress,Z0.ByteSize)">
            <summary>
            Defines a memory reference
            </summary>
            <param name="address">The address</param>
            <param name="bytes">The number of reference bytes</param>
        </member>
        <member name="M:Z0.z.name``1(``0)">
            <summary>
            Defines a name
            </summary>
            <param name="src">The name content</param>
            <typeparam name="S">The name type</typeparam>
        </member>
        <member name="M:Z0.z.name(System.String)">
            <summary>
            Defines a name
            </summary>
            <param name="src">The name content</param>
        </member>
        <member name="M:Z0.z.nat8i``1(``0)">
            <summary>
            Returns the numeric value represented by a natural type
            </summary>
            <param name="n">The natural type representative</param>
            <typeparam name="K">A natural type</typeparam>
        </member>
        <member name="M:Z0.z.nat8u``1(``0)">
            <summary>
            Returns the numeric value represented by a natural type
            </summary>
            <param name="n">The natural type representative</param>
            <typeparam name="K">A natural type</typeparam>
        </member>
        <member name="M:Z0.z.nat16i``1(``0)">
            <summary>
            Returns the numeric value represented by a natural type
            </summary>
            <param name="n">The natural type representative</param>
            <typeparam name="K">A natural type</typeparam>
        </member>
        <member name="M:Z0.z.nat16u``1(``0)">
            <summary>
            Returns the numeric value represented by a natural type
            </summary>
            <param name="n">The natural type representative</param>
            <typeparam name="K">A natural type</typeparam>
        </member>
        <member name="M:Z0.z.nat32i``1(``0)">
            <summary>
            Returns the numeric value represented by a natural type
            </summary>
            <param name="n">The natural type representative</param>
            <typeparam name="K">A natural type</typeparam>
        </member>
        <member name="M:Z0.z.nat32u``1(``0)">
            <summary>
            Returns the numeric value represented by a natural type
            </summary>
            <param name="n">The natural type representative</param>
            <typeparam name="K">A natural type</typeparam>
        </member>
        <member name="M:Z0.z.nat64u``1(``0)">
            <summary>
            Returns the numeric value represented by a natural type
            </summary>
            <param name="n">The natural type representative</param>
            <typeparam name="K">A natural type</typeparam>
        </member>
        <member name="M:Z0.z.nat64i``1(``0)">
            <summary>
            Returns the numeric value represented by a natural type
            </summary>
            <param name="n">The natural type representative</param>
            <typeparam name="K">A natural type</typeparam>
        </member>
        <member name="M:Z0.z.nat``2(``0,``1)">
            <summary>
            Returns the numeric value represented by a natural type
            </summary>
            <param name="n"></param>
            <param name="t"></param>
            <typeparam name="N"></typeparam>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Z0.z.next(System.Byte@,System.Byte@)">
            <summary>
             Effects: movzx eax,byte ptr [rcx] => mov [rdx],al => eax,byte ptr [rdx+1] => mov [rdx],al => rax,[rcx+1]
            </summary>
            <param name="src">The source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.z.next(System.Byte@,System.UInt16@)">
            <summary>
            Effects: movzx eax,word ptr [rcx] => mov [rdx],ax => movzx eax,word ptr [rdx+2] => [rdx],ax => lea rax,[rcx+2]
            </summary>
            <param name="src"></param>
            <param name="dst"></param>
        </member>
        <member name="M:Z0.z.next(System.Byte@,System.UInt32@)">
            <summary>
            Effects: mov eax,[rcx] => mov [rdx],eax => mov eax,[rdx+4] => mov [rdx],eax => lea rax,[rcx+4]
            </summary>
            <param name="src">The source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.z.next(System.Byte@,System.UInt64@)">
            <summary>
            Effects: mov rax,[rcx] => mov [rdx],rax => mov rax,[rdx+8] => mov [rdx],rax => lea rax,[rcx+8]
            </summary>
            <param name="src">The source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.z.next(System.SByte@,System.Byte@)">
             <summary>
            
             </summary>
             <param name="src">The source</param>
             <param name="dst">The target</param>
        </member>
        <member name="M:Z0.z.next(System.SByte@,System.UInt16@)">
             <summary>
            
             </summary>
             <param name="src"></param>
             <param name="dst"></param>
        </member>
        <member name="M:Z0.z.next(System.SByte@,System.UInt32@)">
             <summary>
            
             </summary>
             <param name="src">The source</param>
             <param name="dst">The target</param>
        </member>
        <member name="M:Z0.z.next(System.SByte@,System.UInt64@)">
             <summary>
            
             </summary>
             <param name="src">The source</param>
             <param name="dst">The target</param>
        </member>
        <member name="M:Z0.z.next(System.UInt16@,System.Byte@)">
            <summary>
            movzx eax,byte ptr [rcx] => mov [rdx],al => movzx eax,byte ptr [rdx+1] => mov [rdx],al => lea rax,[rcx+2]
            </summary>
            <param name="src">The source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.z.next(System.UInt16@,System.UInt16@)">
             <summary>
            
             </summary>
             <param name="src">The source</param>
             <param name="dst">The target</param>
        </member>
        <member name="M:Z0.z.next(System.UInt16@,System.UInt32@)">
             <summary>
            
             </summary>
             <param name="src">The source</param>
             <param name="dst">The target</param>
        </member>
        <member name="M:Z0.z.next(System.UInt16@,System.UInt64@)">
             <summary>
            
             </summary>
             <param name="src">The source</param>
             <param name="dst">The target</param>
        </member>
        <member name="M:Z0.z.next(System.UInt32@,System.Byte@)">
             <summary>
            
             </summary>
             <param name="src">The source</param>
             <param name="dst">The target</param>
        </member>
        <member name="M:Z0.z.next(System.UInt32@,System.UInt16@)">
             <summary>
            
             </summary>
             <param name="src">The source</param>
             <param name="dst">The target</param>
        </member>
        <member name="M:Z0.z.next(System.UInt32@,System.UInt32@)">
             <summary>
            
             </summary>
             <param name="src">The source</param>
             <param name="dst">The target</param>
        </member>
        <member name="M:Z0.z.next(System.UInt32@,System.UInt64@)">
             <summary>
            
             </summary>
             <param name="src">The source</param>
             <param name="dst">The target</param>
        </member>
        <member name="M:Z0.z.next(System.UInt64@,System.Byte@)">
             <summary>
            
             </summary>
             <param name="src">The source</param>
             <param name="dst">The target</param>
        </member>
        <member name="M:Z0.z.next(System.UInt64@,System.UInt16@)">
             <summary>
            
             </summary>
             <param name="src">The source</param>
             <param name="dst">The target</param>
        </member>
        <member name="M:Z0.z.next(System.UInt64@,System.UInt32@)">
            <summary>
            mov eax,[rcx] => mov [rdx],eax => mov eax,[rdx+4] => mov [rdx],eax => lea rax,[rcx+20h]
            </summary>
            <param name="src">The source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.z.next(System.UInt64@,System.UInt64@)">
            <summary>
            mov rax,[rcx] => mov [rdx],rax => mov rax,[rdx+8] => [rdx],rax => lea rax,[rcx+40h]
            </summary>
            <param name="src">The source</param>
            <param name="dst">The target</param>
        </member>
        <member name="M:Z0.z.nk``1(``0)">
            <summary>
            Returns a parametric numeric-kind classifier
            </summary>
            <typeparam name="T">The numeric type</typeparam>
        </member>
        <member name="M:Z0.z.nk(System.Type)">
            <summary>
            Determines the source types's numeric kind classifier
            </summary>
            <param name="t">The type to classify</param>
        </member>
        <member name="M:Z0.z.none``1">
            <summary>
            Defines a non-valued option
            </summary>
            <typeparam name="T">The value type, if the value existed</typeparam>
        </member>
        <member name="M:Z0.z.nullis``1(``0)">
            <summary>
            Returns true if the source is null
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.nullnot``1(``0)">
            <summary>
            Returns true if the source is non-null
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.one``1(``0)">
            <summary>
            Returns generic 1 for a primal source type
            </summary>
            <param name="t">A primal type representative</param>
            <typeparam name="T">The primal source type</typeparam>
        </member>
        <member name="M:Z0.z.ones``1(``0)">
            <summary>
            Ones all bits each and every ... one
            </summary>
            <param name="t">A primal type representative</param>
            <typeparam name="T">The primal source type</typeparam>
        </member>
        <member name="M:Z0.z.option``1(``0)">
            <summary>
            Defines an option for a reference type; a valued option is produced if the source is non-null; otherwise, a non-valued option is produced
            </summary>
            <param name="src">A source value, or null</param>
            <typeparam name="T">The enclosed type</typeparam>
        </member>
        <member name="M:Z0.z.option``1(System.Nullable{``0})">
            <summary>
            Defines an option for a nullable value type; a valued option is produced if the source is non-null; otherwise, a non-valued option is produced
            </summary>
            <param name="src">A source value, or null</param>
            <typeparam name="T">The enclosed type</typeparam>
        </member>
        <member name="M:Z0.z.outcome``1(System.Boolean,``0)">
            <summary>
            Defines an outcome spec
            </summary>
            <param name="ok">Specifies whether the operation succeeded</param>
            <param name="data">The operation data</param>
            <typeparam name="T">The operation data type</typeparam>
        </member>
        <member name="M:Z0.z.p16i``1(``0@)">
            <summary>
            Presents a generic reference as a short pointer
            </summary>
            <param name="src">The memory reference</param>
            <typeparam name="T">The source reference type</typeparam>
        </member>
        <member name="M:Z0.z.p16u``1(``0@)">
            <summary>
            Presents a generic reference as a ushort pointer
            </summary>
            <param name="src">The memory reference</param>
            <typeparam name="T">The source reference type</typeparam>
        </member>
        <member name="M:Z0.z.p32i``1(``0@)">
            <summary>
            Presents a generic reference as an int32 pointer
            </summary>
            <param name="src">The memory reference</param>
            <typeparam name="T">The source reference type</typeparam>
        </member>
        <member name="M:Z0.z.p32u``1(``0@)">
            <summary>
            Presents a generic reference as an uint32 pointer
            </summary>
            <param name="src">The memory reference</param>
            <typeparam name="T">The source reference type</typeparam>
        </member>
        <member name="M:Z0.z.p64i``1(``0@)">
            <summary>
            Presents a generic reference as an int64 pointer
            </summary>
            <param name="src">The memory reference</param>
            <typeparam name="T">The source reference type</typeparam>
        </member>
        <member name="M:Z0.z.p64u``1(``0@)">
            <summary>
            Presents a generic reference as an int64 pointer
            </summary>
            <param name="src">The memory reference</param>
            <typeparam name="T">The source reference type</typeparam>
        </member>
        <member name="M:Z0.z.p8i``1(``0@)">
            <summary>
            Presents a generic reference as an sbyte pointer
            </summary>
            <param name="src">The memory reference</param>
            <typeparam name="T">The source reference type</typeparam>
        </member>
        <member name="M:Z0.z.p8u``1(``0@)">
            <summary>
            Presents a generic reference as a byte pointer
            </summary>
            <param name="src">The memory reference</param>
            <typeparam name="T">The source reference type</typeparam>
        </member>
        <member name="M:Z0.z.pair``1(``0,``0)">
            <summary>
            Creates an homogenous pair
            </summary>
            <param name="a">The first member</param>
            <param name="b">The second member</param>
            <typeparam name="T">The member type</typeparam>
        </member>
        <member name="M:Z0.z.paired``2(``0,``1)">
            <summary>
            Creates a non-homogenous pair
            </summary>
            <param name="a">The first member</param>
            <param name="b">The second member</param>
            <typeparam name="T0">The first member type</typeparam>
            <typeparam name="T1">The second member type</typeparam>
        </member>
        <member name="M:Z0.z.parsed``2(``0,``1)">
            <summary>
            Defines a successful parse result
            </summary>
            <param name="source">The input vaue</param>
            <param name="value">The parsed value</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.z.parsed``1(System.Object,``0)" -->
        <member name="M:Z0.z.pchar(System.String)">
            <summary>
            Retrieves a pointer to a string that, hopefully (shouldn't)  move
            </summary>
            <param name="src">The source string</param>
        </member>
        <member name="M:Z0.z.pinnable``1(System.Span{``0})">
            <summary>
            Returns a pinnable reference to the leading cell of a specified <see cref='T:System.Span`1'/>
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.pinnable``1(System.ReadOnlySpan{``0})">
            <summary>
            Returns a pinnable reference to the leading cell of a specified <see cref='T:System.ReadOnlySpan`1'/>
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.primal(System.TypeCode)">
            <summary>
            Returns the type-code identified primal kind
            </summary>
            <param name="src">The type code</param>
        </member>
        <member name="M:Z0.z.project(System.UInt64@,System.UInt32@)">
            <summary>
            Projects a reference-identified source into a reference-identified target and advances the source by the projected size
            </summary>
            <param name="src">The source data</param>
            <param name="dst">The target reference</param>
        </member>
        <member name="M:Z0.z.project(System.Byte@,System.Byte@)">
            <summary>
            Projects a reference-identified source into a reference-identified target and advances the source by the projected size
            </summary>
            <param name="src">The source data</param>
            <param name="dst">The target reference</param>
        </member>
        <member name="M:Z0.z.project(System.UInt16@,System.Byte@)">
            <summary>
            Projects a reference-identified source into a reference-identified target and advances the source by the projected size
            </summary>
            <param name="src">The source data</param>
            <param name="dst">The target reference</param>
        </member>
        <member name="M:Z0.z.project(System.UInt32@,System.Byte@)">
            <summary>
            Projects a reference-identified source into a reference-identified target and advances the source by the projected size
            </summary>
            <param name="src">The source</param>
            <param name="dst">The target reference</param>
        </member>
        <member name="M:Z0.z.project(System.UInt32@,System.UInt16@)">
            <summary>
            Projects a reference-identified source into a reference-identified target and advances the source by the projected size
            </summary>
            <param name="src">The source data</param>
            <param name="dst">The target reference</param>
        </member>
        <member name="M:Z0.z.project(System.UInt64@,System.Byte@)">
            <summary>
            Projects a reference-identified source into a reference-identified target and advances the source by the projected size
            </summary>
            <param name="src">The source data</param>
            <param name="dst">The target reference</param>
        </member>
        <member name="M:Z0.z.project(System.UInt64@,System.UInt16@)">
            <summary>
            Projects a reference-identified source into a reference-identified target and advances the source by the projected size
            </summary>
            <param name="src">The source data</param>
            <param name="dst">The target reference</param>
        </member>
        <member name="M:Z0.z.pvoid``1(``0@)">
            <summary>
            Converts a generic reference into a void pointer
            </summary>
            <param name="src">The memory reference</param>
            <typeparam name="T">The type of the referenced data</typeparam>
        </member>
        <member name="M:Z0.z.quad``1(``0,``0,``0,``0)">
            <summary>
            Defines an homogenous 4-tuple
            </summary>
            <param name="a">The first member</param>
            <param name="b">The second member</param>
            <param name="c">The third member</param>
            <param name="d">The fourth member</param>
            <typeparam name="T">The member type</typeparam>
        </member>
        <member name="M:Z0.z.read``1(Z0.W8,``0@)">
            <summary>
            Interprets a readonly generic reference as a readonly uint8 reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.read``1(Z0.W16,``0@)">
            <summary>
            Interprets a readonly generic reference as a readonly uint16 reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.read``1(Z0.W32,``0@)">
            <summary>
            Interprets a readonly generic reference as a readonly uint32 reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.read``1(Z0.W64,``0@)">
            <summary>
            Interprets a readonly generic reference as a readonly uint64 reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.reader(System.IO.Stream)">
            <summary>
            Allocates a caller-disposed reader for the source
            </summary>
            <param name="src">The source stream</param>
        </member>
        <member name="M:Z0.z.rebox(System.Object,Z0.NumericKind)">
            <summary>
            Converts a boxed numeric value of one kind to a boxed numeric value of specified kind, if possible.
            If not possible, returns the original value
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target kind</param>
        </member>
        <member name="M:Z0.z.recover``1(Z0.W8,``0@)">
            <summary>
            Interprets a readonly generic reference as a uint8 reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.recover``1(Z0.W16,``0@)">
            <summary>
            Interprets a readonly generic reference as a uint16 reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.recover``1(Z0.W32,``0@)">
            <summary>
            Interprets a readonly generic reference as a uint32 reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.recover``1(Z0.W64,``0@)">
            <summary>
            Interprets a readonly generic reference as a uint64 reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.reduce``1(Z0.Option{Z0.Option{``0}})">
            <summary>
            Implements the canonical join operation that reduces the monadic depth by one level
            </summary>
            <param name="src">The optional option</param>
            <typeparam name="T">The encapsulated value</typeparam>
        </member>
        <member name="M:Z0.z.reduce``1(System.Collections.Generic.IEnumerable{``0}[])">
            <summary>
            Implements the canonical join operation that reduces the (LiNQ-monadic) depth by one level
            </summary>
            <param name="src">The optional option</param>
            <typeparam name="T">The encapsulated value</typeparam>
        </member>
        <member name="M:Z0.z.refptr``1(``0@)">
            <summary>
            Presents generic reference as a generic pointer
            </summary>
            <param name="src">The memory reference</param>
            <typeparam name="T">The reference type</typeparam>
            <remarks>For all T, effects: mov rax,rcx</remarks>
        </member>
        <member name="M:Z0.z.refptr``1(``0@,System.Int32)">
            <summary>
            Presents generic reference as a generic pointer displaced by an element offset
            </summary>
            <param name="src">The memory reference</param>
            <param name="offset">The number of elements to skip</param>
            <typeparam name="T">The reference type</typeparam>
            <remarks>
            Effects
            width[T]=8:  movsxd rax,edx => add rax,rcx
            width[T]=16: movsxd rax,edx => lea rax,[rcx+rax*2]
            width[T]=32: movsxd rax,edx => lea rax,[rcx+rax*4]
            width[T]=64: movsxd rax,edx => lea rax,[rcx+rax*8]
            </remarks>
        </member>
        <member name="M:Z0.z.refptr``2(``0@)">
            <summary>
            Presents a generic reference r:T as a generic pointer p:T
            </summary>
            <param name="r">The memory reference</param>
            <typeparam name="T">The source reference type</typeparam>
            <typeparam name="P">The target pointer type</typeparam>
        </member>
        <member name="M:Z0.z.scalar``2(``0@)">
            <summary>
            Interprets a scalar value of one sort as a scalar value of another
            </summary>
            <param name="eVal">The enum value</param>
            <param name="tVal">The primal output value</param>
            <typeparam name="E">The enum type</typeparam>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.z.seek``2(``0@,System.UInt32)">
            <summary>
            Advances an S-reference in units measured by T-cells and returns
            the resulting T-cell reference
            </summary>
            <param name="src">The data source</param>
            <param name="count">The number of T-cells to advance</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.z.seek``1(System.Span{``0},System.UInt32)">
            <summary>
            Returns a reference to a T-measured offset-identified cell
            </summary>
            <param name="src">The data source</param>
            <param name="offset">The T-measured offset count</param>
            <typeparam name="T">The cell type</typeparam>
            <remarks>
            Effects
            width[T]=8:  mov rax,[rcx] => movsxd rdx,edx => add rax,rdx
            width[T]=16: mov rax,[rcx] => movsxd rdx,edx => lea rax,[rax+rdx*2]
            width[T]=32: mov rax,[rcx] => movsxd rdx,edx => lea rax,[rax+rdx*4]
            width[T]=64: mov rax,[rcx] => movsxd rdx,edx => lea rax,[rax+rdx*8]
            </remarks>
        </member>
        <member name="M:Z0.z.seek``1(System.Span{``0},System.UInt64)">
            <summary>
            Returns a reference to a T-measured offset-identified cell
            </summary>
            <param name="src">The data source</param>
            <param name="offset">The T-measured offset count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.seek``1(System.Span{``0},System.Byte)">
            <summary>
            Returns a reference to a T-measured offset-identified cell
            </summary>
            <param name="src">The data source</param>
            <param name="offset">The T-measured offset count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.seek``1(System.Span{``0},System.UInt16)">
            <summary>
            Returns a reference to a T-measured offset-identified cell
            </summary>
            <param name="src">The data source</param>
            <param name="offset">The T-measured offset count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.seek``1(``0@,System.Byte)">
            <summary>
            Returns a reference to a T-measured offset-identified cell
            </summary>
            <param name="src">The data source</param>
            <param name="offset">The T-measured offset count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.seek``1(``0@,System.UInt16)">
            <summary>
            Returns a reference to a T-measured offset-identified cell
            </summary>
            <param name="src">The data source</param>
            <param name="offset">The T-measured offset count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.seek``1(``0@,System.UInt32)">
            <summary>
            Returns a reference to a T-measured offset-identified cell
            </summary>
            <param name="src">The data source</param>
            <param name="offset">The T-measured offset count</param>
            <typeparam name="T">The cell type</typeparam>
            <remarks>
            Effects
            width[T]=8:  movsxd rax,edx => add rax,rcx
            width[T]=16: movsxd rax,edx => lea rax,[rcx+rax*2]
            width[T]=32: movsxd rax,edx => lea rax,[rcx+rax*4]
            width[T]=64: movsxd rax,edx => lea rax,[rcx+rax*8]
            </remarks>
        </member>
        <member name="M:Z0.z.seek``1(``0@,System.UInt64)">
            <summary>
            Returns a reference to a T-measured offset-identified cell
            </summary>
            <param name="src">The data source</param>
            <param name="offset">The T-measured offset count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.seek``1(``0@,System.Int32)">
            <summary>
            Returns a reference to a T-measured offset-identified cell
            </summary>
            <param name="src">The data source</param>
            <param name="offset">The T-measured offset count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.seek16``1(``0@,System.UInt32)">
            <summary>
            Skips a specified number of 16-bit source segments and returns a reference to the located cell
            </summary>
            <param name="src">The data source</param>
            <param name="count">The number of 16-bit segments to skip</param>
            <typeparam name="T">The (arbitrary) source type</typeparam>
        </member>
        <member name="M:Z0.z.seek16``1(System.Span{``0},System.UInt32)">
            <summary>
            Adds an offset to the head of a span, measured relative to 16-bit segments, and returns the resulting reference
            </summary>
            <param name="src">The source span</param>
            <param name="count">The number of 16-bit segments to skip</param>
            <typeparam name="T">The source element type</typeparam>
        </member>
        <member name="M:Z0.z.seek32``1(``0@,System.UInt32)">
            <summary>
            Adds an offset, measured by segments of bit-width <see cref='T:Z0.W32'/>, to a source reference and presents the cell
            at the offset as an unsigned integer of bit-width <see cref='T:Z0.W32'/>
            </summary>
            <param name="src">The data source</param>
            <param name="count">The number of 32-bit segments to skip</param>
            <typeparam name="T">The (arbitrary) source type</typeparam>
        </member>
        <member name="M:Z0.z.seek32``1(System.Span{``0},System.UInt32)">
            <summary>
            Adds an offset to the head of a span, measured relative to 32-bit segments, and returns the resulting reference
            </summary>
            <param name="src">The source span</param>
            <param name="count">The number of 32-bit segments to skip</param>
            <typeparam name="T">The source element type</typeparam>
        </member>
        <member name="M:Z0.z.seek64``1(``0@,System.UInt32)">
            <summary>
            Adds an offset, measured by 32-bit segments, to a source reference and presents the cell
            at the offset as an unsigned integer of bit-width <see cref='T:Z0.W64'/>
            </summary>
            <param name="src">The data source</param>
            <param name="count">The number of 64-bit segments to skip</param>
            <typeparam name="T">The (arbitrary) source type</typeparam>
        </member>
        <member name="M:Z0.z.seek64``1(System.Span{``0},System.UInt32)">
            <summary>
            Adds a specified offset count, measured by 64-bit segments, to the leading cell of a source span
            and returns the offset cell as an unsigned integer of bit-width <see cref='T:Z0.W64'/>
            </summary>
            <param name="src">The source span</param>
            <param name="count">The number of 64-bit segments to skip</param>
            <typeparam name="T">The source element type</typeparam>
        </member>
        <member name="M:Z0.z.seek8``1(``0@,System.UInt32)">
            <summary>
            Skips a specified number of 8-bit source segments and returns a reference to the located cell
            </summary>
            <param name="src">The data source</param>
            <param name="count">The number of 8-bit segments to skip</param>
            <typeparam name="T">The (arbitrary) source type</typeparam>
        </member>
        <member name="M:Z0.z.seek8g``1(``0@,System.UInt32)">
            <summary>
            Adds an offset to a reference, measured in bytes
            </summary>
            <param name="src">The source reference</param>
            <param name="count">The number of bytes to add</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.z.seek8``1(System.Span{``0},System.UInt32)">
            <summary>
            Adds an offset to the head of a span, measured relative to 8-bit segments, and returns the resulting reference
            </summary>
            <param name="src">The source span</param>
            <param name="count">The number of 8-bit segments to skip</param>
            <typeparam name="T">The source element type</typeparam>
        </member>
        <member name="M:Z0.z.segref``1(``0@,System.UInt32)">
            <summary>
            Presents a reference as a .. reference
            </summary>
            <param name="src">The leading cell</param>
            <param name="count">The covered cell count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.segref``1(Z0.MemoryAddress,System.UInt32)">
            <summary>
            Captures a parametric reference to cell content beginning at a specified address
            </summary>
            <param name="src">The content address</param>
            <param name="count">The content cell count</param>
            <typeparam name="T">The content type</typeparam>
        </member>
        <member name="M:Z0.z.segref(System.Void*,System.UInt32)">
            <summary>
            Captures an untyped sized reference
            </summary>
            <param name="pSrc">The source pointer</param>
            <param name="size">The data size</param>
        </member>
        <member name="M:Z0.z.segref(Z0.MemoryAddress,System.UInt32)">
            <summary>
            Captures an untyped sized reference
            </summary>
            <param name="src">The reference address</param>
            <param name="size">The data size</param>
        </member>
        <member name="M:Z0.z.set(System.SByte,System.Byte,Z0.BitState)">
            <summary>
            Aligns an index-identified source bit with with a suplied state
            </summary>
            <param name="src">The source</param>
            <param name="pos">The source bit index</param>
            <param name="state">The state with which to align a source bit</param>
        </member>
        <member name="M:Z0.z.set(System.Byte,System.Byte,Z0.BitState)">
            <summary>
            Aligns an index-identified source bit with with a suplied state
            </summary>
            <param name="src">The source</param>
            <param name="pos">The source bit index</param>
            <param name="state">The state with which to align a source bit</param>
        </member>
        <member name="M:Z0.z.set(System.Int16,System.Byte,Z0.BitState)">
            <summary>
            Aligns an index-identified source bit with with a suplied state
            </summary>
            <param name="src">The source</param>
            <param name="pos">The source bit index</param>
            <param name="state">The state with which to align a source bit</param>
        </member>
        <member name="M:Z0.z.set(System.UInt16,System.Byte,Z0.BitState)">
            <summary>
            Aligns an index-identified source bit with with a suplied state
            </summary>
            <param name="src">The source</param>
            <param name="pos">The source bit index</param>
            <param name="state">The state with which to align a source bit</param>
        </member>
        <member name="M:Z0.z.set(System.Int32,System.Byte,Z0.BitState)">
            <summary>
            Aligns an index-identified source bit with with a suplied state
            </summary>
            <param name="src">The source</param>
            <param name="pos">The source bit index</param>
            <param name="state">The state with which to align a source bit</param>
        </member>
        <member name="M:Z0.z.set(System.UInt32,System.Byte,Z0.BitState)">
            <summary>
            Aligns an index-identified source bit with with a suplied state
            </summary>
            <param name="src">The source</param>
            <param name="pos">The source bit index</param>
            <param name="state">The state with which to align a source bit</param>
        </member>
        <member name="M:Z0.z.set(System.Int64,System.Byte,Z0.BitState)">
            <summary>
            Aligns an index-identified source bit with with a suplied state
            </summary>
            <param name="src">The source</param>
            <param name="pos">The source bit index</param>
            <param name="state">The state with which to align a source bit</param>
        </member>
        <member name="M:Z0.z.set(System.UInt64,System.Byte,Z0.BitState)">
            <summary>
            Aligns an index-identified source bit with with a suplied state
            </summary>
            <param name="src">The source</param>
            <param name="index">The source bit index</param>
            <param name="value">The state with which to align a source bit</param>
        </member>
        <member name="M:Z0.z.set(System.SByte,System.Byte,System.Boolean)">
            <summary>
            Aligns an index-identified source bit with with a suplied state
            </summary>
            <param name="src">The source</param>
            <param name="pos">The source bit index</param>
            <param name="state">The state with which to align a source bit</param>
        </member>
        <member name="M:Z0.z.set(System.Byte,System.Byte,System.Boolean)">
            <summary>
            Aligns an index-identified source bit with with a suplied state
            </summary>
            <param name="src">The source</param>
            <param name="pos">The source bit index</param>
            <param name="state">The state with which to align a source bit</param>
        </member>
        <member name="M:Z0.z.set(System.Int16,System.Byte,System.Boolean)">
            <summary>
            Aligns an index-identified source bit with with a suplied state
            </summary>
            <param name="src">The source</param>
            <param name="pos">The source bit index</param>
            <param name="state">The state with which to align a source bit</param>
        </member>
        <member name="M:Z0.z.set(System.UInt16,System.Byte,System.Boolean)">
            <summary>
            Aligns an index-identified source bit with with a suplied state
            </summary>
            <param name="src">The source</param>
            <param name="pos">The source bit index</param>
            <param name="state">The state with which to align a source bit</param>
        </member>
        <member name="M:Z0.z.set(System.Int32,System.Byte,System.Boolean)">
            <summary>
            Aligns an index-identified source bit with with a suplied state
            </summary>
            <param name="src">The source</param>
            <param name="pos">The source bit index</param>
            <param name="state">The state with which to align a source bit</param>
        </member>
        <member name="M:Z0.z.set(System.UInt32,System.Byte,System.Boolean)">
            <summary>
            Aligns an index-identified source bit with with a suplied state
            </summary>
            <param name="src">The source</param>
            <param name="pos">The source bit index</param>
            <param name="state">The state with which to align a source bit</param>
        </member>
        <member name="M:Z0.z.set(System.Int64,System.Byte,System.Boolean)">
            <summary>
            Aligns an index-identified source bit with with a suplied state
            </summary>
            <param name="src">The source</param>
            <param name="pos">The source bit index</param>
            <param name="state">The state with which to align a source bit</param>
        </member>
        <member name="M:Z0.z.set(System.UInt64,System.Byte,System.Boolean)">
            <summary>
            Aligns an index-identified source bit with with a suplied state
            </summary>
            <param name="src">The source</param>
            <param name="index">The source bit index</param>
            <param name="value">The state with which to align a source bit</param>
        </member>
        <member name="M:Z0.z.sfunc``1">
            <summary>
            Creates a structural function of specified parametric type
            </summary>
            <typeparam name="S">The host type</typeparam>
        </member>
        <member name="M:Z0.z.sfunc``2(``0,``1)">
            <summary>
            Creates a structural function of specified parametric type
            </summary>
            <typeparam name="S">The host type</typeparam>
        </member>
        <member name="M:Z0.z.sfunc``3(``0,``1,``2)">
            <summary>
            Creates a structural function of specified parametric type
            </summary>
            <typeparam name="S">The host type</typeparam>
        </member>
        <member name="M:Z0.z.sign(System.Byte)">
            <summary>
            Converts a <see cref='T:System.Byte'/> to a <see cref='T:System.SByte'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.sign(System.UInt16)">
            <summary>
            Converts a <see cref='T:System.UInt16'/> to a <see cref='T:System.Int16'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.sign(System.UInt32)">
            <summary>
            Converts a <see cref='T:System.UInt32'/> to a <see cref='T:System.Int32'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.sign(System.UInt64)">
            <summary>
            Converts a <see cref='T:System.UInt64'/> to a <see cref='T:System.Int64'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.skip``1(``0@,System.Byte)">
            <summary>
            Skips a specified number of source elements and returns a readonly reference to the result
            </summary>
            <param name="src">The source reference</param>
            <param name="count">The number of elements to skip</param>
            <typeparam name="T">The source element type</typeparam>
        </member>
        <member name="M:Z0.z.skip``1(``0@,System.UInt16)">
            <summary>
            Skips a specified number of source elements and returns a readonly reference to the result
            </summary>
            <param name="src">The source reference</param>
            <param name="count">The number of elements to skip</param>
            <typeparam name="T">The source element type</typeparam>
        </member>
        <member name="M:Z0.z.skip``1(``0@,System.UInt32)">
            <summary>
            Skips a specified number of source elements and returns a readonly reference to the result
            </summary>
            <param name="src">The source reference</param>
            <param name="count">The number of elements to skip</param>
            <typeparam name="T">The source element type</typeparam>
        </member>
        <member name="M:Z0.z.skip``1(``0@,System.UInt64)">
            <summary>
            Skips a specified number of source elements and returns a readonly reference to the result
            </summary>
            <param name="src">The source reference</param>
            <param name="count">The number of elements to skip</param>
            <typeparam name="T">The source element type</typeparam>
        </member>
        <member name="M:Z0.z.skip``1(``0@,System.Int64)">
            <summary>
            Skips a specified number of source elements and returns a readonly reference to the result
            </summary>
            <param name="src">The source reference</param>
            <param name="count">The number of elements to skip</param>
            <typeparam name="T">The source element type</typeparam>
        </member>
        <member name="M:Z0.z.skip``1(``0[],System.Double)">
            <summary>
            Skips a specified number of source elements and returns a readonly reference to the result
            </summary>
            <param name="src">The source reference</param>
            <param name="count">The number of elements to skip</param>
            <typeparam name="T">The source element type</typeparam>
        </member>
        <member name="M:Z0.z.skip8``1(``0@,System.UInt32)">
            <summary>
            Skips a specified number of 8-bit source segments and returns a reference to the located cell
            </summary>
            <param name="src">The source span</param>
            <param name="count">The number of 8-bit segments to skip</param>
            <typeparam name="T">The (arbitrary) source type</typeparam>
        </member>
        <member name="M:Z0.z.snapshot(System.Diagnostics.Stopwatch)">
            <summary>
            Captures a stopwatch duration
            </summary>
            <param name="sw">A running/stopped stopwatch</param>
        </member>
        <member name="M:Z0.z.some``1(``0)">
            <summary>
            Defines a valued option
            </summary>
            <param name="value">The value</param>
            <typeparam name="T">The type of the extant value</typeparam>
        </member>
        <member name="M:Z0.z.span``2(``0@,System.Int32)">
            <summary>
            Creates a T-span from an S-reference
            </summary>
            <param name="src">A reference to the leading source cell</param>
            <param name="count">The source cell count</param>
            <typeparam name="S">The source cell type</typeparam>
            <typeparam name="T">The target cell type</typeparam>
        </member>
        <member name="M:Z0.z.span``2(``0@)">
            <summary>
            Creates a T-span from a single S-reference
            </summary>
            <param name="src">A reference to the source cell</param>
            <typeparam name="S">The source cell type</typeparam>
            <typeparam name="T">The target cell type</typeparam>
        </member>
        <member name="M:Z0.z.span``1(System.Int64)">
            <summary>
            Allocates storage for a specified number of T-cells
            </summary>
            <param name="count">The cell allocation count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.span``1(System.UInt32)">
            <summary>
            Allocates storage for a specified number of T-cells
            </summary>
            <param name="count">The cell allocation count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.span``1(System.ReadOnlySpan{``0})">
            <summary>
            Constructs a span from a readonly span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.z.span``1(System.Collections.Generic.IEnumerable{``0},Z0.Count)">
            <summary>
            Constructs a span of specified length from a sequence
            </summary>
            <param name="src">The source sequence</param>
            <param name="length">The length of the result span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.z.span``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
            <summary>
            Constructs a span of specified length from the sequence obtained by skipping a specified number of leading elements
            </summary>
            <param name="src">The source sequence</param>
            <param name="offset">The number of elements to skip</param>
            <param name="length">The length of the result span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.z.span16c``1(``0@)">
            <summary>
            Creates a u16 span from a T-cell reference
            </summary>
            <param name="src">The reference cell</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.span16c(System.ReadOnlySpan{System.Byte})">
            <summary>
            Creates a u16 span from a T-cell reference
            </summary>
            <param name="src">The reference cell</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.span16u``1(``0@)">
            <summary>
            Creates a u16 span from a T-cell reference
            </summary>
            <param name="src">The reference cell</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.span32u``1(``0@)">
            <summary>
            Creates a u32 span from a T-cell reference
            </summary>
            <param name="src">The reference cell</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.span64u``1(``0@)">
            <summary>
            Creates a u64 span from a T-cell reference
            </summary>
            <param name="src">The reference cell</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.span8u``1(``0@)">
            <summary>
            Creates a bytespan from a T-cell reference
            </summary>
            <param name="src">The reference cell</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.stopwatch(System.Boolean)">
            <summary>
            Creates a new stopwatch and optionally start it
            </summary>
            <param name="start">Whether to start the new stopwatch</param>
        </member>
        <member name="M:Z0.z.store``1(``0@,System.Span{System.Byte})">
            <summary>
            Fills a caller-supplied buffer with T-cell bytes
            </summary>
            <param name="src">The data source</param>
            <param name="dst">The target buffer</param>
        </member>
        <member name="M:Z0.z.store``2(``0@,``1@)">
            <summary>
            Writes a source to a target
            </summary>
            <param name="src">The source value</param>
            <param name="dst">The target cell</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.z.store``1(System.Collections.Generic.IEnumerable{``0},System.Span{``0})">
            <summary>
            Fills a caller-supplied span with data produced by a T-enumerable
            </summary>
            <param name="src">The data source</param>
            <param name="dst">The target</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.z.stream(System.String,System.Text.Encoding)">
            <summary>
            Allocates a caller-disposed stream over a string
            </summary>
            <param name="src">The source text</param>
            <param name="encoding">The text encoding</param>
        </member>
        <member name="M:Z0.z.stream``1(``0[])">
            <summary>
            Procduces a possibly-empty but finite value stream
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="src">The items included in the stream</param>
        </member>
        <member name="M:Z0.z.stream``1(``0,``0[])">
            <summary>
            Procduces a nonempty finite value stream
            </summary>
            <param name="head">The first stream element</param>
            <param name="tail">The remaining stream elements</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.z.stream``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Procduces an output stream by concatenating two input streams
            </summary>
            <param name="head">The first stream</param>
            <param name="tail">The second stream</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.z.stream``1(``0,System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Produces a nonempty stream
            </summary>
            <param name="head">The first element of the new stream</param>
            <param name="tail">The remaining elements of the new stream</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.z.stream``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Procduces an output stream by concatenating three input streams
            </summary>
            <param name="s1">The first stream</param>
            <param name="s2">The second stream</param>
            <param name="s3">The third stream</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.z.success``1(``0)">
            <summary>
            Creates a positive computation outcome
            </summary>
            <param name="data">The computation result</param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Z0.z.task``1(System.Func{``0})">
            <summary>
            Executes a worker that computes a value within the context of a new task
            </summary>
            <param name="worker">The worker to execute</param>
        </member>
        <member name="M:Z0.z.task(System.Action)">
            <summary>
            Executes a worker within the context of a new task
            </summary>
            <param name="worker">The worker to execute</param>
        </member>
        <member name="M:Z0.z.task``2(System.Func{``0,``1},``0)">
            <summary>
            Executes a worker that computes a value within the context of a new task
            </summary>
            <param name="worker">The worker to execute</param>
            <param name="s0">The value to supply to the worker</param>
        </member>
        <member name="M:Z0.z.test(System.SByte,System.Byte)">
            <summary>
            Determines the state of an index-identified bit
            </summary>
            <param name="src">The source value</param>
            <param name="pos">The 0-based index of the bit to test</param>
        </member>
        <member name="M:Z0.z.test(System.Byte,System.Byte)">
            <summary>
            Determines the state of an index-identified bit
            </summary>
            <param name="src">The source value</param>
            <param name="pos">The 0-based index of the bit to test</param>
        </member>
        <member name="M:Z0.z.test(System.Int16,System.Byte)">
            <summary>
            Determines the state of an index-identified bit
            </summary>
            <param name="src">The source value</param>
            <param name="pos">The 0-based index of the bit to test</param>
        </member>
        <member name="M:Z0.z.test(System.UInt16,System.Byte)">
            <summary>
            Determines the state of an index-identified bit
            </summary>
            <param name="src">The source value</param>
            <param name="pos">The 0-based index of the bit to test</param>
        </member>
        <member name="M:Z0.z.test(System.Int32,System.Byte)">
            <summary>
            Determines the state of an index-identified bit
            </summary>
            <param name="src">The source value</param>
            <param name="pos">The 0-based index of the bit to test</param>
        </member>
        <member name="M:Z0.z.test(System.UInt32,System.Byte)">
            <summary>
            Determines the state of an index-identified bit
            </summary>
            <param name="src">The source value</param>
            <param name="pos">The 0-based index of the bit to test</param>
        </member>
        <member name="M:Z0.z.test(System.Int64,System.Byte)">
            <summary>
            Determines the state of an index-identified bit
            </summary>
            <param name="src">The source value</param>
            <param name="pos">The 0-based index of the bit to test</param>
        </member>
        <member name="M:Z0.z.test(System.UInt64,System.Byte)">
            <summary>
            Determines the state of an index-identified bit
            </summary>
            <param name="src">The source value</param>
            <param name="pos">The 0-based index of the bit to test</param>
        </member>
        <member name="M:Z0.z.test(System.Single,System.Byte)">
            <summary>
            Determines the state of an index-identified bit
            </summary>
            <param name="src">The source value</param>
            <param name="pos">The 0-based index of the bit to test</param>
        </member>
        <member name="M:Z0.z.test(System.Double,System.Byte)">
            <summary>
            Determines the state of an index-identified bit
            </summary>
            <param name="src">The source value</param>
            <param name="pos">The 0-based index of the bit to test</param>
        </member>
        <member name="M:Z0.z.test(System.Decimal,System.Byte)">
            <summary>
            Determines the state of an index-identified bit
            </summary>
            <param name="src">The source value</param>
            <param name="pos">The 0-based index of the bit to test</param>
        </member>
        <member name="M:Z0.z.tripled``3(``0,``1,``2)">
            <summary>
            Creates a non-homogenous triple
            </summary>
            <param name="a">The first member</param>
            <param name="b">The second member</param>
            <param name="c">The third member</param>
            <typeparam name="A">The first member type</typeparam>
            <typeparam name="B">The second member type</typeparam>
            <typeparam name="C">The third member type</typeparam>
        </member>
        <member name="M:Z0.z.tspan``1(``0[])">
            <summary>
            Covers an array with a <see cref='T:Z0.TableSpan`1'/>
            </summary>
            <param name="src">The array to cover</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.tspan``1(System.Collections.Generic.List{``0})">
            <summary>
            Creates a <see cref='T:Z0.TableSpan`1'/> from a <see cref='T:System.Collections.Generic.List`1'/>
            </summary>
            <param name="src">The array to cover</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.tspan``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a <see cref='T:Z0.TableSpan`1'/> from a <see cref='T:System.Collections.Generic.IEnumerable`1'/>
            </summary>
            <param name="src">The array to cover</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.tspan``1(System.Byte)">
            <summary>
            Allocates a <see cref='T:Z0.TableSpan`1'/> for a specified number of cells
            </summary>
            <param name="count">The cell count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.tspan``1(System.UInt16)">
            <summary>
            Allocates a <see cref='T:Z0.TableSpan`1'/> for a specified number of cells
            </summary>
            <param name="count">The cell count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.tspan``1(System.UInt32)">
            <summary>
            Allocates a <see cref='T:Z0.TableSpan`1'/> for a specified number of cells
            </summary>
            <param name="count">The cell count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.tspan``1(System.UInt64)">
            <summary>
            Allocates a <see cref='T:Z0.TableSpan`1'/> for a specified number of cells
            </summary>
            <param name="count">The cell count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.tspan``1(Z0.Count)">
            <summary>
            Allocates a <see cref='T:Z0.TableSpan`1'/> for a specified number of cells
            </summary>
            <param name="count">The cell count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.u16(System.Boolean)">
            <summary>
            Converts a <see cref='T:System.Boolean'/> to a <see cref='T:System.UInt16'/>
            </summary>
            <param name="on">The source state</param>
        </member>
        <member name="M:Z0.z.u16``1(``0@)">
            <summary>
            Presents a T-references as a <see cref='T:System.UInt16'/> reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.u32(System.Boolean)">
            <summary>
            Converts a <see cref='T:System.Boolean'/> to a <see cref='T:System.UInt32'/>
            </summary>
            <param name="on">The source state</param>
        </member>
        <member name="M:Z0.z.u32``1(``0@)">
            <summary>
            Presents a parametric references as a <see cref='T:System.UInt32'/> reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.u64(System.Boolean)">
            <summary>
            Converts a <see cref='T:System.Boolean'/> to a <see cref='T:System.UInt64'/>
            </summary>
            <param name="on">The source state</param>
        </member>
        <member name="M:Z0.z.u64``1(``0@)">
            <summary>
            Presents a T-references as a <see cref='T:System.UInt64'/> reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.u8(System.Boolean)">
            <summary>
            Converts a <see cref='T:System.Boolean'/> to a <see cref='T:System.Byte'/>
            </summary>
            <param name="on">The source state</param>
        </member>
        <member name="M:Z0.z.u8``1(``0@)">
            <summary>
            Presents a T-references as a <see cref='T:System.Byte'/> reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.u8``1(``0@,System.Int32)">
            <summary>
            Adds a byte-measured offset to a parametric reference and presents the result as a <see cref='T:System.Byte'/> reference
            </summary>
            <param name="src">The source reference</param>
            <param name="offset">The offset count, measured in bytes</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.uint16``1(``0)">
            <summary>
            Converts a parametric source to a <see cref='T:System.UInt16'/>
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.uint16``1(System.Nullable{``0})">
            <summary>
            Converts a nullable parametric source to a nullable <see cref='T:System.UInt16'/>
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.uint32``1(``0)">
            <summary>
            Converts a parametric source to a <see cref='T:System.UInt32'/>
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.uint32``1(System.Nullable{``0})">
            <summary>
            Converts a nullable parametric source to a nullable <see cref='T:System.UInt32'/>
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.uint32(System.SByte)">
            <summary>
            Converts a <see cref='T:System.SByte'/> to a <see cref='T:System.UInt32'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.uint32(System.Byte)">
            <summary>
            Converts a <see cref='T:System.Byte'/> to a <see cref='T:System.UInt32'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.uint64``1(``0)">
            <summary>
            Converts a parametric source to a <see cref='T:System.UInt64'/>
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.uint64``1(System.Nullable{``0})">
            <summary>
            Converts a nullable parametric source to a nullable <see cref='T:System.UInt64'/>
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.uint64(System.SByte)">
            <summary>
            Converts a <see cref='T:System.SByte'/> to a <see cref='T:System.UInt64'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.uint64(System.Byte)">
            <summary>
            Converts a <see cref='T:System.Byte'/> to a <see cref='T:System.UInt64'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.uint64(System.Int16)">
            <summary>
            Converts a <see cref='T:System.Int16'/> to a <see cref='T:System.UInt64'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.uint64(System.UInt16)">
            <summary>
            Converts a <see cref='T:System.UInt16'/> to a <see cref='T:System.UInt64'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.uint8``1(``0)">
            <summary>
            Converts a parametric source to a <see cref='T:System.Byte'/>
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.uint8``1(System.Nullable{``0})">
            <summary>
            Converts a nullable parametric source to a nullable <see cref='T:System.Byte'/>
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.uint8(System.SByte)">
            <summary>
            Converts a <see cref='T:System.SByte'/> to a <see cref='T:System.Byte'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.uint8(System.Byte)">
            <summary>
            Defines an identity function over <see cref='T:System.Byte'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.uint8(System.Int16)">
            <summary>
            Converts a <see cref='T:System.Int16'/> to a <see cref='T:System.Byte'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.uint8(System.UInt16)">
            <summary>
            Converts a <see cref='T:System.UInt16'/> to a <see cref='T:System.Byte'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.uint8(System.Int32)">
            <summary>
            Converts a <see cref='T:System.Int32'/> to a <see cref='T:System.Byte'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.uint8(System.UInt32)">
            <summary>
            Converts a <see cref='T:System.UInt32'/> to a <see cref='T:System.Byte'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.uint8(System.Int64)">
            <summary>
            Converts a <see cref='T:System.Int64'/> to a <see cref='T:System.Byte'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.uint8(System.UInt64)">
            <summary>
            Converts a <see cref='T:System.UInt64'/> to a <see cref='T:System.Byte'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.uint8(System.Single)">
            <summary>
            Converts a <see cref='T:System.Single'/> to a <see cref='T:System.Byte'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.uint8(System.Double)">
            <summary>
            Converts a <see cref='T:System.Double'/> to a <see cref='T:System.Byte'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.unbox``1(System.Object)">
            <summary>
            Takes a value out of a box
            </summary>
            <param name="src">The boxed value</param>
            <typeparam name="T">The boxed type</typeparam>
        </member>
        <member name="M:Z0.z.unpack``1(``0,System.Span{Z0.BitState})">
            <summary>
            Populates a caller-supplied target with unpacked source bits
            </summary>
            <param name="src">The data source</param>
            <param name="dst">The target</param>
            <typeparam name="T">The data source type</typeparam>
        </member>
        <member name="M:Z0.z.unparsed``2(``0,``1)">
            <summary>
            Defines a parse result that signals failure
            </summary>
            <param name="source">The input value</param>
            <param name="target">The (invalid) target value</param>
            <typeparam name="S">The input type</typeparam>
            <typeparam name="T">The parse target type</typeparam>
        </member>
        <member name="M:Z0.z.unparsed``2(``0,``1,System.String)">
            <summary>
            Defines a parse result that signals failure
            </summary>
            <param name="source">The input value</param>
            <param name="target">The (invalid) target value</param>
            <param name="reason">The failure reason</param>
            <typeparam name="S">The input type</typeparam>
            <typeparam name="T">The parse target type</typeparam>
        </member>
        <member name="M:Z0.z.unparsed``1(System.String,``0)">
            <summary>
            Defines a parse result that signals failure
            </summary>
            <param name="source">The input value</param>
            <param name="target">The (invalid) target value</param>
            <param name="reason">The failure reason, if available</param>
            <typeparam name="S">The input type</typeparam>
            <typeparam name="T">The parse target type</typeparam>
        </member>
        <member name="M:Z0.z.unparsed``1(System.String,System.Exception,``0)">
            <summary>
            Defines a parse result that signals failure
            </summary>
            <param name="source">The input value</param>
            <param name="error">The excaption that occurred</param>
            <param name="target">The default (and invalid) target value</param>
            <typeparam name="T">The parse target type</typeparam>
        </member>
        <member name="M:Z0.z.unparsed``1(System.String,System.String)">
            <summary>
            Defines a parse result that signals failure
            </summary>
            <param name="source">The input value</param>
            <param name="reason">The failure reason</param>
            <typeparam name="T">The parse target type</typeparam>
        </member>
        <member name="M:Z0.z.unparsed``1(System.Char,System.Object)">
            <summary>
            Defines a parse result that signals failure
            </summary>
            <param name="source">The input value</param>
            <param name="reason">The failure reason, if available</param>
            <typeparam name="T">The parse target type</typeparam>
        </member>
        <member name="M:Z0.z.unsign(System.SByte)">
            <summary>
            Converts a <see cref='T:System.SByte'/> to a <see cref='T:System.Byte'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.unsign(System.Int16)">
            <summary>
            Converts a <see cref='T:System.Int16'/> to a <see cref='T:System.UInt16'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.unsign(System.Int32)">
            <summary>
            Converts a <see cref='T:System.Int32'/> to a <see cref='T:System.UInt32'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.unsign(System.Int64)">
            <summary>
            Converts a <see cref='T:System.Int64'/> to a <see cref='T:System.UInt64'/>
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.unsigned(System.Byte)">
            <summary>
            This function exists to remediate, in certain situations, the compiler's blindly illogical 
            devotion to signed 32-bit integers
            </summary>
            <param name="src">The source value that the compiler cannot interpret an unsigned 8-bit integer</param>
        </member>
        <member name="M:Z0.z.unsigned(System.UInt16)">
            <summary>
            This function exists to remediate, in certain situations, the compiler's blindly illogical 
            devotion to signed 32-bit integers
            </summary>
            <param name="src">The source value that the compiler cannot interpret an unsigned 16-bit integer</param>
        </member>
        <member name="M:Z0.z.unsigned(System.UInt32)">
            <summary>
            This function exists to complement the remedial functions <see cref='M:Z0.z.unsigned(System.Byte)'/> and  <see cref='M:Z0.z.unsigned(System.UInt16)'/> 
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.unsigned(System.UInt64)">
            <summary>
            This function exists to complement the remedial functions <see cref='M:Z0.z.unsigned(System.Byte)'/> and  <see cref='M:Z0.z.unsigned(System.UInt16)'/> 
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.z.vapid``1(``0@)">
            <summary>
            Determines whether a structural value is 'empty':
            A structural value is *empty* if, when rendered as an array of bytes, each aelement of the array is zero.
            </summary>
            <param name="src">The value to adjudicate</param>
            <typeparam name="T">The value type</typeparam>
        </member>
        <member name="M:Z0.z.view(Z0.StringRef@)">
            <summary>
            Reveals the character data identified by a string reference
            </summary>
            <param name="src">The source reference</param>
        </member>
        <member name="M:Z0.z.view``1(Z0.SegRef@)">
            <summary>
            Covers a memory reference with a readonly span
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.view``2(``0@)">
            <summary>
            Presents a readonly S-reference as a readonly T-reference
            </summary>
            <param name="src">The data source</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.z.view``1(``0@,System.UInt32)">
            <summary>
            Creates a T-span from a supplied reference
            </summary>
            <param name="src">A reference to the leading cell</param>
            <param name="count">The source cell count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.view``1(Z0.W8,``0@)">
            <summary>
            Presents a readonly T-reference as a reference of bit-width w
            </summary>
            <param name="w">The target width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.view``1(Z0.W16,``0@)">
            <summary>
            Presents a readonly T-reference as a reference of bit-width w
            </summary>
            <param name="w">The target width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.view``1(Z0.W32,``0@)">
            <summary>
            Presents a readonly T-reference as a reference of bit-width w
            </summary>
            <param name="w">The target width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.view``1(Z0.W64,``0@)">
            <summary>
            Presents a readonly T-reference as a reference of bit-width w
            </summary>
            <param name="w">The target width selector</param>
            <param name="src">The data source</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.view8i``1(``0@)">
            <summary>
            Interprets a readonly T-reference as a readonly int8 reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.view8u``1(``0@)">
            <summary>
            Interprets a readonly T-reference as a readonly uint8 reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.view16i``1(``0@)">
            <summary>
            Interprets a readonly T-reference as a readonly int16 reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.view16u``1(``0@)">
            <summary>
            Interprets a readonly T-reference as a readonly uint16 reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.view32i``1(``0@)">
            <summary>
            Interprets a readonly T-reference as a readonly int32 reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.view32u``1(``0@)">
            <summary>
            Interprets a readonly T-reference as a readonly uint32 reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.view64i``1(``0@)">
            <summary>
            Interprets a readonly T-reference as a readonly uint64 reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.view64u``1(``0@)">
            <summary>
            Interprets a readonly T-reference as a readonly uint64 reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.view64f``1(``0@)">
            <summary>
            Interprets a readonly T-reference as a readonly float64 reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.view128f``1(``0@)">
            <summary>
            Interprets a readonly T-reference as a readonly float128 reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.view16c``1(``0@)">
            <summary>
            Interprets a readonly T-reference as a readonly char reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.view1u``1(``0@)">
            <summary>
            Interprets a readonly T-reference as a readonly bool reference
            </summary>
            <param name="src">The source reference</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.z.iseq``1(``0[])">
            <summary>
            Produces an indexed sequence from a parameter array
            </summary>
            <param name="src">The source items</param>
            <typeparam name="T">The item type</typeparam>
        </member>
        <member name="M:Z0.z.vindex``1(``0[])">
            <summary>
            Creates a value index from an array
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.vset``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a value set from a stream
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.vset``1(``0[])">
            <summary>
            Creates a value set from an array
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.z.width``1(``0)">
            <summary>
            Computes the type width of a parametrically-identified type
            </summary>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="T:Z0.ClMulMask">
            <summary>
            Defines a mask that specifies the left/right vector components from which a carry-less product will be formed
            </summary>
        </member>
        <member name="F:Z0.ClMulMask.X00">
            <summary>
            For a product P = XY, multiply the lo(X) and lo(Y)
            </summary>
        </member>
        <member name="F:Z0.ClMulMask.X01">
            <summary>
            For a product P = XY, multiply the lo(X) and hi(Y)
            </summary>
        </member>
        <member name="F:Z0.ClMulMask.X10">
            <summary>
            For a product P = XY, multiply the hi(X) and lo(Y)
            </summary>
        </member>
        <member name="F:Z0.ClMulMask.X11">
            <summary>
            For a product P = XY, multiply the hi(X) and hi(Y)
            </summary>
        </member>
        <member name="T:Z0.VLut16">
            <summary>
            Implements a parallel 16-way lookup
            </summary>
        </member>
        <member name="T:Z0.VLut32">
            <summary>
            Implements a parallel 32-way lookup
            </summary>
        </member>
        <member name="M:Z0.VXTend.Cell``1(System.Runtime.Intrinsics.Vector128{``0},System.Int32)">
            <summary>
            Extracts an index-identified component from the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="index">The index of the component to extract</param>
            <typeparam name="T">The primal component type</typeparam>
        </member>
        <member name="M:Z0.VXTend.Cell``1(System.Runtime.Intrinsics.Vector128{``0},System.Int32,``0)">
            <summary>
            Sets an index-identified component to a specified value
            </summary>
            <param name="src">The source vector</param>
            <param name="index">The index of the component to extract</param>
            <param name="value">The new component value</param>
            <typeparam name="T">The primal component type</typeparam>
        </member>
        <member name="M:Z0.VXTend.Cell``1(System.Runtime.Intrinsics.Vector256{``0},System.Int32,``0)">
            <summary>
            Sets an index-identified component to a specified value
            </summary>
            <param name="src">The source vector</param>
            <param name="index">The index of the component to extract</param>
            <param name="value">The new component value</param>
            <typeparam name="T">The primal component type</typeparam>
        </member>
        <member name="M:Z0.VXTend.Cell``1(System.Runtime.Intrinsics.Vector256{``0},System.Int32)">
            <summary>
            Extracts an index-identified component from the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="index">The index of the component to extract</param>
            <typeparam name="T">The primal component type</typeparam>
        </member>
        <member name="M:Z0.VXTend.Length``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>
            Returns the number of source vector components
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.VXTend.Length``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>
            Returns the number of source vector components
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.VXTend.LoadVector``1(Z0.SpanBlock128{``0}@)">
            <summary>
            Loads a 128-bit vector from the first 128-bit block
            </summary>
            <param name="src">The source span</param>
            <param name="block">The block index</param>
            <typeparam name="T">The primitive type</typeparam>
        </member>
        <member name="M:Z0.VXTend.LoadVector``1(Z0.SpanBlock128{``0}@,System.Int32)">
            <summary>
            Loads a block-identified 128-bit vector
            </summary>
            <param name="src">The source span</param>
            <param name="block">The block index</param>
            <typeparam name="T">The primitive type</typeparam>
        </member>
        <member name="M:Z0.VXTend.LoadVectors``1(Z0.SpanBlock128{``0}@,System.Int32,System.Int32)">
            <summary>
            Loads 2 block-indexed 128-bit vectors
            </summary>
            <param name="src">The source span</param>
            <param name="block1">The block index of the first vector</param>
            <param name="block2">The block index of the second vector</param>
            <typeparam name="T">The primitive type</typeparam>
        </member>
        <member name="M:Z0.VXTend.LoadVectors``1(Z0.SpanBlock128{``0}@,System.Int32,System.Int32,System.Int32)">
            <summary>
            Loads 3 block-indexed 128-bit vectors
            </summary>
            <param name="src">The source span</param>
            <param name="block1">The block index of the first vector</param>
            <param name="block2">The block index of the second vector</param>
            <param name="block3">The block index of the third vector</param>
            <typeparam name="T">The primitive type</typeparam>
        </member>
        <member name="M:Z0.VXTend.LoadVector``1(Z0.SpanBlock256{``0}@)">
            <summary>
            Loads a 256-bit vector from the first 256-bit block
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The primitive type</typeparam>
        </member>
        <member name="M:Z0.VXTend.LoadVectors``1(Z0.SpanBlock256{``0}@,System.Int32,System.Int32)">
            <summary>
            Loads 2 block-indexed 256-bit vectors
            </summary>
            <param name="src">The source span</param>
            <param name="block1">The block index of the first vector</param>
            <param name="block2">The block index of the second vector</param>
            <typeparam name="T">The primitive type</typeparam>
        </member>
        <member name="M:Z0.VXTend.LoadVectors``1(Z0.SpanBlock256{``0}@,System.Int32,System.Int32,System.Int32)">
            <summary>
            Loads 3 block-indexed 256-bit vectors
            </summary>
            <param name="src">The source span</param>
            <param name="block1">The block index of the first vector</param>
            <param name="block2">The block index of the second vector</param>
            <param name="block3">The block index of the third vector</param>
            <typeparam name="T">The primitive type</typeparam>
        </member>
        <member name="M:Z0.VXTend.LoadVector``1(Z0.SpanBlock512{``0}@)">
            <summary>
            Loads a 512-bit vector from the first 512-bit block
            </summary>
            <param name="src">The source span</param>
            <param name="block">The block index</param>
            <typeparam name="T">The primitive type</typeparam>
        </member>
        <member name="M:Z0.VXTend.LoadVector``1(Z0.SpanBlock256{``0}@,System.Int32)">
            <summary>
            Loads a 256-bit vector from an index-identified block
            </summary>
            <param name="src">The source span</param>
            <param name="block">The block index</param>
            <typeparam name="T">The primitive type</typeparam>
        </member>
        <member name="M:Z0.VXTend.LoadVector``1(Z0.SpanBlock256{``0}@,System.UInt32)">
            <summary>
            Loads a 256-bit vector from an index-identified block
            </summary>
            <param name="src">The source span</param>
            <param name="block">The block index</param>
            <typeparam name="T">The primitive type</typeparam>
        </member>
        <member name="M:Z0.VXTend.LoadVector``1(Z0.SpanBlock512{``0}@,System.Int32)">
            <summary>
            Loads 512-bit vector from an index-identified block
            </summary>
            <param name="src">The source span</param>
            <param name="block">The block index</param>
            <typeparam name="T">The primitive type</typeparam>
        </member>
        <member name="M:Z0.VXTend.LoadVector``1(System.Span{``0},Z0.W128,System.Int32)">
            <summary>
            Loads a 128-bit vector from a span
            </summary>
            <param name="src">The source span</param>
            <param name="offset">The position of the fist source element </param>
        </member>
        <member name="M:Z0.VXTend.LoadVector``1(System.Span{``0},Z0.W256,System.Int32)">
            <summary>
            Loads a 256-bit vector from a span
            </summary>
            <param name="src">The source span</param>
            <param name="offset">The position of the fist source element </param>
        </member>
        <member name="M:Z0.VXTend.LoadVector``1(System.Span{``0},Z0.W512,System.Int32)">
            <summary>
            Loads a 512-bit vector from a span
            </summary>
            <param name="src">The source span</param>
            <param name="offset">The position of the fist source element </param>
        </member>
        <member name="M:Z0.VXTend.LoadVector``1(System.ReadOnlySpan{``0},Z0.W128,System.Int32)">
            <summary>
            Loads a 128-bit vector from a readonly span
            </summary>
            <param name="src">The source span</param>
            <param name="offset">The position of the fist source element </param>
        </member>
        <member name="M:Z0.VXTend.LoadVector``1(System.ReadOnlySpan{``0},Z0.W256,System.Int32)">
            <summary>
            Loads a 256-bit vector from a readonly span
            </summary>
            <param name="src">The source span</param>
            <param name="offset">The position of the fist source element </param>
        </member>
        <member name="M:Z0.VXTend.LoadVector``1(System.ReadOnlySpan{``0},Z0.W512,System.Int32)">
            <summary>
            Loads a 512-bit vector from a readonly span
            </summary>
            <param name="src">The source span</param>
            <param name="offset">The position of the fist source element </param>
        </member>
        <member name="M:Z0.VXTend.StoreTo``1(System.Runtime.Intrinsics.Vector128{``0},System.Span{``0},System.Int32)">
            <summary>
            Stores vector content to a caller-supplied span
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.VXTend.StoreTo``1(System.Runtime.Intrinsics.Vector256{``0},System.Span{``0},System.Int32)">
            <summary>
            Stores vector content to a caller-supplied span
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.VXTend.StoreTo``1(Z0.Vector512{``0},System.Span{``0},System.Int32)">
            <summary>
            Stores vector content to a caller-supplied span
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
        </member>
        <member name="M:Z0.VXTend.StoreTo``1(System.Runtime.Intrinsics.Vector128{``0},``0@,System.Int32)">
            <summary>
            Stores vector content to a memory reference
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
            <param name="offset">The target offset</param>
        </member>
        <member name="M:Z0.VXTend.StoreTo``1(System.Runtime.Intrinsics.Vector256{``0},``0@,System.Int32)">
            <summary>
            Stores vector content to a memory reference
            </summary>
            <param name="src">The source vector</param>
            <param name="dst">The target memory</param>
            <param name="offset">The target offset</param>
        </member>
        <member name="M:Z0.VXTend.ToSpan``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>
            Allocates a span into which vector content is stored
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The component type</typeparam>
        </member>
        <member name="M:Z0.VXTend.ToSpan``1(System.Runtime.Intrinsics.Vector256{``0})">
            <summary>
            Allocates and deposits vector content to a span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The component type</typeparam>
        </member>
        <member name="M:Z0.VXTend.ToSpan``1(Z0.Vector512{``0})">
            <summary>
            Allocates and deposits vector content to a span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The component type</typeparam>
        </member>
        <member name="F:Z0.VXTend.Closure">
            <summary>
            Specifies unsigned integral types of widths <see cref='F:Z0.Konst.NumericWidths'/>
            </summary>
        </member>
        <member name="T:Z0.IAppError">
            <summary>
            Characterizes an event that describes an error
            </summary>
        </member>
        <member name="T:Z0.IAppError`1">
            <summary>
            Characterizes an error event reification
            </summary>
        </member>
        <member name="T:Z0.IAppEvent">
            <summary>
            Characterizes a correlated message, accompanied by arbitrary content,
            that describes an occurrence of something interesting
            </summary>
        </member>
        <member name="T:Z0.IAppEvent`1">
            <summary>
            Characterizes a reified application event
            </summary>
            <typeparam name="F">The reification type</typeparam>
        </member>
        <member name="T:Z0.IAppEventSink`1">
            <summary>
            Characterizes an event-parametric application event sink
            </summary>
            <typeparam name="E">The event type</typeparam>
        </member>
        <member name="P:Z0.IAppMsg.Kind">
            <summary>
            The message classification
            </summary>
        </member>
        <member name="P:Z0.IAppMsg.Flair">
            <summary>
            The message foreground color when rendered for display
            </summary>
        </member>
        <member name="P:Z0.IAppMsg.IsError">
            <summary>
            Specifies whether the message describes an error
            </summary>
        </member>
        <member name="T:Z0.IDataEvent`1">
            <summary>
            Characterizes a reified application event
            </summary>
            <typeparam name="F">The reification type</typeparam>
        </member>
        <member name="T:Z0.IWfEvent`1">
            <summary>
            Characterizes a reified event
            </summary>
            <typeparam name="H">The reifying type</typeparam>
        </member>
        <member name="T:Z0.IWfEvent`2">
            <summary>
            Characterizes a reified event with parametric content
            </summary>
            <typeparam name="H">The event type</typeparam>
            <typeparam name="T">The content type</typeparam>
        </member>
        <member name="T:Z0.AppMsg">
            <summary>
            Defines a message that encapsulates application diagnostic/status/error message content
            </summary>
        </member>
        <member name="P:Z0.AppMsg.Kind">
            <summary>
            The message classification
            </summary>
        </member>
        <member name="P:Z0.AppMsg.Flair">
            <summary>
            The message foreground color when rendered for display
            </summary>
        </member>
        <member name="F:Z0.AppMsgData.Content">
            <summary>
            The message payload
            </summary>
        </member>
        <member name="F:Z0.AppMsgData.Pattern">
            <summary>
            Defines a content render pattern, if applicable
            </summary>
        </member>
        <member name="F:Z0.AppMsgData.Kind">
            <summary>
            The message classification
            </summary>
        </member>
        <member name="F:Z0.AppMsgData.Flair">
            <summary>
            The message foreground color when rendered for display
            </summary>
        </member>
        <member name="F:Z0.AppMsgData.Origin">
            <summary>
            Specifies the emitting executable part
            </summary>
        </member>
        <member name="F:Z0.AppMsgData`1.Content">
            <summary>
            The message payload
            </summary>
        </member>
        <member name="F:Z0.AppMsgData`1.Pattern">
            <summary>
            Defines a content render pattern, if applicable
            </summary>
        </member>
        <member name="F:Z0.AppMsgData`1.Kind">
            <summary>
            The message classification
            </summary>
        </member>
        <member name="F:Z0.AppMsgData`1.Flair">
            <summary>
            The message foreground color when rendered for display
            </summary>
        </member>
        <member name="F:Z0.AppMsgData`1.Origin">
            <summary>
            Specifies the emitting executable part
            </summary>
        </member>
        <member name="T:Z0.AppMsgSource">
            <summary>
            Specifies application message origination details
            </summary>
        </member>
        <member name="F:Z0.AppMsgSource.Part">
            <summary>
            Specifies the emitting executable part
            </summary>
        </member>
        <member name="F:Z0.AppMsgSource.Caller">
            <summary>
            The name of the member that originated the message
            </summary>
        </member>
        <member name="F:Z0.AppMsgSource.File">
            <summary>
            The path to the source file in which the message originated
            </summary>
        </member>
        <member name="F:Z0.AppMsgSource.Line">
            <summary>
            The source file line number on which the message originated
            </summary>
        </member>
        <member name="T:Z0.EventId">
            <summary>
            Defines logical event identity
            </summary>
        </member>
        <member name="P:Z0.EventId.Ts">
            <summary>
            The originating part/host
            </summary>
        </member>
        <member name="P:Z0.EventId.Ct">
            <summary>
            The event classifier/discriminator
            </summary>
        </member>
        <member name="M:Z0.WfEventId.define(System.String,System.Nullable{Z0.CorrelationToken})">
            <summary>
            Creates a workflow event
            </summary>
            <param name="name">The event name</param>
            <param name="ct">The correlation token, if any</param>
            <param name="ts">The timestamp which, if unspecified, will default to the event creation time (now)</param>
        </member>
        <member name="P:Z0.WfEventId.Name">
            <summary>
            The event data type name
            </summary>
        </member>
        <member name="M:Z0.WfEvents.created(Z0.WfStepId,Z0.CorrelationToken,Z0.FlairKind)">
            <summary>
            Defines a <see cref='T:Z0.CreatedEvent'/> event
            </summary>
            <param name="id">The step identifier</param>
            <param name="ct">The correlation token</param>
            <param name="flair">The flair</param>
        </member>
        <member name="M:Z0.WfEvents.created(Z0.ToolId,Z0.CorrelationToken,Z0.FlairKind)">
            <summary>
            Defines a <see cref='T:Z0.CmdCreatedEvent'/> event
            </summary>
            <param name="id">The step identifier</param>
            <param name="ct">The correlation token</param>
            <param name="flair">The flair</param>
        </member>
        <member name="M:Z0.WfEvents.created``1(Z0.WfStepId,``0,Z0.CorrelationToken,Z0.FlairKind)">
            <summary>
            Defines a <see cref='T:Z0.CreatedEvent`1'/> event
            </summary>
            <param name="id">The step identifier</param>
            <param name="ct">The correlation token</param>
            <param name="flair">The flair</param>
        </member>
        <member name="M:Z0.WfEvents.disposed(Z0.WfStepId,Z0.CorrelationToken)">
            <summary>
            Defines a <see cref='T:Z0.DisposedEvent'/> event
            </summary>
            <param name="id">The step identifier</param>
            <param name="ct">The correlation token</param>
        </member>
        <member name="M:Z0.WfEvents.disposed``1(Z0.WfStepId,``0,Z0.CorrelationToken)">
            <summary>
            Defines a <see cref='T:Z0.Disposed`1'/> event that carries a specified payload
            </summary>
            <param name="id">The step identifier</param>
            <param name="payload">The payload data</param>
            <param name="ct">The correlation token</param>
        </member>
        <member name="M:Z0.WfEvents.status``1(Z0.WfStepId,``0,Z0.CorrelationToken)">
            <summary>
            Creates a <see cref='T:Z0.StatusEvent`1'/> message
            </summary>
            <param name="step">The executing step</param>
            <param name="content">The status content</param>
            <param name="ct">The correlation token</param>
            <typeparam name="T">The content type</typeparam>
        </member>
        <member name="M:Z0.WfEvents.succeeded(Z0.CmdSpec,Z0.CorrelationToken,Z0.FlairKind)">
            <summary>
            Defines a <see cref='T:Z0.CmdSucceeded`1'/> event
            </summary>
            <param name="id">The step identifier</param>
            <param name="ct">The correlation token</param>
            <param name="flair">The flair</param>
        </member>
        <member name="M:Z0.WfEvents.succeeded``1(Z0.CmdSpec,``0,Z0.CorrelationToken,Z0.FlairKind)">
            <summary>
            Defines a <see cref='T:Z0.CmdSucceeded`1'/> event
            </summary>
            <param name="id">The step identifier</param>
            <param name="ct">The correlation token</param>
            <param name="flair">The flair</param>
        </member>
        <member name="M:Z0.WfEvents.trace``1(Z0.WfStepId,``0,Z0.CorrelationToken)">
            <summary>
            Creates a <see cref='T:Z0.TraceEvent`1'/> message
            </summary>
            <param name="step">The executing step</param>
            <param name="content">The status content</param>
            <param name="ct">The correlation token</param>
            <typeparam name="T">The content type</typeparam>
        </member>
        <member name="M:Z0.AppMsgExchange.Create">
            <summary>
            Creates an exchange and underlying queue
            </summary>
        </member>
        <member name="T:Z0.BenchmarkRecord">
            <summary>
            Defines a benchmark measure for an operator
            </summary>
        </member>
        <member name="F:Z0.BenchmarkRecord.OpId">
            <summary>
            The name of the measured operation
            </summary>
        </member>
        <member name="F:Z0.BenchmarkRecord.OpCount">
            <summary>
            Either the invocation count or the number of discrete operations performed
            </summary>
        </member>
        <member name="F:Z0.BenchmarkRecord.Timing">
            <summary>
            The measured time
            </summary>
        </member>
        <member name="T:Z0.EventRelay`1">
            <summary>
            Defines a sink that forwards deposits to a receiver
            </summary>
        </member>
        <member name="T:Z0.HubRelay">
            <summary>
            Defines a sink that forwards deposits to a receiver
            </summary>
        </member>
        <member name="T:Z0.HubRelay`1">
            <summary>
            Defines a sink that forwards deposits to a receiver
            </summary>
        </member>
        <member name="T:Z0.TestCaseRecord">
            <summary>
            Describes the outcome of a test case
            </summary>
        </member>
        <member name="T:Z0.WfDataSink`1">
            <summary>
            Defines a canonical table sink predicated on a process function
            </summary>
        </member>
        <member name="M:Z0.WfMsgExchange.Create(Z0.IWfShell)">
            <summary>
            Creates an exchange and underlying queue
            </summary>
        </member>
        <member name="P:Z0.Shell`1.AppPaths">
            <summary>
            The default application path collection
            </summary>
        </member>
        <member name="P:Z0.Shell`1.Term">
            <summary>
            The shell terminal
            </summary>
        </member>
        <member name="T:Z0.Shell`2">
            <summary>
            Base class for shells with pararametric context
            </summary>
            <typeparam name="S">The shell reification type</typeparam>
            <typeparam name="C">The shell context type</typeparam>
        </member>
        <member name="P:Z0.IWfInit.Shell">
            <summary>
            The context root
            </summary>
        </member>
        <member name="P:Z0.IWfInit.Logs">
            <summary>
            The specified log configuration
            </summary>
        </member>
        <member name="P:Z0.IWfInit.ApiParts">
            <summary>
            The input data archive configuration
            </summary>
        </member>
        <member name="P:Z0.IWfInit.Control">
            <summary>
            The entry assembly
            </summary>
        </member>
        <member name="P:Z0.IWfInit.Api">
            <summary>
            The configured api set
            </summary>
        </member>
        <member name="P:Z0.IWfInit.ControlId">
            <summary>
            The controlling part
            </summary>
        </member>
        <member name="P:Z0.IWfInit.PartIdentities">
            <summary>
            The parts considered by the workflow
            </summary>
        </member>
        <member name="T:Z0.WfInit">
            <summary>
            Captures workflow configuration data
            </summary>
        </member>
        <member name="P:Z0.WfInit.Control">
            <summary>
            The entry assembly
            </summary>
        </member>
        <member name="P:Z0.WfInit.ControlId">
            <summary>
            The entry assembly identifier
            </summary>
        </member>
        <member name="P:Z0.WfInit.PartIdentities">
            <summary>
            The parts considered by the workflow
            </summary>
        </member>
        <member name="P:Z0.WfInit.Context">
            <summary>
            The context root
            </summary>
        </member>
        <member name="P:Z0.WfInit.Logs">
            <summary>
            The specified log configuration
            </summary>
        </member>
        <member name="P:Z0.WfInit.ApiParts">
            <summary>
            The input data archive configuration
            </summary>
        </member>
        <member name="T:Z0.WfPaths">
            <summary>
            Reifies default application path service
            </summary>
        </member>
        <member name="M:Z0.WfShell.sink``1(Z0.IWfShell,Z0.ValueReceiver{``0})">
            <summary>
            Creates a T-parametric sink predicated on a <see cref='T:Z0.ValueReceiver`1'/> process function
            </summary>
            <param name="wf">The workflow context</param>
            <param name="f">The process function</param>
            <typeparam name="T">The data type</typeparam>
        </member>
        <member name="M:Z0.Workflow.source(System.String,System.String,System.Nullable{System.Int32})">
            <summary>
            Defines a <see cref='T:Z0.AppMsgSource'/>
            </summary>
            <param name="caller">The member name</param>
            <param name="file">The caller file path</param>
            <param name="line">The caller line number</param>
        </member>
        <member name="M:Z0.Workflow.step``1">
            <summary>
            Defines a workflow step id predicated on a parametric controller type
            </summary>
            <typeparam name="T">The host type</typeparam>
        </member>
        <member name="T:Z0.WfTermLog">
            <summary>
            Reifies a workflow event receiver that both logs received events and renders received events to the terminal
            </summary>
        </member>
        <member name="M:Z0.XWFShell.Subscribe``1(``0,Z0.IWfBroker,System.Action{``0})">
            <summary>
            Registers an event receiver to which brokered events will be relayed
            </summary>
            <param name="e">An event representative</param>
            <param name="broker">The broker</param>
            <param name="receiver">The handler invoked upon event occurrence</param>
            <typeparam name="E">The event type</typeparam>
        </member>
        <member name="M:Z0.AppErrors.define``1(System.String,``0)">
            <summary>
            Creates an error event
            </summary>
            <param name="content">The event content</param>
        </member>
        <member name="T:Z0.StepAttribute">
            <summary>
            Identifies a workflow step controller
            </summary>
        </member>
        <member name="T:Z0.WfHostAttribute">
            <summary>
            Identifies a workflow host
            </summary>
        </member>
        <member name="M:Z0.CaseLogs.write(System.String,System.IO.FileStream,System.Text.Encoding)">
            <summary>
            Writes text data to the target
            </summary>
            <param name="src">The source content</param>
            <param name="dst">The target stream</param>
            <param name="encoding">The encoding to use, which defaults to <see cref='P:System.Text.Encoding.UTF8'/> if unspecified</param>
        </member>
        <member name="P:Z0.ILogPaths.RuntimeLogs">
            <summary>
            The global application log root
            </summary>
        </member>
        <member name="P:Z0.ILogPaths.RuntimeData">
            <summary>
            The global application log root
            </summary>
        </member>
        <member name="P:Z0.ILogPaths.AppLogFolder">
            <summary>
            The name of the runtime log folder
            </summary>
        </member>
        <member name="T:Z0.IShell">
            <summary>
            Characterizes console-controlled, perhaps user-initiated, thread of execution
            </summary>
        </member>
        <member name="T:Z0.IShell`1">
            <summary>
            Characterizes a reified shell
            </summary>
        </member>
        <member name="T:Z0.ITestLogger">
            <summary>
            Defines minimal contract for a log message sink
            </summary>
        </member>
        <member name="P:Z0.ITestLogPaths.TestDataFolder">
            <summary>
            The name of a folder to which test data is emitted
            </summary>
        </member>
        <member name="P:Z0.ITestLogPaths.TestDataRoot">
            <summary>
            The root folder for test-specific data
            </summary>
        </member>
        <member name="P:Z0.ITestLogPaths.TestLogRoot">
            <summary>
            The root test directory
            </summary>
        </member>
        <member name="M:Z0.ITestLogPaths.TestDataDir(System.Type)">
            <summary>
            Defines a test-specific data folder
            </summary>
            <param name="test">The test host type</param>
        </member>
        <member name="M:Z0.ITestLogPaths.TestDataDir``1">
            <summary>
            Defines a parametrically-identified test-specific data folder
            </summary>
            <typeparam name="T">The test host type</typeparam>
        </member>
        <member name="P:Z0.IWfPaths.DbRoot">
            <summary>
            The workflow's database root
            </summary>
        </member>
        <member name="P:Z0.IWfPaths.AppDataDir">
            <summary>
            The executing application's data directory
            </summary>
        </member>
        <member name="P:Z0.IWfPaths.DevRoot">
            <summary>
            The path to the root development directory
            </summary>
        </member>
        <member name="P:Z0.IWfPaths.OutcomeFolder">
            <summary>
            The name of the folder into which test results are deposited
            </summary>
        </member>
        <member name="P:Z0.IWfPaths.DevSrcFolder">
            <summary>
            The name of the development source folder
            </summary>
        </member>
        <member name="P:Z0.IWfPaths.ConfigFileName">
            <summary>
            The name of an application configuration file
            </summary>
        </member>
        <member name="P:Z0.IWfPaths.ConfigRoot">
            <summary>
            The path to the directory that contains runtime configuration data
            </summary>
        </member>
        <member name="P:Z0.IWfPaths.ResourceRoot">
            <summary>
            The path to the root application resource directory
            </summary>
        </member>
        <member name="P:Z0.IWfPaths.ResIndexDir">
            <summary>
            The path to the resource index directory
            </summary>
        </member>
        <member name="P:Z0.IWfPaths.AppFolder">
            <summary>
            The executing application's folder name
            </summary>
        </member>
        <member name="P:Z0.IWfPaths.AppDevRoot">
            <summary>
            The application-relative source code directory
            </summary>
        </member>
        <member name="P:Z0.IWfPaths.AppConfigPath">
            <summary>
            The executing application's configuration file path
            </summary>
        </member>
        <member name="P:Z0.IWfPaths.AppDataRoot">
            <summary>
            The executing application's data directory
            </summary>
        </member>
        <member name="P:Z0.IWfPaths.AppCaptureRoot">
            <summary>
            The application-relative capture directory
            </summary>
        </member>
        <member name="M:Z0.IWfPaths.ForApp">
            <summary>
            Creates a path provider for the controlling application
            </summary>
        </member>
        <member name="T:Z0.IWfState`1">
            <summary>
            Attaches a state/context to a <see cref='T:Z0.IWfShell'/>
            </summary>
            <typeparam name="S">The state type</typeparam>
        </member>
        <member name="T:Z0.IWfStep">
            <summary>
            Describes a workflow step
            </summary>
        </member>
        <member name="T:Z0.IWfStep`1">
            <summary>
            Describes a workflow step
            </summary>
        </member>
        <member name="T:Z0.IWfStepArg">
            <summary>
            Defines an untyped characterization of a wokflow operand
            </summary>
        </member>
        <member name="P:Z0.IWfStepArg.Index">
            <summary>
            An integer that identifies an argument within the context of the defining step
            </summary>
        </member>
        <member name="P:Z0.IWfStepArg.Value">
            <summary>
            The encoded argument value
            </summary>
        </member>
        <member name="T:Z0.IWfStepArg`1">
            <summary>
            Characterizes a workflow operand
            </summary>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="T:Z0.IWfStepArg`2">
            <summary>
            Characterizes a workflow operand argument with parametric index type
            </summary>
            <typeparam name="T">The operand type</typeparam>
            <typeparam name="H">The operand type</typeparam>
        </member>
        <member name="T:Z0.IWfStepArg`3">
            <summary>
            Characterizes a refied workflow operand argument with parametric index type
            </summary>
            <typeparam name="T">The operand type</typeparam>
            <typeparam name="H">The operand type</typeparam>
        </member>
        <member name="P:Z0.IWfStepId.HostName">
            <summary>
            The fully-qualified host name
            </summary>
        </member>
        <member name="P:Z0.IWfStepId.Token">
            <summary>
            The step token
            </summary>
        </member>
        <member name="P:Z0.IWfStepId`1.Z0#IWfStepId#Token">
            <summary>
            The step token
            </summary>
        </member>
        <member name="T:Z0.LogLevel">
            <summary>
            Classifier for application messages
            </summary>
        </member>
        <member name="F:Z0.LogLevel.None">
            <summary>
            Boring
            </summary>
        </member>
        <member name="F:Z0.LogLevel.Babble">
            <summary>
            Identifies chatty content
            </summary>
        </member>
        <member name="F:Z0.LogLevel.Info">
            <summary>
            Identifies informational content
            </summary>
        </member>
        <member name="F:Z0.LogLevel.Warning">
            <summary>
            Identifies warning content
            </summary>
        </member>
        <member name="F:Z0.LogLevel.Error">
            <summary>
            Identifies error content
            </summary>
        </member>
        <member name="F:Z0.LogLevel.Benchmark">
            <summary>
            Identifies benchmark/timing result
            </summary>
        </member>
        <member name="F:Z0.LogLevel.HiliteCL">
            <summary>
            Cyan foreground
            </summary>
        </member>
        <member name="T:Z0.WfDelegates.Indexer`1">
            <summary>
            Canonical signature for a function that projects the values of an enumeration onto a contiguous and strictly monotonic sequence
            of integers [0,.., n - 1] where n denotes the maximum number of indexed items
            </summary>
            <param name="k">The enum literal to map to an integer value</param>
            <typeparam name="E">The enum type</typeparam>
        </member>
        <member name="T:Z0.FsFlows`2">
            <summary>
            Defines a 1-many FSO flow
            </summary>
        </member>
        <member name="T:Z0.FsFlow`2">
            <summary>
            Defines a heterogenous file system object flow
            </summary>
        </member>
        <member name="T:Z0.FsFlow`1">
            <summary>
            Defines a homogenous file system object flow
            </summary>
        </member>
        <member name="T:Z0.CallingMember">
            <summary>
            Captures invocation origin details
            </summary>
        </member>
        <member name="F:Z0.CallingMember.Name">
            <summary>
            The originator name
            </summary>
        </member>
        <member name="F:Z0.CallingMember.File">
            <summary>
            The name of the file from which the invocation occurred
            </summary>
        </member>
        <member name="F:Z0.CallingMember.FileLine">
            <summary>
            The file-relative invocation line number
            </summary>
        </member>
        <member name="T:Z0.WfAction`1">
            <summary>
            Represents a step in a workflow that accepts no arguments
            </summary>
        </member>
        <member name="T:Z0.WfStepId">
            <summary>
            Identifies a workflow step - which is synonymous with its actuator/host/controller
            </summary>
        </member>
        <member name="P:Z0.WfStepId.Token">
            <summary>
            The step token
            </summary>
        </member>
        <member name="T:Z0.WfStepId`2">
            <summary>
            Identifies a workflow step
            </summary>
        </member>
        <member name="P:Z0.WfStepId`2.Source">
            <summary>
            The step controller
            </summary>
        </member>
        <member name="P:Z0.WfStepId`2.Target">
            <summary>
            The step effector
            </summary>
        </member>
        <member name="P:Z0.WfStepId`2.Token">
            <summary>
            The step token
            </summary>
        </member>
        <member name="T:Z0.WfStepId`1">
            <summary>
            Identifies a workflow step
            </summary>
        </member>
        <member name="P:Z0.WfStepId`1.HostName">
            <summary>
            The step name
            </summary>
        </member>
        <member name="P:Z0.WfStepId`1.Control">
            <summary>
            The step controller
            </summary>
        </member>
        <member name="P:Z0.WfStepId`1.Effect">
            <summary>
            The step effector
            </summary>
        </member>
        <member name="P:Z0.WfStepId`1.Token">
            <summary>
            The step token
            </summary>
        </member>
        <member name="T:Z0.Env">
            <summary>
            Reifies an application environment service predicated on environment variables
            </summary>
        </member>
        <member name="T:Z0.EnvVar">
            <summary>
            Defines a nonparametric environment variable
            </summary>
        </member>
        <member name="P:Z0.EnvVar.Name">
            <summary>
            The environment variable name
            </summary>
        </member>
        <member name="P:Z0.EnvVar.Value">
            <summary>
            The environment variable value
            </summary>
        </member>
        <member name="T:Z0.EnvVar`1">
            <summary>
            Defines a value-parametric environment variable
            </summary>
        </member>
        <member name="F:Z0.WfConfig.Control">
            <summary>
            The controlling part
            </summary>
        </member>
        <member name="F:Z0.WfConfig.Args">
            <summary>
            The controlling arguments, in raw form as supplied by the entry point or caller
            </summary>
        </member>
        <member name="F:Z0.WfConfig.Settings">
            <summary>
            The shell settings
            </summary>
        </member>
        <member name="F:Z0.WfConfig.Parts">
            <summary>
            The parts considered by the workflow
            </summary>
        </member>
        <member name="F:Z0.WfConfig.ModuleRoot">
            <summary>
            The module directory
            </summary>
        </member>
        <member name="F:Z0.WfConfig.CaptureRoot">
            <summary>
            The root capture directory
            </summary>
        </member>
        <member name="F:Z0.WfConfig.TableRoot">
            <summary>
            The root table directory
            </summary>
        </member>
        <member name="F:Z0.WfConfig.StatusPath">
            <summary>
            The shell-specific status log path
            </summary>
        </member>
        <member name="F:Z0.WfConfig.ErrorPath">
            <summary>
            The shell-specific error log path
            </summary>
        </member>
        <member name="F:Z0.WfLogConfig.Control">
            <summary>
            The controlling part identifier
            </summary>
        </member>
        <member name="F:Z0.WfLogConfig.Root">
            <summary>
            The log file root directory
            </summary>
        </member>
        <member name="F:Z0.WfLogConfig.StatusLog">
            <summary>
            The status log path
            </summary>
        </member>
        <member name="F:Z0.WfLogConfig.ErrorLog">
            <summary>
            The error log path
            </summary>
        </member>
        <member name="F:Z0.WfLogConfig.DbRoot">
            <summary>
            The location to which completed logs are published
            </summary>
        </member>
        <member name="M:Z0.Unsupported.define``1">
            <summary>
            Populates a <see cref="T:System.NotSupportedException"/> complaining that a 
            parametrically-identified type is not supported
            </summary>
            <typeparam name="T">The unsupported type</typeparam>
        </member>
        <member name="M:Z0.Unsupported.define(System.Type)">
            <summary>
            Populates a <see cref="T:System.NotSupportedException"/> complaining that a 
            parametrically-identified type is not supported
            </summary>
            <typeparam name="T">The unsupported type</typeparam>
        </member>
        <member name="M:Z0.Unsupported.value``1(``0)">
            <summary>
            Populates a <see cref="T:System.NotSupportedException"/> complaining that a  value is not supported
            </summary>
            <typeparam name="T">The value type</typeparam>
        </member>
        <member name="M:Z0.Unsupported.define``1(System.String)">
            <summary>
            Populates a <see cref="T:System.NotSupportedException"/>, populated with a custom message describing why a 
            parametrically-identified type is not supported
            </summary>
            <typeparam name="T">The unsupported type</typeparam>
        </member>
        <member name="M:Z0.Unsupported.define(Z0.NumericKind)">
            <summary>
            Populates a <see cref="T:System.NotSupportedException"/> complaining that a specified numeric kind isn't supported
            </summary>
            <typeparam name="T">The unsupported type</typeparam>
        </member>
        <member name="M:Z0.Unsupported.raise``1">
            <summary>
            Raises <see cref="T:System.NotSupportedException"/> complaining that a 
            parametrically-identified type is not supported
            </summary>
            <typeparam name="T">The unsupported type</typeparam>
        </member>
        <member name="M:Z0.Unsupported.raise``1(``0)">
            <summary>
            Populates a <see cref="T:System.NotSupportedException"/> complaining that a  value is not supported
            </summary>
            <typeparam name="T">The value type</typeparam>
        </member>
        <member name="M:Z0.Unsupported.raise``1(System.String)">
            <summary>
            Raises <see cref="T:System.NotSupportedException"/> populated with a custom message describing why a 
            parametrically-identified type is not supported
            </summary>
            <typeparam name="T">The unsupported type</typeparam>
        </member>
        <member name="M:Z0.RootLegacy.thread(System.UInt32)">
            <summary>
            Searches for a thread given an OS-assigned id, not the useless clr id
            </summary>
            <param name="id">The OS thread Id</param>
        </member>
        <member name="T:System.Meridiem">
            <summary>
            Provides an enumeration of AM or PM to support 12-hour clock values in the <see cref="T:System.TimeOfDay"/> type.
            </summary>
            <remarks>
            Though commonly used in English, these abbreviations derive from Latin.
            AM is an abbreviation for "Ante Meridiem", meaning "before mid-day".
            PM is an abbreviation for "Post Meridiem", meaning "after mid-day".
            </remarks>
        </member>
        <member name="F:System.Meridiem.AM">
            <summary>
            
            </summary>
        </member>
        <member name="F:System.Meridiem.PM">
            <summary>
            
            </summary>
        </member>
        <member name="T:System.Date">
            <summary>
            Represents a whole date, having a year, month and day component.
            All values are in the proleptic Gregorian (ISO 8601) calendar system unless otherwise specified.
            </summary>
        </member>
        <member name="M:System.Date.Between(System.Date,System.Date)">
            <summary>
            Defines a <see cref="T:Z0.DateRange"/> bounded below by <paramref name="MinDate"/>
            and above by <paramref name="MaxDate"/>
            </summary>
            <param name="MinDate">The range minimum</param>
            <param name="MaxDate">The range maximum</param>
        </member>
        <member name="M:System.Date.ToLexicalString">
            <summary>
            Renders a <see cref="T:System.Date"/> to the form YYYY-MM-DD
            </summary>
        </member>
        <member name="P:System.Date.MinValue">
            <summary>
            Represents the smallest possible value of <see cref="T:System.Date"/>. This field is read-only.
            </summary>
        </member>
        <member name="P:System.Date.MaxValue">
            <summary>
            Represents the largest possible value of <see cref="T:System.Date"/>. This field is read-only.
            </summary>
        </member>
        <member name="M:System.Date.#ctor(System.Int32)">
            <summary>
            Initializes a new instance of a <see cref="T:System.Date"/> structure to a specified number of days.
            </summary>
            <param name="dayNumber">The number of days since January 1, 0001 in the proleptic Gregorian calendar.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="dayNumber"/> is out of the range supported by the <see cref="T:System.Date"/> object.
            </exception>
        </member>
        <member name="M:System.Date.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of a <see cref="T:System.Date"/> structure to a specified year, month, and day.
            </summary>
            <param name="year">The year (1 through 9999).</param>
            <param name="month">The month (1 through 12).</param>
            <param name="day">The day (1 through the number of days in <paramref name="month"/>).</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="year"/> is less than 1 or greater than 9999.
            <para>-or-</para>
            <paramref name="month"/> is less than 1 or greater than 12.
            <para>-or-</para>
            <paramref name="day"/> is less than 1 or greater than the number of days in <paramref name="month"/>.
            </exception>
        </member>
        <member name="M:System.Date.#ctor(System.Int32,System.Int32,System.Int32,System.Globalization.Calendar)">
            <summary>
            Initializes a new instance of Date structure to a specified year, month, and day for the specified calendar.
            </summary>
            <param name="year">The year (1 through the number of years in <paramref name="calendar"/>).</param>
            <param name="month">The month (1 through the number of months in <paramref name="calendar"/>).</param>
            <param name="day">The day (1 through the number of days in <paramref name="month"/>).</param>
            <param name="calendar">
            The calendar that is used to interpret <paramref name="year"/>,
            <paramref name="month"/>, and <paramref name="day"/>.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="calendar"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="year"/> is not in the range supported by <paramref name="calendar"/>.
            <para>-or-</para>
            <paramref name="month"/> is less than 1 or greater than the number of months in <paramref name="calendar"/>.
            <para>-or-</para>
            <paramref name="day"/> is less than 1 or greater than the number of days in <paramref name="month"/>.
            </exception>
        </member>
        <member name="M:System.Date.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of a <see cref="T:System.Date"/> structure to a specified year, and day of year.
            </summary>
            <param name="year">The year (1 through 9999).</param>
            <param name="dayOfYear">The day of year (1 through the number of days in <paramref name="year"/>).</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="year"/> is less than 1 or greater than 9999.
            <para>-or-</para>
            <paramref name="dayOfYear"/> is less than 1 or greater than the number of days in <paramref name="year"/>.
            </exception>
            <remarks>
            Note that standard years have days numbered 1 through 365, while leap years have days numbered 1 through 366.
            </remarks>
        </member>
        <member name="P:System.Date.Year">
            <summary>
            Gets the year component of the date represented by this instance.
            </summary>
            <value>The year component, expressed as a value between 1 and 9999.</value>
        </member>
        <member name="P:System.Date.Month">
            <summary>
            Gets the month component of the date represented by this instance.
            </summary>
            <value>The month component, expressed as a value between 1 and 12.</value>
        </member>
        <member name="P:System.Date.Day">
            <summary>
            Gets the day component of the date represented by this instance.
            </summary>
            <value>The day component, expressed as a value between 1 and 31.</value>
        </member>
        <member name="P:System.Date.DayOfYear">
            <summary>
            Gets the day of the year represented by this instance.
            </summary>
            <value>The day of the year, expressed as a value between 1 and 366.</value>
        </member>
        <member name="P:System.Date.DayOfWeek">
            <summary>
            Gets the day of the week represented by this instance.
            </summary>
            <value>An enumerated constant that indicates the day of the week of this <see cref="T:System.Date"/> value.</value>
        </member>
        <member name="P:System.Date.DayNumber">
            <summary>
            Gets the number of days since January 1, 0001 in the proleptic Gregorian calendar.
            </summary>
            <value>
            The number of days that represent the date of this instance.
            The value is between <c>Date.MinValue.DayNumber</c> and <c>Date.MaxValue.DayNumber</c>.
            </value>
        </member>
        <member name="M:System.Date.At(System.TimeOfDay)">
            <summary>
            Creates a <see cref="T:System.DateTime"/> object from the current <see cref="T:System.Date"/> and the specified <see cref="T:System.TimeOfDay"/>.
            The resulting value has a <see cref="P:System.DateTime.Kind"/> of <see cref="F:System.DateTimeKind.Unspecified"/>.
            </summary>
            <remarks>
            Since neither <see cref="T:System.Date"/> or <see cref="T:System.TimeOfDay"/> keep track of <see cref="T:System.DateTimeKind"/>,
            recognize that the <see cref="T:System.DateTime"/> produced by <c>Date.Today.At(TimeOfDay.Now)</c> will have
            <see cref="F:System.DateTimeKind.Unspecified"/>, rather than then <see cref="F:System.DateTimeKind.Local"/> that would be
            given by <c>DateTime.Now</c>.
            <para>The same applies for <see cref="F:System.DateTimeKind.Utc"/>.</para>
            </remarks>
        </member>
        <member name="M:System.Date.ToDateTimeAtMidnight">
            <summary>
            Creates a <see cref="T:System.DateTime"/> object from the current <see cref="T:System.Date"/>, with the time set to midnight
            (00:00:00). The resulting value has a <see cref="P:System.DateTime.Kind"/> of <see cref="F:System.DateTimeKind.Unspecified"/>.
            </summary>
            <remarks>
            Note that midnight might be ambiguous or invalid in some time zones on DST transition days.
            Though this method is time zone ignorant, the resulting value should be considered suspect and used with
            caution.
            </remarks>
        </member>
        <member name="M:System.Date.IsLeapYear(System.Int32)">
            <summary>
            Returns an indication whether the specified year is a leap year.
            </summary>
            <param name="year">A 4-digit year.</param>
            <returns><c>true</c> if year is a leap year; otherwise, <c>false</c>.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="year"/> is less than 1 or greater than 9999.
            </exception>
        </member>
        <member name="M:System.Date.DaysInMonth(System.Int32,System.Int32)">
            <summary>
            Returns the number of days in the specified month and year.
            </summary>
            <returns>
            The number of days in <paramref name="month"/> for the specified <paramref name="year"/>.
            For example, if <paramref name="month"/> equals 2 for February, the return value is 28 or 29 depending
            upon whether <paramref name="year"/> is a leap year.
            </returns>
            <param name="year">The year.</param>
            <param name="month">The month (a number ranging from 1 to 12).</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="month"/> is less than 1 or greater than 12.
            <para>-or-</para>
            <paramref name="year"/> is less than 1 or greater than 9999.
            </exception>
        </member>
        <member name="M:System.Date.TodayInTimeZone(System.TimeZoneInfo)">
            <summary>
            Gets a <see cref="T:System.Date"/> object that is set to the current date in the specified time zone.
            </summary>
            <param name="timeZoneInfo">The <see cref="T:System.TimeZoneInfo"/> instance.</param>
            <returns>The current <see cref="T:System.Date"/> for the specified time zone.</returns>
        </member>
        <member name="P:System.Date.Today">
            <summary>
            Gets a <see cref="T:System.Date"/> object that is set to the current date,
            expressed in this computer's local time zone.
            </summary>
            <value>An object whose value is the current local date.</value>
        </member>
        <member name="P:System.Date.UtcToday">
            <summary>
            Gets a <see cref="T:System.Date"/> object that is set to the current date,
            expressed as Coordinated Universal Time (UTC).
            </summary>
            <value>An object whose value is the current UTC date.</value>
        </member>
        <member name="M:System.Date.AddYears(System.Int32)">
            <summary>
            Gets a <see cref="T:System.Date"/> object whose value is ahead or behind the value of this instance by the specified
            number of years. Positive values will move the date forward; negative values will move the date backwards.
            <para>
            If the original date is a leap day (February 29), and the resulting year is not a leap year, the resulting
            value will be adjusted to February 28.
            </para>
            </summary>
            <param name="years">The number of years to adjust by. The value can be negative or positive.</param>
            <returns>
            A new <see cref="T:System.Date"/> object which is the result of adjusting this instance by the
            <paramref name="years"/> specified.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="years"/> or the resulting <see cref="T:System.Date"/> is less than <see cref="P:System.Date.MinValue"/>
            or greater than <see cref="P:System.Date.MaxValue"/>.
            </exception>
        </member>
        <member name="M:System.Date.AddMonths(System.Int32)">
            <summary>
            Gets a <see cref="T:System.Date"/> object whose value is ahead or behind the value of this instance by the specified
            number of months. Positive values will move the date forward; negative values will move the date backwards.
            <para>
            Since the number of days in a months varies, the resulting date may not necessarily fall on the same
            day. If the resulting value would have landed on a day that doesn't exist within a month, the value is
            adjusted backward to the last day of the month.
            </para>
            </summary>
            <param name="months">The number of months to adjust by. The value can be negative or positive.</param>
            <returns>
            A new <see cref="T:System.Date"/> object which is the result of adjusting this instance by the
            <paramref name="months"/> specified.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="months"/> or the resulting <see cref="T:System.Date"/> is less than <see cref="P:System.Date.MinValue"/>
            or greater than <see cref="P:System.Date.MaxValue"/>.
            </exception>
        </member>
        <member name="M:System.Date.AddDays(System.Int32)">
            <summary>
            Gets a <see cref="T:System.Date"/> object whose value is ahead or behind the value of this instance by the specified
            number of days. Positive values will move the date forward; negative values will move the date backwards.
            </summary>
            <param name="days">The number of days to adjust by. The value can be negative or positive.</param>
            <returns>
            A new <see cref="T:System.Date"/> object which is the result of adjusting this instance by the
            <paramref name="days"/> specified.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="days"/> or the resulting <see cref="T:System.Date"/> is less than <see cref="P:System.Date.MinValue"/>
            or greater than <see cref="P:System.Date.MaxValue"/>.
            </exception>
        </member>
        <member name="M:System.Date.DaysUntil(System.Date)">
            <summary>
            Returns the number of days remaining from this date to the <paramref name="date"/> specified.
            If the <paramref name="date"/> has already passed, the result will be negative.
            </summary>
            <param name="date">The target <see cref="T:System.Date"/> value.</param>
            <returns>The integer number of days until the date specified.</returns>
            <remarks>
            This operation uses an exclusive upper bound.
            For example, if the current instance represents January 1st, there is one day until January 2nd.
            </remarks>
        </member>
        <member name="M:System.Date.DaysSince(System.Date)">
            <summary>
            Returns the number of days elapsed from the <paramref name="date"/> specified to this date.
            If the <paramref name="date"/> has not yet passed, the result will be negative.
            </summary>
            <param name="date">The target <see cref="T:System.Date"/> value.</param>
            <returns>The integer number of days since the date specified.</returns>
            <remarks>
            This operation uses an exclusive upper bound.
            For example, if the current instance represents January 2nd, there has been one day since January 1st.
            </remarks>
        </member>
        <member name="M:System.Date.MonthsUntil(System.Date)">
            <summary>
            Returns the number of whole months remaining from this date to the <paramref name="date"/> specified.
            If the <paramref name="date"/> has already passed, the result will be negative.
            </summary>
            <param name="date">The target <see cref="T:System.Date"/> value.</param>
            <returns>The integer number of whole months until the date specified.</returns>
            <remarks>
            This operation uses an exclusive upper bound.
            For example, if the current instance represents January 1st, there is one month until February 1st.
            </remarks>
        </member>
        <member name="M:System.Date.MonthsSince(System.Date)">
            <summary>
            Returns the number of whole months elapsed from the <paramref name="date"/> specified to this date.
            If the <paramref name="date"/> has not yet passed, the result will be negative.
            </summary>
            <param name="date">The target <see cref="T:System.Date"/> value.</param>
            <returns>The integer number of whole months since the date specified.</returns>
            <remarks>
            This operation uses an exclusive upper bound.
            For example, if the current instance represents February 1st, there has been one month since January 1st.
            </remarks>
        </member>
        <member name="M:System.Date.YearsUntil(System.Date)">
            <summary>
            Returns the number of whole years remaining from this date to the <paramref name="date"/> specified.
            If the <paramref name="date"/> has already passed, the result will be negative.
            </summary>
            <param name="date">The target <see cref="T:System.Date"/> value.</param>
            <returns>The integer number of whole years until the date specified.</returns>
            <remarks>
            This operation uses an exclusive upper bound.
            For example, if the current instance represents <c>2000-01-01</c>,
            there is one year until <c>2001-01-01</c>.
            </remarks>
        </member>
        <member name="M:System.Date.YearsSince(System.Date)">
            <summary>
            Returns the number of whole years elapsed from the <paramref name="date"/> specified to this date.
            If the <paramref name="date"/> has not yet passed, the result will be negative.
            </summary>
            <param name="date">The target <see cref="T:System.Date"/> value.</param>
            <returns>The integer number of whole years since the date specified.</returns>
            <remarks>
            This operation uses an exclusive upper bound.
            For example, if the current instance represents <c>2001-01-01</c>,
            there has been one year since <c>2000-01-01</c>.
            </remarks>
        </member>
        <member name="M:System.Date.IsBetween(System.Date,System.Date,System.Boolean)">
            <summary>
            Determines if a date falls within the range provided.
            </summary>
            <param name="startDate">The starting date, inclusive.</param>
            <param name="endDate">
            The ending date, either inclusive or exclusive, depending on the value of
            <paramref name="exclusiveEndDate"/>.
            </param>
            <param name="exclusiveEndDate">
            If true, then the <paramref name="endDate"/> is treated as exclusive.
            Otherwise, the <paramref name="endDate"/> is treated as inclusive.
            The default is <c>false</c> (inclusive).
            </param>
            <returns>True, if the date falls within the range, false otherwise.</returns>
            <remarks>
            Because a <see cref="T:System.Date"/> is intended to represent a whole calendar date,
            this operation is inclusive by default.  For example, January 7th would be
            considered to be included in the week of January 1st through January 7th.
            If you desire the end date to be excluded, then set the <paramref name="exclusiveEndDate"/>
            parameter to <c>true</c>.
            </remarks>
        </member>
        <member name="M:System.Date.Compare(System.Date,System.Date)">
            <summary>
            Compares two instances of <see cref="T:System.Date"/> and returns an integer that indicates whether the first
            instance is earlier than, the same as, or later than the second instance.
            </summary>
            <param name="left">The first object to compare.</param>
            <param name="right">The second object to compare.</param>
            <returns>
            A signed number indicating the relative values of <paramref name="left"/> and <paramref name="right"/>.
            <list type="table">
            <listheader><term>Value</term><term>Description</term></listheader>
            <item>
              <term>Less than zero</term>
              <term><paramref name="left"/> is earlier than <paramref name="right"/>.</term>
            </item>
            <item>
              <term>Zero</term>
              <term><paramref name="left"/> is the same as <paramref name="right"/>.</term>
            </item>
            <item>
              <term>Greater than zero</term>
              <term><paramref name="left"/> is later than <paramref name="right"/>.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:System.Date.CompareTo(System.Date)">
            <summary>
            Compares the value of this instance to a specified <see cref="T:System.Date"/> value and returns an integer that
            indicates whether this instance is earlier than, the same as, or later than the specified
            <see cref="T:System.Date"/> value.
            </summary>
            <param name="value">The object to compare to the current instance.</param>
            <returns>
            A signed number indicating the relative values of this instance and the <paramref name="value"/> parameter.
            <list type="table">
            <listheader><term>Value</term><term>Description</term></listheader>
            <item>
              <term>Less than zero</term>
              <term>This instance is earlier than <paramref name="value"/>.</term>
            </item>
            <item>
              <term>Zero</term>
              <term>This instance is the same as <paramref name="value"/>.</term>
            </item>
            <item>
              <term>Greater than zero</term>
              <term>This instance is later than <paramref name="value"/>.</term>
            </item>
            </list>
            </returns>
        </member>
        <member name="M:System.Date.CompareTo(System.Object)">
            <summary>
            Compares the value of this instance to a specified object that contains a <see cref="T:System.Date"/> value and
            returns an integer that indicates whether this instance is earlier than, the same as, or later than the
            specified <see cref="T:System.Date"/> value.
            </summary>
            <param name="value">The object to compare to the current instance.</param>
            <returns>
            A signed number indicating the relative values of this instance and the <paramref name="value"/> parameter.
            <list type="table">
            <listheader><term>Value</term><term>Description</term></listheader>
            <item>
              <term>Less than zero</term>
              <term>This instance is earlier than <paramref name="value"/>.</term>
            </item>
            <item>
              <term>Zero</term>
              <term>This instance is earlier than <paramref name="value"/>.</term>
            </item>
            <item>
              <term>Greater than zero</term>
              <term>
                This instance is later than <paramref name="value"/>,
                or <paramref name="value"/> is <c>null</c>.
              </term>
            </item>
            </list>
            </returns>
            <exception cref="T:System.ArgumentException">
            <paramref name="value"/> is not a <see cref="T:System.Date"/>.
            </exception>
        </member>
        <member name="M:System.Date.Equals(System.Date,System.Date)">
            <summary>
            Returns a value indicating whether two <see cref="T:System.Date"/> instances have the same date value.
            </summary>
            <param name="left">The first object to compare.</param>
            <param name="right">The second object to compare.</param>
            <returns><c>true</c> if the two values are equal; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:System.Date.Equals(System.Date)">
            <summary>
            Returns a value indicating whether the value of this instance is equal to the value of the specified
            <see cref="T:System.Date"/> instance.
            </summary>
            <param name="value">The other <see cref="T:System.Date"/> object to compare against this instance.</param>
            <returns>
            <c>true</c> if the <paramref name="value"/> parameter equals the value of this instance;
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:System.Date.Equals(System.Object)">
            <summary>
            Returns a value indicating whether this instance is equal to the specified object.
            </summary>
            <param name="value">The object to compare to this instance.</param>
            <returns>
            <c>true</c> if <paramref name="value"/> is an instance of <see cref="T:System.Date"/>
            and equals the value of this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:System.Date.GetHashCode">
            <summary>
            Returns the hash code of this instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
            <remarks>
            The hash code of a <see cref="T:System.Date"/> object is the day number, which is the 
            number of days since January 1, 0001 in the proleptic Gregorian calendar.
            </remarks>
        </member>
        <member name="M:System.Date.ToString">
            <summary>
            Converts the value of the current <see cref="T:System.Date"/> object to its equivalent string representation.
            </summary>
            <returns>A string representation of value of the current <see cref="T:System.Date"/> object.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The date is outside the range of dates supported by the calendar used by the current culture.
            </exception>
        </member>
        <member name="M:System.Date.ToString(System.IFormatProvider)">
            <summary>
            Converts the value of the current <see cref="T:System.Date"/> object to its equivalent string representation
            using the specified culture-specific format information.
            </summary>
            <param name="provider">An object that supplies culture-specific formatting information.</param>
            <returns>
            A string representation of value of the current <see cref="T:System.Date"/> object as specified by
            <paramref name="provider"/>.
            </returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The date is outside the range of dates supported by the calendar used by <paramref name="provider"/>.
            </exception>
        </member>
        <member name="M:System.Date.ToString(System.String)">
            <summary>
            Converts the value of the current <see cref="T:System.Date"/> object to its equivalent string representation
            using the specified format.
            </summary>
            <param name="format">A standard or custom date format string.</param>
            <returns>
            A string representation of value of the current <see cref="T:System.Date"/> object as specified by
            <paramref name="format"/>.
            </returns>
            <exception cref="T:System.FormatException">
            The length of <paramref name="format"/> is 1, and it is not one of the format specifier characters defined
            for <see cref="T:System.Globalization.DateTimeFormatInfo"/>.
            <para>-or-</para>
            <paramref name="format"/> does not contain a valid custom format pattern.
            <para>-or-</para>
            The standard or custom format specified is not valid for a <see cref="T:System.Date"/> object, because it contains
            a time-of-day component.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The date is outside the range of dates supported by the calendar used by the current culture.
            </exception>
        </member>
        <member name="M:System.Date.ToString(System.String,System.IFormatProvider)">
            <summary>
            Converts the value of the current <see cref="T:System.Date"/> object to its equivalent string representation
            using the specified format and culture-specific format information.
            </summary>
            <param name="format">A standard or custom date format string.</param>
            <param name="provider">An object that supplies culture-specific formatting information.</param>
            <returns>
            A string representation of value of the current <see cref="T:System.Date"/> object as specified by
            <paramref name="format"/> and <paramref name="provider"/>.
            </returns>
            <exception cref="T:System.FormatException">
            The length of <paramref name="format"/> is 1, and it is not one of the format specifier characters defined
            for <see cref="T:System.Globalization.DateTimeFormatInfo"/>.
            <para>-or-</para>
            <paramref name="format"/> does not contain a valid custom format pattern.
            <para>-or-</para>
            The standard or custom format specified is not valid for a <see cref="T:System.Date"/> object, because it contains
            a time-of-day component.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The date is outside the range of dates supported by the calendar used by <paramref name="provider"/>.
            </exception>
        </member>
        <member name="M:System.Date.ToLongDateString">
            <summary>
            Converts the value of the current <see cref="T:System.Date"/> object to its equivalent long date string
            representation.
            </summary>
            <returns>
            A string that contains the long date string representation of the current <see cref="T:System.Date"/> object.
            </returns>
            <remarks>
            The value of the current <see cref="T:System.Date"/> object is formatted using the pattern defined by the
            <see cref="P:System.Globalization.DateTimeFormatInfo.LongDatePattern" /> property associated with the current thread culture.
            </remarks>
        </member>
        <member name="M:System.Date.ToShortDateString">
            <summary>
            Converts the value of the current <see cref="T:System.Date"/> object to its equivalent short date string
            representation.
            </summary>
            <returns>
            A string that contains the short date string representation of the current <see cref="T:System.Date"/> object.
            </returns>
            <remarks>
            The value of the current <see cref="T:System.Date"/> object is formatted using the pattern defined by the
            <see cref="P:System.Globalization.DateTimeFormatInfo.ShortDatePattern" /> property associated with the current thread culture.
            </remarks>
        </member>
        <member name="M:System.Date.ToIsoString">
            <summary>
            Converts the value of the current <see cref="T:System.Date"/> object to its equivalent ISO standard string
            representation (ISO-8601), which has the format: <c>yyyy-MM-dd</c>.
            </summary>
            <returns>
            A string that contains the ISO standard string representation of the current <see cref="T:System.Date"/> object.
            </returns>
            <remarks>
            Because the ISO-8601 standard uses the proleptic Gregorian calendar, this method always uses the calendar
            of the <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>, despite the setting of the current culture.
            </remarks>
        </member>
        <member name="M:System.Date.Parse(System.String)">
            <summary>
            Converts the string representation of a date to its <see cref="T:System.Date"/> equivalent.
            </summary>
            <param name="s">A string that contains a date to convert.</param>
            <returns>An object that is equivalent to the date contained in <paramref name="s"/>.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="s"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.FormatException">
            <paramref name="s"/> does not contain a valid string representation of a date.
            </exception>
        </member>
        <member name="M:System.Date.Parse(System.String,System.IFormatProvider)">
            <summary>
            Converts the string representation of a date to its <see cref="T:System.Date"/> equivalent
            by using culture-specific format information.
            </summary>
            <param name="s">A string that contains a date to convert.</param>
            <param name="provider">
            An object that supplies culture-specific formatting information about <paramref name="s"/>.
            </param>
            <returns>
            An object that is equivalent to the date contained in <paramref name="s"/>,
            as specified by <paramref name="provider"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="s"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.FormatException">
            <paramref name="s"/> does not contain a valid string representation of a date.
            </exception>
        </member>
        <member name="M:System.Date.Parse(System.String,System.IFormatProvider,System.Globalization.DateTimeStyles)">
            <summary>
            Converts the string representation of a date to its <see cref="T:System.Date"/> equivalent
            by using culture-specific format information and formatting style.
            </summary>
            <param name="s">A string that contains a date to convert.</param>
            <param name="provider">
            An object that supplies culture-specific formatting information about <paramref name="s"/>.
            </param>
            <param name="styles">
            A bitwise combination of the enumeration values that indicates the style elements that
            can be present in <paramref name="s"/> for the parse operation to succeed.
            Note that only styles related to whitespace handling are applicable on a <see cref="T:System.Date"/>.
            A typical value to specify is <see cref="F:System.Globalization.DateTimeStyles.None"/>.
            </param>
            <returns>
            An object that is equivalent to the date contained in <paramref name="s"/>,
            as specified by <paramref name="provider"/> and <paramref name="styles"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="s"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.FormatException">
            <paramref name="s"/> does not contain a valid string representation of a date.
            </exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="styles"/> styles contains an invalid <see cref="T:System.Globalization.DateTimeStyles"/> values.
            The only styles that are valid for a <see cref="T:System.Date"/> are:
            <see cref="F:System.Globalization.DateTimeStyles.None"/>, <see cref="F:System.Globalization.DateTimeStyles.AllowLeadingWhite"/>,
            <see cref="F:System.Globalization.DateTimeStyles.AllowTrailingWhite"/>, <see cref="F:System.Globalization.DateTimeStyles.AllowInnerWhite"/>, and
            <see cref="F:System.Globalization.DateTimeStyles.AllowWhiteSpaces"/>.  The other styles are invalid because they only apply
            when both a date and time are being parsed together.
            </exception>
        </member>
        <member name="M:System.Date.ParseExact(System.String,System.String,System.IFormatProvider)">
            <summary>
            Converts the specified string representation of a date to its <see cref="T:System.Date"/> equivalent
            using the specified format and culture-specific format information.
            The format of the string representation must match the specified format exactly or an exception is thrown.
            </summary>
            <param name="s">A string that contains a date to convert.</param>
            <param name="format">A format specifier that defines the required format of <paramref name="s"/>.</param>
            <param name="provider">
            An object that supplies culture-specific formatting information about <paramref name="s"/>.
            </param>
            <returns>
            An object that is equivalent to the date contained in <paramref name="s"/>,
            as specified by <paramref name="format"/> and <paramref name="provider"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="s"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.FormatException">
            <paramref name="s"/> or <paramref name="format"/> is an empty string.
            <para>-or-</para>
            <paramref name="s"/> does not contain a date that corresponds to the pattern specified in <paramref name="format"/>.
            <para>-or-</para>
            <paramref name="format"/> contains a format pattern that is not applicable to a <see cref="T:System.Date"/>.
            </exception>
        </member>
        <member name="M:System.Date.ParseExact(System.String,System.String,System.IFormatProvider,System.Globalization.DateTimeStyles)">
            <summary>
            Converts the specified string representation of a date to its <see cref="T:System.Date"/> equivalent
            using the specified format, culture-specific format information, and style.
            The format of the string representation must match the specified format exactly or an exception is thrown.
            </summary>
            <param name="s">A string that contains a date to convert.</param>
            <param name="format">A format specifier that defines the required format of <paramref name="s"/>.</param>
            <param name="provider">
            An object that supplies culture-specific formatting information about <paramref name="s"/>.
            </param>
            <param name="styles">
            A bitwise combination of the enumeration values that indicates the style elements that
            can be present in <paramref name="s"/> for the parse operation to succeed.
            Note that only styles related to whitespace handling are applicable on a <see cref="T:System.Date"/>.
            A typical value to specify is <see cref="F:System.Globalization.DateTimeStyles.None"/>.
            </param>
            <returns>
            An object that is equivalent to the date contained in <paramref name="s"/>,
            as specified by <paramref name="format"/>, <paramref name="provider"/> and <paramref name="styles"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="s"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.FormatException">
            <paramref name="s"/> or <paramref name="format"/> is an empty string.
            <para>-or-</para>
            <paramref name="s"/> does not contain a date that corresponds to the pattern specified in <paramref name="format"/>.
            <para>-or-</para>
            <paramref name="format"/> contains a format pattern that is not applicable to a <see cref="T:System.Date"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="styles"/> styles contains an invalid <see cref="T:System.Globalization.DateTimeStyles"/> values.
            The only styles that are valid for a <see cref="T:System.Date"/> are:
            <see cref="F:System.Globalization.DateTimeStyles.None"/>, <see cref="F:System.Globalization.DateTimeStyles.AllowLeadingWhite"/>,
            <see cref="F:System.Globalization.DateTimeStyles.AllowTrailingWhite"/>, <see cref="F:System.Globalization.DateTimeStyles.AllowInnerWhite"/>, and
            <see cref="F:System.Globalization.DateTimeStyles.AllowWhiteSpaces"/>.  The other styles are invalid because they only apply
            when both a date and time are being parsed together.
            </exception>
        </member>
        <member name="M:System.Date.ParseExact(System.String,System.String[],System.IFormatProvider,System.Globalization.DateTimeStyles)">
            <summary>
            Converts the specified string representation of a date to its <see cref="T:System.Date"/> equivalent
            using the specified array of formats, culture-specific format information, and style.
            The format of the string representation must match at least one of the specified formats
            exactly or an exception is thrown.
            </summary>
            <param name="s">A string that contains a date to convert.</param>
            <param name="formats">An array of allowable formats of <paramref name="s"/>.</param>
            <param name="provider">
            An object that supplies culture-specific formatting information about <paramref name="s"/>.
            </param>
            <param name="styles">
            A bitwise combination of the enumeration values that indicates the style elements that
            can be present in <paramref name="s"/> for the parse operation to succeed.
            Note that only styles related to whitespace handling are applicable on a <see cref="T:System.Date"/>.
            A typical value to specify is <see cref="F:System.Globalization.DateTimeStyles.None"/>.
            </param>
            <returns>
            An object that is equivalent to the date contained in <paramref name="s"/>,
            as specified by <paramref name="formats"/>, <paramref name="provider"/> and <paramref name="styles"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="s"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.FormatException">
            <paramref name="s"/> is an empty string.
            <para>-or-</para>
            An element of <paramref name="formats"/> is an empty string.
            <para>-or-</para>
            <paramref name="s"/> does not contain a date that corresponds to any element of <paramref name="formats"/>.
            <para>-or-</para>
            An element of <paramref name="formats"/> contains a format pattern that is not applicable to a <see cref="T:System.Date"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="styles"/> styles contains an invalid <see cref="T:System.Globalization.DateTimeStyles"/> values.
            The only styles that are valid for a <see cref="T:System.Date"/> are:
            <see cref="F:System.Globalization.DateTimeStyles.None"/>, <see cref="F:System.Globalization.DateTimeStyles.AllowLeadingWhite"/>,
            <see cref="F:System.Globalization.DateTimeStyles.AllowTrailingWhite"/>, <see cref="F:System.Globalization.DateTimeStyles.AllowInnerWhite"/>, and
            <see cref="F:System.Globalization.DateTimeStyles.AllowWhiteSpaces"/>.  The other styles are invalid because they only apply
            when both a date and time are being parsed together.
            </exception>
        </member>
        <member name="M:System.Date.TryParse(System.String,System.Date@)">
            <summary>
            Converts the specified string representation of a date to its <see cref="T:System.Date"/> equivalent
            and returns a value that indicates whether the conversion succeeded.
            </summary>
            <param name="s">A string containing a date to convert.</param>
            <param name="date">
            When this method returns, contains the <see cref="T:System.Date"/> value equivalent to the date
            contained in <paramref name="s"/>, if the conversion succeeded, or <see cref="P:System.Date.MinValue"/>
            if the conversion failed. The conversion fails if the <paramref name="s"/> parameter is
            <c>null</c>, is an empty string (""), or does not contain a valid string representation of a date.
            This parameter is passed uninitialized.
            </param>
            <returns>
            <c>true</c> if the <paramref name="s"/> parameter was converted successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:System.Date.TryParse(System.String,System.IFormatProvider,System.Globalization.DateTimeStyles,System.Date@)">
            <summary>
            Converts the specified string representation of a date to its <see cref="T:System.Date"/> equivalent
            using the specified culture-specific format information and formatting style,
            and returns a value that indicates whether the conversion succeeded.
            </summary>
            <param name="s">A string containing a date to convert.</param>
            <param name="provider">
            An object that supplies culture-specific formatting information about <paramref name="s"/>.
            </param>
            <param name="styles">
            A bitwise combination of the enumeration values that indicates the style elements that
            can be present in <paramref name="s"/> for the parse operation to succeed.
            Note that only styles related to whitespace handling are applicable on a <see cref="T:System.Date"/>.
            A typical value to specify is <see cref="F:System.Globalization.DateTimeStyles.None"/>.
            </param>
            <param name="date">
            When this method returns, contains the <see cref="T:System.Date"/> value equivalent to the date
            contained in <paramref name="s"/>, if the conversion succeeded, or <see cref="P:System.Date.MinValue"/>
            if the conversion failed. The conversion fails if the <paramref name="s"/> parameter is
            <c>null</c>, is an empty string (""), or does not contain a valid string representation of a date.
            This parameter is passed uninitialized.
            </param>
            <returns>
            <c>true</c> if the <paramref name="s"/> parameter was converted successfully; otherwise, <c>false</c>.
            </returns>
            <exception cref="T:System.ArgumentException">
            <paramref name="styles"/> styles contains an invalid <see cref="T:System.Globalization.DateTimeStyles"/> values.
            The only styles that are valid for a <see cref="T:System.Date"/> are:
            <see cref="F:System.Globalization.DateTimeStyles.None"/>, <see cref="F:System.Globalization.DateTimeStyles.AllowLeadingWhite"/>,
            <see cref="F:System.Globalization.DateTimeStyles.AllowTrailingWhite"/>, <see cref="F:System.Globalization.DateTimeStyles.AllowInnerWhite"/>, and
            <see cref="F:System.Globalization.DateTimeStyles.AllowWhiteSpaces"/>.  The other styles are invalid because they only apply
            when both a date and time are being parsed together.
            </exception>
        </member>
        <member name="M:System.Date.TryParseExact(System.String,System.String,System.IFormatProvider,System.Globalization.DateTimeStyles,System.Date@)">
            <summary>
            Converts the specified string representation of a date to its <see cref="T:System.Date"/> equivalent
            using the specified format, culture-specific format information, and style.
            The format of the string representation must match the specified format exactly.
            The method returns a value that indicates whether the conversion succeeded.
            </summary>
            <param name="s">A string containing a date to convert.</param>
            <param name="format">A format specifier that defines the required format of <paramref name="s"/>.</param>
            <param name="provider">
            An object that supplies culture-specific formatting information about <paramref name="s"/>.
            </param>
            <param name="styles">
            A bitwise combination of the enumeration values that indicates the style elements that
            can be present in <paramref name="s"/> for the parse operation to succeed.
            Note that only styles related to whitespace handling are applicable on a <see cref="T:System.Date"/>.
            A typical value to specify is <see cref="F:System.Globalization.DateTimeStyles.None"/>.
            </param>
            <param name="date">
            When this method returns, contains the <see cref="T:System.Date"/> value equivalent to the date
            contained in <paramref name="s"/>, if the conversion succeeded, or <see cref="P:System.Date.MinValue"/>
            if the conversion failed. The conversion fails if either the <paramref name="s"/> or
            <paramref name="format"/> parameter is <c>null</c>, is an empty string (""), or does not
            contain a date that coresponds to the pattern specified in <paramref name="format"/>.
            This parameter is passed uninitialized.
            </param>
            <returns>
            <c>true</c> if the <paramref name="s"/> parameter was converted successfully; otherwise, <c>false</c>.
            </returns>
            <exception cref="T:System.ArgumentException">
            <paramref name="styles"/> styles contains an invalid <see cref="T:System.Globalization.DateTimeStyles"/> values.
            The only styles that are valid for a <see cref="T:System.Date"/> are:
            <see cref="F:System.Globalization.DateTimeStyles.None"/>, <see cref="F:System.Globalization.DateTimeStyles.AllowLeadingWhite"/>,
            <see cref="F:System.Globalization.DateTimeStyles.AllowTrailingWhite"/>, <see cref="F:System.Globalization.DateTimeStyles.AllowInnerWhite"/>, and
            <see cref="F:System.Globalization.DateTimeStyles.AllowWhiteSpaces"/>.  The other styles are invalid because they only apply
            when both a date and time are being parsed together.
            </exception>
        </member>
        <member name="M:System.Date.TryParseExact(System.String,System.String[],System.IFormatProvider,System.Globalization.DateTimeStyles,System.Date@)">
            <summary>
            Converts the specified string representation of a date to its <see cref="T:System.Date"/> equivalent
            using the specified array of formats, culture-specific format information, and style.
            The format of the string representation must match at least one of the specified formats exactly.
            The method returns a value that indicates whether the conversion succeeded.
            </summary>
            <param name="s">A string containing a date to convert.</param>
            <param name="formats">An array of allowable formats of <paramref name="s"/>.</param>
            <param name="provider">
            An object that supplies culture-specific formatting information about <paramref name="s"/>.
            </param>
            <param name="styles">
            A bitwise combination of the enumeration values that indicates the style elements that
            can be present in <paramref name="s"/> for the parse operation to succeed.
            Note that only styles related to whitespace handling are applicable on a <see cref="T:System.Date"/>.
            A typical value to specify is <see cref="F:System.Globalization.DateTimeStyles.None"/>.
            </param>
            <param name="date">
            When this method returns, contains the <see cref="T:System.Date"/> value equivalent to the date
            contained in <paramref name="s"/>, if the conversion succeeded, or <see cref="P:System.Date.MinValue"/>
            if the conversion failed. The conversion fails if either the <paramref name="s"/> or
            <paramref name="formats"/> parameter is <c>null</c>, <paramref name="s"/> or an element of
            <paramref name="formats"/> is an empty string (""), or the format of <paramref name="s"/> is not
            exactly as specified by at least one of the format patterns in <paramref name="formats"/>.
            This parameter is passed uninitialized.
            </param>
            <returns>
            <c>true</c> if the <paramref name="s"/> parameter was converted successfully; otherwise, <c>false</c>.
            </returns>
            <exception cref="T:System.ArgumentException">
            <paramref name="styles"/> styles contains an invalid <see cref="T:System.Globalization.DateTimeStyles"/> values.
            The only styles that are valid for a <see cref="T:System.Date"/> are:
            <see cref="F:System.Globalization.DateTimeStyles.None"/>, <see cref="F:System.Globalization.DateTimeStyles.AllowLeadingWhite"/>,
            <see cref="F:System.Globalization.DateTimeStyles.AllowTrailingWhite"/>, <see cref="F:System.Globalization.DateTimeStyles.AllowInnerWhite"/>, and
            <see cref="F:System.Globalization.DateTimeStyles.AllowWhiteSpaces"/>.  The other styles are invalid because they only apply
            when both a date and time are being parsed together.
            </exception>
        </member>
        <member name="M:System.Date.op_Equality(System.Date,System.Date)">
            <summary>
            Determines whether two specified instances of <see cref="T:System.Date"/> are equal.
            </summary>
            <param name="left">The first object to compare.</param>
            <param name="right">The second object to compare.</param>
            <returns>
            <c>true</c> if <paramref name="left"/> and <paramref name="right"/> represent the same date;
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:System.Date.op_Inequality(System.Date,System.Date)">
            <summary>
            Determines whether two specified instances of <see cref="T:System.Date"/> are not equal.
            </summary>
            <param name="left">The first object to compare.</param>
            <param name="right">The second object to compare.</param>
            <returns>
            <c>true</c> if <paramref name="left"/> and <paramref name="right"/> do not represent the same date;
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:System.Date.op_GreaterThan(System.Date,System.Date)">
            <summary>
            Determines whether one specified <see cref="T:System.Date"/> is later than another specified <see cref="T:System.Date"/>.
            </summary>
            <param name="left">The first object to compare.</param>
            <param name="right">The second object to compare.</param>
            <returns>
            <c>true</c> if <paramref name="left"/> is later than <paramref name="right"/>; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:System.Date.op_GreaterThanOrEqual(System.Date,System.Date)">
            <summary>
            Determines whether one specified <see cref="T:System.Date"/> is equal to or later than another specified <see cref="T:System.Date"/>.
            </summary>
            <param name="left">The first object to compare.</param>
            <param name="right">The second object to compare.</param>
            <returns>
            <c>true</c> if <paramref name="left"/> is equal to or later than <paramref name="right"/>; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:System.Date.op_LessThan(System.Date,System.Date)">
            <summary>
            Determines whether one specified <see cref="T:System.Date"/> is earlier than another specified <see cref="T:System.Date"/>.
            </summary>
            <param name="left">The first object to compare.</param>
            <param name="right">The second object to compare.</param>
            <returns>
            <c>true</c> if <paramref name="left"/> is earlier than <paramref name="right"/>; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:System.Date.op_LessThanOrEqual(System.Date,System.Date)">
            <summary>
            Determines whether one specified <see cref="T:System.Date"/> is equal to or earlier than another specified <see cref="T:System.Date"/>.
            </summary>
            <param name="left">The first object to compare.</param>
            <param name="right">The second object to compare.</param>
            <returns>
            <c>true</c> if <paramref name="left"/> is equal to or earlier than <paramref name="right"/>; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:System.Date.op_Implicit(System.DateTime)~System.Date">
            <summary>
            Implicitly casts a <see cref="T:System.DateTime"/> object to a <see cref="T:System.Date"/> by returning a new
            <see cref="T:System.Date"/> object that has the equivalent year, month, and day components.  This is useful when
            using APIs that express a calendar date as a <see cref="T:System.DateTime"/> and expect the consumer to ignore
            the time portion of the value.  This operator enables these values to be assigned to a variable having
            a <see cref="T:System.Date"/> type.
            </summary>
            <param name="dateTime">A <see cref="T:System.DateTime"/> value whose date portion will be used to construct a new
            <see cref="T:System.Date"/> object, and whose time portion will be ignored.</param>
            <returns>A newly constructed <see cref="T:System.Date"/> object with an equivalent date value.</returns>
            <remarks>
            Fundamentally, a date-only value and a date-time value are two different concepts.  In previous versions
            of the .NET framework, the <see cref="T:System.Date"/> type did not exist, and thus several date-only values were
            represented by using a <see cref="T:System.DateTime"/> with the time set to midnight (00:00:00).  For example, the
            <see cref="P:System.DateTime.Today"/> and <see cref="P:System.DateTime.Date"/> properties exhibit this behavior.
            This implicit cast operator allows those APIs to be naturally used with <see cref="T:System.Date"/>.
            <para>
            Also note that when evaluated as a full date-time, the input <paramref name="dateTime"/> might not actually
            exist, since some time zones (ex: Brazil) will spring-forward directly from 23:59 to 01:00, skipping over
            midnight.  Using a <see cref="T:System.Date"/> object avoids this particular edge case, and several others.
            </para>
            </remarks>
        </member>
        <member name="M:System.Date.op_Implicit(System.Date)~System.DateTime">
            <summary>
            Implicitly casts a <see cref="T:System.Date"/> object to a <see cref="T:System.DateTime"/> by returning a new
            <see cref="T:System.DateTime"/> object that has the equivalent year, month, and day components, and has its time
            set to midnight (00:00:00).  This is useful when using APIs that express a calendar date as a
            <see cref="T:System.DateTime"/> and ignore the time portion of the value.  This operator enables <see cref="T:System.Date"/>
            values to be passed to a method expecting a <see cref="T:System.DateTime"/>.
            <para>
            Use with caution, as midnight may not necessarily be valid in every time zone on every day of the year.
            For example, when Brazil springs forward for daylight saving time, the clocks skip from 23:59:59 directly
            to 01:00:00.
            </para>
            </summary>
            <param name="date">A <see cref="T:System.Date"/> value whose date portion will be used to construct a new
            <see cref="T:System.DateTime"/> object.</param>
            <returns>
            A newly constructed <see cref="T:System.DateTime"/> object with an equivalent date value, and the time set
            to midnight (00:00:00).
            </returns>
            <remarks>
            Fundamentally, a date-only value and a date-time value are two different concepts.  In previous versions
            of the .NET framework, the <see cref="T:System.Date"/> type did not exist, and thus several date-only values were
            represented by using a <see cref="T:System.DateTime"/> with the time set to midnight (00:00:00).  For example, the
            <see cref="M:System.Globalization.Calendar.GetYear(System.DateTime)"/> method expects a <see cref="T:System.DateTime"/>, even though it only uses the date
            component. This implicit cast operator allows those APIs to be naturally used with <see cref="T:System.Date"/>.
            </remarks>
        </member>
        <member name="M:System.Date.DateFromDateTime(System.DateTime)">
            <summary>
            Constructs a <see cref="T:System.Date"/> object from the date component of a <see cref="T:System.DateTime"/>.
            </summary>
        </member>
        <member name="M:System.Date.DateToDayNumber(System.Int32,System.Int32,System.Int32)">
            <summary>
            Returns the day number count corresponding to the given year, month, and day.
            Will check the if the parameters are valid.
            </summary>
        </member>
        <member name="M:System.Date.GetDatePart(System.Int32)">
            <summary>
            Returns a given date part of this DateTime. This method is used
            to compute the year, day-of-year, month, or day part.
            </summary>
        </member>
        <member name="M:System.Date.NormalizeDateFormat(System.String)">
            <summary>
            Normalizes a format string that has standard or custom date/time formats,
            such that the formatted output can only contain a date when applied.
            </summary>
            <exception cref="T:System.FormatException">
            The format string contained a format specifier that is only applicable
            when a time-of-day would be part of the formatted output.
            </exception>
        </member>
        <member name="M:System.Date.GetSchema(System.Object)">
            <summary>
            Gets a <see cref="T:System.Xml.XmlQualifiedName"/> that represents the <c>xs:date</c> type of the
            W3C XML Schema Definition (XSD) specification.
            </summary>
            <remarks>
            This is required to support the <see cref="T:System.Xml.Serialization.XmlSchemaProviderAttribute"/> applied to this structure.
            </remarks>
        </member>
        <member name="M:System.Date.System#Xml#Serialization#IXmlSerializable#GetSchema">
            <summary>
            Required by the <see cref="T:System.Xml.Serialization.IXmlSerializable"/> interface.
            </summary>
            <returns><c>null</c></returns>
        </member>
        <member name="M:System.Date.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <summary>
            Generates a <see cref="T:System.Date"/> object from its XML representation.
            </summary>
            <param name="reader">The <see cref="T:System.Xml.XmlReader"/> stream from which the object is deserialized.</param>
            <remarks>
            An <c>xs:date</c> uses the ISO-8601 extended date format. The equivalent .NET Framework format string
            is <c>yyyy-MM-dd</c>.  This method always uses the proleptic Gregorian calendar of the
            <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>, regardless of the current culture setting.
            </remarks>
        </member>
        <member name="M:System.Date.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <summary>
            Converts a <see cref="T:System.Date"/> object into its XML representation.
            </summary>
            <param name="writer">The <see cref="T:System.Xml.XmlWriter"/> stream to which the object is serialized.</param>
            <remarks>
            An <c>xs:date</c> uses the ISO-8601 extended date format. The equivalent .NET Framework format string
            is <c>yyyy-MM-dd</c>.  This method always uses the proleptic Gregorian calendar of the
            <see cref="P:System.Globalization.CultureInfo.InvariantCulture"/>, regardless of the current culture setting.
            </remarks>
        </member>
        <member name="T:System.TimeZoneOffsetResolver">
            <summary>
            
            </summary>
            <param name="dateTime"></param>
            <param name="timeZone"></param>
            <returns></returns>
        </member>
        <member name="T:System.TimeZoneOffsetResolvers">
            <summary>
            
            </summary>
        </member>
        <member name="M:System.TimeZoneOffsetResolvers.Default(System.DateTime,System.TimeZoneInfo)">
            <summary>
            
            </summary>
            <param name="dt"></param>
            <param name="timeZone"></param>
            <returns></returns>
        </member>
        <member name="T:System.DateTimeExtensions">
            <summary>
            Extension methods for <see cref="T:System.DateTime"/>.
            </summary>
        </member>
        <member name="M:System.DateTimeExtensions.Date(System.DateTime)">
            <summary>
            Gets a <see cref="M:System.DateTimeExtensions.Date(System.DateTime)"/> value that represents the date component of the current
            <see cref="T:System.DateTime"/> object.
            </summary>
            <param name="dateTime">The <see cref="T:System.DateTime"/> instance.</param>
            <returns>The <see cref="M:System.DateTimeExtensions.Date(System.DateTime)"/> value.</returns>
        </member>
        <member name="M:System.DateTimeExtensions.TimeOfDay(System.DateTime)">
            <summary>
            Gets a <see cref="M:System.DateTimeExtensions.TimeOfDay(System.DateTime)"/> value that represents the time component of the current
            <see cref="T:System.DateTime"/> object.
            </summary>
            <param name="dateTime">The <see cref="T:System.DateTime"/> instance.</param>
            <returns>The <see cref="M:System.DateTimeExtensions.TimeOfDay(System.DateTime)"/> value.</returns>
        </member>
        <member name="M:System.DateTimeExtensions.NowInTimeZone(System.TimeZoneInfo)">
            <summary>
            Gets a <see cref="T:System.DateTime"/> object that is set to the current date and time in the specified time zone.
            </summary>
            <param name="timeZoneInfo">The <see cref="T:System.TimeZoneInfo"/> instance.</param>
            <returns>The current <see cref="T:System.DateTime"/> for the specified time zone.</returns>
        </member>
        <member name="M:System.DateTimeExtensions.AddYears(System.DateTime,System.Int32,System.TimeZoneInfo)">
            <summary>
            
            </summary>
            <param name="dateTime"></param>
            <param name="years"></param>
            <param name="timeZone"></param>
            <returns></returns>
        </member>
        <member name="M:System.DateTimeExtensions.AddYears(System.DateTime,System.Int32,System.TimeZoneInfo,System.TimeZoneOffsetResolver)">
            <summary>
            
            </summary>
            <param name="dateTime"></param>
            <param name="years"></param>
            <param name="timeZone"></param>
            <param name="resolver"></param>
            <returns></returns>
        </member>
        <member name="M:System.DateTimeExtensions.AddMonths(System.DateTime,System.Int32,System.TimeZoneInfo)">
            <summary>
            
            </summary>
            <param name="dateTime"></param>
            <param name="months"></param>
            <param name="timeZone"></param>
            <returns></returns>
        </member>
        <member name="M:System.DateTimeExtensions.AddMonths(System.DateTime,System.Int32,System.TimeZoneInfo,System.TimeZoneOffsetResolver)">
            <summary>
            
            </summary>
            <param name="dateTime"></param>
            <param name="months"></param>
            <param name="timeZone"></param>
            <param name="resolver"></param>
            <returns></returns>
        </member>
        <member name="M:System.DateTimeExtensions.AddDays(System.DateTime,System.Int32,System.TimeZoneInfo)">
            <summary>
            
            </summary>
            <param name="dateTime"></param>
            <param name="days"></param>
            <param name="timeZone"></param>
            <returns></returns>
        </member>
        <member name="M:System.DateTimeExtensions.AddDays(System.DateTime,System.Int32,System.TimeZoneInfo,System.TimeZoneOffsetResolver)">
            <summary>
            
            </summary>
            <param name="dateTime"></param>
            <param name="days"></param>
            <param name="timeZone"></param>
            <param name="resolver"></param>
            <returns></returns>
        </member>
        <member name="M:System.DateTimeExtensions.AddHours(System.DateTime,System.Double,System.TimeZoneInfo)">
            <summary>
            
            </summary>
            <param name="dateTime"></param>
            <param name="hours"></param>
            <param name="timeZone"></param>
            <returns></returns>
        </member>
        <member name="M:System.DateTimeExtensions.AddHours(System.DateTime,System.Double,System.TimeZoneInfo,System.TimeZoneOffsetResolver)">
            <summary>
            
            </summary>
            <param name="dateTime"></param>
            <param name="hours"></param>
            <param name="timeZone"></param>
            <param name="resolver"></param>
            <returns></returns>
        </member>
        <member name="M:System.DateTimeExtensions.AddMinutes(System.DateTime,System.Double,System.TimeZoneInfo)">
            <summary>
            
            </summary>
            <param name="dateTime"></param>
            <param name="minutes"></param>
            <param name="timeZone"></param>
            <returns></returns>
        </member>
        <member name="M:System.DateTimeExtensions.AddMinutes(System.DateTime,System.Double,System.TimeZoneInfo,System.TimeZoneOffsetResolver)">
            <summary>
            
            </summary>
            <param name="dateTime"></param>
            <param name="minutes"></param>
            <param name="timeZone"></param>
            <param name="resolver"></param>
            <returns></returns>
        </member>
        <member name="M:System.DateTimeExtensions.AddSeconds(System.DateTime,System.Double,System.TimeZoneInfo)">
            <summary>
            
            </summary>
            <param name="dateTime"></param>
            <param name="seconds"></param>
            <param name="timeZone"></param>
            <returns></returns>
        </member>
        <member name="M:System.DateTimeExtensions.AddSeconds(System.DateTime,System.Double,System.TimeZoneInfo,System.TimeZoneOffsetResolver)">
            <summary>
            
            </summary>
            <param name="dateTime"></param>
            <param name="seconds"></param>
            <param name="timeZone"></param>
            <param name="resolver"></param>
            <returns></returns>
        </member>
        <member name="M:System.DateTimeExtensions.AddMilliseconds(System.DateTime,System.Double,System.TimeZoneInfo)">
            <summary>
            
            </summary>
            <param name="dateTime"></param>
            <param name="milliseconds"></param>
            <param name="timeZone"></param>
        </member>
        <member name="M:System.DateTimeExtensions.AddMilliseconds(System.DateTime,System.Double,System.TimeZoneInfo,System.TimeZoneOffsetResolver)">
            <summary>
            
            </summary>
            <param name="dateTime"></param>
            <param name="milliseconds"></param>
            <param name="timeZone"></param>
            <param name="resolver"></param>
        </member>
        <member name="M:System.DateTimeExtensions.AddTicks(System.DateTime,System.Int64,System.TimeZoneInfo)">
            <summary>
            
            </summary>
            <param name="dateTime"></param>
            <param name="ticks"></param>
            <param name="timeZone"></param>
        </member>
        <member name="M:System.DateTimeExtensions.AddTicks(System.DateTime,System.Int64,System.TimeZoneInfo,System.TimeZoneOffsetResolver)">
            <summary>
            
            </summary>
            <param name="dateTime"></param>
            <param name="ticks"></param>
            <param name="timeZone"></param>
            <param name="resolver"></param>
            <returns></returns>
        </member>
        <member name="M:System.DateTimeExtensions.Add(System.DateTime,System.TimeSpan,System.TimeZoneInfo)">
            <summary>
            
            </summary>
            <param name="dateTime"></param>
            <param name="timeSpan"></param>
            <param name="timeZone"></param>
            <returns></returns>
        </member>
        <member name="M:System.DateTimeExtensions.Subtract(System.DateTime,System.TimeSpan,System.TimeZoneInfo)">
            <summary>
            
            </summary>
            <param name="dateTime"></param>
            <param name="timeSpan"></param>
            <param name="timeZone"></param>
            <returns></returns>
        </member>
        <member name="M:System.DateTimeExtensions.Subtract(System.DateTime,System.TimeSpan,System.TimeZoneInfo,System.TimeZoneOffsetResolver)">
            <summary>
            
            </summary>
            <param name="dateTime"></param>
            <param name="timeSpan"></param>
            <param name="timeZone"></param>
            <param name="resolver"></param>
            <returns></returns>
        </member>
        <member name="M:System.DateTimeExtensions.Add(System.DateTime,System.TimeSpan,System.TimeZoneInfo,System.TimeZoneOffsetResolver)">
            <summary>
            
            </summary>
            <param name="dateTime"></param>
            <param name="timeSpan"></param>
            <param name="timeZone"></param>
            <param name="resolver"></param>
            <returns></returns>
        </member>
        <member name="M:System.DateTimeExtensions.AddByDate(System.DateTime,System.Func{System.DateTime,System.DateTime},System.TimeZoneInfo,System.TimeZoneOffsetResolver)">
            <summary>
            
            </summary>
            <param name="dateTime"></param>
            <param name="operation"></param>
            <param name="timeZone"></param>
            <param name="resolver"></param>
            <returns></returns>
        </member>
        <member name="T:System.DateTimeOffsetExtensions">
            <summary>
            Extension methods for <see cref="T:System.DateTimeOffset"/>.
            </summary>
        </member>
        <member name="M:System.DateTimeOffsetExtensions.Date(System.DateTimeOffset)">
            <summary>
            Gets a <see cref="M:System.DateTimeOffsetExtensions.Date(System.DateTimeOffset)"/> value that represents the date component of the current
            <see cref="T:System.DateTimeOffset"/> object.
            </summary>
            <param name="dateTimeOffset">The <see cref="T:System.DateTimeOffset"/> instance.</param>
            <returns>The <see cref="M:System.DateTimeOffsetExtensions.Date(System.DateTimeOffset)"/> value.</returns>
        </member>
        <member name="M:System.DateTimeOffsetExtensions.TimeOfDay(System.DateTimeOffset)">
            <summary>
            Gets a <see cref="M:System.DateTimeOffsetExtensions.TimeOfDay(System.DateTimeOffset)"/> value that represents the time component of the current
            <see cref="T:System.DateTimeOffset"/> object.
            </summary>
            <param name="dateTimeOffset">The <see cref="T:System.DateTimeOffset"/> instance.</param>
            <returns>The <see cref="M:System.DateTimeOffsetExtensions.TimeOfDay(System.DateTimeOffset)"/> value.</returns>
        </member>
        <member name="M:System.DateTimeOffsetExtensions.NowInTimeZone(System.TimeZoneInfo)">
            <summary>
            Gets a <see cref="T:System.DateTimeOffset"/> object that is set to the current date, time,
            and offset from Coordinated Universal Time (UTC) in the specified time zone.
            </summary>
            <param name="timeZoneInfo">The <see cref="T:System.TimeZoneInfo"/> instance.</param>
            <returns>The current <see cref="T:System.DateTimeOffset"/> for the specified time zone.</returns>
        </member>
        <member name="M:System.DateTimeOffsetExtensions.AddYears(System.DateTimeOffset,System.Int32,System.TimeZoneInfo)">
            <summary>
            
            </summary>
            <param name="dateTimeOffset"></param>
            <param name="years"></param>
            <param name="timeZone"></param>
            <returns></returns>
        </member>
        <member name="M:System.DateTimeOffsetExtensions.AddYears(System.DateTimeOffset,System.Int32,System.TimeZoneInfo,System.TimeZoneOffsetResolver)">
            <summary>
            
            </summary>
            <param name="dateTimeOffset"></param>
            <param name="years"></param>
            <param name="timeZone"></param>
            <param name="resolver"></param>
            <returns></returns>
        </member>
        <member name="M:System.DateTimeOffsetExtensions.AddMonths(System.DateTimeOffset,System.Int32,System.TimeZoneInfo)">
            <summary>
            
            </summary>
            <param name="dateTimeOffset"></param>
            <param name="months"></param>
            <param name="timeZone"></param>
            <returns></returns>
        </member>
        <member name="M:System.DateTimeOffsetExtensions.AddMonths(System.DateTimeOffset,System.Int32,System.TimeZoneInfo,System.TimeZoneOffsetResolver)">
            <summary>
            
            </summary>
            <param name="dateTimeOffset"></param>
            <param name="months"></param>
            <param name="timeZone"></param>
            <param name="resolver"></param>
            <returns></returns>
        </member>
        <member name="M:System.DateTimeOffsetExtensions.AddDays(System.DateTimeOffset,System.Int32,System.TimeZoneInfo)">
            <summary>
            
            </summary>
            <param name="dateTimeOffset"></param>
            <param name="days"></param>
            <param name="timeZone"></param>
            <returns></returns>
        </member>
        <member name="M:System.DateTimeOffsetExtensions.AddDays(System.DateTimeOffset,System.Int32,System.TimeZoneInfo,System.TimeZoneOffsetResolver)">
            <summary>
            
            </summary>
            <param name="dateTimeOffset"></param>
            <param name="days"></param>
            <param name="timeZone"></param>
            <param name="resolver"></param>
            <returns></returns>
        </member>
        <member name="M:System.DateTimeOffsetExtensions.AddHours(System.DateTimeOffset,System.Double,System.TimeZoneInfo)">
            <summary>
            
            </summary>
            <param name="dateTimeOffset"></param>
            <param name="hours"></param>
            <param name="timeZone"></param>
            <returns></returns>
        </member>
        <member name="M:System.DateTimeOffsetExtensions.AddMinutes(System.DateTimeOffset,System.Double,System.TimeZoneInfo)">
            <summary>
            
            </summary>
            <param name="dateTimeOffset"></param>
            <param name="minutes"></param>
            <param name="timeZone"></param>
            <returns></returns>
        </member>
        <member name="M:System.DateTimeOffsetExtensions.AddSeconds(System.DateTimeOffset,System.Double,System.TimeZoneInfo)">
            <summary>
            
            </summary>
            <param name="dateTimeOffset"></param>
            <param name="seconds"></param>
            <param name="timeZone"></param>
            <returns></returns>
        </member>
        <member name="M:System.DateTimeOffsetExtensions.AddMilliseconds(System.DateTimeOffset,System.Double,System.TimeZoneInfo)">
            <summary>
            
            </summary>
            <param name="dateTimeOffset"></param>
            <param name="milliseconds"></param>
            <param name="timeZone"></param>
            <returns></returns>
        </member>
        <member name="M:System.DateTimeOffsetExtensions.AddTicks(System.DateTimeOffset,System.Int64,System.TimeZoneInfo)">
            <summary>
            
            </summary>
            <param name="dateTimeOffset"></param>
            <param name="ticks"></param>
            <param name="timeZone"></param>
            <returns></returns>
        </member>
        <member name="M:System.DateTimeOffsetExtensions.Subtract(System.DateTimeOffset,System.TimeSpan,System.TimeZoneInfo)">
            <summary>
            
            </summary>
            <param name="dateTimeOffset"></param>
            <param name="timeSpan"></param>
            <param name="timeZone"></param>
            <returns></returns>
        </member>
        <member name="M:System.DateTimeOffsetExtensions.Add(System.DateTimeOffset,System.TimeSpan,System.TimeZoneInfo)">
            <summary>
            
            </summary>
            <param name="dateTimeOffset"></param>
            <param name="timeSpan"></param>
            <param name="timeZone"></param>
            <returns></returns>
        </member>
        <member name="M:System.DateTimeOffsetExtensions.AddByDate(System.DateTimeOffset,System.Func{System.DateTime,System.DateTime},System.TimeZoneInfo,System.TimeZoneOffsetResolver)">
            <summary>
            
            </summary>
            <param name="dateTimeOffset"></param>
            <param name="operation"></param>
            <param name="timeZone"></param>
            <param name="resolver"></param>
            <returns></returns>
        </member>
        <member name="T:System.TimeOfDay">
            <summary>
            Represents a time of day, as would be read from a clock, within the range 00:00:00 to 23:59:59.9999999
            Has properties for working with both 12-hour and 24-hour time values.
            </summary>
        </member>
        <member name="F:System.TimeOfDay.MinValue">
            <summary>
            Represents the smallest possible value of <see cref="T:System.TimeOfDay"/>. This field is read-only.
            </summary>
        </member>
        <member name="F:System.TimeOfDay.MaxValue">
            <summary>
            Represents the largest possible value of <see cref="T:System.TimeOfDay"/>. This field is read-only.
            </summary>
        </member>
        <member name="M:System.TimeOfDay.#ctor(System.Int64)">
            <summary>
            Initializes a new instance of a <see cref="T:System.TimeOfDay"/> structure to a specified number of ticks.
            </summary>
            <param name="ticks">
            A time expressed in the number of 100-nanosecond intervals that have elapsed since midnight (00:00:00),
            without regard to daylight saving time transitions.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="ticks"/> is out of the range supported by the <see cref="T:System.TimeOfDay"/> object.
            </exception>
        </member>
        <member name="M:System.TimeOfDay.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of a <see cref="T:System.TimeOfDay"/> structure to the specified
            hour and minute.
            </summary>
            <param name="hour">The hours (0 through 23).</param>
            <param name="minute">The minutes (0 through 59).</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="hour"/> is less than 0 or greater than 23.
            <para>-or-</para>
            <paramref name="minute"/> is less than 0 or greater than 59.
            </exception>
        </member>
        <member name="M:System.TimeOfDay.#ctor(System.Int32,System.Int32,System.Meridiem)">
            <summary>
            Initializes a new instance of a <see cref="T:System.TimeOfDay"/> structure to the specified
            hour, minute, and meridiem, using the hours of a 12-hour clock.
            </summary>
            <param name="hour">The hours (1 through 12).</param>
            <param name="minute">The minutes (0 through 59).</param>
            <param name="meridiem">The meridiem, either <see cref="F:System.Meridiem.AM"/>,
            or <see cref="F:System.Meridiem.PM"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="hour"/> is less than 1 or greater than 12.
            <para>-or-</para>
            <paramref name="minute"/> is less than 0 or greater than 59.
            </exception>
        </member>
        <member name="M:System.TimeOfDay.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of a <see cref="T:System.TimeOfDay"/> structure to the specified
            hour, minute, and second, using the hours of a 24-hour clock.
            </summary>
            <param name="hour">The hours (0 through 23).</param>
            <param name="minute">The minutes (0 through 59).</param>
            <param name="second">The seconds (0 through 59).</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="hour"/> is less than 0 or greater than 23.
            <para>-or-</para>
            <paramref name="minute"/> is less than 0 or greater than 59.
            <para>-or-</para>
            <paramref name="second"/> is less than 0 or greater than 59.
            </exception>
        </member>
        <member name="M:System.TimeOfDay.#ctor(System.Int32,System.Int32,System.Int32,System.Meridiem)">
            <summary>
            Initializes a new instance of a <see cref="T:System.TimeOfDay"/> structure to the specified
            hour, minute, second, and meridiem, using the hours of a 12-hour clock.
            </summary>
            <param name="hour">The hours (1 through 12).</param>
            <param name="minute">The minutes (0 through 59).</param>
            <param name="second">The seconds (0 through 59).</param>
            <param name="meridiem">The meridiem, either <see cref="F:System.Meridiem.AM"/>,
            or <see cref="F:System.Meridiem.PM"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="hour"/> is less than 1 or greater than 12.
            <para>-or-</para>
            <paramref name="minute"/> is less than 0 or greater than 59.
            <para>-or-</para>
            <paramref name="second"/> is less than 0 or greater than 59.
            </exception>
        </member>
        <member name="M:System.TimeOfDay.#ctor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes a new instance of a <see cref="T:System.TimeOfDay"/> structure to the specified
            hour, minute, second, and millisecond, using the hours of a 24-hour clock.
            </summary>
            <param name="hour">The hours (0 through 23).</param>
            <param name="minute">The minutes (0 through 59).</param>
            <param name="second">The seconds (0 through 59).</param>
            <param name="millisecond">The milliseconds (0 through 999).</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="hour"/> is less than 0 or greater than 23.
            <para>-or-</para>
            <paramref name="minute"/> is less than 0 or greater than 59.
            <para>-or-</para>
            <paramref name="second"/> is less than 0 or greater than 59.
            <para>-or-</para>
            <paramref name="millisecond"/> is less than 0 or greater than 999.
            </exception>
        </member>
        <member name="M:System.TimeOfDay.#ctor(System.Int32,System.Int32,System.Int32,System.Int32,System.Meridiem)">
            <summary>
            Initializes a new instance of a <see cref="T:System.TimeOfDay"/> structure to the specified
            hour, minute, second, millisecond, and meridiem, using the hours of a 12-hour clock.
            </summary>
            <param name="hour">The hours (1 through 12).</param>
            <param name="minute">The minutes (0 through 59).</param>
            <param name="second">The seconds (0 through 59).</param>
            <param name="millisecond">The milliseconds (0 through 999).</param>
            <param name="meridiem">The meridiem, either <see cref="F:System.Meridiem.AM"/>,
            or <see cref="F:System.Meridiem.PM"/>.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="hour"/> is less than 1 or greater than 12.
            <para>-or-</para>
            <paramref name="minute"/> is less than 0 or greater than 59.
            <para>-or-</para>
            <paramref name="second"/> is less than 0 or greater than 59.
            <para>-or-</para>
            <paramref name="millisecond"/> is less than 0 or greater than 999.
            </exception>
        </member>
        <member name="P:System.TimeOfDay.Hour">
            <summary>
            Gets the hour component of the time represented by this instance, using the hours of a 24-hour clock.
            </summary>
            <value>The hour component, expressed as a value between 0 and 23.</value>
        </member>
        <member name="P:System.TimeOfDay.HourOf12HourClock">
            <summary>
            Gets the hour component of the time represented by this instance, using the hours of a 12-hour clock.
            </summary>
            <value>The hour component, expressed as a value between 1 and 12.</value>
        </member>
        <member name="P:System.TimeOfDay.Meridiem">
            <summary>
            Gets the meridiem (AM or PM) of the time represented by this instance.
            The meridiem can be used inconjunction with the <see cref="P:System.TimeOfDay.HourOf12HourClock"/> property
            to represent this instance's time on a 12-hour clock.
            </summary>
            <value>An enumerated constant that indicates the meridiem of this <see cref="T:System.TimeOfDay"/> value.</value>
            <remarks>
            Though commonly used in English, these abbreviations derive from Latin.
            AM is an abbreviation for "Ante Meridiem", meaning "before mid-day".
            PM is an abbreviation for "Post Meridiem", meaning "after mid-day".
            </remarks>
        </member>
        <member name="P:System.TimeOfDay.Minute">
            <summary>
            Gets the minute component of the time represented by this instance.
            </summary>
            <value>The minute component, expressed as a value between 0 and 59.</value>
        </member>
        <member name="P:System.TimeOfDay.Second">
            <summary>
            Gets the second component of the time represented by this instance.
            </summary>
            <value>The second component, expressed as a value between 0 and 59.</value>
        </member>
        <member name="P:System.TimeOfDay.Millisecond">
            <summary>
            Gets the millisecond component of the time represented by this instance.
            </summary>
            <value>The millisecond component, expressed as a value between 0 and 999.</value>
        </member>
        <member name="P:System.TimeOfDay.Ticks">
            <summary>
            Gets the number of ticks that represent the time of this instance.
            </summary>
            <value>
            The number of ticks that represent the time of this instance.
            The value is between <c>TimeOfDay.MinValue.Ticks</c> and <c>TimeOfDay.MaxValue.Ticks</c>.
            </value>
            <remarks>
            Each tick is a 100-nanosecond interval.  Collectively, they represent the time that has
            elapsed since midnight (00:00:00), without regard to daylight saving time transitions.
            </remarks>
        </member>
        <member name="M:System.TimeOfDay.On(System.Date)">
            <summary>
            Creates a <see cref="T:System.DateTime"/> object from the current <see cref="T:System.TimeOfDay"/> and the specified <see cref="T:System.Date"/>.
            The resulting value has a <see cref="P:System.DateTime.Kind"/> of <see cref="F:System.DateTimeKind.Unspecified"/>.
            </summary>
            <remarks>
            Since neither <see cref="T:System.Date"/> or <see cref="T:System.TimeOfDay"/> keep track of <see cref="T:System.DateTimeKind"/>,
            recognize that the <see cref="T:System.DateTime"/> produced by <c>TimeOfDay.Now.On(Date.Today)</c> will have
            <see cref="F:System.DateTimeKind.Unspecified"/>, rather than then <see cref="F:System.DateTimeKind.Local"/> that would be
            given by <c>DateTime.Now</c>.
            <para>The same applies for <see cref="F:System.DateTimeKind.Utc"/>.</para>
            </remarks>
        </member>
        <member name="M:System.TimeOfDay.NowInTimeZone(System.TimeZoneInfo)">
            <summary>
            Gets a <see cref="T:System.TimeOfDay"/> object that is set to the current time in the specified time zone.
            </summary>
            <param name="timeZoneInfo">The <see cref="T:System.TimeZoneInfo"/> instance.</param>
            <returns>The current <see cref="T:System.TimeOfDay"/> for the specified time zone.</returns>
        </member>
        <member name="P:System.TimeOfDay.Now">
            <summary>
            Gets a <see cref="T:System.TimeOfDay"/> object that is set to the current time,
            expressed in this computer's local time zone.
            </summary>
            <value>An object whose value is the current local time.</value>
        </member>
        <member name="P:System.TimeOfDay.UtcNow">
            <summary>
            Gets a <see cref="T:System.TimeOfDay"/> object that is set to the current time,
            expressed as Coordinated Universal Time (UTC).
            </summary>
            <value>An object whose value is the current UTC time.</value>
        </member>
        <member name="M:System.TimeOfDay.IsBetween(System.TimeOfDay,System.TimeOfDay)">
            <summary>
            Determines if a time falls within the range provided.
            Supports both "normal" ranges such as 10:00-12:00, and ranges that span midnight such as 23:00-01:00.
            </summary>
            <param name="startTime">The starting time of day, inclusive.</param>
            <param name="endTime">The ending time of day, exclusive.</param>
            <returns>True, if the time falls within the range, false otherwise.</returns>
        </member>
        <member name="M:System.TimeOfDay.CalculateDuration(System.TimeOfDay,System.TimeOfDay)">
            <summary>
            Calculates the duration between two time values.
            Assumes a standard day, with no invalid or ambiguous times due to Daylight Saving Time.
            Supports both "normal" ranges such as 10:00-12:00, and ranges that span midnight such as 23:00-01:00.
            Unlike <see cref="M:System.TimeOfDay.Subtract(System.TimeOfDay)"/>, this operation does not assume that both values
            belong to the same calendar date.  If <paramref name="startTime"/> is greater than
            <paramref name="endTime"/>, it behaves as if <paramref mame="endTime"/> were on the day following
            the <paramref name="startTime"/> date.
            </summary>
            <param name="startTime">The starting time of day, inclusive.</param>
            <param name="endTime">The ending time of day, exclusive.</param>
            <returns>A <see cref="T:System.TimeSpan"/> representing the duration between the two values.</returns>
        </member>
        <member name="M:System.TimeOfDay.Subtract(System.TimeOfDay)">
            <summary>
            Subtracts another <see cref="T:System.TimeOfDay"/> value from this instance, returning a <see cref="T:System.TimeSpan"/>.
            Assumes a standard day, with no invalid or ambiguous times due to Daylight Saving Time.
            This operation assumes that both values belong to the same calendar date, and thus the result will
            be negative if <paramref name="startTime"/> is greater than this instance.
            </summary>
            <param name="startTime">The starting time of day, inclusive.</param>
            <returns>
            A <see cref="T:System.TimeSpan"/> representing the duration between the <paramref name="startTime"/>
            (inclusive), and this instance (exclusive).
            </returns>
        </member>
        <member name="M:System.TimeOfDay.Add(System.TimeSpan)">
            <summary>
            Gets a <see cref="T:System.TimeOfDay"/> object whose value is ahead or behind the value of this instance by the
            specified amount of time. Positive values will move the time forward; negative values will move the
            time backwards.
            </summary>
            <param name="timeSpan">The amount of time to adjust by. The value can be negative or positive.</param>
            <returns>
            A new <see cref="T:System.TimeOfDay"/> object which is the result of adjusting this instance by the
            <paramref name="timeSpan"/> specified.
            </returns>
            <remarks>
            The time is modeled on a circular 24-hour clock.  When a value crosses midnight, it carries forward
            into the next day.  For example, 23:00 plus two hours is 01:00.
            </remarks>
        </member>
        <member name="M:System.TimeOfDay.AddHours(System.Double)">
            <summary>
            Gets a <see cref="T:System.TimeOfDay"/> object whose value is ahead or behind the value of this instance by the
            specified number of hours. Positive values will move the time forward; negative values will move the
            time backwards.
            </summary>
            <param name="hours">The number of hours to adjust by. The value can be negative or positive.</param>
            <returns>
            A new <see cref="T:System.TimeOfDay"/> object which is the result of adjusting this instance by the
            <paramref name="hours"/> specified.
            </returns>
            <remarks>
            The time is modeled on a circular 24-hour clock.  When a value crosses midnight, it carries forward
            into the next day.  For example, 23:00 plus one hour is 00:00.
            </remarks>
        </member>
        <member name="M:System.TimeOfDay.AddMinutes(System.Double)">
            <summary>
            Gets a <see cref="T:System.TimeOfDay"/> object whose value is ahead or behind the value of this instance by the
            specified number of minutes. Positive values will move the time forward; negative values will move the
            time backwards.
            </summary>
            <param name="minutes">The number of minutes to adjust by. The value can be negative or positive.</param>
            <returns>
            A new <see cref="T:System.TimeOfDay"/> object which is the result of adjusting this instance by the
            <paramref name="minutes"/> specified.
            </returns>
            <remarks>
            The time is modeled on a circular 24-hour clock.  When a value crosses midnight, it carries forward
            into the next day.  For example, 23:59 plus one minute is 00:00.
            </remarks>
        </member>
        <member name="M:System.TimeOfDay.AddSeconds(System.Double)">
            <summary>
            Gets a <see cref="T:System.TimeOfDay"/> object whose value is ahead or behind the value of this instance by the
            specified number of seconds. Positive values will move the time forward; negative values will move the
            time backwards.
            </summary>
            <param name="seconds">The number of seconds to adjust by. The value can be negative or positive.</param>
            <returns>
            A new <see cref="T:System.TimeOfDay"/> object which is the result of adjusting this instance by the
            <paramref name="seconds"/> specified.
            </returns>
            <remarks>
            The time is modeled on a circular 24-hour clock.  When a value crosses midnight, it carries forward
            into the next day.  For example, 23:59:59 plus one second is 00:00:00.
            </remarks>
        </member>
        <member name="M:System.TimeOfDay.AddMilliseconds(System.Double)">
            <summary>
            Gets a <see cref="T:System.TimeOfDay"/> object whose value is ahead or behind the value of this instance by the
            specified number of milliseconds. Positive values will move the time forward; negative values will move the
            time backwards.
            </summary>
            <param name="milliseconds">
            The number of milliseconds to adjust by. The value can be negative or positive.
            </param>
            <returns>
            A new <see cref="T:System.TimeOfDay"/> object which is the result of adjusting this instance by the
            <paramref name="milliseconds"/> specified.
            </returns>
            <remarks>
            The time is modeled on a circular 24-hour clock.  When a value crosses midnight, it carries forward
            into the next day.  For example, 23:59:59.9990000 plus one millisecond is 00:00:00.0000000.
            </remarks>
        </member>
        <member name="M:System.TimeOfDay.AddTicks(System.Int64)">
            <summary>
            Gets a <see cref="T:System.TimeOfDay"/> object whose value is ahead or behind the value of this instance by the
            specified number of ticks. Positive values will move the time forward; negative values will move the
            time backwards.
            </summary>
            <param name="ticks">
            The number of ticks to adjust by. The value can be negative or positive.
            A tick is a unit of time equal to 100 nanoseconds.
            </param>
            <returns>
            A new <see cref="T:System.TimeOfDay"/> object which is the result of adjusting this instance by the
            <paramref name="ticks"/> specified.
            </returns>
            <remarks>
            The time is modeled on a circular 24-hour clock.  When a value crosses midnight, it carries forward
            into the next day.  For example, 23:59:59.9999999 plus one tick is 00:00:00.0000000.
            </remarks>
        </member>
        <member name="M:System.TimeOfDay.Subtract(System.TimeSpan)">
            <summary>
            Gets a <see cref="T:System.TimeOfDay"/> object whose value is ahead or behind the value of this instance by the
            specified amount of time. Positive values will move the time backwards; negative values will move the
            time forward.  This is equivalent to calling <c>Add(timeSpan.Negate())</c>.
            </summary>
            <param name="timeSpan">The amount of time to adjust by. The value can be negative or positive.</param>
            <returns>
            A new <see cref="T:System.TimeOfDay"/> object which is the result of adjusting this instance by the
            <paramref name="timeSpan"/> specified.
            </returns>
            <remarks>
            The time is modeled on a circular 24-hour clock.  When a value crosses midnight, it carries backwards
            into the previous day.  For example, 01:00 minus two hours is 23:00.
            </remarks>
        </member>
        <member name="M:System.TimeOfDay.op_Addition(System.TimeOfDay,System.TimeSpan)">
            <summary>
            Adds a specified time interval to a specified time, yielding a new time.
            </summary>
            <param name="timeOfDay">The time of day value to add to.</param>
            <param name="timeSpan">The time interval to add.</param>
            <returns>
            A <see cref="T:System.TimeOfDay"/> object which is the result of adding the <paramref name="timeSpan"/>
            specified to the <paramref name="timeOfDay"/> provided.
            </returns>
            <remarks>
            The time is modeled on a circular 24-hour clock.  When a value crosses midnight, it carries forward
            into the next day.  For example, 23:00 plus two hours is 01:00.
            </remarks>
        </member>
        <member name="M:System.TimeOfDay.op_Subtraction(System.TimeOfDay,System.TimeSpan)">
            <summary>
            Subtracts a specified time interval to a specified time, yielding a new time.
            </summary>
            <param name="timeOfDay">The time of day value to subtract from.</param>
            <param name="timeSpan">The time interval to subtract.</param>
            <returns>
            A <see cref="T:System.TimeOfDay"/> object which is the result of subtracting the <paramref name="timeSpan"/>
            specified from the <paramref name="timeOfDay"/> provided.
            </returns>
            <remarks>
            The time is modeled on a circular 24-hour clock.  When a value crosses midnight, it carries backwards
            into the previous day.  For example, 01:00 minus two hours is 23:00.
            </remarks>
        </member>
        <member name="M:System.TimeOfDay.op_Subtraction(System.TimeOfDay,System.TimeOfDay)">
            <summary>
            Calculates the duration between the <paramref name="startTime"/> and <paramref name="endTime"/>.
            Assumes a standard day, with no invalid or ambiguous times due to Daylight Saving Time.
            Supports both "normal" ranges such as 10:00-12:00, and ranges that span midnight such as 23:00-01:00.
            This operation assumes that both values belong to the same calendar date, and thus the result will
            be negative if <paramref name="startTime"/> is greater than <paramref name="endTime"/>.
            </summary>
            <param name="startTime">The starting time of day, inclusive.</param>
            <param name="endTime">The ending time of day, exclusive.</param>
            <returns>
            A <see cref="T:System.TimeSpan"/> representing the duration between the two time of day values.
            </returns>
        </member>
        <member name="M:System.TimeOfDay.Compare(System.TimeOfDay,System.TimeOfDay)">
            <summary>
            Compares two instances of <see cref="T:System.TimeOfDay"/> and returns an integer that indicates whether the first
            instance is earlier than, the same as, or later than the second instance, within the same day.
            </summary>
            <param name="left">The first object to compare.</param>
            <param name="right">The second object to compare.</param>
            <returns>
            A signed number indicating the relative values of <paramref name="left"/> and <paramref name="right"/>.
            <list type="table">
            <listheader><term>Value</term><term>Description</term></listheader>
            <item>
              <term>Less than zero</term>
              <term><paramref name="left"/> is earlier than <paramref name="right"/>.</term>
            </item>
            <item>
              <term>Zero</term>
              <term><paramref name="left"/> is the same as <paramref name="right"/>.</term>
            </item>
            <item>
              <term>Greater than zero</term>
              <term><paramref name="left"/> is later than <paramref name="right"/>.</term>
            </item>
            </list>
            </returns>
            <remarks>
            This operation considers all time values to be contained within the same day.  If you need to compare
            time values that cross midnight into a different day, use the <see cref="M:System.TimeOfDay.IsBetween(System.TimeOfDay,System.TimeOfDay)"/> method instead.
            </remarks>
        </member>
        <member name="M:System.TimeOfDay.CompareTo(System.TimeOfDay)">
            <summary>
            Compares the value of this instance to a specified <see cref="T:System.TimeOfDay"/> value and returns an integer
            that indicates whether this instance is earlier than, the same as, or later than the specified
            <see cref="T:System.TimeOfDay"/> value, within the same day.
            </summary>
            <param name="value">The object to compare to the current instance.</param>
            <returns>
            A signed number indicating the relative values of this instance and the <paramref name="value"/> parameter.
            <list type="table">
            <listheader><term>Value</term><term>Description</term></listheader>
            <item>
              <term>Less than zero</term>
              <term>This instance is earlier than <paramref name="value"/>.</term>
            </item>
            <item>
              <term>Zero</term>
              <term>This instance is the same as <paramref name="value"/>.</term>
            </item>
            <item>
              <term>Greater than zero</term>
              <term>This instance is later than <paramref name="value"/>.</term>
            </item>
            </list>
            </returns>
            <remarks>
            This operation considers all time values to be contained within the same day.  If you need to compare
            time values that cross midnight into a different day, use the <see cref="M:System.TimeOfDay.IsBetween(System.TimeOfDay,System.TimeOfDay)"/> method instead.
            </remarks>
        </member>
        <member name="M:System.TimeOfDay.CompareTo(System.Object)">
            <summary>
            Compares the value of this instance to a specified object that contains a <see cref="T:System.TimeOfDay"/> value and
            returns an integer that indicates whether this instance is earlier than, the same as, or later than the
            specified <see cref="T:System.TimeOfDay"/> value, within the same day.
            </summary>
            <param name="value">The object to compare to the current instance.</param>
            <returns>
            A signed number indicating the relative values of this instance and the <paramref name="value"/> parameter.
            <list type="table">
            <listheader><term>Value</term><term>Description</term></listheader>
            <item>
              <term>Less than zero</term>
              <term>This instance is earlier than <paramref name="value"/>.</term>
            </item>
            <item>
              <term>Zero</term>
              <term>This instance is earlier than <paramref name="value"/>.</term>
            </item>
            <item>
              <term>Greater than zero</term>
              <term>
                This instance is later than <paramref name="value"/>,
                or <paramref name="value"/> is <c>null</c>.
              </term>
            </item>
            </list>
            </returns>
            <remarks>
            This operation considers all time values to be contained within the same day.  If you need to compare
            time values that cross midnight into a different day, use the <see cref="M:System.TimeOfDay.IsBetween(System.TimeOfDay,System.TimeOfDay)"/> method instead.
            </remarks>
            <exception cref="T:System.ArgumentException">
            <paramref name="value"/> is not a <see cref="T:System.TimeOfDay"/>.
            </exception>
        </member>
        <member name="M:System.TimeOfDay.Equals(System.TimeOfDay,System.TimeOfDay)">
            <summary>
            Returns a value indicating whether two <see cref="T:System.TimeOfDay"/> instances have the same time value.
            </summary>
            <param name="left">The first object to compare.</param>
            <param name="right">The second object to compare.</param>
            <returns><c>true</c> if the two values are equal; otherwise, <c>false</c>.</returns>
        </member>
        <member name="M:System.TimeOfDay.Equals(System.TimeOfDay)">
            <summary>
            Returns a value indicating whether the value of this instance is equal to the value of the specified
            <see cref="T:System.TimeOfDay"/> instance.
            </summary>
            <param name="value">The other <see cref="T:System.TimeOfDay"/> object to compare against this instance.</param>
            <returns>
            <c>true</c> if the <paramref name="value"/> parameter equals the value of this instance;
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:System.TimeOfDay.Equals(System.Object)">
            <summary>
            Returns a value indicating whether this instance is equal to the specified object.
            </summary>
            <param name="value">The object to compare to this instance.</param>
            <returns>
            <c>true</c> if <paramref name="value"/> is an instance of <see cref="T:System.TimeOfDay"/>
            and equals the value of this instance; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:System.TimeOfDay.GetHashCode">
            <summary>
            Returns the hash code of this instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
            <remarks>
            The hash code of a <see cref="T:System.TimeOfDay"/> object is the same as the hash code of
            its <see cref="P:System.TimeOfDay.Ticks"/> value.
            </remarks>
        </member>
        <member name="M:System.TimeOfDay.ToString">
            <summary>
            Converts the value of the current <see cref="T:System.TimeOfDay"/> object to its equivalent string representation.
            </summary>
            <returns>A string representation of value of the current <see cref="T:System.TimeOfDay"/> object.</returns>
        </member>
        <member name="M:System.TimeOfDay.ToString(System.IFormatProvider)">
            <summary>
            Converts the value of the current <see cref="T:System.TimeOfDay"/> object to its equivalent string representation
            using the specified culture-specific format information.
            </summary>
            <param name="provider">An object that supplies culture-specific formatting information.</param>
            <returns>
            A string representation of value of the current <see cref="T:System.TimeOfDay"/> object as specified by
            <paramref name="provider"/>.
            </returns>
        </member>
        <member name="M:System.TimeOfDay.ToString(System.String)">
            <summary>
            Converts the value of the current <see cref="T:System.TimeOfDay"/> object to its equivalent string representation
            using the specified format.
            </summary>
            <param name="format">A standard or custom time-of-day format string.</param>
            <returns>
            A string representation of value of the current <see cref="T:System.TimeOfDay"/> object as specified by
            <paramref name="format"/>.
            </returns>
            <exception cref="T:System.FormatException">
            The length of <paramref name="format"/> is 1, and it is not one of the format specifier characters defined
            for <see cref="T:System.Globalization.DateTimeFormatInfo"/>.
            <para>-or-</para>
            <paramref name="format"/> does not contain a valid custom format pattern.
            <para>-or-</para>
            The standard or custom format specified is not valid for a <see cref="T:System.TimeOfDay"/> object, because it
            contains a date component.
            </exception>
        </member>
        <member name="M:System.TimeOfDay.ToString(System.String,System.IFormatProvider)">
            <summary>
            Converts the value of the current <see cref="T:System.TimeOfDay"/> object to its equivalent string representation
            using the specified format and culture-specific format information.
            </summary>
            <param name="format">A standard or custom time-of-day format string.</param>
            <param name="provider">An object that supplies culture-specific formatting information.</param>
            <returns>
            A string representation of value of the current <see cref="T:System.TimeOfDay"/> object as specified by
            <paramref name="format"/> and <paramref name="provider"/>.
            </returns>
            <exception cref="T:System.FormatException">
            The length of <paramref name="format"/> is 1, and it is not one of the format specifier characters defined
            for <see cref="T:System.Globalization.DateTimeFormatInfo"/>.
            <para>-or-</para>
            <paramref name="format"/> does not contain a valid custom format pattern.
            <para>-or-</para>
            The standard or custom format specified is not valid for a <see cref="T:System.TimeOfDay"/> object, because it
            contains a date component.
            </exception>
        </member>
        <member name="M:System.TimeOfDay.ToLongTimeString">
            <summary>
            Converts the value of the current <see cref="T:System.TimeOfDay"/> object to its equivalent
            long time string representation.
            </summary>
            <returns>A string that contains the long time string representation of the
            current <see cref="T:System.TimeOfDay"/> object.</returns>
            <remarks>The value of the current <see cref="T:System.TimeOfDay"/> object is formatted
            using the pattern defined by the <see cref="P:System.Globalization.DateTimeFormatInfo.LongTimePattern" />
            property associated with the current thread culture.</remarks>
        </member>
        <member name="M:System.TimeOfDay.ToShortTimeString">
            <summary>
            Converts the value of the current <see cref="T:System.TimeOfDay"/> object to its equivalent
            short time string representation.
            </summary>
            <returns>A string that contains the short time string representation of the
            current <see cref="T:System.TimeOfDay"/> object.</returns>
            <remarks>The value of the current <see cref="T:System.TimeOfDay"/> object is formatted
            using the pattern defined by the <see cref="P:System.Globalization.DateTimeFormatInfo.ShortTimePattern" />
            property associated with the current thread culture.</remarks>
        </member>
        <member name="M:System.TimeOfDay.Parse(System.String)">
            <summary>
            Converts the string representation of a time-of-day to its <see cref="T:System.TimeOfDay"/> equivalent.
            </summary>
            <param name="s">A string that contains a time-of-day to convert.</param>
            <returns>An object that is equivalent to the time-of-day contained in <paramref name="s"/>.</returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="s"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.FormatException">
            <paramref name="s"/> does not contain a valid string representation of a time-of-day.
            </exception>
        </member>
        <member name="M:System.TimeOfDay.Parse(System.String,System.IFormatProvider)">
            <summary>
            Converts the string representation of a time-of-day to its <see cref="T:System.TimeOfDay"/> equivalent
            by using culture-specific format information.
            </summary>
            <param name="s">A string that contains a time-of-day to convert.</param>
            <param name="provider">
            An object that supplies culture-specific formatting information about <paramref name="s"/>.
            </param>
            <returns>
            An object that is equivalent to the time-of-day contained in <paramref name="s"/>,
            as specified by <paramref name="provider"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="s"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.FormatException">
            <paramref name="s"/> does not contain a valid string representation of a time-of-day.
            </exception>
        </member>
        <member name="M:System.TimeOfDay.Parse(System.String,System.IFormatProvider,System.Globalization.DateTimeStyles)">
            <summary>
            Converts the string representation of a time-of-day to its <see cref="T:System.TimeOfDay"/> equivalent
            by using culture-specific format information and formatting style.
            </summary>
            <param name="s">A string that contains a time-of-day to convert.</param>
            <param name="provider">
            An object that supplies culture-specific formatting information about <paramref name="s"/>.
            </param>
            <param name="styles">
            A bitwise combination of the enumeration values that indicates the style elements that
            can be present in <paramref name="s"/> for the parse operation to succeed.
            Note that only styles related to whitespace handling are applicable on a <see cref="T:System.TimeOfDay"/>.
            A typical value to specify is <see cref="F:System.Globalization.DateTimeStyles.None"/>.
            </param>
            <returns>
            An object that is equivalent to the time-of-day contained in <paramref name="s"/>,
            as specified by <paramref name="provider"/> and <paramref name="styles"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="s"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.FormatException">
            <paramref name="s"/> does not contain a valid string representation of a time-of-day.
            </exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="styles"/> styles contains an invalid <see cref="T:System.Globalization.DateTimeStyles"/> values.
            The only styles that are valid for a <see cref="T:System.TimeOfDay"/> are:
            <see cref="F:System.Globalization.DateTimeStyles.None"/>, <see cref="F:System.Globalization.DateTimeStyles.AllowLeadingWhite"/>,
            <see cref="F:System.Globalization.DateTimeStyles.AllowTrailingWhite"/>, <see cref="F:System.Globalization.DateTimeStyles.AllowInnerWhite"/>, and
            <see cref="F:System.Globalization.DateTimeStyles.AllowWhiteSpaces"/>.  The other styles are invalid because they only apply
            when both a date and time are being parsed together.
            </exception>
        </member>
        <member name="M:System.TimeOfDay.ParseExact(System.String,System.String,System.IFormatProvider)">
            <summary>
            Converts the specified string representation of a time-of-day to its <see cref="T:System.TimeOfDay"/> equivalent
            using the specified format and culture-specific format information.
            The format of the string representation must match the specified format exactly or an exception is thrown.
            </summary>
            <param name="s">A string that contains a time-of-day to convert.</param>
            <param name="format">A format specifier that defines the required format of <paramref name="s"/>.</param>
            <param name="provider">
            An object that supplies culture-specific formatting information about <paramref name="s"/>.
            </param>
            <returns>
            An object that is equivalent to the time-of-day contained in <paramref name="s"/>,
            as specified by <paramref name="format"/> and <paramref name="provider"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="s"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.FormatException">
            <paramref name="s"/> or <paramref name="format"/> is an empty string.
            <para>-or-</para>
            <paramref name="s"/> does not contain a time-of-day that corresponds to the pattern specified in
            <paramref name="format"/>.
            <para>-or-</para>
            <paramref name="format"/> contains a format pattern that is not applicable to a <see cref="T:System.TimeOfDay"/>.
            </exception>
        </member>
        <member name="M:System.TimeOfDay.ParseExact(System.String,System.String,System.IFormatProvider,System.Globalization.DateTimeStyles)">
            <summary>
            Converts the specified string representation of a time-of-day to its <see cref="T:System.TimeOfDay"/> equivalent
            using the specified format, culture-specific format information, and style.
            The format of the string representation must match the specified format exactly or an exception is thrown.
            </summary>
            <param name="s">A string that contains a time-of-day to convert.</param>
            <param name="format">A format specifier that defines the required format of <paramref name="s"/>.</param>
            <param name="provider">
            An object that supplies culture-specific formatting information about <paramref name="s"/>.
            </param>
            <param name="styles">
            A bitwise combination of the enumeration values that indicates the style elements that
            can be present in <paramref name="s"/> for the parse operation to succeed.
            Note that only styles related to whitespace handling are applicable on a <see cref="T:System.TimeOfDay"/>.
            A typical value to specify is <see cref="F:System.Globalization.DateTimeStyles.None"/>.
            </param>
            <returns>
            An object that is equivalent to the time-of-day contained in <paramref name="s"/>,
            as specified by <paramref name="format"/>, <paramref name="provider"/> and <paramref name="styles"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="s"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.FormatException">
            <paramref name="s"/> or <paramref name="format"/> is an empty string.
            <para>-or-</para>
            <paramref name="s"/> does not contain a time-of-day that corresponds to the pattern specified in
            <paramref name="format"/>.
            <para>-or-</para>
            <paramref name="format"/> contains a format pattern that is not applicable to a <see cref="T:System.TimeOfDay"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="styles"/> styles contains an invalid <see cref="T:System.Globalization.DateTimeStyles"/> values.
            The only styles that are valid for a <see cref="T:System.TimeOfDay"/> are:
            <see cref="F:System.Globalization.DateTimeStyles.None"/>, <see cref="F:System.Globalization.DateTimeStyles.AllowLeadingWhite"/>,
            <see cref="F:System.Globalization.DateTimeStyles.AllowTrailingWhite"/>, <see cref="F:System.Globalization.DateTimeStyles.AllowInnerWhite"/>, and
            <see cref="F:System.Globalization.DateTimeStyles.AllowWhiteSpaces"/>.  The other styles are invalid because they only apply
            when both a date and time are being parsed together.
            </exception>
        </member>
        <member name="M:System.TimeOfDay.ParseExact(System.String,System.String[],System.IFormatProvider,System.Globalization.DateTimeStyles)">
            <summary>
            Converts the specified string representation of a time-of-day to its <see cref="T:System.TimeOfDay"/> equivalent
            using the specified array of formats, culture-specific format information, and style.
            The format of the string representation must match at least one of the specified formats
            exactly or an exception is thrown.
            </summary>
            <param name="s">A string that contains a time-of-day to convert.</param>
            <param name="formats">An array of allowable formats of <paramref name="s"/>.</param>
            <param name="provider">
            An object that supplies culture-specific formatting information about <paramref name="s"/>.
            </param>
            <param name="styles">
            A bitwise combination of the enumeration values that indicates the style elements that
            can be present in <paramref name="s"/> for the parse operation to succeed.
            Note that only styles related to whitespace handling are applicable on a <see cref="T:System.TimeOfDay"/>.
            A typical value to specify is <see cref="F:System.Globalization.DateTimeStyles.None"/>.
            </param>
            <returns>
            An object that is equivalent to the time-of-day contained in <paramref name="s"/>,
            as specified by <paramref name="formats"/>, <paramref name="provider"/> and <paramref name="styles"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">
            <paramref name="s"/> is <c>null</c>.
            </exception>
            <exception cref="T:System.FormatException">
            <paramref name="s"/> is an empty string.
            <para>-or-</para>
            An element of <paramref name="formats"/> is an empty string.
            <para>-or-</para>
            <paramref name="s"/> does not contain a time-of-day that corresponds to any element of
            <paramref name="formats"/>.
            <para>-or-</para>
            An element of <paramref name="formats"/> contains a format pattern that is not applicable to a
            <see cref="T:System.TimeOfDay"/>.
            </exception>
            <exception cref="T:System.ArgumentException">
            <paramref name="styles"/> styles contains an invalid <see cref="T:System.Globalization.DateTimeStyles"/> values.
            The only styles that are valid for a <see cref="T:System.TimeOfDay"/> are:
            <see cref="F:System.Globalization.DateTimeStyles.None"/>, <see cref="F:System.Globalization.DateTimeStyles.AllowLeadingWhite"/>,
            <see cref="F:System.Globalization.DateTimeStyles.AllowTrailingWhite"/>, <see cref="F:System.Globalization.DateTimeStyles.AllowInnerWhite"/>, and
            <see cref="F:System.Globalization.DateTimeStyles.AllowWhiteSpaces"/>.  The other styles are invalid because they only apply
            when both a date and time are being parsed together.
            </exception>
        </member>
        <member name="M:System.TimeOfDay.TryParse(System.String,System.TimeOfDay@)">
            <summary>
            Converts the specified string representation of a time-of-day to its <see cref="T:System.TimeOfDay"/> equivalent
            and returns a value that indicates whether the conversion succeeded.
            </summary>
            <param name="s">A string containing a time-of-day to convert.</param>
            <param name="timeOfDay">
            When this method returns, contains the <see cref="T:System.TimeOfDay"/> value equivalent to the time-of-day
            contained in <paramref name="s"/>, if the conversion succeeded, or <see cref="F:System.TimeOfDay.MinValue"/>
            if the conversion failed. The conversion fails if the <paramref name="s"/> parameter is
            <c>null</c>, is an empty string (""), or does not contain a valid string representation of a time-of-day.
            This parameter is passed uninitialized.
            </param>
            <returns>
            <c>true</c> if the <paramref name="s"/> parameter was converted successfully; otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:System.TimeOfDay.TryParse(System.String,System.IFormatProvider,System.Globalization.DateTimeStyles,System.TimeOfDay@)">
            <summary>
            Converts the specified string representation of a time-of-day to its <see cref="T:System.TimeOfDay"/> equivalent
            using the specified culture-specific format information and formatting style,
            and returns a value that indicates whether the conversion succeeded.
            </summary>
            <param name="s">A string containing a time-of-day to convert.</param>
            <param name="provider">
            An object that supplies culture-specific formatting information about <paramref name="s"/>.
            </param>
            <param name="styles">
            A bitwise combination of the enumeration values that indicates the style elements that
            can be present in <paramref name="s"/> for the parse operation to succeed.
            Note that only styles related to whitespace handling are applicable on a <see cref="T:System.TimeOfDay"/>.
            A typical value to specify is <see cref="F:System.Globalization.DateTimeStyles.None"/>.
            </param>
            <param name="timeOfDay">
            When this method returns, contains the <see cref="T:System.TimeOfDay"/> value equivalent to the time-of-day
            contained in <paramref name="s"/>, if the conversion succeeded, or <see cref="F:System.TimeOfDay.MinValue"/>
            if the conversion failed. The conversion fails if the <paramref name="s"/> parameter is
            <c>null</c>, is an empty string (""), or does not contain a valid string representation of a time-of-day.
            This parameter is passed uninitialized.
            </param>
            <returns>
            <c>true</c> if the <paramref name="s"/> parameter was converted successfully; otherwise, <c>false</c>.
            </returns>
            <exception cref="T:System.ArgumentException">
            <paramref name="styles"/> styles contains an invalid <see cref="T:System.Globalization.DateTimeStyles"/> values.
            The only styles that are valid for a <see cref="T:System.TimeOfDay"/> are:
            <see cref="F:System.Globalization.DateTimeStyles.None"/>, <see cref="F:System.Globalization.DateTimeStyles.AllowLeadingWhite"/>,
            <see cref="F:System.Globalization.DateTimeStyles.AllowTrailingWhite"/>, <see cref="F:System.Globalization.DateTimeStyles.AllowInnerWhite"/>, and
            <see cref="F:System.Globalization.DateTimeStyles.AllowWhiteSpaces"/>.  The other styles are invalid because they only apply
            when both a date and time are being parsed together.
            </exception>
        </member>
        <member name="M:System.TimeOfDay.TryParseExact(System.String,System.String,System.IFormatProvider,System.Globalization.DateTimeStyles,System.TimeOfDay@)">
            <summary>
            Converts the specified string representation of a time-of-day to its <see cref="T:System.TimeOfDay"/> equivalent
            using the specified format, culture-specific format information, and style.
            The format of the string representation must match the specified format exactly.
            The method returns a value that indicates whether the conversion succeeded.
            </summary>
            <param name="s">A string containing a time-of-day to convert.</param>
            <param name="format">A format specifier that defines the required format of <paramref name="s"/>.</param>
            <param name="provider">
            An object that supplies culture-specific formatting information about <paramref name="s"/>.
            </param>
            <param name="styles">
            A bitwise combination of the enumeration values that indicates the style elements that
            can be present in <paramref name="s"/> for the parse operation to succeed.
            Note that only styles related to whitespace handling are applicable on a <see cref="T:System.TimeOfDay"/>.
            A typical value to specify is <see cref="F:System.Globalization.DateTimeStyles.None"/>.
            </param>
            <param name="timeOfDay">
            When this method returns, contains the <see cref="T:System.TimeOfDay"/> value equivalent to the time-of-day
            contained in <paramref name="s"/>, if the conversion succeeded, or <see cref="F:System.TimeOfDay.MinValue"/>
            if the conversion failed. The conversion fails if either the <paramref name="s"/> or
            <paramref name="format"/> parameter is <c>null</c>, is an empty string (""), or does not
            contain a time-of-day that coresponds to the pattern specified in <paramref name="format"/>.
            This parameter is passed uninitialized.
            </param>
            <returns>
            <c>true</c> if the <paramref name="s"/> parameter was converted successfully; otherwise, <c>false</c>.
            </returns>
            <exception cref="T:System.ArgumentException">
            <paramref name="styles"/> styles contains an invalid <see cref="T:System.Globalization.DateTimeStyles"/> values.
            The only styles that are valid for a <see cref="T:System.TimeOfDay"/> are:
            <see cref="F:System.Globalization.DateTimeStyles.None"/>, <see cref="F:System.Globalization.DateTimeStyles.AllowLeadingWhite"/>,
            <see cref="F:System.Globalization.DateTimeStyles.AllowTrailingWhite"/>, <see cref="F:System.Globalization.DateTimeStyles.AllowInnerWhite"/>, and
            <see cref="F:System.Globalization.DateTimeStyles.AllowWhiteSpaces"/>.  The other styles are invalid because they only apply
            when both a date and time are being parsed together.
            </exception>
        </member>
        <member name="M:System.TimeOfDay.TryParseExact(System.String,System.String[],System.IFormatProvider,System.Globalization.DateTimeStyles,System.TimeOfDay@)">
            <summary>
            Converts the specified string representation of a time-of-day to its <see cref="T:System.TimeOfDay"/> equivalent
            using the specified array of formats, culture-specific format information, and style.
            The format of the string representation must match at least one of the specified formats exactly.
            The method returns a value that indicates whether the conversion succeeded.
            </summary>
            <param name="s">A string containing a time-of-day to convert.</param>
            <param name="formats">An array of allowable formats of <paramref name="s"/>.</param>
            <param name="provider">
            An object that supplies culture-specific formatting information about <paramref name="s"/>.
            </param>
            <param name="styles">
            A bitwise combination of the enumeration values that indicates the style elements that
            can be present in <paramref name="s"/> for the parse operation to succeed.
            Note that only styles related to whitespace handling are applicable on a <see cref="T:System.TimeOfDay"/>.
            A typical value to specify is <see cref="F:System.Globalization.DateTimeStyles.None"/>.
            </param>
            <param name="timeOfDay">
            When this method returns, contains the <see cref="T:System.TimeOfDay"/> value equivalent to the time-of-day
            contained in <paramref name="s"/>, if the conversion succeeded, or <see cref="F:System.TimeOfDay.MinValue"/>
            if the conversion failed. The conversion fails if either the <paramref name="s"/> or
            <paramref name="formats"/> parameter is <c>null</c>, <paramref name="s"/> or an element of
            <paramref name="formats"/> is an empty string (""), or the format of <paramref name="s"/> is not
            exactly as specified by at least one of the format patterns in <paramref name="formats"/>.
            This parameter is passed uninitialized.
            </param>
            <returns>
            <c>true</c> if the <paramref name="s"/> parameter was converted successfully; otherwise, <c>false</c>.
            </returns>
            <exception cref="T:System.ArgumentException">
            <paramref name="styles"/> styles contains an invalid <see cref="T:System.Globalization.DateTimeStyles"/> values.
            The only styles that are valid for a <see cref="T:System.TimeOfDay"/> are:
            <see cref="F:System.Globalization.DateTimeStyles.None"/>, <see cref="F:System.Globalization.DateTimeStyles.AllowLeadingWhite"/>,
            <see cref="F:System.Globalization.DateTimeStyles.AllowTrailingWhite"/>, <see cref="F:System.Globalization.DateTimeStyles.AllowInnerWhite"/>, and
            <see cref="F:System.Globalization.DateTimeStyles.AllowWhiteSpaces"/>.  The other styles are invalid because they only apply
            when both a date and time are being parsed together.
            </exception>
        </member>
        <member name="M:System.TimeOfDay.op_Equality(System.TimeOfDay,System.TimeOfDay)">
            <summary>
            Determines whether two specified instances of <see cref="T:System.TimeOfDay"/> are equal.
            </summary>
            <param name="left">The first object to compare.</param>
            <param name="right">The second object to compare.</param>
            <returns>
            <c>true</c> if <paramref name="left"/> and <paramref name="right"/> represent the same time of day;
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:System.TimeOfDay.op_Inequality(System.TimeOfDay,System.TimeOfDay)">
            <summary>
            Determines whether two specified instances of <see cref="T:System.TimeOfDay"/> are not equal.
            </summary>
            <param name="left">The first object to compare.</param>
            <param name="right">The second object to compare.</param>
            <returns>
            <c>true</c> if <paramref name="left"/> and <paramref name="right"/> do not represent the same time of day;
            otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:System.TimeOfDay.op_GreaterThan(System.TimeOfDay,System.TimeOfDay)">
            <summary>
            Determines whether one specified <see cref="T:System.TimeOfDay"/> is later than another specified
            <see cref="T:System.TimeOfDay"/>, within the same day.
            </summary>
            <param name="left">The first object to compare.</param>
            <param name="right">The second object to compare.</param>
            <returns>
            <c>true</c> if <paramref name="left"/> is later than <paramref name="right"/> within the same day;
            otherwise, <c>false</c>.
            </returns>
            <remarks>
            This operation considers all time values to be contained within the same day.  If you need to compare
            time values that cross midnight into a different day, use the <see cref="M:System.TimeOfDay.IsBetween(System.TimeOfDay,System.TimeOfDay)"/> method instead.
            </remarks>
        </member>
        <member name="M:System.TimeOfDay.op_GreaterThanOrEqual(System.TimeOfDay,System.TimeOfDay)">
            <summary>
            Determines whether one specified <see cref="T:System.TimeOfDay"/> is equal to or later than another specified
            <see cref="T:System.TimeOfDay"/>, within the same day.
            </summary>
            <param name="left">The first object to compare.</param>
            <param name="right">The second object to compare.</param>
            <returns>
            <c>true</c> if <paramref name="left"/> is equal to or later than <paramref name="right"/> within the same day;
            otherwise, <c>false</c>.
            </returns>
            <remarks>
            This operation considers all time values to be contained within the same day.  If you need to compare
            time values that cross midnight into a different day, use the <see cref="M:System.TimeOfDay.IsBetween(System.TimeOfDay,System.TimeOfDay)"/> method instead.
            </remarks>
        </member>
        <member name="M:System.TimeOfDay.op_LessThan(System.TimeOfDay,System.TimeOfDay)">
            <summary>
            Determines whether one specified <see cref="T:System.TimeOfDay"/> is earlier than another specified
            <see cref="T:System.TimeOfDay"/>, within the same day.
            </summary>
            <param name="left">The first object to compare.</param>
            <param name="right">The second object to compare.</param>
            <returns>
            <c>true</c> if <paramref name="left"/> is earlier than <paramref name="right"/> within the same day;
            otherwise, <c>false</c>.
            </returns>
            <remarks>
            This operation considers all time values to be contained within the same day.  If you need to compare
            time values that cross midnight into a different day, use the <see cref="M:System.TimeOfDay.IsBetween(System.TimeOfDay,System.TimeOfDay)"/> method instead.
            </remarks>
        </member>
        <member name="M:System.TimeOfDay.op_LessThanOrEqual(System.TimeOfDay,System.TimeOfDay)">
            <summary>
            Determines whether one specified <see cref="T:System.TimeOfDay"/> is equal to or earlier than another specified
            <see cref="T:System.TimeOfDay"/>, within the same day.
            </summary>
            <param name="left">The first object to compare.</param>
            <param name="right">The second object to compare.</param>
            <returns>
            <c>true</c> if <paramref name="left"/> is equal to or earlier than <paramref name="right"/> within the same day;
            otherwise, <c>false</c>.
            </returns>
            <remarks>
            This operation considers all time values to be contained within the same day.  If you need to compare
            time values that cross midnight into a different day, use the <see cref="M:System.TimeOfDay.IsBetween(System.TimeOfDay,System.TimeOfDay)"/> method instead.
            </remarks>
        </member>
        <member name="M:System.TimeOfDay.op_Implicit(System.TimeSpan)~System.TimeOfDay">
            <summary>
            Implicitly casts a <see cref="T:System.TimeSpan"/> object to a <see cref="T:System.TimeOfDay"/> by returning a new
            <see cref="T:System.TimeOfDay"/> object that has the equivalent hours, minutes, seconds, and fractional seconds
            components.  This is useful when using APIs that express a time-of-day as the elapsed time since
            midnight, such that their values can be assigned to a variable having a <see cref="T:System.TimeOfDay"/> type.
            </summary>
            <param name="timeSpan">A <see cref="T:System.TimeSpan"/> value representing the time elapsed since midnight,
            without regard to daylight saving time transitions.</param>
            <returns>A newly constructed <see cref="T:System.TimeOfDay"/> object with an equivalent value.</returns>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="timeSpan"/> is either negative, or greater than <c>23:59:59.9999999</c>, and thus cannot be
            mapped to a <see cref="T:System.TimeOfDay"/>.
            </exception>
            <remarks>
            Fundamentally, a time-of-day and an elapsed-time are two different concepts.  In previous versions
            of the .NET framework, the <see cref="T:System.TimeOfDay"/> type did not exist, and thus several time-of-day
            values were represented by <see cref="T:System.TimeSpan"/> values erroneously.  For example, the
            <see cref="P:System.DateTime.TimeOfDay"/> property returns a value having a <see cref="T:System.TimeSpan"/> type.
            This implicit cast operator allows those APIs to be naturally used with <see cref="T:System.TimeOfDay"/>.
            <para>
            Also note that the input <paramref name="timeSpan"/> might actually *not* accurately represent the
            "time elapsed since midnight" on days containing a daylight saving time transition.
            </para>
            </remarks>
        </member>
        <member name="M:System.TimeOfDay.op_Explicit(System.TimeOfDay)~System.TimeSpan">
            <summary>
            Enables explicit casting of a <see cref="T:System.TimeOfDay"/> object to a <see cref="T:System.TimeSpan"/> by returning a new
            <see cref="T:System.TimeSpan"/> object that has the equivalent hours, minutes, seconds, and fractional seconds
            components.  This is useful when using APIs that express a time-of-day as the elapsed time since
            midnight, such that a <see cref="T:System.TimeOfDay"/> type can be passed to a method expecting a
            <see cref="T:System.TimeSpan"/> parameter as a time-of-day.
            </summary>
            <param name="timeOfDay">A <see cref="T:System.TimeOfDay"/> value.</param>
            <returns>
            A newly constructed <see cref="T:System.TimeSpan"/> object representing the time elapsed since midnight, without
            regard to daylight saving time transitions.
            </returns>
        </member>
        <member name="M:System.TimeOfDay.Hours12To24(System.Int32,System.Meridiem)">
            <summary>
            Converts the time from a 12-hour-clock representation to a 24-hour-clock representation.
            </summary>
        </member>
        <member name="M:System.TimeOfDay.TimeOfDayFromTimeSpan(System.TimeSpan)">
            <summary>
            Constructs a <see cref="T:System.TimeOfDay"/> from a <see cref="T:System.TimeSpan"/> representing the time elapsed since
            midnight, without regard to daylight saving time transitions.
            </summary>
        </member>
        <member name="M:System.TimeOfDay.NormalizeTimeFormat(System.String)">
            <summary>
            Normalizes a format string that has standard or custom date/time formats,
            such that the formatted output can only contain a time-of-day when applied.
            </summary>
            <exception cref="T:System.FormatException">
            The format string contained a format specifier that is only applicable
            when a date would be part of the formatted output.
            </exception>
        </member>
        <member name="M:System.TimeOfDay.GetSchema(System.Object)">
            <summary>
            Gets a <see cref="T:System.Xml.XmlQualifiedName"/> that represents the <c>xs:time</c> type of the
            W3C XML Schema Definition (XSD) specification.
            </summary>
            <remarks>
            This is required to support the <see cref="T:System.Xml.Serialization.XmlSchemaProviderAttribute"/> applied to this structure.
            </remarks>
        </member>
        <member name="M:System.TimeOfDay.System#Xml#Serialization#IXmlSerializable#GetSchema">
            <summary>
            Required by the <see cref="T:System.Xml.Serialization.IXmlSerializable"/> interface.
            </summary>
            <returns><c>null</c></returns>
        </member>
        <member name="M:System.TimeOfDay.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <summary>
            Generates a <see cref="T:System.TimeOfDay"/> object from its XML representation.
            </summary>
            <param name="reader">The <see cref="T:System.Xml.XmlReader"/> stream from which the object is deserialized.</param>
            <remarks>
            An <c>xs:time</c> uses the ISO-8601 extended time format, with up to seven decimal places of fractional
            seconds.  The equivalent .NET Framework format string is <c>HH:mm:ss.FFFFFFF</c>.
            </remarks>
        </member>
        <member name="M:System.TimeOfDay.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <summary>
            Converts a <see cref="T:System.TimeOfDay"/> object into its XML representation.
            </summary>
            <param name="writer">The <see cref="T:System.Xml.XmlWriter"/> stream to which the object is serialized.</param>
            <remarks>
            An <c>xs:time</c> uses the ISO-8601 extended time format, with up to seven decimal places of fractional
            seconds.  The equivalent .NET Framework format string is <c>HH:mm:ss.FFFFFFF</c>.
            </remarks>
        </member>
        <member name="M:nfunc.natrep``1">
            <summary>
            Constructs a natural representative
            </summary>
            <typeparam name="K">The representative type</typeparam>
        </member>
        <member name="M:nfunc.demand(System.Boolean,System.String)">
            <summary>
            Demands truth that is enforced with an exception upon false
            </summary>
            <param name="x">The value to test</param>
        </member>
    </members>
</doc>
