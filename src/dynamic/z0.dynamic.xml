<?xml version="1.0"?>
<doc>
    <assembly>
        <name>z0.dynamic</name>
    </assembly>
    <members>
        <member name="F:Z0.ActionDelegate.Id">
            <summary>
            The operation identity
            </summary>
        </member>
        <member name="M:Z0.IDynamicImmediate.CreateUnaryOp(Z0.TypeWidth,System.Reflection.MethodInfo,System.Byte)">
            <summary>
            Creates a unary operator with an embedded immediate value
            </summary>
            <param name="w">The operand width</param>
            <param name="src">The defining method that requires an immediate value</param>
            <param name="imm">The immediate value to embed</param>
        </member>
        <member name="M:Z0.IDynamicImmediate.CreateBinaryOp(Z0.TypeWidth,System.Reflection.MethodInfo,System.Byte)">
            <summary>
            Creates a binary operator with an embedded immediate value
            </summary>
            <param name="w">The operand width</param>
            <param name="src">The defining method that requires an immediate value</param>
            <param name="imm">The immediate value to embed</param>
        </member>
        <member name="M:Z0.IDynamicImmediate.UnaryInjector``1">
            <summary>
            Creates an immediate injector for unary operators with non-immediate operands of parametric width
            </summary>
            <typeparam name="W">The operand width</typeparam>
        </member>
        <member name="M:Z0.IDynamicImmediate.BinaryInjector``1">
            <summary>
            Creates an immediate injector for binary operators with non-immediate operands of parametric width
            </summary>
            <typeparam name="W">The operand width</typeparam>
        </member>
        <member name="M:Z0.IDynamicImmediate.UnaryInjector``1(Z0.W128)">
            <summary>
            Creates a 128-bit T-parametric unary immediate injector
            </summary>
            <param name="w">The vector operand width</param>
            <param name="k">The operator kind</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.IDynamicImmediate.UnaryInjector``1(Z0.W256)">
            <summary>
            Creates a 256-bit T-parametric unary immediate injector
            </summary>
            <param name="w">The vector operand width</param>
            <param name="k">The operator kind</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.IDynamicImmediate.BinaryInjector``1(Z0.W128)">
            <summary>
            Creates a 128-bit T-parametric binary immediate injector
            </summary>
            <param name="w">The vector operand width</param>
            <param name="k">The operator kind</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.IDynamicImmediate.BinaryInjector``1(Z0.W256)">
            <summary>
            Creates a 256-bit T-parametric binary immediate injector
            </summary>
            <param name="w">The vector operand width</param>
            <param name="k">The operator kind</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.IDynamicImmediate.CreateUnaryOp``1(System.Reflection.MethodInfo,Z0.W128,System.Byte)">
            <summary>
            Creates a 128-bit vectorized parametric unary operator that consumes an immediate value in the second argument
            </summary>
            <param name="src">The defining method</param>
            <param name="imm">The immediate value to embed</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.IDynamicImmediate.CreateBinaryOp``1(System.Reflection.MethodInfo,Z0.W128,System.Byte)">
            <summary>
            Creates a parametric 128-bit vectorized binary operator that adapts a like-kinded operator that consumes an immediate value in the third argument
            </summary>
            <param name="src">The defining method</param>
            <param name="imm">The immediate value to embed</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.IDynamicImmediate.CreateUnaryOp``1(System.Reflection.MethodInfo,Z0.W256,System.Byte)">
            <summary>
            Creates a parametric 128-bit vectorized unary operator that adapts a like-kinded operator that consumes an immediate value in the second argument
            </summary>
            <param name="src">The defining method</param>
            <param name="imm">The immediate value to embed</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.IDynamicImmediate.CreateBinaryOp``1(System.Reflection.MethodInfo,Z0.W256,System.Byte)">
            <summary>
            Creates a parametric 256-bit vectorized binary operator that adapts a like-kinded operator that consumes an immediate value in the third argument
            </summary>
            <param name="src">The defining method</param>
            <param name="imm">The immediate value to embed</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.IFixedDynamic.EmitFixedUnary``1(Z0.BufferToken,Z0.ApiCodeBlock)">
            <summary>
            Loads executable source into an identified buffer and creates a fixed unary operator over the buffer
            </summary>
            <param name="buffer">The target buffer</param>
            <param name="src">The executable source</param>
            <typeparam name="F">The fixed operand type</typeparam>
        </member>
        <member name="M:Z0.IFixedDynamic.EmitFixedBinary``1(Z0.BufferToken,Z0.ApiCodeBlock)">
            <summary>
            Loads source into a token-identified buffer and covers it with a fixed binary operator
            </summary>
            <param name="buffer">The target buffer</param>
            <param name="src">The code to load</param>
            <typeparam name="F">The fixed operand type</typeparam>
        </member>
        <member name="M:Z0.IFixedDynamic.EmitFixedTernary``1(Z0.BufferToken,Z0.ApiCodeBlock)">
            <summary>
            Loads executable source into an identified buffer and creates a fixed unary operator over the buffer
            </summary>
            <param name="dst">The target buffer</param>
            <param name="src">The executable source</param>
            <typeparam name="F">The fixed operand type</typeparam>
        </member>
        <member name="M:Z0.IFixedDynamic.EmitFixedUnary(Z0.BufferToken,Z0.W8,Z0.ApiCodeBlock)">
            <summary>
            Creates a fixed 8-bit unary operator from caller-supplied x86 source code
            </summary>
            <param name="dst">The target buffer sequence</param>
            <param name="w">The width selector</param>
            <param name="src">The source code</param>
        </member>
        <member name="M:Z0.IFixedDynamic.EmitFixedUnary(Z0.BufferToken,Z0.W16,Z0.ApiCodeBlock)">
            <summary>
            Creates a fixed 16-bit unary operator from caller-supplied x86 source code
            </summary>
            <param name="dst">The target buffer sequence</param>
            <param name="w">The width selector</param>
            <param name="src">The source code</param>
        </member>
        <member name="M:Z0.IFixedDynamic.EmitFixedUnary(Z0.BufferToken,Z0.W32,Z0.ApiCodeBlock)">
            <summary>
            Creates a fixed 32-bit unary operator from caller-supplied x86 source code
            </summary>
            <param name="dst">The target buffer sequence</param>
            <param name="w">The width selector</param>
            <param name="src">The source code</param>
        </member>
        <member name="M:Z0.IFixedDynamic.EmitFixedUnary(Z0.BufferToken,Z0.W64,Z0.ApiCodeBlock)">
            <summary>
            Creates a fixed 64-bit unary operator from caller-supplied x86 source code
            </summary>
            <param name="dst">The target buffer sequence</param>
            <param name="index">The index of the buffer to load</param>
            <param name="w">The width selector</param>
            <param name="src">The source code</param>
        </member>
        <member name="M:Z0.IFixedDynamic.EmitFixedUnary(Z0.BufferToken,Z0.W128,Z0.ApiCodeBlock)">
            <summary>
            Creates a fixed 128-bit unary operator from caller-supplied x86 source code
            </summary>
            <param name="dst">The target buffer sequence</param>
            <param name="w">The width selector</param>
            <param name="src">The source code</param>
        </member>
        <member name="M:Z0.IFixedDynamic.EmitFixedUnary(Z0.BufferToken,Z0.W256,Z0.ApiCodeBlock)">
            <summary>
            Creates a fixed 256-bit unary operator from caller-supplied x86 source code
            </summary>
            <param name="dst">The target buffer sequence</param>
            <param name="w">The width selector</param>
            <param name="src">The source code</param>
        </member>
        <member name="M:Z0.IFixedDynamic.EmitFixedBinary(Z0.BufferToken,Z0.W8,Z0.ApiCodeBlock)">
            <summary>
            Creates a fixed 8-bit binary operator from caller-supplied x86 source code
            </summary>
            <param name="dst">The target buffer sequence</param>
            <param name="index">The index of the buffer to load</param>
            <param name="w">The width selector</param>
            <param name="src">The source code</param>
        </member>
        <member name="M:Z0.IFixedDynamic.EmitFixedBinary(Z0.BufferToken,Z0.W16,Z0.ApiCodeBlock)">
            <summary>
            Creates a fixed 16-bit binary operator from caller-supplied x86 source code
            </summary>
            <param name="dst">The target buffer sequence</param>
            <param name="index">The index of the buffer to load</param>
            <param name="w">The width selector</param>
            <param name="src">The source code</param>
        </member>
        <member name="M:Z0.IFixedDynamic.EmitFixedBinary(Z0.BufferToken,Z0.W32,Z0.ApiCodeBlock)">
            <summary>
            Creates a fixed 32-bit binary operator from caller-supplied x86 source code
            </summary>
            <param name="dst">The target buffer sequence</param>
            <param name="index">The index of the buffer to load</param>
            <param name="w">The width selector</param>
            <param name="src">The source code</param>
        </member>
        <member name="M:Z0.IFixedDynamic.EmitFixedBinary(Z0.BufferToken,Z0.W64,Z0.ApiCodeBlock)">
            <summary>
            Creates a fixed 64-bit binary operator from caller-supplied x86 source code
            </summary>
            <param name="dst">The target buffer sequence</param>
            <param name="index">The index of the buffer to load</param>
            <param name="w">The width selector</param>
            <param name="src">The source code</param>
        </member>
        <member name="M:Z0.IFixedDynamic.EmitFixedBinary(Z0.BufferToken,Z0.W128,Z0.ApiCodeBlock)">
            <summary>
            Creates a fixed 128-bit binary operator from caller-supplied x86 source code
            </summary>
            <param name="dst">The target buffer sequence</param>
            <param name="index">The index of the buffer to load</param>
            <param name="w">The width selector</param>
            <param name="src">The source code</param>
        </member>
        <member name="M:Z0.IFixedDynamic.EmitFixedBinary(Z0.BufferToken,Z0.W256,Z0.ApiCodeBlock)">
            <summary>
            Creates a fixed 256-bit binary operator from caller-supplied x86 source code
            </summary>
            <param name="dst">The target buffer sequence</param>
            <param name="index">The index of the buffer to load</param>
            <param name="w">The width selector</param>
            <param name="src">The source code</param>
        </member>
        <member name="M:Z0.Dynop.EmitFixedBinaryOp(Z0.BufferToken,Z0.N8,Z0.ApiCodeBlock)">
            <summary>
            Creates a fixed 8-bit binary operator from caller-supplied x86 source code
            </summary>
            <param name="buffer">Identifies the target buffer</param>
            <param name="w">The width selector</param>
            <param name="src">The source code</param>
        </member>
        <member name="M:Z0.Dynop.EmitFixedBinaryOp(Z0.BufferToken,Z0.N16,Z0.ApiCodeBlock)">
            <summary>
            Creates a fixed 16-bit binary operator from caller-supplied x86 source code
            </summary>
            <param name="buffer">Identifies the target buffer</param>
            <param name="w">The width selector</param>
            <param name="src">The source code</param>
        </member>
        <member name="M:Z0.Dynop.EmitFixedBinaryOp(Z0.BufferToken,Z0.N32,Z0.ApiCodeBlock)">
            <summary>
            Creates a fixed 32-bit binary operator from caller-supplied x86 source code
            </summary>
            <param name="buffer">Identifies the target buffer</param>
            <param name="w">The width selector</param>
            <param name="src">The source code</param>
        </member>
        <member name="M:Z0.Dynop.EmitFixedBinaryOp(Z0.BufferToken,Z0.N64,Z0.ApiCodeBlock)">
            <summary>
            Creates a fixed 64-bit binary operator from caller-supplied x86 source code
            </summary>
            <param name="buffer">Identifies the target buffer</param>
            <param name="w">The width selector</param>
            <param name="src">The source code</param>
        </member>
        <member name="M:Z0.Dynop.EmitFixedBinaryOp(Z0.BufferToken,Z0.N128,Z0.ApiCodeBlock)">
            <summary>
            Creates a fixed 128-bit binary operator from caller-supplied x86 source code
            </summary>
            <param name="buffer">Identifies the target buffer</param>
            <param name="w">The width selector</param>
            <param name="src">The source code</param>
        </member>
        <member name="M:Z0.Dynop.EmitFixedBinaryOp(Z0.BufferToken,Z0.N256,Z0.ApiCodeBlock)">
            <summary>
            Creates a fixed 256-bit binary operator from caller-supplied x86 source code
            </summary>
            <param name="buffer">Identifies the target buffer</param>
            <param name="w">The width selector</param>
            <param name="src">The source code</param>
        </member>
        <member name="M:Z0.Dynop.EmitFixedFunc``2(Z0.BufferToken,Z0.ApiCodeBlock)">
            <summary>
            Loads executable source into an identified buffer and creates a fixed unary function over the buffer
            </summary>
            <param name="dst">The target buffer</param>
            <param name="src">The executable source</param>
        </member>
        <member name="M:Z0.Dynop.EmitFixedFunc``3(Z0.BufferToken,Z0.ApiCodeBlock)">
            <summary>
            Loads executable source into an identified buffer and creates a fixed binary function over the buffer
            </summary>
            <param name="dst">The target buffer</param>
            <param name="src">The executable source</param>
        </member>
        <member name="M:Z0.Dynop.EmitFixedFunc``4(Z0.BufferToken,Z0.ApiCodeBlock)">
            <summary>
            Loads executable source into an identified buffer and creates a fixed binary function over the buffer
            </summary>
            <param name="dst">The target buffer</param>
            <param name="src">The executable source</param>
        </member>
        <member name="M:Z0.Dynop.EmitFixedUnaryOp``1(Z0.BufferToken,Z0.ApiCodeBlock)">
            <summary>
            Loads executable source into an identified buffer and creates a fixed unary operator over the buffer
            </summary>
            <param name="buffer">The target buffer</param>
            <param name="src">The executable source</param>
            <typeparam name="F">The fixed operand type</typeparam>
        </member>
        <member name="M:Z0.Dynop.EmitFixedBinaryOp``1(Z0.BufferToken,Z0.ApiCodeBlock)">
            <summary>
            Loads source into a token-identified buffer and covers it with a fixed binary operator
            </summary>
            <param name="buffer">The target buffer</param>
            <param name="src">The code to load</param>
            <typeparam name="F">The fixed operand type</typeparam>
        </member>
        <member name="M:Z0.Dynop.EmitFixedTernaryOp``1(Z0.BufferToken,Z0.ApiCodeBlock)">
            <summary>
            Loads executable source into an identified buffer and creates a fixed unary operator over the buffer
            </summary>
            <param name="dst">The target buffer</param>
            <param name="src">The executable source</param>
            <typeparam name="F">The fixed operand type</typeparam>
        </member>
        <member name="M:Z0.Dynop.EmitUnaryOp``1(Z0.BufferToken,Z0.ApiCodeBlock)">
            <summary>
            Loads executable code into a token-identified buffer and covers it with a parametric unary operator
            </summary>
            <param name="buffer">The buffer token</param>
            <param name="src">The code to load</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.Dynop.EmitBinaryOp``1(Z0.BufferToken,Z0.ApiCodeBlock)">
            <summary>
            Loads executable code into a token-identified buffer and covers it with a parametric binary operator
            </summary>
            <param name="buffer">The buffer token</param>
            <param name="src">The code to load</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.Dynop.EmitTernaryOp``1(Z0.BufferToken,Z0.ApiCodeBlock)">
            <summary>
            Loads executable code into a token-identified buffer and covers it with a parametric ternary operator
            </summary>
            <param name="dst">The buffer token</param>
            <param name="src">The code to load</param>
            <typeparam name="T">The operand type</typeparam>
        </member>
        <member name="M:Z0.LinqXFunc.f``1(System.Func{``0})">
            <summary>
            Creates a function expression for an emitter
            </summary>
            <param name="f">The source delegate</param>
            <typeparam name="X">The function argument type</typeparam>
            <typeparam name="Y">The return type</typeparam>
        </member>
        <member name="M:Z0.LinqXFunc.f``2(System.Func{``0,``1})">
            <summary>
            Creates a function expression over a function delegate of arity 1
            </summary>
            <param name="f">The source delegate</param>
            <typeparam name="X">The function argument type</typeparam>
            <typeparam name="Y">The return type</typeparam>
        </member>
        <member name="M:Z0.LinqXFunc.f``3(System.Func{``0,``1,``2})">
            <summary>
            Creates a function expression over a function delegate of arity 2
            </summary>
            <param name="f">The source delegate</param>
            <typeparam name="X1">The type of the first argument</typeparam>
            <typeparam name="X2">The type of the second argument</typeparam>
            <typeparam name="R">The return type</typeparam>
        </member>
        <member name="M:Z0.LinqXFunc.f``4(System.Func{``0,``1,``2,``3})">
            <summary>
            Creates a function expression over a function delegate of arity 3
            </summary>
            <param name="f">The source delegate</param>
            <typeparam name="X1">The type of the first argument</typeparam>
            <typeparam name="X2">The type of the second argument</typeparam>
            <typeparam name="X3">The type of the third argument</typeparam>
            <typeparam name="Y">The return type</typeparam>
        </member>
        <member name="M:Z0.LinqXFunc.f``1(System.Func{``0,``0,``0})">
            <summary>
            Creates a function expression over an homogenous function delegate of arity 2
            </summary>
            <param name="f">The source delegate</param>
            <typeparam name="X">The operand type</typeparam>
        </member>
        <member name="M:Z0.LinqXFunc.f``1(System.Func{``0,``0,``0,``0})">
            <summary>
            Creates a function expression over an homogenous function delegate of arity 3
            </summary>
            <param name="f">The source delegate</param>
            <typeparam name="X">The operand type</typeparam>
        </member>
        <member name="M:Z0.LinqXFunc.fx``1(System.Func{``0})">
            <summary>
            Creates a linq expression over an emitter
            </summary>
            <param name="f">The source delegate</param>
            <typeparam name="X">The function operand type</typeparam>
            <typeparam name="R">The function return type</typeparam>
        </member>
        <member name="M:Z0.LinqXFunc.fx``2(System.Func{``0,``1})">
            <summary>
            Creates a linq expression over a function delegate of arity 1
            </summary>
            <param name="f">The source delegate</param>
            <typeparam name="X">The function operand type</typeparam>
            <typeparam name="R">The function return type</typeparam>
        </member>
        <member name="M:Z0.LinqXFunc.fx``3(System.Func{``0,``1,``2})">
            <summary>
            Creates a linq expression over a function delegate of arity 2
            </summary>
            <param name="f">The source delegate</param>
            <typeparam name="X1">The type of the first operand</typeparam>
            <typeparam name="X2">The type of the second operand</typeparam>
            <typeparam name="R">The function return type</typeparam>
        </member>
        <member name="M:Z0.LinqXFunc.fx``4(System.Func{``0,``1,``2,``3})">
            <summary>
            Creates a linq expression over a function delegate of arity 3
            </summary>
            <param name="f">The source delegate</param>
            <typeparam name="X1">The type of the first operand</typeparam>
            <typeparam name="X2">The type of the second operand</typeparam>
            <typeparam name="X3">The type of the third operand</typeparam>
            <typeparam name="Y">The function return type</typeparam>
        </member>
        <member name="M:Z0.XFuncX.Func``1(System.Reflection.MethodInfo,System.Object)">
            <summary>
            Creates a delegate for an emitter
            </summary>
            <param name="host">The declaring type instance, if applicable</param>
            <typeparam name="X">The result type</typeparam>
        </member>
        <member name="M:Z0.XFuncX.Func``2(System.Reflection.MethodInfo,System.Object)">
            <summary>
            Creates a delegate for a function f:X->Y realized by a specified method
            </summary>
            <typeparam name="X1">The type of the first parameter</typeparam>
            <typeparam name="X2">The type of the second parameter</typeparam>
            <typeparam name="Y">The result type</typeparam>
            <param name="member">The source method</param>
            <param name="host">An instance of the declaring type, if applicable</param>
        </member>
        <member name="M:Z0.XFuncX.Func``3(System.Reflection.MethodInfo,System.Object)">
            <summary>
            Creates a delegate for a function f:X1->X2->Y realized by a specified method
            </summary>
            <typeparam name="X1">The type of the first parameter</typeparam>
            <typeparam name="X2">The type of the second parameter</typeparam>
            <typeparam name="Y">The result type</typeparam>
            <param name="member">The source method</param>
            <param name="host">An instance of the declaring type, if applicable</param>
        </member>
        <member name="M:Z0.XFuncX.Func``4(System.Reflection.MethodInfo,System.Object)">
            <summary>
            Creates a delegate for a function f:X1->X2->X3->Y realized by a specified method
            </summary>
            <typeparam name="X1">The type of the first parameter</typeparam>
            <typeparam name="X2">The type of the second parameter</typeparam>
            <typeparam name="X3">Tye type of the third parameter</typeparam>
            <typeparam name="Y">The result type</typeparam>
            <param name="member">The source method</param>
            <param name="host">An instance of the declaring type, if applicable</param>
        </member>
        <member name="M:Z0.XFuncX.Func``5(System.Reflection.MethodInfo,System.Object)">
            <summary>
            Creates a delegate for a function f:X1->X2->X3->X4->Y realized by a specified method
            </summary>
            <typeparam name="X1">The type of the first parameter</typeparam>
            <typeparam name="X2">The type of the second parameter</typeparam>
            <typeparam name="X3">Tye type of the third parameter</typeparam>
            <typeparam name="X4">Tye type of the fourth parameter</typeparam>
            <typeparam name="Y">The result type</typeparam>
            <param name="member">The source method</param>
            <param name="host">An instance of the declaring type, if applicable</param>
        </member>
        <member name="M:Z0.XFuncX.GetValueMemberName``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Extracts the name of the value member referenced by an expression delegate
            </summary>
            <typeparam name="T">The member selector</typeparam>
            <typeparam name="M">The member type</typeparam>
            <param name="selector">The selecting expression that identifies the desired member</param>
        </member>
        <member name="M:Z0.XFuncX.GetAccessedProperty(System.Linq.Expressions.Expression)">
            <summary>
            Extracts property info from a member expression, if possbile, and otherwise returns null
            </summary>
            <param name="x">The expression to examine</param>
        </member>
        <member name="M:Z0.XFuncX.AccessedMember(System.Linq.Expressions.Expression)">
            <summary>
            Extracts member info from an expression, if possbile; otherwise returns none
            </summary>
            <param name="x">The expression to examine</param>
        </member>
        <member name="M:Z0.XFuncX.AccessedProperty(System.Linq.Expressions.Expression)">
            <summary>
            Extracts property info from an expression, if possbile; otherwise returns none
            </summary>
            <param name="x">The expression to examine</param>
        </member>
        <member name="M:Z0.XFuncX.GetMember``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Extracts the member info for the member referenced by an expression delegate
            </summary>
            <typeparam name="T">The first selector parameter</typeparam>
            <typeparam name="M">The member type</typeparam>
            <param name="selector">The selecting expression that identifies the desired member</param>
        </member>
        <member name="M:Z0.XFuncX.GetDataMember``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Extracts the <see cref="T:Z0.ClrDataMember"/> for the member referenced by a an expression delegate
            </summary>
            <typeparam name="T">The member selector</typeparam>
            <typeparam name="M">The member type</typeparam>
            <param name="selector">The selecting expression that identifies the desired member</param>
        </member>
        <member name="M:Z0.XFuncX.GetField``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Extracts the field info for the field referenced by an expression delegate
            </summary>
            <typeparam name="F">The field type</typeparam>
            <param name="selector">The selecting expression that identifies the desired member</param>
        </member>
        <member name="M:Z0.XFuncX.GetField``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Extracts the field info for the field referenced by an expression delegate
            </summary>
            <typeparam name="T">The declaring type</typeparam>
            <typeparam name="P">The property type</typeparam>
            <param name="selector">The selecting expression that identifies the desired member</param>
        </member>
        <member name="M:Z0.XFuncX.GetMethod``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Extracts the method info for the function referenced by an expression delegate
            </summary>
            <typeparam name="T">The function return type</typeparam>
            <param name="selector">The call expression</param>
        </member>
        <member name="M:Z0.XFuncX.GetMethod``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Extracts the method info for the function referenced by an expression delegate
            </summary>
            <typeparam name="T1">The first function argument</typeparam>
            <typeparam name="T2">The function return type</typeparam>
            <param name="selector">The call expression</param>
        </member>
        <member name="M:Z0.XFuncX.GetMethod``3(System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})">
            <summary>
            Extracts the method info for the function referenced by an expression delegate
            </summary>
            <typeparam name="T1">The first function argument</typeparam>
            <typeparam name="T2">The second function argument</typeparam>
            <typeparam name="R">The function return type</typeparam>
            <param name="selector">The call expression</param>
        </member>
        <member name="M:Z0.XFuncX.GetMethod``4(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3}})">
            <summary>
            Extracts the method info for the function referenced by an expression delegate
            </summary>
            <typeparam name="T1">The first function argument</typeparam>
            <typeparam name="T2">The second function argument</typeparam>
            <typeparam name="T3">The third function argument</typeparam>
            <typeparam name="R">The function return type</typeparam>
            <param name="selector">Specifies the call expression</param>
        </member>
        <member name="M:Z0.XFuncX.GetMethod``1(System.Linq.Expressions.Expression{System.Action{``0}})">
            <summary>
            Extracts the method for the action referenced by an an expression delegate
            </summary>
            <typeparam name="T">The action argument</typeparam>
            <param name="selector">Specifies the call expression</param>
        </member>
        <member name="M:Z0.XFuncX.GetMethod``2(System.Linq.Expressions.Expression{System.Action{``0,``1}})">
            <summary>
            Extracts the method info for the action referenced by an expression delegate
            </summary>
            <typeparam name="T1">The first action argument</typeparam>
            <typeparam name="T2">The second action argument</typeparam>
            <param name="selector">Specifies the call expression</param>
        </member>
        <member name="M:Z0.XFuncX.GetMethod``3(System.Linq.Expressions.Expression{System.Action{``0,``1,``2}})">
            <summary>
            Extracts the method info for the action referenced by an expression delegate
            </summary>
            <typeparam name="T1">The first action argument</typeparam>
            <typeparam name="T2">The second action argument</typeparam>
            <typeparam name="T3">The third action argument</typeparam>
            <param name="selector">Specifies the call expression</param>
        </member>
        <member name="M:Z0.XFuncX.GetMethod``4(System.Linq.Expressions.Expression{System.Action{``0,``1,``2,``3}})">
            <summary>
            Extracts the method info for the action referenced by an expression delegate
            </summary>
            <typeparam name="T1">The first action argument</typeparam>
            <typeparam name="T2">The second action argument</typeparam>
            <typeparam name="T3">The third action argument</typeparam>
            <typeparam name="T4">The fourth action argument</typeparam>
            <param name="selector">The call expression</param>
        </member>
        <member name="M:Z0.XFuncX.GetProperty``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Extracts the property info for the property referenced by an expression delegate
            </summary>
            <typeparam name="P">The property type</typeparam>
            <param name="selector">The selecting expression that identifies the desired member</param>
        </member>
        <member name="M:Z0.XFuncX.GetProperty``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Extracts the property info for the property referenced by an expression delegate
            </summary>
            <typeparam name="T">The declaring type</typeparam>
            <typeparam name="P">The property type</typeparam>
            <param name="selector">The selecting expression that identifies the desired member</param>
        </member>
        <member name="M:Z0.XFuncX.IsConversion(System.Linq.Expressions.Expression)">
            <summary>
            Tests whether an expression is a conversion
            </summary>
            <param name="x">The expression to examine</param>
        </member>
        <member name="M:Z0.XFuncX.IsConversion``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Tests whether a member is wrapped in a conversion
            </summary>
            <typeparam name="T">The declaring type</typeparam>
            <typeparam name="R">The member type</typeparam>
            <param name="selector">Expression that identifies the member</param>
        </member>
        <member name="M:Z0.XFuncX.IsMemberAccess(System.Linq.Expressions.Expression)">
            <summary>
            Tests whether the test expression is a member access expression
            </summary>
            <param name="x">The expression to examine</param>
        </member>
        <member name="M:Z0.XFuncX.IsCall(System.Linq.Expressions.Expression)">
            <summary>
            Tests whether the test expression is a function call
            </summary>
            <param name="x">The expression to examine</param>
        </member>
        <member name="M:Z0.XFuncX.IsSelect(System.Linq.Expressions.Expression)">
            <summary>
            Tests whether an expression is an application of the LINQ select operator
            </summary>
            <param name="x">The expression to test</param>
        </member>
        <member name="M:Z0.XFuncX.IsLogical(System.Linq.Expressions.Expression)">
            <summary>
            Tests whether an expression is a logical operator
            </summary>
            <param name="x">The expression to examine</param>
        </member>
        <member name="M:Z0.XFuncX.IsLambda(System.Linq.Expressions.Expression)">
            <summary>
            Tests whether an expression is a lambda expression
            </summary>
            <param name="x">The expression to examine</param>
        </member>
        <member name="M:Z0.XFuncX.IsDisjunction``1(``0)">
            <summary>
            Tests whether an expression is a logical disjunction
            </summary>
            <param name="x">The expression to examine</param>
        </member>
        <member name="M:Z0.XFuncX.IsConjunction``1(``0)">
            <summary>
            Tests whether an expression is a logical conjunction
            </summary>
            <param name="x">The expression to examine</param>
        </member>
        <member name="M:Z0.XFuncX.IsJunction(System.Linq.Expressions.Expression)">
            <summary>
            Deterines whether the test expression is either a logical conjuntion or disjunction
            </summary>
            <param name="X">The expression to examine</param>
        </member>
        <member name="M:Z0.XFuncX.IsOneOf``2(System.Linq.Expressions.Expression)">
            <summary>
            Performs a type-test on an expression
            </summary>
            <typeparam name="X1">The first candidate type</typeparam>
            <typeparam name="X2">The second candidate type</typeparam>
            <param name="x">The expression to test</param>
        </member>
        <member name="M:Z0.XFuncX.IsOneOf``3(System.Linq.Expressions.Expression)">
            <summary>
            Performs a type-test on an expression
            </summary>
            <typeparam name="X1">The first candidate type</typeparam>
            <typeparam name="X2">The second candidate type</typeparam>
            <typeparam name="X3">The third candidate type</typeparam>
            <param name="x">The expression to test</param>
        </member>
        <member name="M:Z0.XFuncX.IsOneOf``4(System.Linq.Expressions.Expression)">
            <summary>
            Performs a type-test on an expression
            </summary>
            <typeparam name="X1">The first candidate type</typeparam>
            <typeparam name="X2">The second candidate type</typeparam>
            <typeparam name="X3">The third candidate type</typeparam>
            <typeparam name="X4">The fourth candidate type</typeparam>
            <param name="x">The expression to test</param>
        </member>
        <member name="M:Z0.XFuncX.BinaryOp``1(System.Reflection.MethodInfo,System.Object)">
            <summary>
            Creates a delegate for a binary operator f:X->X->X realized by a specified method
            </summary>
            <param name="member">The source method</param>
            <param name="host">An instance of the declaring type, if applicable</param>
            <typeparam name="X">The operand type</typeparam>
        </member>
        <member name="M:Z0.XFuncX.SelectionSubject``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Gets the expression that directly identifies the selected subject
            </summary>
            <typeparam name="M">The member type</typeparam>
            <param name="selector">The selecting expression that identifies the desired member</param>
        </member>
        <member name="M:Z0.XFuncX.SelectionSubject``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Gets the expression that directly identifies the selected subject
            </summary>
            <typeparam name="T">The declaring type</typeparam>
            <typeparam name="M">The member type</typeparam>
            <param name="selector">The selecting expression that identifies the desired member</param>
        </member>
        <member name="M:Z0.XFuncX.SelectedPropertyName``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Determines the name of the property as identified by an expression delegate
            </summary>
            <typeparam name="T">The declaring type</typeparam>
            <typeparam name="P">The property type</typeparam>
            <param name="selector">The selecting expression that identifies the desired member</param>
        </member>
        <member name="M:Z0.XFuncX.CalledMethod(System.Linq.Expressions.Expression)">
            <summary>
            Returns the method invoked by an expression, if any
            </summary>
            <param name="x">The expression to test</param>
        </member>
        <member name="M:Z0.XFuncX.Conjunction``1(``0)">
            <summary>
            Returns the expression if it is a logical conjunction and None otherwise
            </summary>
            <param name="x">The expression to examine</param>
        </member>
        <member name="M:Z0.XFuncX.Disjunction``1(``0)">
            <summary>
            Returns the expression if it is a logical disjunction and None otherwise
            </summary>
            <param name="x">The expression to examine</param>
        </member>
        <member name="M:Z0.XFuncX.Constant(System.Linq.Expressions.Expression)">
            <summary>
            Extracts a value from a constant expression if possible
            </summary>
            <param name="x">The expression to examine</param>
        </member>
        <member name="M:Z0.LinqXPress.and(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            Creates a conjunction of a left and right expression
            </summary>
            <param name="a">The left expression</param>
            <param name="b">The right expression</param>
        </member>
        <member name="M:Z0.LinqXPress.and``2(System.Func{``0,System.Boolean},System.Func{``1,System.Boolean})">
            <summary>
            Forms a conjunction from two function predicates
            </summary>
            <typeparam name="X1">The first predicate argument type</typeparam>
            <typeparam name="X2">The second predicate argument type</typeparam>
            <param name="p1">The first predicate</param>
            <param name="p2">The second predicate</param>
        </member>
        <member name="M:Z0.LinqXPress.call(System.Object,System.Reflection.MethodInfo,System.Linq.Expressions.ParameterExpression[])">
            <summary>
            Creates an expression that invokes a static or instance method
            </summary>
            <param name="Host">The object that exposes the method if not static; otherwise null</param>
            <param name="m">The method to be invoked</param>
            <param name="args">The arguments supplied to the method when invoked</param>
        </member>
        <member name="M:Z0.LinqXPress.call(System.Reflection.MethodInfo,System.Linq.Expressions.ParameterExpression[])">
            <summary>
            Creates an expression that invokes a static method
            </summary>
            <param name="m">The method to be invoked</param>
            <param name="args">The arguments supplied to the method when invoked</param>
        </member>
        <member name="M:Z0.LinqXPress.constant(System.Object)">
            <summary>
            Creates a constant expression
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.LinqXPress.convert(System.Linq.Expressions.Expression,System.Type)">
            <summary>
            Defines a conversion from a source expression to a target type
            </summary>
            <param name="e">The source expression</param>
            <param name="dstType">The target type</param>
        </member>
        <member name="M:Z0.LinqXPress.convert``1(System.Linq.Expressions.Expression)">
            <summary>
            Defines a conversion from a source expression to a target type
            </summary>
            <typeparam name="T">The target type</typeparam>
            <param name="e">The source expression</param>
        </member>
        <member name="M:Z0.LinqXPress.factory``1">
            <summary>
            Defines a function that will invoke the default constructor to create
            an instance of type <typeparamref name="X"/>
            </summary>
            <typeparam name="X">The type of instance to create</typeparam>
        </member>
        <member name="M:Z0.LinqXPress.factory``2">
            <summary>
            Defines a strongly-typed function that will invoke a one-parameter constructor to create a target type instance
            </summary>
            <typeparam name="X">The constructor parameter type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.LinqXPress.factory(System.Type,System.Type)">
            <summary>
            Defines a weakly-typed function that will invoke a one-parameter constructor to create a target type instance
            </summary>
            <param name="arg">The constuctor argument type</param>
            <param name="target">The target type</param>
        </member>
        <member name="M:Z0.LinqXPress.factory``3">
            <summary>
            Defines a strongly-typed function that will invoke a two-parameter constructor to create a target type instance
            </summary>
            <typeparam name="X1">The first constructor parameter type</typeparam>
            <typeparam name="X2">The second constructor parameter type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.LinqXPress.factory(System.Type,System.Type,System.Type)">
            <summary>
            Defines a weakly-typed function that will invoke a two-parameter constructor to create a target type instance
            </summary>
            <param name="arg1">The first constuctor parameter type</param>
            <param name="arg1">The second constuctor parameter type</param>
            <param name="target">The target type</param>
        </member>
        <member name="M:Z0.LinqXPress.factory``4">
            <summary>
            Defines a strongly-typed function that will invoke a three-parameter constructor to create a target type instance
            </summary>
            <typeparam name="X1">The first constructor parameter type</typeparam>
            <typeparam name="X2">The second constructor parameter type</typeparam>
            <typeparam name="X3">The third constructor parameter type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.LinqXPress.func``1(System.Func{``0})">
            <summary>
            Creates an expression from an emitter
            </summary>
            <typeparam name="T">The emission type</typeparam>
            <param name="f">The emitter</param>
        </member>
        <member name="M:Z0.LinqXPress.func``2(System.Func{``0,``1})">
            <summary>
            Creates an expression from a function delegate of arity 1
            </summary>
            <typeparam name="X">The function operand type</typeparam>
            <typeparam name="Y">The function return type</typeparam>
            <param name="f">The source delegate</param>
        </member>
        <member name="M:Z0.LinqXPress.func``3(System.Func{``0,``1,``2})">
            <summary>
            Creates an expression from a function delegate of arity 2
            </summary>
            <typeparam name="X1">The type of the first operand</typeparam>
            <typeparam name="X2">The type of the second operand</typeparam>
            <typeparam name="Y">The function return type</typeparam>
            <param name="f">The source delegate</param>
        </member>
        <member name="M:Z0.LinqXPress.func``4(System.Func{``0,``1,``2,``3})">
            <summary>
            Creates an expression from a function delegate of arity 3
            </summary>
            <typeparam name="X1">The type of the first operand</typeparam>
            <typeparam name="X2">The type of the second operand</typeparam>
            <typeparam name="X3">The type of the third operand</typeparam>
            <typeparam name="Y">The function return type</typeparam>
            <param name="f">The source delegate</param>
        </member>
        <member name="M:Z0.LinqXPress.func``1(System.Reflection.MethodInfo,System.Object)">
            <summary>
            Creates and caches a delegate for a method realizing an emitter
            </summary>
            <typeparam name="X">The emission type</typeparam>
            <param name="m">The source method</param>
            <param name="host">An object instance for the method, if applicable</param>
        </member>
        <member name="M:Z0.LinqXPress.func``2(System.Reflection.MethodInfo,System.Object)">
            <summary>
            Creates and caches a delegate for a method realizing a function f:X->Y
            </summary>
            <typeparam name="X">The operand type</typeparam>
            <typeparam name="Y">The return type</typeparam>
            <param name="m">The source method</param>
            <param name="host">An object instance for the method, if applicable</param>
        </member>
        <member name="M:Z0.LinqXPress.func``2(System.Type,System.String,System.Object)">
            <summary>
            Creates and caches a delegate for a method realizing a function f:X->Y
            </summary>
            <typeparam name="X">The operand type</typeparam>
            <typeparam name="Y">The return type</typeparam>
            <param name="declarer">The declaring type</param>
            <param name="name">The name of the method</param>
            <param name="host">An object instance for the method, if applicable</param>
        </member>
        <member name="M:Z0.LinqXPress.func1(System.Reflection.MethodInfo,System.Object)">
            <summary>
            Creates a weakly-typed delegate for a function f:X->Y
            </summary>
            <param name="m">The source method</param>
            <param name="host">The instance of the declaring type, if method is not static</param>
        </member>
        <member name="M:Z0.LinqXPress.func2(System.Reflection.MethodInfo,System.Object)">
            <summary>
            Creates a weakly-typed delegate for a function f:X->Y
            </summary>
            <param name="m">The source method</param>
            <param name="host">The instance of the declaring type, if method is not static</param>
        </member>
        <member name="M:Z0.LinqXPress.func``3(System.Reflection.MethodInfo,System.Object)">
            <summary>
            Creates and caches a function delegate for a method realizing a function f:(X1,X2) -> Y
            </summary>
            <typeparam name="X1">The first operand type</typeparam>
            <typeparam name="X2">The second operand type</typeparam>
            <typeparam name="Y">The return type</typeparam>
            <param name="m">The source method</param>
            <param name="host">The instance of the declaring type, if method is not static</param>
        </member>
        <member name="M:Z0.LinqXPress.func``4(System.Reflection.MethodInfo,System.Object)">
            <summary>
            Creates and caches a function delegate for a method realizing a function f:X1->X2->X3->Y
            </summary>
            <typeparam name="X1">The first operand type</typeparam>
            <typeparam name="X2">The second operand type</typeparam>
            <typeparam name="X3">The third operand type</typeparam>
            <typeparam name="Y">The return type</typeparam>
            <param name="m">The source method</param>
            <param name="host">The instance of the declaring type, if method is not static</param>
        </member>
        <member name="M:Z0.LinqXPress.func``5(System.Reflection.MethodInfo,System.Object)">
            <summary>
            Creates and caches a function delegate for a method realizing a function f:X1->X2->X3->X4->Y
            </summary>
            <typeparam name="X1">The first operand type</typeparam>
            <typeparam name="X2">The second operand type</typeparam>
            <typeparam name="X3">The third operand type</typeparam>
            <typeparam name="Y">The return type</typeparam>
            <param name="m">The source method</param>
            <param name="host">The instance of the declaring type, if method is not static</param>
        </member>
        <member name="M:Z0.LinqXPress.ctor(System.Type,System.Type[])">
            <summary>
            Searches a type for an instance constructor that matches a specified signature
            </summary>
            <param name="declaringType">The type to search</param>
            <param name="argTypes">The method parameter types in ordinal position</param>
        </member>
        <member name="M:Z0.LinqXPress.ctor``1(System.Type[])">
            <summary>
            Searches a type for an instance constructor that matches a specified signature
            </summary>
            <param name="args">The method parameter types in ordinal position</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.LinqXPress.ctor``2">
            <summary>
            Searches a type for an instance constructor that matches a parametrically-specified signature
            </summary>
            <param name="args">The method parameter types in ordinal position</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.LinqXPress.ctor``3">
            <summary>
            Searches a type for an instance constructor that matches a parametrically-specified signature
            </summary>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.LinqXPress.fmake``1(System.Func{``0})">
            <summary>
            Defines a function expression for an emitter
            </summary>
            <typeparam name="X">The emission type</typeparam>
            <param name="f">The emitter</param>
        </member>
        <member name="M:Z0.LinqXPress.fmake``2(System.Func{``0,``1})">
            <summary>
            Defines a function expression for a heterogenous function of arity 1
            </summary>
            <typeparam name="X">The function argument type</typeparam>
            <typeparam name="Y">The return type</typeparam>
            <param name="f">The source function</param>
        </member>
        <member name="M:Z0.LinqXPress.fmake``3(System.Func{``0,``1,``2})">
            <summary>
            Defines a function expression for a heterogenous function of arity 2
            </summary>
            <typeparam name="X1">The type of the first argument</typeparam>
            <typeparam name="X2">The type of the second argument</typeparam>
            <typeparam name="Y">The return type</typeparam>
            <param name="f">The source function</param>
        </member>
        <member name="M:Z0.LinqXPress.fmake``4(System.Func{``0,``1,``2,``3})">
            <summary>
            Produces a 3-argument func expression
            </summary>
            <typeparam name="X1">The type of the first argument</typeparam>
            <typeparam name="X2">The type of the second argument</typeparam>
            <typeparam name="X3">The type of the third argument</typeparam>
            <typeparam name="Y">The return type</typeparam>
            <param name="f">The source function</param>
        </member>
        <member name="M:Z0.LinqXPress.invoke(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression[])">
            <summary>
            Creates an expression to call a function
            </summary>
            <param name="f">An expression representing the function to invoke</param>
            <param name="args">The function arguments</param>
        </member>
        <member name="M:Z0.LinqXPress.invoke``2(System.Func{``0,``1},System.String)">
            <summary>
            Creates an invocation expression for a function f:X->Y
            </summary>
            <typeparam name="X">The function argument type</typeparam>
            <typeparam name="Y">The function return type</typeparam>
            <param name="f">The function delegate</param>
            <param name="arg">The name of argument</param>
        </member>
        <member name="M:Z0.LinqXPress.invoke``3(System.Func{``0,``1,``2},System.String,System.String)">
            <summary>
            Creates an invocation expression for a function f:X1->X2->Y
            </summary>
            <typeparam name="X1">The type of the first function argument</typeparam>
            <typeparam name="X2">The type of the second function argument</typeparam>
            <typeparam name="Y">The function return type</typeparam>
            <param name="f">The source function</param>
            <param name="arg1">The name of the first argument</param>
            <param name="arg2">The name of the second argument</param>
        </member>
        <member name="M:Z0.LinqXPress.lambda``1(System.Linq.Expressions.Expression)">
            <summary>
            Defines a lambda expression sans parameters
            </summary>
            <typeparam name="T">The aligned delegate type</typeparam>
            <param name="body">The expression body</param>
        </member>
        <member name="M:Z0.LinqXPress.lambda``1(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression)">
            <summary>
            Creates a lambda expression
            </summary>
            <param name="parameters">The expression parameters</param>
            <param name="body">The expression body</param>
            <typeparam name="T">The aligned delegate type</typeparam>
        </member>
        <member name="M:Z0.LinqXPress.lambda``1(System.ValueTuple{System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression)">
            <summary>
            Creates a 2-parameter lambda expression
            </summary>
            <typeparam name="T">The aligned delegate type</typeparam>
            <param name="parameters">The expression parameters</param>
            <param name="body">The expression body</param>
        </member>
        <member name="M:Z0.LinqXPress.lambda``1(System.ValueTuple{System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression,System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression)">
            <summary>
            Defines a lambda expression
            </summary>
            <typeparam name="T">The aligned delegate type</typeparam>
            <param name="parameters">The expression parameters</param>
            <param name="body">The expression body</param>
        </member>
        <member name="M:Z0.LinqXPress.emitter``1(System.Linq.Expressions.Expression)">
            <summary>
            Creates a an emitter expression
            </summary>
            <param name="parameters">The expression parameters</param>
            <param name="body">The expression body</param>
        </member>
        <member name="M:Z0.LinqXPress.lambda``2(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression)">
            <summary>
            Creates a 1-argument lambda expression
            </summary>
            <param name="parameters">The expression parameters</param>
            <param name="body">The expression body</param>
        </member>
        <member name="M:Z0.LinqXPress.lambda``3(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression)">
            <summary>
            Creates a 2-argument lambda expression
            </summary>
            <param name="parameters">The expression parameters</param>
            <param name="body">The expression body</param>
        </member>
        <member name="M:Z0.LinqXPress.lambda``4(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression)">
            <summary>
            Creates a 3-argument lambda expression
            </summary>
            <param name="parameters">The expression parameters</param>
            <param name="body">The expression body</param>
        </member>
        <member name="M:Z0.LinqXPress.lambda``5(System.Collections.Generic.IEnumerable{System.Linq.Expressions.ParameterExpression},System.Linq.Expressions.Expression)">
            <summary>
            Creates a 4-argument lambda expression
            </summary>
            <param name="parameters">The expression parameters</param>
            <param name="body">The expression body</param>
        </member>
        <member name="M:Z0.LinqXPress.lambda``2(System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.UnaryExpression})">
            <summary>
            Creates a unary lambda expression
            </summary>
            <param name="f">The defining function</param>
        </member>
        <member name="M:Z0.LinqXPress.lambda``3(System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.BinaryExpression})">
            <summary>
            Creates a binary lambda expression
            </summary>
            <param name="f">The defining function</param>
        </member>
        <member name="M:Z0.LinqXPress.or(System.Linq.Expressions.Expression,System.Linq.Expressions.Expression)">
            <summary>
            Creates a disjunction of a left and right expression
            </summary>
            <param name="lhs">The left expression</param>
            <param name="rhs">The right expression</param>
        </member>
        <member name="M:Z0.LinqXPress.or``2(System.Func{``0,System.Boolean},System.Func{``1,System.Boolean})">
            <summary>
            Forms a disjunction from two function predicates
            </summary>
            <typeparam name="X1">The first predicate argument type</typeparam>
            <typeparam name="X2">The second predicate argument type</typeparam>
            <param name="f1">The first predicate</param>
            <param name="f2">The second predicate</param>
        </member>
        <member name="M:Z0.LinqXPress.paramX``1(System.String)">
            <summary>
            Creates a parameter expression
            </summary>
            <typeparam name="X">The parameter type</typeparam>
            <param name="name">The parameter name</param>
        </member>
        <member name="M:Z0.LinqXPress.paramX``2">
            <summary>
            Creates a parameter expression array of length 2
            </summary>
            <typeparam name="X1">The first parameter type</typeparam>
            <typeparam name="X2">The second parameter type</typeparam>
        </member>
        <member name="M:Z0.LinqXPress.paramX``3">
            <summary>
            Creates a parameter expression array of length 3
            </summary>
            <typeparam name="X1">The first parameter type</typeparam>
            <typeparam name="X2">The second parameter type</typeparam>
            <typeparam name="X3">The third parameter type</typeparam>
        </member>
        <member name="M:Z0.LinqXPress.paramX``4">
            <summary>
            Creates a parameter expression array of length 4
            </summary>
            <typeparam name="X1">The first parameter type</typeparam>
            <typeparam name="X2">The second parameter type</typeparam>
            <typeparam name="X3">The third parameter type</typeparam>
        </member>
        <member name="M:Z0.LinqXPress.paramX``1(System.Int32)">
            <summary>
            Creates a parameter expression where the parameter name is predicated on an integer value
            </summary>
            <param name="i">The paremeter index</param>
            <typeparam name="X">The parameter type</typeparam>
        </member>
        <member name="M:Z0.LinqXPress.paramX(System.Type,System.String)">
            <summary>
            Creates a parameter expression
            </summary>
            <param name="t">The parameter type</param>
            <param name="name">The parameter name</param>
        </member>
        <member name="M:Z0.LinqXPress.paramX(System.Reflection.ParameterInfo)">
            <summary>
            Creates a parameter expression from a reflected parameter
            </summary>
            <param name="p">The reflected parameter</param>
        </member>
        <member name="M:Z0.LinqXPress.paramX(System.Type,System.Int32)">
            <summary>
            Creates a parameter expression where the parameter name is predicated on an integer value
            </summary>
            <param name="i">The paremeter index</param>
        </member>
        <member name="M:Z0.LinqXPress.paramXPair``2">
            <summary>
            Creates a parameter expression 2-tuple
            </summary>
            <typeparam name="X1">The type of the first parameter</typeparam>
            <typeparam name="X2">The type of the second parameter</typeparam>
        </member>
        <member name="M:Z0.LinqXPress.paramXTriple``3">
            <summary>
            Creates a parameter expression 3-tuple
            </summary>
            <typeparam name="X1">The type of the first parameter</typeparam>
            <typeparam name="X2">The type of the second parameter</typeparam>
            <typeparam name="X3">The type of the third parameter</typeparam>
        </member>
        <member name="M:Z0.LinqXPress.params(System.Type[])">
            <summary>
            Creates an auto-named parameter expression array from an array of parameter types
            </summary>
            <param name="paramTypes">The parameter types</param>
        </member>
        <member name="M:Z0.LinqXPress.test(System.Object,System.Type)">
            <summary>
            Creates a type-test expression
            </summary>
            <param name="value">The value to test</param>
            <param name="t">The type to test against</param>
        </member>
        <member name="M:Z0.LinqXPress.test``1(System.Object)">
            <summary>
            Creates an expression to adjudicate whether a value if of a specified type
            </summary>
            <param name="value">The value to test</param>
            <typeparam name="T">The type to test against</typeparam>
        </member>
        <member name="M:Z0.LinqXQuery.called(System.Linq.Expressions.Expression)">
            <summary>
            Returns the method invoked by an expression, if any
            </summary>
            <param name="x">The expression to test</param>
        </member>
        <member name="M:Z0.LinqXQuery.constant(System.Linq.Expressions.Expression)">
            <summary>
            Extracts a value from a constant expression if possible
            </summary>
            <param name="x">The expression to examine</param>
        </member>
        <member name="M:Z0.LinqXQuery.field``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Extracts the field info for the field referenced by an expression delegate
            </summary>
            <typeparam name="F">The field type</typeparam>
            <param name="selector">The selecting expression that identifies the desired member</param>
        </member>
        <member name="M:Z0.LinqXQuery.field``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Extracts the field info for the field referenced by an expression delegate
            </summary>
            <typeparam name="T">The declaring type</typeparam>
            <typeparam name="P">The property type</typeparam>
            <param name="selector">The selecting expression that identifies the desired member</param>
        </member>
        <member name="M:Z0.LinqXQuery.IsConversion(System.Linq.Expressions.Expression)">
            <summary>
            Tests whether an expression is a conversion
            </summary>
            <param name="x">The expression to examine</param>
        </member>
        <member name="M:Z0.LinqXQuery.IsConversion``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Tests whether a member is wrapped in a conversion
            </summary>
            <typeparam name="T">The declaring type</typeparam>
            <typeparam name="R">The member type</typeparam>
            <param name="selector">Expression that identifies the member</param>
        </member>
        <member name="M:Z0.LinqXQuery.IsAccess(System.Linq.Expressions.Expression)">
            <summary>
            Tests whether the test expression is a member access expression
            </summary>
            <param name="x">The expression to examine</param>
        </member>
        <member name="M:Z0.LinqXQuery.IsCall(System.Linq.Expressions.Expression)">
            <summary>
            Tests whether the test expression is a function call
            </summary>
            <param name="x">The expression to examine</param>
        </member>
        <member name="M:Z0.LinqXQuery.IsSelect(System.Linq.Expressions.Expression)">
            <summary>
            Tests whether an expression is an application of the LINQ select operator
            </summary>
            <param name="x">The expression to test</param>
        </member>
        <member name="M:Z0.LinqXQuery.IsLogical(System.Linq.Expressions.Expression)">
            <summary>
            Tests whether an expression is a logical operator
            </summary>
            <param name="x">The expression to examine</param>
        </member>
        <member name="M:Z0.LinqXQuery.IsLambda(System.Linq.Expressions.Expression)">
            <summary>
            Tests whether an expression is a lambda expression
            </summary>
            <param name="x">The expression to examine</param>
        </member>
        <member name="M:Z0.LinqXQuery.disjunction``1(``0)">
            <summary>
            If the source expression is a logical disjunction, returns the expression; otherwise, returns none
            </summary>
            <param name="x">The expression to examine</param>
        </member>
        <member name="M:Z0.LinqXQuery.conjunction``1(``0)">
            <summary>
            Tests whether an expression is a logical conjunction
            </summary>
            <param name="x">The expression to examine</param>
        </member>
        <member name="M:Z0.LinqXQuery.junction``1(``0)">
            <summary>
            Deterines whether the test expression is either a logical conjunction or disjunction
            </summary>
            <param name="X">The expression to examine</param>
        </member>
        <member name="M:Z0.LinqXQuery.member``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Extracts the member info for the member referenced by an expression delegate
            </summary>
            <typeparam name="T">The first selector parameter</typeparam>
            <typeparam name="M">The member type</typeparam>
            <param name="selector">The selecting expression that identifies the desired member</param>
        </member>
        <member name="M:Z0.LinqXQuery.method``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Extracts the method info for the function referenced by an expression delegate
            </summary>
            <typeparam name="T">The function return type</typeparam>
            <param name="selector">The call expression</param>
        </member>
        <member name="M:Z0.LinqXQuery.method``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Extracts the method info for the function referenced by an expression delegate
            </summary>
            <typeparam name="T1">The first function argument</typeparam>
            <typeparam name="T2">The function return type</typeparam>
            <param name="selector">The call expression</param>
        </member>
        <member name="M:Z0.LinqXQuery.method``3(System.Linq.Expressions.Expression{System.Func{``0,``1,``2}})">
            <summary>
            Extracts the method info for the function referenced by an expression delegate
            </summary>
            <typeparam name="T1">The first function argument</typeparam>
            <typeparam name="T2">The second function argument</typeparam>
            <typeparam name="R">The function return type</typeparam>
            <param name="selector">The call expression</param>
        </member>
        <member name="M:Z0.LinqXQuery.method``4(System.Linq.Expressions.Expression{System.Func{``0,``1,``2,``3}})">
            <summary>
            Extracts the method info for the function referenced by an expression delegate
            </summary>
            <typeparam name="T1">The first function argument</typeparam>
            <typeparam name="T2">The second function argument</typeparam>
            <typeparam name="T3">The third function argument</typeparam>
            <typeparam name="R">The function return type</typeparam>
            <param name="selector">Specifies the call expression</param>
        </member>
        <member name="M:Z0.LinqXQuery.method``1(System.Linq.Expressions.Expression{System.Action{``0}})">
            <summary>
            Extracts the method for the action referenced by an an expression delegate
            </summary>
            <typeparam name="T">The action argument</typeparam>
            <param name="selector">Specifies the call expression</param>
        </member>
        <member name="M:Z0.LinqXQuery.method``2(System.Linq.Expressions.Expression{System.Action{``0,``1}})">
            <summary>
            Extracts the method info for the action referenced by an expression delegate
            </summary>
            <typeparam name="T1">The first action argument</typeparam>
            <typeparam name="T2">The second action argument</typeparam>
            <param name="selector">Specifies the call expression</param>
        </member>
        <member name="M:Z0.LinqXQuery.method``3(System.Linq.Expressions.Expression{System.Action{``0,``1,``2}})">
            <summary>
            Extracts the method info for the action referenced by an expression delegate
            </summary>
            <typeparam name="T1">The first action argument</typeparam>
            <typeparam name="T2">The second action argument</typeparam>
            <typeparam name="T3">The third action argument</typeparam>
            <param name="selector">Specifies the call expression</param>
        </member>
        <member name="M:Z0.LinqXQuery.method``4(System.Linq.Expressions.Expression{System.Action{``0,``1,``2,``3}})">
            <summary>
            Extracts the method info for the action referenced by an expression delegate
            </summary>
            <typeparam name="T1">The first action argument</typeparam>
            <typeparam name="T2">The second action argument</typeparam>
            <typeparam name="T3">The third action argument</typeparam>
            <typeparam name="T4">The fourth action argument</typeparam>
            <param name="selector">The call expression</param>
        </member>
        <member name="M:Z0.LinqXQuery.property``1(System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Extracts the property info for the property referenced by an expression delegate
            </summary>
            <typeparam name="P">The property type</typeparam>
            <param name="selector">The selecting expression that identifies the desired member</param>
        </member>
        <member name="M:Z0.LinqXQuery.property``2(System.Linq.Expressions.Expression{System.Func{``0,``1}})">
            <summary>
            Extracts the property info for the property referenced by an expression delegate
            </summary>
            <typeparam name="T">The declaring type</typeparam>
            <typeparam name="P">The property type</typeparam>
            <param name="selector">The selecting expression that identifies the desired member</param>
        </member>
        <member name="M:Z0.LinqXQuery.test``2(System.Linq.Expressions.Expression)">
            <summary>
            Performs a type-test on an expression
            </summary>
            <typeparam name="X1">The first candidate type</typeparam>
            <typeparam name="X2">The second candidate type</typeparam>
            <param name="x">The expression to test</param>
        </member>
        <member name="M:Z0.LinqXQuery.test``3(System.Linq.Expressions.Expression)">
            <summary>
            Performs a type-test on an expression
            </summary>
            <typeparam name="X1">The first candidate type</typeparam>
            <typeparam name="X2">The second candidate type</typeparam>
            <typeparam name="X3">The third candidate type</typeparam>
            <param name="x">The expression to test</param>
        </member>
        <member name="M:Z0.LinqXQuery.test``4(System.Linq.Expressions.Expression)">
            <summary>
            Performs a type-test on an expression
            </summary>
            <typeparam name="X1">The first candidate type</typeparam>
            <typeparam name="X2">The second candidate type</typeparam>
            <typeparam name="X3">The third candidate type</typeparam>
            <typeparam name="X4">The fourth candidate type</typeparam>
            <param name="x">The expression to test</param>
        </member>
        <member name="T:Z0.XFunc`1">
            <summary>
            Wraps a delegate that implicitly converts into a LINQ expression
            </summary>
            <typeparam name="X">The function return type</typeparam>
        </member>
        <member name="P:Z0.XFunc`1.Fx">
            <summary>
            The expression derived from the source function
            </summary>
        </member>
        <member name="M:Z0.XFunc`1.op_Implicit(Z0.XFunc{`0})~System.Linq.Expressions.Expression{System.Func{`0}}">
            <summary>
            Implicitly converts a func expression to linq expression
            </summary>
            <param name="fx">The source func expression</param>
        </member>
        <member name="M:Z0.XFunc`1.op_Implicit(System.Func{`0})~Z0.XFunc{`0}">
            <summary>
            Implicitly constructs a func expression from a func
            </summary>
            <param name="f">The source function</param>
        </member>
        <member name="T:Z0.XFunc`2">
            <summary>
            Wraps a delegate that implicitly converts into a LINQ expression
            </summary>
            <typeparam name="X">The function argument type</typeparam>
            <typeparam name="Y">The function return type</typeparam>
        </member>
        <member name="P:Z0.XFunc`2.Fx">
            <summary>
            The expression derived from the source function
            </summary>
        </member>
        <member name="M:Z0.XFunc`2.op_Implicit(Z0.XFunc{`0,`1})~System.Linq.Expressions.Expression{System.Func{`0,`1}}">
            <summary>
            Implicitly converts a func expression to linq expression
            </summary>
            <param name="fx">The source func expression</param>
        </member>
        <member name="M:Z0.XFunc`2.op_Implicit(System.Func{`0,`1})~Z0.XFunc{`0,`1}">
            <summary>
            Implicitly constructs a func expression from a func
            </summary>
            <param name="f">The source function</param>
        </member>
        <member name="T:Z0.XFunc`3">
            <summary>
            Wraps a delegate that implicitly converts into a LINQ expression
            </summary>
            <typeparam name="X1">The type of the first argument</typeparam>
            <typeparam name="X2">The type of the second argument</typeparam>
            <typeparam name="Y">The function return type</typeparam>
        </member>
        <member name="P:Z0.XFunc`3.Fx">
            <summary>
            The expression derived from the source function
            </summary>
        </member>
        <member name="M:Z0.XFunc`3.op_Implicit(Z0.XFunc{`0,`1,`2})~System.Linq.Expressions.Expression{System.Func{`0,`1,`2}}">
            <summary>
            Implicitly converts a func expression to linq expression
            </summary>
            <param name="fx">The source func expression</param>
        </member>
        <member name="M:Z0.XFunc`3.op_Implicit(System.Func{`0,`1,`2})~Z0.XFunc{`0,`1,`2}">
            <summary>
            Implicitly constructs a func expression from a func
            </summary>
            <param name="f">The source function</param>
        </member>
        <member name="T:Z0.XFunc`4">
            <summary>
            Wraps a delegate that implicitly converts into a LINQ expression
            </summary>
            <typeparam name="X1">The type of the first argument</typeparam>
            <typeparam name="X2">The type of the second argument</typeparam>
            <typeparam name="X3">The type of the third argument</typeparam>
            <typeparam name="Y">The function return type</typeparam>
        </member>
        <member name="P:Z0.XFunc`4.Fx">
            <summary>
            The expression derived from the source function
            </summary>
        </member>
        <member name="M:Z0.XFunc`4.op_Implicit(Z0.XFunc{`0,`1,`2,`3})~System.Linq.Expressions.Expression{System.Func{`0,`1,`2,`3}}">
            <summary>
            Implicitly converts a func expression to linq expression
            </summary>
            <param name="fx">The source func expression</param>
        </member>
        <member name="M:Z0.XFunc`4.op_Implicit(System.Func{`0,`1,`2,`3})~Z0.XFunc{`0,`1,`2,`3}">
            <summary>
            Implicitly constructs a func expression from a func
            </summary>
            <param name="f">The source function</param>
        </member>
        <member name="T:Z0.Dynamics.BinaryOperator`1">
            <summary>
            Represents a binary operator
            </summary>
            <typeparam name="F"></typeparam>
        </member>
        <member name="T:Z0.Dynamics.ComparisonOperator`1">
            <summary>
            Represents a comparison operator
            </summary>
            <typeparam name="F"></typeparam>
        </member>
        <member name="T:Z0.Dynamics.Junction">
            <summary>
            Represents a logical connective where each constituent is a member predicate
            </summary>
        </member>
        <member name="T:Z0.Dynamics.Operator`1">
            <summary>
            Represents an operator
            </summary>
            <typeparam name="F">The operator type</typeparam>
        </member>
        <member name="P:Z0.Dynamics.Operator`1.Name">
            <summary>
            The name of the operator
            </summary>
        </member>
        <member name="P:Z0.Dynamics.Operator`1.Symbol">
            <summary>
            The symbol used to denote the opeator
            </summary>
        </member>
        <member name="T:Z0.Dynamics.OperatorApplication`1">
            <summary>
            Represents the application of an operator to a set of operands
            </summary>
            <typeparam name="O"></typeparam>
        </member>
        <member name="P:Z0.Dynamics.OperatorApplication`1.Operator">
            <summary>
            Specifies the operator
            </summary>
        </member>
        <member name="P:Z0.Dynamics.OperatorApplication`1.Operands">
            <summary>
            Specivies the operands
            </summary>
        </member>
        <member name="T:Z0.Dynamics.ConditionalActions">
            <summary>
            Defines helper methods for working with LINQ expressions
            </summary>
        </member>
        <member name="M:Z0.Dynamics.ConditionalActions.IsNullityOperator(System.Linq.Expressions.Expression)">
            <summary>
            Tests whether an expression is a nullity operator
            </summary>
            <param name="x">The expression to examine</param>
        </member>
        <member name="M:Z0.Dynamics.ConditionalActions.TryGetNullityOperator(System.Linq.Expressions.Expression)">
            <summary>
            Extracts a nullity operator if detected
            </summary>
            <param name="x">The source expression</param>
        </member>
        <member name="M:Z0.Dynamics.ConditionalActions.TryGetComparisonOperator(System.Linq.Expressions.Expression)">
            <summary>
            Extracts a comparison operator if detected
            </summary>
            <param name="x">The source expression</param>
        </member>
        <member name="M:Z0.Dynamics.ConditionalActions.OnConjunction``1(``0,System.Action{``0})">
            <summary>
            Invokes the supplied action if the expression is a conjunction and returns true in this case and otherwise false
            </summary>
            <param name="x">The source expression</param>
            <param name="a">The operation to conditionally invoke</param>
        </member>
        <member name="M:Z0.Dynamics.ConditionalActions.OnComparisonOperator(System.Linq.Expressions.Expression,System.Action{Z0.Dynamics.IComparisonOperator})">
            <summary>
            Invokes the supplied action if the expression is a comparision operator
            </summary>
            <param name="x">The source expression</param>
            <param name="a">The operation to conditionally invoke</param>
        </member>
        <member name="M:Z0.Dynamics.ConditionalActions.OnNullityOperator(System.Linq.Expressions.Expression,System.Action{Z0.Dynamics.INullityOperator})">
            <summary>
            Invokes the supplied action if the expression is a nullity operator and returns true in this case and otherwise false
            </summary>
            <param name="x">The source expression</param>
            <param name="a">The operation to conditionally invoke</param>
        </member>
        <member name="M:Z0.Dynamics.ConditionalActions.OnDisjunction``1(``0,System.Action{``0})">
            <summary>
            Invokes the supplied action if the expression is a disjunction and returns true in this case and otherwise false
            </summary>
            <param name="x">The source expression</param>
            <param name="a">The operation to conditionally invoke</param>
        </member>
        <member name="T:Z0.Dynamics.DataMemberArrow">
            <summary>
            Defines a directed association between two data members
            </summary>
        </member>
        <member name="F:Z0.Dynamics.DataMemberArrow.Source">
            <summary>
            The supplier member
            </summary>
        </member>
        <member name="F:Z0.Dynamics.DataMemberArrow.Target">
            <summary>
            The client member
            </summary>
        </member>
        <member name="T:Z0.Dynamics.DataMemberArrow`2">
            <summary>
            Defines a directed association between two value members defined by two respective types
            </summary>
            <typeparam name="X">The source type</typeparam>
            <typeparam name="Y">The target type</typeparam>
        </member>
        <member name="P:Z0.Dynamics.DataMemberArrow`2.Source">
            <summary>
            The supplier member
            </summary>
        </member>
        <member name="P:Z0.Dynamics.DataMemberArrow`2.Target">
            <summary>
            The client member
            </summary>
        </member>
        <member name="T:Z0.Dynamics.DataMemberArrows`2">
            <summary>
            Defines a collection of directed member associations
            </summary>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.Dynamics.ExpressionFactories.True``1">
            <summary>
            Creates an expression that defines a function that returns true
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Z0.Dynamics.ExpressionFactories.False``1">
            <summary>
            Creates an expression that defines a function that returns false
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Z0.Dynamics.ExpressionFactories.Or``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Creates an expression that defines a logical OR function
            </summary>
            <param name="left"></param>
            <param name="right"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Z0.Dynamics.ExpressionFactories.And``1(System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}},System.Linq.Expressions.Expression{System.Func{``0,System.Boolean}})">
            <summary>
            Creates an expression that defines a logical AND function
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Z0.Dynamics.ExpressionFactories.Equal``1(System.Linq.Expressions.Expression{System.Func{``0}},System.Linq.Expressions.Expression{System.Func{``0}})">
            <summary>
            Creates an expression tha defines an equality comparison
            </summary>
            <param name="lhs"></param>
            <param name="rhs"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="T:Z0.Dynamics.ExpressionModelFactory`1">
            <summary>
            Defines contract for functions that create models from LINQ expression trees
            </summary>
            <typeparam name="M">The type of model the function will produce</typeparam>
            <param name="X">The expression from which the model's structure will be derived</param>
        </member>
        <member name="T:Z0.Dynamics.IOperatorApplication">
            <summary>
            Specifies the application of an n-ary operator to n operands
            </summary>
        </member>
        <member name="P:Z0.Dynamics.IOperatorApplication.Operator">
            <summary>
            The opererator to apply
            </summary>
        </member>
        <member name="P:Z0.Dynamics.IOperatorApplication.Operands">
            <summary>
            The operands
            </summary>
        </member>
        <member name="T:Z0.Dynamics.Conjunction">
            <summary>
            Represents a logical conjunction; i.e., the and conective that evaluates to true if and only if all of its operands are true
            </summary>
        </member>
        <member name="T:Z0.Dynamics.Disjunction">
            <summary>
            Represents a logical disjunction; i.e., the or connective that evaluates to true if and only if one or more of it's operands are true
            </summary>
        </member>
        <member name="T:Z0.Dynamics.MemberPredicate`1">
            <summary>
            Represents an operation that evaluates a member aspect and returns a boolean result
            </summary>
            <typeparam name="OP">The type of operator that when applied carries out the evaluation represented by the predicate</typeparam>
        </member>
        <member name="T:Z0.Dynamics.MemberValuePredicate`1">
            <summary>
            Represents an operation that evaluates the value of a member and returns a boolean result
            </summary>
            <typeparam name="OP">The type of operator that when applied carries out the evaluation represented by the predicate</typeparam>
        </member>
        <member name="T:Z0.Dynamics.SelectedMember">
            <summary>
            Represents a member selection
            </summary>
        </member>
        <member name="T:Z0.Dynamics.SelectionModel">
            <summary>
            Defines a set of members together with the criteria used to determine a selected collection
            </summary>
        </member>
        <member name="P:Z0.Dynamics.SelectionModel.SelectedMembers">
            <summary>
            The members that represent the columns to be selected
            </summary>
        </member>
        <member name="P:Z0.Dynamics.SelectionModel.MemberOrder">
            <summary>
            Optional order-by specification
            </summary>
        </member>
        <member name="P:Z0.Dynamics.SelectionModel.Junctions">
            <summary>
            A sequence of con/dis-junctions that will fitler the results set
            and effectively represents a WHERE clausee
            </summary>
        </member>
        <member name="P:Z0.Dynamics.SelectionModel.Facets">
            <summary>
            Facets such as TOP and DISTINCT
            </summary>
        </member>
        <member name="T:Z0.Dynamics.SelectMethod">
            <summary>
            Identifies a select method
            </summary>
        </member>
        <member name="T:Z0.Dynamics.StandardMethods">
            <summary>
            Collects standard method classifications
            </summary>
        </member>
        <member name="T:Z0.Dynamics.WhereMethod">
            <summary>
            Identifies a where method
            </summary>
        </member>
        <member name="T:Z0.Dynamics.AndOperator">
            <summary>
            Represents the logical and operator
            </summary>
        </member>
        <member name="T:Z0.Dynamics.EqualOperator">
            <summary>
            Represents the equal operator
            </summary>
        </member>
        <member name="P:Z0.Dynamics.Operators.Gt`1.Exists">
            <summary>
            Specifies whether the operator exists for <typeparamref name="T"/>
            </summary>
        </member>
        <member name="P:Z0.Dynamics.Operators.Inc`1.Exists">
            <summary>
            Specifies whether the operator exists for <typeparamref name="T"/>
            </summary>
        </member>
        <member name="P:Z0.Dynamics.Operators.Lt`1.Exists">
            <summary>
            Specifies whether the operator exists for <typeparamref name="T"/>
            </summary>
        </member>
        <member name="P:Z0.Dynamics.Operators.LtEq`1.Exists">
            <summary>
            Specifies whether the operator exists for <typeparamref name="T"/>
            </summary>
        </member>
        <member name="T:Z0.DelegatedContract">
            <summary>
            A primary implementation of the <see cref="T:Z0.IDynamicContractMessenger"/> contract
            that delgates contract implementation through a supplied <see cref="T:Z0.DelegateIndex"/>
            </summary>
        </member>
        <member name="M:Z0.DelegatedContract.Realize``1(System.String,Z0.DelegateIndex)">
            <summary>
            Realizes implementation of a contract by mediating access to a <see cref="T:Z0.DelegateIndex"/>
            </summary>
            <typeparam name="TContract">The type of realized contract</typeparam>
            <returns></returns>
        </member>
        <member name="T:Z0.DelegateIndex">
            <summary>
            Indexes a collection of delegates that (potentially) specify a <see cref="T:Z0.IDynamicContractMessenger"/> realization
            </summary>
        </member>
        <member name="M:Z0.DelegateIndex.Getter``1(System.String,System.Func{``0})">
            <summary>
            Indexes a property get method
            </summary>
            <typeparam name="T">The property type</typeparam>
            <param name="name">The name of the property get method</param>
            <param name="f">The get delegate</param>
        </member>
        <member name="M:Z0.DelegateIndex.Getter(System.String)">
            <summary>
            Retrieves a property get method
            </summary>
            <param name="name">The name of the get method</param>
            <returns></returns>
        </member>
        <member name="M:Z0.DelegateIndex.Setter``1(System.String,System.Action{``0})">
            <summary>
            Specifies a property setter
            </summary>
            <typeparam name="T">The property type</typeparam>
            <param name="name">The name of the property set method</param>
            <param name="a">The set action</param>
        </member>
        <member name="M:Z0.DelegateIndex.Setter(System.String)">
            <summary>
            Retrieves named property set method
            </summary>
            <param name="name">The name of the get method</param>
            <returns></returns>
        </member>
        <member name="M:Z0.DelegateIndex.Function(System.String,System.Delegate)">
            <summary>
            Specifies a function delegate
            </summary>
            <param name="name">The method</param>
            <param name="f">The delegate</param>
        </member>
        <member name="M:Z0.DelegateIndex.Action(System.String,System.Delegate)">
            <summary>
            Specifies an action delegate
            </summary>
            <param name="name">The name of the action</param>
            <param name="a">The action</param>
        </member>
        <member name="M:Z0.DelegateIndex.Action(System.String)">
            <summary>
            Retrieves an action delegate
            </summary>
            <param name="name">The name of the action</param>
            <returns></returns>
        </member>
        <member name="M:Z0.DelegateIndex.Function(System.String)">
            <summary>
            Retrieves a function delegate
            </summary>
            <param name="name">The name of the function</param>
        </member>
        <member name="T:Z0.DelegateIndexBuilder`1">
            <summary>
            Implementation of a builder pattern that constructs <see cref="T:Z0.DelegateIndex"/> instances
            based on supplied expressions and upon completion emits an implementation of the specified 
            contract type, returning an instance to this implementation to the caller
            </summary>
            <typeparam name="TContract">The contract type</typeparam>
        </member>
        <member name="M:Z0.DelegateIndexBuilder`1.type_array``1">
            <summary>
            Creates an array of <see cref="T:System.Type"/> references from the supplied type parameters
            </summary>
            <typeparam name="T1">The first type parameter</typeparam>
            <returns></returns>
        </member>
        <member name="M:Z0.DelegateIndexBuilder`1.type_array``2">
            <summary>
            Creates an array of <see cref="T:System.Type"/> references from the supplied type parameters
            </summary>
            <typeparam name="T1">The first type parameter</typeparam>
            <typeparam name="T2">The second type parameter</typeparam>
            <returns></returns>
        </member>
        <member name="M:Z0.DelegateIndexBuilder`1.type_array``3">
            <summary>
            Creates an array of <see cref="T:System.Type"/> references from the supplied type parameters
            </summary>
            <typeparam name="T1">The first type parameter</typeparam>
            <typeparam name="T2">The second type parameter</typeparam>
            <typeparam name="T3">The third type parameter</typeparam>
            <returns></returns>
        </member>
        <member name="M:Z0.DelegateIndexBuilder`1.type_array``4">
            <summary>
            Creates an array of <see cref="T:System.Type"/> references from the supplied type parameters
            </summary>
            <typeparam name="T1">The first type parameter</typeparam>
            <typeparam name="T2">The second type parameter</typeparam>
            <typeparam name="T3">The third type parameter</typeparam>
            <typeparam name="T4">The fourth type parameter</typeparam>
            <returns></returns>
        </member>
        <member name="M:Z0.DelegateIndexBuilder`1.Realize">
            <summary>
            Emits the implementation defined by the builder and returns an intance of this implementation
            to the caller
            </summary>
            <returns></returns>
        </member>
        <member name="T:Z0.DynamicContract">
            <summary>
            Provides access to high-level dynamic contract capabilities
            </summary>
        </member>
        <member name="M:Z0.DynamicContract.Realize``1(Z0.IDynamicContractMessenger)">
            <summary>
            Realizes implementation of a user-defined contract by delegating through a <see cref="T:Z0.IDynamicContractMessenger"/> implementation
            </summary>
            <typeparam name="TContract">The type of realized contract</typeparam>
            <param name="messenger">The dynamic contract</param>
            <returns></returns>
        </member>
        <member name="M:Z0.DynamicContract.Realize``1(Z0.IDynamicContract)">
            <summary>
            Realizes implementation of an interface contract via an instance of the <see cref="T:Z0.DynamicContractHost`1"/> type
            </summary>
            <typeparam name="TContract"></typeparam>
            <param name="contract"></param>
            <returns></returns>
        </member>
        <member name="T:Z0.DynamicContractImplementor">
            <summary>
            Generates an implementation of a specified interface type that delegates to an implementation
            of <see cref="T:Z0.IDynamicContractMessenger"/>
            </summary>
        </member>
        <member name="M:Z0.DynamicContractImplementor.ImplementContract``1(System.String)">
            <summary>
            Generates implementation of an interface contract that delegates to <see cref="T:Z0.IDynamicContractMessenger"/>
            </summary>
            <typeparam name="T">The type of contract for which an implementation will be generated</typeparam>
            <param name="ImplementationName">The name of the implemented type</param>
            <returns></returns>
        </member>
        <member name="T:Z0.IDynamicContract">
            <summary>
            Defines contract for dynamic operation invocation
            </summary>
        </member>
        <member name="M:Z0.IDynamicContract.InvokeFunction(System.Reflection.MethodInfo,System.Object[])">
            <summary>
            Invokes a function that is identified by and accessed via a <see cref="T:System.Reflection.MethodInfo"/>
            </summary>
            <param name="method">The contracting method</param>
            <param name="parameters">The method parameters</param>
            <returns></returns>
        </member>
        <member name="M:Z0.IDynamicContract.InvokeAction(System.Reflection.MethodInfo,System.Object[])">
            <summary>
            Invokes an action that is identified by and accessed via a <see cref="T:System.Reflection.MethodInfo"/>
            </summary>
            <param name="method">The contracting method</param>
            <param name="parameters">The method parameters</param>
            <returns></returns>
        </member>
        <member name="M:Z0.IDynamicContract.GetPropertyValue(System.Reflection.PropertyInfo)">
            <summary>
            Retrieves the value of a property that is indentified by and accessed via a <see cref="T:System.Reflection.PropertyInfo"/>
            </summary>
            <param name="property"></param>
            <returns></returns>
        </member>
        <member name="M:Z0.IDynamicContract.SetPropertyValue(System.Reflection.PropertyInfo,System.Object)">
            <summary>
            Sets the value of a property that is indentified by and accessed via a <see cref="T:System.Reflection.PropertyInfo"/>
            </summary>
            <param name="property"></param>
            <param name="value"></param>
        </member>
        <member name="P:Z0.IDynamicContract.ImplementationName">
            <summary>
            The name given to identify a particular implementation
            </summary>
        </member>
        <member name="T:Z0.IDynamicContractMessenger">
            <summary>
            Defines communication channel between application code and dynamically generated IL
            </summary>
            <remarks>
            This interface is defined without overloaded methods or other aspects that would
            make IL interop more troublesome
            </remarks>
        </member>
        <member name="M:Z0.IDynamicContractMessenger.InvokeFunction(System.Reflection.MethodBase)">
            <summary>
            Sends a 0-argument function invocation through the channel
            </summary>
            <param name="method">The method to invoke</param>
            <returns></returns>
        </member>
        <member name="M:Z0.IDynamicContractMessenger.InvokeFunctionWithParameters(System.Reflection.MethodBase,System.Object[])">
            <summary>
            Sends an n-argument function invocation through the channel and returns the result
            </summary>
            <param name="method">The method to invoke</param>
            <returns></returns>
        </member>
        <member name="M:Z0.IDynamicContractMessenger.InvokeAction(System.Reflection.MethodBase)">
            <summary>
            Send a 0-argument action invocation through the channel
            </summary>
            <param name="method">The method to invoke</param>
        </member>
        <member name="M:Z0.IDynamicContractMessenger.InvokeActionWithParameters(System.Reflection.MethodBase,System.Object[])">
            <summary>
            Send an n-argument action invocation through the channel
            </summary>
            <param name="method">The method to invoke</param>
        </member>
        <member name="M:Z0.IDynamicContractMessenger.GetPropertyValue(System.Reflection.MethodBase)">
            <summary>
            Retrieves the value of a property through the channel
            </summary>
            <param name="getter">The get accessor</param>
            <returns></returns>
        </member>
        <member name="M:Z0.IDynamicContractMessenger.SetPropertyValue(System.Reflection.MethodBase,System.Object[])">
            <summary>
            Sets the vale of a property through the channel
            </summary>
            <param name="setter">The set accessor</param>
            <param name="value">The value to send</param>
        </member>
        <member name="P:Z0.IDynamicContractMessenger.ImplementationName">
            <summary>
            The name of the contract implementation
            </summary>
        </member>
        <member name="P:Z0.DynamicOps.Add`1.Exists">
            <summary>
            Specifies whether the operator exists for <typeparamref name="T"/>
            </summary>
        </member>
        <member name="P:Z0.DynamicOps.Dec`1.Exists">
            <summary>
            Specifies whether the operator exists for <typeparamref name="T"/>
            </summary>
        </member>
        <member name="M:Z0.CalcManaged.eval(Z0.Kinds.Add,System.Byte,System.Byte)">
            <summary>
            Computes the sum of two unsigned 8-bit integers
            </summary>
            <param name="f">The operation selector</param>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.CalcManaged.eval(Z0.Kinds.Sub,System.Byte,System.Byte)">
            <summary>
            Computes the difference between two unsigned 8-bit integers
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.CalcManaged.eval(Z0.Kinds.Mul,System.Byte,System.Byte)">
            <summary>
            Computes the product of two unsigned 8-bit integers
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.CalcManaged.eval(Z0.Kinds.Div,System.Byte,System.Byte)">
            <summary>
            Computes the quotient between two unsigned 8-bit integers
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.CalcManaged.eval(Z0.BitLogicKinds.And,System.Byte,System.Byte)">
            <summary>
            Computes the bitwise and between two unsigned 8-bit integers
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.CalcNative.eval(Z0.Kinds.Mul,System.Byte,System.Byte)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.CalcNative.eval(Z0.Kinds.Sub,System.Byte,System.Byte)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.CalcNative.eval(Z0.BitLogicKinds.And,System.Byte,System.Byte)" -->
        <member name="P:Z0.CalculatorCode.add_ᐤ8iㆍ8iᐤ">
            <summary>
            X86-executable code obtained by disassembling <see cref="M:Z0.CalcManaged.eval(Z0.Kinds.Add,System.Byte,System.Byte)"/>
            </summary>
        </member>
        <member name="P:Z0.CalculatorCode.sub_ᐤ8uㆍ8uᐤ">
            <summary>
            X86-executable code obtained by disassembling <see cref="M:Z0.CalcManaged.eval(Z0.Kinds.Sub,System.Byte,System.Byte)"/>
            </summary>
        </member>
        <member name="P:Z0.CalculatorCode.mul_ᐤ8uㆍ8uᐤ">
            <summary>
            X86-executable code obtained by disassembling <see cref="M:Z0.CalcManaged.eval(Z0.Kinds.Mul,System.Byte,System.Byte)"/>
            </summary>
        </member>
        <member name="P:Z0.CalculatorCode.div_ᐤ8uㆍ8uᐤ">
            <summary>
            X86-executable code obtained by disassembling <see cref="M:Z0.CalcManaged.eval(Z0.Kinds.Div,System.Byte,System.Byte)"/>
            </summary>
        </member>
        <member name="P:Z0.CalculatorCode.and_ᐤ8uㆍ8uᐤ">
            <summary>
            X86-executable code obtained by disassembling <see cref="M:Z0.CalcManaged.eval(Z0.BitLogicKinds.And,System.Byte,System.Byte)"/>
            </summary>
        </member>
        <member name="M:Z0.Dynexus.UnaryInjector``1(Z0.W128)">
            <summary>
            Creates a 128-bit T-parametric unary immediate injector
            </summary>
            <param name="w">The vector operand width</param>
            <param name="k">The operator kind</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.Dynexus.UnaryInjector``1(Z0.W256)">
            <summary>
            Creates a 256-bit T-parametric unary immediate injector
            </summary>
            <param name="w">The vector operand width</param>
            <param name="k">The operator kind</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.Dynexus.BinaryInjector``1(Z0.W128)">
            <summary>
            Creates a 128-bit T-parametric binary immediate injector
            </summary>
            <param name="w">The vector operand width</param>
            <param name="k">The operator kind</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.Dynexus.BinaryInjector``1(Z0.W256)">
            <summary>
            Creates a 256-bit T-parametric binary immediate injector
            </summary>
            <param name="w">The vector operand width</param>
            <param name="k">The operator kind</param>
            <typeparam name="T">The vector cell type</typeparam>
        </member>
        <member name="M:Z0.Eval.outcome``1(System.Boolean,``0)">
            <summary>
            Defines an outcome spec
            </summary>
            <param name="ok">Specifies whether the operation succeeded</param>
            <param name="data">The operation data</param>
            <typeparam name="T">The operation data type</typeparam>
        </member>
    </members>
</doc>
