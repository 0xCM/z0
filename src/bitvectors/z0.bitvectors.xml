<?xml version="1.0"?>
<doc>
    <assembly>
        <name>z0.bitvectors</name>
    </assembly>
    <members>
        <member name="M:Z0.BitVector.alt``1(Z0.bit)">
            <summary>
            Creates a bitvector with uniformly alternating states where the state of
            the first bit is determine by a parity bit
            </summary>
            <param name="parity">The state of the first bit</param>
        </member>
        <member name="M:Z0.BitVector.alt``2(Z0.bit,``0)">
            <summary>
            Creates a bitvector with uniformly alternating states where the state of
            the first bit is determined by a parity bit
            </summary>
            <param name="parity">The state of the first bit</param>
            <param name="n">The width selector</param>
        </member>
        <member name="M:Z0.BitVector.alt(Z0.N8,Z0.bit)">
            <summary>
            Creates a bitvector with uniformly alternating states where the state of the
            first bit is determine by a specified parity bit
            </summary>
            <param name="n">The width selector</param>
            <param name="parity">The state of the first bit</param>
        </member>
        <member name="M:Z0.BitVector.alt(Z0.N16,Z0.bit)">
            <summary>
            Creates a bitvector with uniformly alternating states where the state of the
            first bit is determine by a specified parity bit
            </summary>
            <param name="n">The width selector</param>
            <param name="parity">The state of the first bit</param>
        </member>
        <member name="M:Z0.BitVector.alt(Z0.N32,Z0.bit)">
            <summary>
            Creates a bitvector with uniformly alternating states where the state of the
            first bit is determine by a specified parity bit
            </summary>
            <param name="n">The width selector</param>
            <param name="parity">The state of the first bit</param>
        </member>
        <member name="M:Z0.BitVector.alt(Z0.N64,Z0.bit)">
            <summary>
            Creates a bitvector with uniformly alternating states where the state of the
            first bit is determine by a specified parity bit
            </summary>
            <param name="n">The width selector</param>
            <param name="parity">The state of the first bit</param>
        </member>
        <member name="M:Z0.BitVector.bitseg``1(Z0.BitVector{``0},System.Byte,System.Byte)">
            <summary>
            Extracts a contiguous sequence of bits defined by an inclusive range
            </summary>
            <param name="first">The first bit position</param>
            <param name="last">The last bit position</param>
        </member>
        <member name="M:Z0.BitVector.bitseg``2(Z0.BitVector{``0,``1},System.Byte,System.Byte)">
            <summary>
            Extracts a contiguous sequence of bits defined by an inclusive range
            </summary>
            <param name="first">The first bit position</param>
            <param name="last">The last bit position</param>
        </member>
        <member name="M:Z0.BitVector.bitseg(Z0.BitVector4,System.Byte,System.Byte)">
            <summary>
            Extracts a contiguous sequence of bits defined by an inclusive range
            </summary>
            <param name="first">The first bit position</param>
            <param name="last">The last bit position</param>
        </member>
        <member name="M:Z0.BitVector.bitseg(Z0.BitVector8,System.Byte,System.Byte)">
            <summary>
            Extracts a contiguous sequence of bits defined by an inclusive range
            </summary>
            <param name="first">The first bit position</param>
            <param name="last">The last bit position</param>
        </member>
        <member name="M:Z0.BitVector.bitseg(Z0.BitVector16,System.Byte,System.Byte)">
            <summary>
            Extracts a contiguous sequence of bits defined by an inclusive range
            </summary>
            <param name="first">The first bit position</param>
            <param name="last">The last bit position</param>
        </member>
        <member name="M:Z0.BitVector.bitseg(Z0.BitVector32,System.Byte,System.Byte)">
            <summary>
            Extracts a contiguous sequence of bits defined by an inclusive range
            </summary>
            <param name="first">The first bit position</param>
            <param name="last">The last bit position</param>
        </member>
        <member name="M:Z0.BitVector.bitseg(Z0.BitVector64,System.Byte,System.Byte)">
            <summary>
            Extracts a contiguous sequence of bits defined by an inclusive range
            </summary>
            <param name="first">The first bit position</param>
            <param name="last">The last bit position</param>
        </member>
        <member name="M:Z0.BitVector.bitspan(Z0.BitVector4,System.Nullable{System.Int32})">
            <summary>
            Converts the vector to a bitspan representation
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.bitspan(Z0.BitVector8,System.Nullable{System.Int32})">
            <summary>
            Converts the vector to a bitspan representation
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.bitspan(Z0.BitVector16,System.Nullable{System.Int32})">
            <summary>
            Converts the vector to a bitspan representation
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.bitspan(Z0.BitVector24,System.Nullable{System.Int32})">
            <summary>
            Converts the vector to a bitspan representation
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.bitspan(Z0.BitVector32,System.Nullable{System.Int32})">
            <summary>
            Converts the vector to a bitspan representation
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.bitspan(Z0.BitVector64,System.Nullable{System.Int32})">
            <summary>
            Converts the vector to a bitspan representation
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.bitspan``1(Z0.BitVector{``0},System.Nullable{System.Int32})">
            <summary>
            Converts the vector to a bitspan representation
            </summary>
        </member>
        <member name="M:Z0.BitVector.bitspan``2(Z0.BitVector{``0,``1})">
            <summary>
            Converts the vector to a bitspan representation
            </summary>
        </member>
        <member name="M:Z0.BitVector.bitstring``2(Z0.BitVector{``0,``1})">
            <summary>
            Converts the vector content to a bitring representation
            </summary>
        </member>
        <member name="M:Z0.BitVector.bitstring``2(Z0.BitVector{``0,``1},System.Byte[])">
            <summary>
            Converts the vector content to a bitring representation
            </summary>
        </member>
        <member name="M:Z0.BitVector.bitstring``2(Z0.BitVector128{``0,``1}@)">
            <summary>
            Converts the vector to a bitstring representation
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="N">The bitvector width</typeparam>
            <typeparam name="T">The storage cell type</typeparam>
        </member>
        <member name="M:Z0.BitVector.bitstring(Z0.BitVector4)">
            <summary>
            Converts the vector to a bitstring representation
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.bitstring(Z0.BitVector8)">
            <summary>
            Converts the vector to a bitstring representation
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.bitstring(Z0.BitVector16)">
            <summary>
            Converts the vector to a bitstring representation
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.bitstring(Z0.BitVector24)">
            <summary>
            Converts the vector to a bitstring representation
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.bitstring(Z0.BitVector32)">
            <summary>
            Converts the vector to a bitstring representation
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.bitstring(Z0.BitVector64)">
            <summary>
            Converts the vector to a bitstring representation
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.bitstring``1(Z0.BitVector{``0})">
            <summary>
            Extracts the represented data as a bitstring
            </summary>
        </member>
        <member name="M:Z0.BitVector.bitstring``1(Z0.BitVector{``0},System.Int32)">
            <summary>
            Extracts the represented data as a bitstring truncated to a specified width
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.BitVector.cnonimpl``1(Z0.BitVector{``0},Z0.BitVector{``0})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitVector.cnonimpl``2(Z0.BitVector{``0,``1},Z0.BitVector{``0,``1})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitVector.cnonimpl``2(Z0.BitVector128{``0,``1},Z0.BitVector128{``0,``1})" -->
        <member name="M:Z0.BitVector.concat(Z0.BitVector4,Z0.BitVector4)">
            <summary>
            Creates an 8-bit vector by concatenating a pair of 4-bit vectors
            </summary>
            <param name="lo">The lower bits of the new vector</param>
            <param name="hi">The upper bits of the new vector</param>
        </member>
        <member name="M:Z0.BitVector.concat(Z0.BitVector4,Z0.BitVector4,Z0.BitVector4,Z0.BitVector4)">
            <summary>
            Creates a 16-bit vector by concatenating 4 4-bit vectors
            </summary>
            <param name="x0">The first segment that from the least significant bits of the new vector</param>
            <param name="x1">The second segment</param>
            <param name="x2">The third segment</param>
            <param name="x3">The last segment that forms the most significant bits of the new vector</param>
        </member>
        <member name="M:Z0.BitVector.concat(Z0.BitVector8,Z0.BitVector8)">
            <summary>
            Creates an 16-bit vector by concatenating a pair of 8-bit vectors
            </summary>
            <param name="lo">The lower bits of the new vector</param>
            <param name="hi">The upper bits of the new vector</param>
        </member>
        <member name="M:Z0.BitVector.concat(Z0.BitVector16,Z0.BitVector16)">
            <summary>
            Creates a 32-bit vector by concatenating a pair of 16-bit vectors
            </summary>
            <param name="lo">The lower bits of the new vector</param>
            <param name="hi">The upper bits of the new vector</param>
        </member>
        <member name="M:Z0.BitVector.concat(Z0.BitVector8,Z0.BitVector8,Z0.BitVector8,Z0.BitVector8)">
            <summary>
            Creates a 32-bit vector by concatenating 4 8-bit vectors
            </summary>
            <param name="x0">The first segment that forms the least significant bits of the new vector</param>
            <param name="x1">The second segment</param>
            <param name="x2">The third segment</param>
            <param name="x3">The last segment that forms the most significant bits of the new vector</param>
        </member>
        <member name="M:Z0.BitVector.concat(Z0.BitVector8,Z0.BitVector8,Z0.BitVector8,Z0.BitVector8,Z0.BitVector8,Z0.BitVector8,Z0.BitVector8,Z0.BitVector8)">
            <summary>
            Creates a 64-bit vector by concatenating 8 8-bit vectors
            </summary>
            <param name="x0">The first segment that forms the least significant bits of the new vector</param>
            <param name="x1">The second segment</param>
            <param name="x2">The third segment</param>
            <param name="x3">The fourth segment</param>
            <param name="x4">The fifth segment</param>
            <param name="x5">The sixth segment</param>
            <param name="x6">The pentultimate segment</param>
            <param name="x3">The last segment that forms the most significant bits of the new vector</param>
        </member>
        <member name="M:Z0.BitVector.concat(Z0.BitVector16,Z0.BitVector16,Z0.BitVector16,Z0.BitVector16)">
            <summary>
            Creates a 64-bit vector by concatenating 4 16-bit vectors
            </summary>
            <param name="x0">The first segment that forms the least significant bits of the new vector</param>
            <param name="x1">The second segment</param>
            <param name="x2">The third segment</param>
            <param name="x3">The last segment that forms the most significant bits of the new vector</param>
        </member>
        <member name="M:Z0.BitVector.concat(Z0.BitVector32,Z0.BitVector32)">
            <summary>
            Creates a 64-bit vector by concatenating a pair of 32-bit vectors
            </summary>
            <param name="lo">The lower bits of the new vector</param>
            <param name="hi">The upper bits of the new vector</param>
        </member>
        <member name="M:Z0.BitVector.true``1(Z0.BitVector{``0},Z0.BitVector{``0})">
            <summary>
            Computes the bitwise TRUE operator
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <typeparam name="T">The primal scalar upon which the bitvector is predicated</typeparam>
        </member>
        <member name="M:Z0.BitVector.false``1(Z0.BitVector{``0},Z0.BitVector{``0})">
            <summary>
            Computes the bitwise FALSE operator
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <typeparam name="T">The primal scalar upon which the bitvector is predicated</typeparam>
        </member>
        <member name="M:Z0.BitVector.create(Z0.N4,System.Byte)">
            <summary>
            Creates a 4-bit bitvector from the least 4 source bits
            </summary>
            <param name="n">The target width selector</param>
            <param name="src">The bit source</param>
        </member>
        <member name="M:Z0.BitVector.create(Z0.N4,System.UInt16)">
            <summary>
            Creates a 4-bit bitvector from the least 4 source bits
            </summary>
            <param name="n">The target width selector</param>
            <param name="src">The bit source</param>
        </member>
        <member name="M:Z0.BitVector.create(Z0.N4,System.UInt32)">
            <summary>
            Creates a 4-bit bitvector from the least 4 source bits
            </summary>
            <param name="n">The target width selector</param>
            <param name="src">The bit source</param>
        </member>
        <member name="M:Z0.BitVector.create(Z0.N4,System.UInt64)">
            <summary>
            Creates a 4-bit bitvector from the least 4 source bits
            </summary>
            <param name="n">The target width selector</param>
            <param name="src">The bit source</param>
        </member>
        <member name="M:Z0.BitVector.create(Z0.N4,Z0.Bit32,Z0.Bit32)">
            <summary>
            Creates a 4-bit bitvector from 2 explicit bits
            </summary>
            <param name="n">The target width selector</param>
        </member>
        <member name="M:Z0.BitVector.create(Z0.N4,Z0.Bit32,Z0.Bit32,Z0.Bit32)">
            <summary>
            Creates a 4-bit bitvector from 3 explicit bitss
            </summary>
            <param name="n">The target width selector</param>
        </member>
        <member name="M:Z0.BitVector.create(Z0.N4,Z0.Bit32,Z0.Bit32,Z0.Bit32,Z0.Bit32)">
            <summary>
            Creates a 4-bit bitvector from 4 explicit bits
            </summary>
            <param name="n">The target width selector</param>
        </member>
        <member name="M:Z0.BitVector.create(Z0.N4,Z0.BitString)">
            <summary>
            Creates a 4-bit bitvector from a bitstring
            </summary>
            <param name="n">The target width selector</param>
            <param name="src">The bit source</param>
        </member>
        <member name="M:Z0.BitVector.create(Z0.N8,Z0.BitString)">
            <summary>
            Creates a vector from a bitstring
            </summary>
            <param name="n">The target width selector</param>
            <param name="src">The bit source</param>
        </member>
        <member name="M:Z0.BitVector.create(Z0.N8,Z0.Bit32,Z0.Bit32,Z0.Bit32,Z0.Bit32)">
            <summary>
            Creates an 8-bit bitvector from 4 explicit bits
            </summary>
            <param name="n">The target width selector</param>
        </member>
        <member name="M:Z0.BitVector.create(Z0.N8,Z0.bit,Z0.bit,Z0.bit,Z0.bit)">
            <summary>
            Creates an 8-bit bitvector from 4 explicit bits
            </summary>
            <param name="n">The target width selector</param>
        </member>
        <member name="M:Z0.BitVector.create(Z0.N8,Z0.bit,Z0.bit,Z0.bit,Z0.bit,Z0.bit,Z0.bit,Z0.bit,Z0.bit)">
            <summary>
            Creates an 8-bit bitvector from 8 explicit bits
            </summary>
            <param name="n">The target width selector</param>
        </member>
        <member name="M:Z0.BitVector.create(Z0.N8,System.Byte)">
            <summary>
            Creates an 8-bit bitvector from a byte
            </summary>
            <param name="n">The target width selector</param>
            <param name="src">The bit source</param>
        </member>
        <member name="M:Z0.BitVector.create(Z0.N8,System.Int32)">
            <summary>
            Creates an 8-bit bitvector from the least 8 source bits
            </summary>
            <param name="n">The target width selector</param>
            <param name="src">The bit source</param>
        </member>
        <member name="M:Z0.BitVector.create(Z0.N8,System.UInt32)">
            <summary>
            Creates an 8-bit bitvector from the least 8 source bits
            </summary>
            <param name="n">The target width selector</param>
            <param name="src">The bit source</param>
        </member>
        <member name="M:Z0.BitVector.create(Z0.N8,System.UInt64)">
            <summary>
            Creates an 8-bit bitvector from the least 8 source bits
            </summary>
            <param name="n">The target width selector</param>
            <param name="src">The bit source</param>
        </member>
        <member name="M:Z0.BitVector.create(Z0.N16,Z0.BitString)">
            <summary>
            Creates a 16-bit bitvector from a bitstring
            </summary>
            <param name="n">The target width selector</param>
            <param name="src">The bit source</param>
        </member>
        <member name="M:Z0.BitVector.create(Z0.N16,System.Byte,System.Byte)">
            <summary>
            Creates a 16-bit bitvector from hi and lo parts
            </summary>
            <param name="n">The target width selector</param>
            <param name="lo">The lo bits</param>
            <param name="hi">The hi bits</param>
        </member>
        <member name="M:Z0.BitVector.create(Z0.N16,System.UInt64)">
            <summary>
            Creates a 16-bit bitvector from the least 16 source bits
            </summary>
            <param name="n">The target width selector</param>
            <param name="src">The bit source</param>
        </member>
        <member name="M:Z0.BitVector.create(Z0.N32,System.UInt32)">
            <summary>
            Creates a 32-bit bitvector from the totality of the source bits
            </summary>
            <param name="n">The target width selector</param>
            <param name="src">The bit source</param>
        </member>
        <member name="M:Z0.BitVector.create(Z0.N32,System.Int32)">
            <summary>
            Creates a 32-bit bitvector from the totality of the source bits
            </summary>
            <param name="n">The target width selector</param>
            <param name="src">The bit source</param>
        </member>
        <member name="M:Z0.BitVector.create(Z0.N32,System.Int64)">
            <summary>
            Creates a 32-bit bitvector from the least 32 source bits
            </summary>
            <param name="n">The target width selector</param>
            <param name="src">The bit source</param>
        </member>
        <member name="M:Z0.BitVector.create(Z0.N32,System.UInt64)">
            <summary>
            Creates a 32-bit bitvector from the least 32 source bits
            </summary>
            <param name="n">The target width selector</param>
            <param name="src">The bit source</param>
        </member>
        <member name="M:Z0.BitVector.create(Z0.N32,Z0.BitString)">
            <summary>
            Creates a 32-bit bitvector from a bitstring
            </summary>
            <param name="n">The target width selector</param>
            <param name="src">The bit source</param>
        </member>
        <member name="M:Z0.BitVector.create(Z0.N32,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Creates a vector from a bitstring
            </summary>
            <param name="src">The source bitstring</param>
        </member>
        <member name="M:Z0.BitVector.create(Z0.N32,System.UInt16,System.UInt16)">
            <summary>
            Creates a vector from two unsigned 16-bit integers
            </summary>
            <param name="src">The source bitstring</param>
        </member>
        <member name="M:Z0.BitVector.create(Z0.N64,System.UInt16,System.UInt16,System.UInt16,System.UInt16)">
            <summary>
            Creates a generic bitvector from 4 explicit bytes
            </summary>
            <param name="src">The source bitstring</param>
        </member>
        <member name="M:Z0.BitVector.create(Z0.N64,System.Byte)">
            <summary>
            Creates a 64-bit bitvector where the first 8 bits a populated with a specified value and
            all others are zero
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.BitVector.create(Z0.N64,System.UInt16)">
            <summary>
            Creates a vector from a primal source value
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.BitVector.create(Z0.N64,System.UInt32)">
            <summary>
            Creates a vector from a primal source value
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.BitVector.create(Z0.N64,System.UInt64)">
            <summary>
            Creates a vector from a primal source value
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.BitVector.create(Z0.N64,System.UInt32,System.UInt32)">
            <summary>
            Creates a vector from two unsigned 32-bit integers
            </summary>
            <param name="src">The source bitstring</param>
        </member>
        <member name="M:Z0.BitVector.create(Z0.N64,Z0.BitString)">
            <summary>
            Creates a vector from a bitstring
            </summary>
            <param name="src">The source bitstring</param>
        </member>
        <member name="M:Z0.BitVector.dec(Z0.BitVector4)">
            <summary>
            Arithmetically decrements the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.dec(Z0.BitVector8)">
            <summary>
            Arithmetically decrements the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.dec(Z0.BitVector16)">
            <summary>
            Arithmetically decrements the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.dec(Z0.BitVector32)">
            <summary>
            Arithmetically decrements the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.dec(Z0.BitVector64)">
            <summary>
            Arithmetically decrements the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.dec``1(Z0.BitVector{``0})">
            <summary>
            Arithmetically decrements the source vector
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.dec``2(Z0.BitVector{``0,``1})">
            <summary>
            Arithmetically decrements the source vector
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.add(Z0.BitVector4,Z0.BitVector4)">
            <summary>
            Computes the arithmetic sum z := x + y for bitvectors x and y
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.add(Z0.BitVector8,Z0.BitVector8)">
            <summary>
            Computes the arithmetic sum of two bitvectors
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.add(Z0.BitVector16,Z0.BitVector16)">
            <summary>
            Computes the arithmetic sum z := x + y for bitvectors x and y
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.add(Z0.BitVector32,Z0.BitVector32)">
            <summary>
            Computes the arithmetic sum z := x + y for bitvectors x and y
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.add(Z0.BitVector64,Z0.BitVector64)">
            <summary>
            Computes the arithmetic sum z := x + y for bitvectors x and y
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.alloc(Z0.N4)">
            <summary>
            Allocates a 4-bit primal bitvector
            </summary>
            <param name="n">The width discriminator</param>
        </member>
        <member name="M:Z0.BitVector.alloc(Z0.N8)">
            <summary>
            Allocates an 8-bit primal bitvector
            </summary>
            <param name="n">The width discriminator</param>
        </member>
        <member name="M:Z0.BitVector.alloc(Z0.N16)">
            <summary>
            Allocates a primal 16-bit bitvector
            </summary>
            <param name="n">The width discriminator</param>
        </member>
        <member name="M:Z0.BitVector.alloc(Z0.N32)">
            <summary>
            Allocates a primal 32-bit bitvector
            </summary>
            <param name="n">The width discriminator</param>
        </member>
        <member name="M:Z0.BitVector.alloc(Z0.N64)">
            <summary>
            Allocates a primal 64-bit bitvector
            </summary>
            <param name="n">The width discriminator</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.BitVector.and(Z0.BitVector4,Z0.BitVector4)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitVector.and(Z0.BitVector8,Z0.BitVector8)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitVector.and(Z0.BitVector16,Z0.BitVector16)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitVector.and(Z0.BitVector32,Z0.BitVector32)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitVector.and(Z0.BitVector64,Z0.BitVector64)" -->
        <member name="M:Z0.BitVector.loseg``1(Z0.BitVector{``0},System.Byte)">
            <summary>
            Constructs a bitvector formed from the n lest significant bits of the source vector
            </summary>
            <param name="n">The count of least significant bits</param>
        </member>
        <member name="M:Z0.BitVector.loseg(Z0.BitVector4,System.Byte)">
            <summary>
            Constructs a bitvector formed from the n lest significant bits of the current vector
            </summary>
            <param name="count">The count of least significant bits</param>
        </member>
        <member name="M:Z0.BitVector.loseg(Z0.BitVector8,System.Byte)">
            <summary>
            Constructs a bitvector formed from the n lest significant bits of the current vector
            </summary>
            <param name="count">The count of least significant bits</param>
        </member>
        <member name="M:Z0.BitVector.loseg(Z0.BitVector16,System.Byte)">
            <summary>
            Constructs a bitvector formed from the n lest significant bits of the current vector
            </summary>
            <param name="count">The count of least significant bits</param>
        </member>
        <member name="M:Z0.BitVector.loseg(Z0.BitVector32,System.Byte)">
            <summary>
            Constructs a bitvector formed from the n lest significant bits of the current vector
            </summary>
            <param name="count">The count of least significant bits</param>
        </member>
        <member name="M:Z0.BitVector.loseg(Z0.BitVector64,System.Byte)">
            <summary>
            Constructs a bitvector formed from the n lest significant bits of the current vector
            </summary>
            <param name="n">The count of least significant bits</param>
        </member>
        <member name="M:Z0.BitVector.disable``1(Z0.BitVector{``0},System.Int32)">
            <summary>
            Disables a bit if it is enabled
            </summary>
            <param name="index">The position of the bit to disable</param>
        </member>
        <member name="M:Z0.BitVector.disable``2(Z0.BitVector{``0,``1},System.Int32)">
            <summary>
            Disables a bit if it is enabled
            </summary>
            <param name="index">The position of the bit to disable</param>
        </member>
        <member name="M:Z0.BitVector.disable(Z0.BitVector4,System.Int32)">
            <summary>
            Disables a bit if it is enabled
            </summary>
            <param name="pos">The bit position</param>
        </member>
        <member name="M:Z0.BitVector.disable(Z0.BitVector8,System.Int32)">
            <summary>
            Disables a bit if it is enabled
            </summary>
            <param name="index">The bit position</param>
        </member>
        <member name="M:Z0.BitVector.disable(Z0.BitVector16,System.Int32)">
            <summary>
            Disables a bit if it is enabled
            </summary>
            <param name="index">The bit position</param>
        </member>
        <member name="M:Z0.BitVector.disable(Z0.BitVector32,System.Int32)">
            <summary>
            Disables a bit if it is enabled
            </summary>
            <param name="index">The bit position</param>
        </member>
        <member name="M:Z0.BitVector.disable(Z0.BitVector64,System.Int32)">
            <summary>
            Disables a bit if it is enabled
            </summary>
            <param name="index">The bit position</param>
        </member>
        <member name="M:Z0.BitVector.dot(Z0.BitVector4,Z0.BitVector4)">
            <summary>
            Computes the scalar product between two bitvectors
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.dot(Z0.BitVector8,Z0.BitVector8)">
            <summary>
            Computes the scalar product between two bitvectors
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.dot(Z0.BitVector16,Z0.BitVector16)">
            <summary>
            Computes the scalar product between two bitvectors
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.dot(Z0.BitVector32,Z0.BitVector32)">
            <summary>
            Computes the scalar product between two bitvectors
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.dot(Z0.BitVector64,Z0.BitVector64)">
            <summary>
            Computes the scalar product between two bitvectors
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.dot``1(Z0.BitVector{``0},Z0.BitVector{``0})">
            <summary>
            Computes the scalar product between two bitvectors
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.dot``2(Z0.BitVector{``0,``1},Z0.BitVector{``0,``1})">
            <summary>
            Computes the scalar product between two bitvectors
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.dot``2(Z0.BitVector128{``0,``1}@,Z0.BitVector128{``0,``1}@)">
            <summary>
            Computes the scalar product between two bitvectors
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.enable``1(Z0.BitVector{``0},System.Int32)">
            <summary>
            Enables a bit if it is disabled
            </summary>
            <param name="index">The position of the bit to enable</param>
        </member>
        <member name="M:Z0.BitVector.enable``2(Z0.BitVector{``0,``1},System.Int32)">
            <summary>
            Enables a bit if it is disabled
            </summary>
            <param name="index">The position of the bit to enable</param>
        </member>
        <member name="M:Z0.BitVector.enable(Z0.BitVector4,System.Int32)">
            <summary>
            Enables a bit if it is disabled
            </summary>
            <param name="pos">The position of the bit to enable</param>
        </member>
        <member name="M:Z0.BitVector.enable(Z0.BitVector8,System.Int32)">
            <summary>
            Enables a bit if it is disabled
            </summary>
            <param name="index">The position of the bit to enable</param>
        </member>
        <member name="M:Z0.BitVector.enable(Z0.BitVector16,System.Int32)">
            <summary>
            Enables a bit if it is disabled
            </summary>
            <param name="index">The position of the bit to enable</param>
        </member>
        <member name="M:Z0.BitVector.enable(Z0.BitVector32,System.Int32)">
            <summary>
            Enables a bit if it is disabled
            </summary>
            <param name="index">The position of the bit to enable</param>
        </member>
        <member name="M:Z0.BitVector.enable(Z0.BitVector64,System.Int32)">
            <summary>
            Enables a bit if it is disabled
            </summary>
            <param name="index">The position of the bit to enable</param>
        </member>
        <member name="M:Z0.BitVector.extend(Z0.BitVector4,Z0.W8)">
            <summary>
            Zero extends the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The target width</param>
        </member>
        <member name="M:Z0.BitVector.extend(Z0.BitVector8,Z0.W16)">
            <summary>
            Zero extends the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The target width</param>
        </member>
        <member name="M:Z0.BitVector.extend(Z0.BitVector16,Z0.W32)">
            <summary>
            Zero extends the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The target width</param>
        </member>
        <member name="M:Z0.BitVector.extend(Z0.BitVector32,Z0.W64)">
            <summary>
            Zero extends the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The target width</param>
        </member>
        <member name="M:Z0.BitVector.extend(Z0.BitVector64,Z0.W128)">
            <summary>
            Zero extends the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The target width</param>
        </member>
        <member name="M:Z0.BitVector.format``1(Z0.BitVector{``0},System.Nullable{Z0.BitFormat})">
            <summary>
            Formats the bitvector as a bitstring
            </summary>
            <param name="x">The source vector</param>
            <param name="fmt">Optional formatting style</param>
        </member>
        <member name="M:Z0.BitVector.format``2(Z0.BitVector128{``0,``1}@,System.Nullable{Z0.BitFormat})">
            <summary>
            Formats the bitvector as a bitstring
            </summary>
            <param name="x">The source vector</param>
            <param name="fmt">Optional formatting style</param>
        </member>
        <member name="M:Z0.BitVector.format``2(Z0.BitVector{``0,``1},System.Nullable{Z0.BitFormat})">
            <summary>
            Formats the bitvector as a bitstring
            </summary>
            <param name="x">The source vector</param>
            <param name="fmt">Optional formatting style</param>
        </member>
        <member name="M:Z0.BitVector.format(Z0.BitVector4,System.Nullable{Z0.BitFormat})">
            <summary>
            Formats the bitvector as a bitstring
            </summary>
            <param name="x">The source vector</param>
            <param name="fmt">Optional formatting style</param>
        </member>
        <member name="M:Z0.BitVector.format(Z0.BitVector8,System.Nullable{Z0.BitFormat})">
            <summary>
            Formats the bitvector as a bitstring
            </summary>
            <param name="x">The source vector</param>
            <param name="fmt">Optional formatting style</param>
        </member>
        <member name="M:Z0.BitVector.format(Z0.BitVector16,System.Nullable{Z0.BitFormat})">
            <summary>
            Formats the bitvector as a bitstring
            </summary>
            <param name="x">The source vector</param>
            <param name="fmt">Optional formatting style</param>
        </member>
        <member name="M:Z0.BitVector.format(Z0.BitVector24,System.Nullable{Z0.BitFormat})">
            <summary>
            Formats the bitvector as a bitstring
            </summary>
            <param name="x">The source vector</param>
            <param name="fmt">Optional formatting style</param>
        </member>
        <member name="M:Z0.BitVector.format(Z0.BitVector32,System.Nullable{Z0.BitFormat})">
            <summary>
            Formats the bitvector as a bitstring
            </summary>
            <param name="x">The source vector</param>
            <param name="fmt">Optional formatting style</param>
        </member>
        <member name="M:Z0.BitVector.format(Z0.BitVector64,System.Nullable{Z0.BitFormat})">
            <summary>
            Formats the bitvector as a bitstring
            </summary>
            <param name="x">The source vector</param>
            <param name="fmt">Optional formatting style</param>
        </member>
        <member name="M:Z0.BitVector.gather``1(Z0.BitVector{``0},Z0.BitVector{``0})">
            <summary>
            Populates a target vector with specified source bits
            </summary>
            <param name="spec">Identifies the source bits of interest</param>
            <param name="dst">Receives the identified bits</param>
        </member>
        <member name="M:Z0.BitVector.gather``2(Z0.BitVector{``0,``1},Z0.BitVector{``0,``1})">
            <summary>
            Populates a target vector with specified source bits
            </summary>
            <param name="spec">Identifies the source bits of interest</param>
            <param name="dst">Receives the identified bits</param>
        </member>
        <member name="M:Z0.BitVector.gather(Z0.BitVector4,Z0.BitVector4)">
            <summary>
            Populates a target vector with specified source bits
            </summary>
            <param name="spec">Identifies the source bits of interest</param>
            <param name="dst">Receives the identified bits</param>
        </member>
        <member name="M:Z0.BitVector.gather(Z0.BitVector8,Z0.BitVector8)">
            <summary>
            Populates a target vector with specified source bits
            </summary>
            <param name="spec">Identifies the source bits of interest</param>
            <param name="dst">Receives the identified bits</param>
        </member>
        <member name="M:Z0.BitVector.gather(Z0.BitVector16,Z0.BitVector16)">
            <summary>
            Populates a target vector with specified source bits
            </summary>
            <param name="spec">Identifies the source bits of interest</param>
            <param name="dst">Receives the identified bits</param>
        </member>
        <member name="M:Z0.BitVector.gather(Z0.BitVector32,Z0.BitVector32)">
            <summary>
            Populates a target vector with specified source bits
            </summary>
            <param name="spec">Identifies the source bits of interest</param>
            <param name="dst">Receives the identified bits</param>
        </member>
        <member name="M:Z0.BitVector.gather(Z0.BitVector64,Z0.BitVector64)">
            <summary>
            Populates a target vector with specified source bits
            </summary>
            <param name="spec">Identifies the source bits of interest</param>
            <param name="dst">Receives the identified bits</param>
        </member>
        <member name="M:Z0.BitVector.generic``1(``0)">
            <summary>
            Creates a generic bitvector
            </summary>
            <param name="src">The source cell</param>
        </member>
        <member name="M:Z0.BitVector.generic``1(System.Span{System.Byte})">
            <summary>
            Creates a generic bitvector from a span of bytes
            </summary>
            <param name="src">The source bits</param>
            <param name="n">The bitvector length</param>
        </member>
        <member name="M:Z0.BitVector.generic``1(Z0.BitString)">
            <summary>
            Loads an bitvector of minimal size from a source bitstring
            </summary>
            <param name="src">The bitstring source</param>
        </member>
        <member name="M:Z0.BitVector.generic(Z0.N8,System.Byte)">
            <summary>
            Creates a byte-generic bitvector
            </summary>
        </member>
        <member name="M:Z0.BitVector.generic(Z0.N8,Z0.bit,Z0.bit,Z0.bit,Z0.bit)">
            <summary>
            Creates a byte-generic bitvector from 4 bits
            </summary>
        </member>
        <member name="M:Z0.BitVector.generic(System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>
            Creates a byte-generic bitvector from 4 explicit bytes
            </summary>
            <param name="src">The source bitstring</param>
        </member>
        <member name="M:Z0.BitVector.add``1(Z0.BitVector{``0},Z0.BitVector{``0})">
            <summary>
            Computes the arithmetic sum z := x + y for generic bitvectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.add``2(Z0.BitVector128{``0,``1}@,Z0.BitVector128{``0,``1}@)">
            <summary>
            Computes the sum of two 128-bit integers
            </summary>
            <param name="x">The first integer, represented via paired hi/lo components</param>
            <param name="y">The second integer, represented via paired hi/lo components</param>
            <remarks>Follows https://github.com/chfast/intx/include/intx/int128.hpp</remarks>
        </member>
        <member name="M:Z0.BitVector.alloc``2(``0,``1)">
            <summary>
            Allocates a natural bitvector
            </summary>
            <param name="n">The number of bits to store</param>
            <typeparam name="T">The primal storage type</typeparam>
        </member>
        <member name="M:Z0.BitVector.alloc``1(``0)">
            <summary>
            Allocates a generic bitvector
            </summary>
            <param name="n">The number of bits to store</param>
            <typeparam name="T">The primal storage type</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.BitVector.and``1(Z0.BitVector{``0},Z0.BitVector{``0})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitVector.and``2(Z0.BitVector{``0,``1},Z0.BitVector{``0,``1})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitVector.and``2(Z0.BitVector128{``0,``1}@,Z0.BitVector128{``0,``1}@)" -->
        <member name="M:Z0.BitVector.pop``2(Z0.BitVector128{``0,``1}@)">
            <summary>
            Counts the number of enabled bits in the source vector
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.pop``1(Z0.BitVector{``0})">
            <summary>
            Counts the number of enabled bits in the source vector
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.pop``2(Z0.BitVector{``0,``1})">
            <summary>
            Counts the number of enabled bits in the source vector
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.width``2(Z0.BitVector{``0,``1})">
            <summary>
            Computes the effective width of the bitvector as determined by the number of leading zero bits
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.gfmul(Z0.BitVector8,Z0.BitVector8)">
            <summary>
            Computes the GF(256) product of the operands. 
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.BitVector.hamming``1(Z0.BitVector{``0},Z0.BitVector{``0})">
            <summary>
            Computes the Hamming distance between two generic bitvectors
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.hamming``2(Z0.BitVector{``0,``1},Z0.BitVector{``0,``1})">
            <summary>
            Computes the Hamming distance between bitvectors
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.hamming``2(Z0.BitVector128{``0,``1}@,Z0.BitVector128{``0,``1}@)">
            <summary>
            Computes the Hamming distance between bitvectors
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.hamming(Z0.BitVector4,Z0.BitVector4)">
            <summary>
            Computes the Hamming distance between two bitvectors
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.hamming(Z0.BitVector8,Z0.BitVector8)">
            <summary>
            Computes the Hamming distance between two bitvectors
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.hamming(Z0.BitVector16,Z0.BitVector16)">
            <summary>
            Computes the Hamming distance between two bitvectors
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.hamming(Z0.BitVector32,Z0.BitVector32)">
            <summary>
            Computes the Hamming distance between two bitvectors
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.hamming(Z0.BitVector64,Z0.BitVector64)">
            <summary>
            Computes the Hamming distance between two bitvectors
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.hiseg``1(Z0.BitVector{``0},System.Byte)">
            <summary>
            Constructs a bitvector formed from the n most significant bits of the source vector
            </summary>
            <param name="x">The source vector</param>
            <param name="n">The count of least significant bits</param>
        </member>
        <member name="M:Z0.BitVector.hiseg(Z0.BitVector4,System.Byte)">
            <summary>
            Constructs a bitvector formed from the n most significant bits of the source vector
            </summary>
            <param name="x">The source vector</param>
            <param name="n">The count of most significant bits</param>
        </member>
        <member name="M:Z0.BitVector.hiseg(Z0.BitVector8,System.Byte)">
            <summary>
            Constructs a bitvector formed from the n most significant bits of the source vector
            </summary>
            <param name="x">The source vector</param>
            <param name="n">The count of most significant bits</param>
        </member>
        <member name="M:Z0.BitVector.hiseg(Z0.BitVector16,System.Byte)">
            <summary>
            Constructs a bitvector formed from the n most significant bits of the source vector
            </summary>
            <param name="x">The source vector</param>
            <param name="n">The count of most significant bits</param>
        </member>
        <member name="M:Z0.BitVector.hiseg(Z0.BitVector32,System.Byte)">
            <summary>
            Constructs a bitvector formed from the n most significant bits of the source vector
            </summary>
            <param name="x">The source vector</param>
            <param name="n">The count of most significant bits</param>
        </member>
        <member name="M:Z0.BitVector.hiseg(Z0.BitVector64,System.Byte)">
            <summary>
            Constructs a bitvector formed from the n most significant bits of the source vector
            </summary>
            <param name="x">The source vector</param>
            <param name="n">The count of most significant bits</param>
        </member>
        <member name="M:Z0.BitVector.impl``1(Z0.BitVector{``0},Z0.BitVector{``0})">
            <summary>
            Computes the material implication z := x | ~y for bitvectors x and y
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.impl``2(Z0.BitVector{``0,``1},Z0.BitVector{``0,``1})">
            <summary>
            Computes the material implication z := x | ~y for bitvectors x and y
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.impl``2(Z0.BitVector128{``0,``1}@,Z0.BitVector128{``0,``1}@)">
            <summary>
            Computes the material implication z := x | ~y for bitvectors x and y
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.inc``1(Z0.BitVector{``0})">
            <summary>
            Arithmetically increments the source vector
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.inc``2(Z0.BitVector{``0,``1})">
            <summary>
            Arithmetically increments the source vector
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.inc(Z0.BitVector8)">
            <summary>
            Increments the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.inc(Z0.BitVector16)">
            <summary>
            Increments the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.inc(Z0.BitVector32)">
            <summary>
            Increments the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.inc(Z0.BitVector64)">
            <summary>
            Increments the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.init``1(``0)">
            <summary>
            Initializes a generic bitvector with a supplied value
            </summary>
            <param name="src">The value used to initialize the bitvector</param>
        </member>
        <member name="M:Z0.BitVector.init``2(``1,``0)">
            <summary>
            Initializes a natural bitvector over a primal type
            </summary>
            <param name="src">The value used to initialize the bitvector</param>
        </member>
        <member name="M:Z0.BitVector.init``1(System.Runtime.Intrinsics.Vector128{``0})">
            <summary>
            Initializes a full-width 128-bit bitvector
            </summary>
            <param name="src">The value used to initialize the bitvector</param>
        </member>
        <member name="M:Z0.BitVector.init``2(System.Runtime.Intrinsics.Vector128{``1},``0)">
            <summary>
            Initializes a 128-bit bitvector with effective width determined by the parametric natural type that must not exeed 128
            </summary>
            <param name="src">The value used to initialize the bitvector</param>
        </member>
        <member name="M:Z0.BitVector.init(Z0.N4,System.Byte)">
            <summary>
            Initializes a 4-bit bitvector with a supplied value
            </summary>
            <param name="src">The value used to initialize the bitvector</param>
        </member>
        <member name="M:Z0.BitVector.init(System.Byte)">
            <summary>
            Initializes an 8-bit bitvector with a supplied value
            </summary>
            <param name="src">The value used to initialize the bitvector</param>
        </member>
        <member name="M:Z0.BitVector.init(System.UInt16)">
            <summary>
            Creates a populated 16-bit bitvector
            </summary>
            <param name="src">The value used to initialize the bitvector</param>
        </member>
        <member name="M:Z0.BitVector.init(System.UInt16,System.Byte)">
            <summary>
            Initializes a 24-bit bitvector with supplied upper/lower values
            </summary>
            <param name="src">The value used to initialize the bitvector</param>
        </member>
        <member name="M:Z0.BitVector.init(Z0.N24,System.UInt32)">
            <summary>
            Initializes a 24-bit bitvector with a supplied value
            </summary>
            <param name="src">The value used to initialize the bitvector</param>
        </member>
        <member name="M:Z0.BitVector.init(System.UInt32)">
            <summary>
            Initializes a 16-bit bitvector with a supplied value
            </summary>
            <param name="src">The value used to initialize the bitvector</param>
        </member>
        <member name="M:Z0.BitVector.init(System.UInt64)">
            <summary>
            Initializes a 16-bit bitvector with a supplied value
            </summary>
            <param name="src">The value used to initialize the bitvector</param>
        </member>
        <member name="M:Z0.BitVector.inject(Z0.N4,System.Byte)">
            <summary>
            Creates a 4-bit vector directly from the source data, bypassing masked initialization
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.inject``2(``1,``0)">
            <summary>
            Creates an N-bit vector directly from the source data, bypassing masked initialization
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.list(Z0.N8)">
            <summary>
            Enumerates each and every 8-bit bitvector exactly once
            </summary>
            <param name="n">The bitness selector</param>
        </member>
        <member name="M:Z0.BitVector.nonempty(Z0.N8)">
            <summary>
            Enumerates each nonempty 8-bit bitvector 
            </summary>
        </member>
        <member name="M:Z0.BitVector.list(Z0.N16,System.Int32)">
            <summary>
            Enumerates all 16-bit bitvectors whose width is less than or equal to a specified maximum
            </summary>
            <param name="n">The bitness selector</param>
        </member>
        <member name="M:Z0.BitVector.gray(Z0.N8)">
            <summary>
            Enumerates the 8-bit Gray codes
            </summary>
            <param name="n">The bitness selector</param>
        </member>
        <member name="M:Z0.BitVector.list(Z0.N32,System.Int32)">
            <summary>
            Enumerates all 32-bit bitvectors for which the effective width is less than or equal to a specified maximum
            </summary>
        </member>
        <member name="M:Z0.BitVector.list(Z0.N64,System.Int32)">
            <summary>
            Enumerates all 64-bit bitvectors for which the effective width is less than or equal to a specified maximum
            </summary>
        </member>
        <member name="M:Z0.BitVector.modprod``1(Z0.BitVector{``0},Z0.BitVector{``0})">
            <summary>
            Computes the Euclidean scalar product between two bitvectors using modular arithmetic
            </summary>
            <param name="x">The first vector</param>
            <param name="y">The second vector</param>
            <remarks>This should be considered a reference implementation; the dot operation is considerably faster</remarks>
        </member>
        <member name="M:Z0.BitVector.modprod``2(Z0.BitVector{``0,``1},Z0.BitVector{``0,``1})">
            <summary>
            Computes the Euclidean scalar product between two bitvectors using modular arithmetic
            </summary>
            <param name="x">The first vector</param>
            <param name="y">The second vector</param>
            <remarks>This should be considered a reference implementation; the dot operation is considerably faster</remarks>
        </member>
        <member name="M:Z0.BitVector.modprod(Z0.BitVector4,Z0.BitVector4)">
            <summary>
            Computes the Euclidean scalar product between two bitvectors using modular arithmetic
            </summary>
            <param name="x">The first vector</param>
            <param name="y">The second vector</param>
            <remarks>This should be considered a reference implementation; the dot operation is considerably faster</remarks>
        </member>
        <member name="M:Z0.BitVector.modprod(Z0.BitVector8,Z0.BitVector8)">
            <summary>
            Computes the Euclidean scalar product between two bitvectors using modular arithmetic
            </summary>
            <param name="lhs">The first vector</param>
            <param name="rhs">The second vector</param>
            <remarks>This should be considered a reference implementation; the dot operation is considerably faster</remarks>
        </member>
        <member name="M:Z0.BitVector.modprod(Z0.BitVector16,Z0.BitVector16)">
            <summary>
            Computes the Euclidean scalar product between two bitvectors using modular arithmetic
            </summary>
            <param name="x">The first vector</param>
            <param name="y">The second vector</param>
            <remarks>This should be considered a reference implementation; the dot operation is considerably faster</remarks>
        </member>
        <member name="M:Z0.BitVector.modprod(Z0.BitVector32,Z0.BitVector32)">
            <summary>
            Computes the Euclidean scalar product between two bitvectors using modular arithmetic
            </summary>
            <param name="x">The first vector</param>
            <param name="y">The second vector</param>
            <remarks>This should be considered a reference implementation; the dot operation is considerably faster</remarks>
        </member>
        <member name="M:Z0.BitVector.modprod(Z0.BitVector64,Z0.BitVector64)">
            <summary>
            Computes the Euclidean scalar product between two bitvectors using modular arithmetic
            </summary>
            <param name="x">The first vector</param>
            <param name="y">The second vector</param>
            <remarks>This should be considered a reference implementation; the dot operation is considerably faster</remarks>
        </member>
        <member name="M:Z0.BitVector.mux(Z0.BitVector8,Z0.BitVector4)">
            <summary>
            Uses the first three bits of the control operand to select one of 8 bits from the input operand
            </summary>
            <param name="control">Specifies the output selection</param>
            <param name="src">The input from which a bit will be selected</param>
        </member>
        <member name="M:Z0.BitVector.mux(Z0.BitVector16,Z0.BitVector4)">
            <summary>
            Uses the four bits of the control operand to select one of 16 bits from the input operand
            </summary>
            <param name="src">The input from which a bit will be selected</param>
            <param name="control">Specifies the output selection</param>
        </member>
        <member name="M:Z0.BitVector.mux(Z0.BitVector32,Z0.BitVector8)">
            <summary>
            Uses the first 5 bits of the control operand to select one of 32 bits from the input operand
            </summary>
            <param name="src">The input from which a bit will be selected</param>
            <param name="control">Specifies the output selection</param>
        </member>
        <member name="M:Z0.BitVector.mux(Z0.BitVector64,Z0.BitVector8)">
            <summary>
            Uses the first 6 bits of the control operand to select one of 64 bits from the input operand
            </summary>
            <param name="src">The input from which a bit will be selected</param>
            <param name="control">Specifies the output selection</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.BitVector.nand``1(Z0.BitVector{``0},Z0.BitVector{``0})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitVector.nand``2(Z0.BitVector{``0,``1},Z0.BitVector{``0,``1})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitVector.nand``2(Z0.BitVector128{``0,``1},Z0.BitVector128{``0,``1})" -->
        <member name="M:Z0.BitVector.natural``2(``0,``1)">
            <summary>
            Defines a bitvector of natural width
            </summary>
            <param name="n">The width selector</param>
            <param name="a">The scalar source data</param>
            <typeparam name="N">The width type</typeparam>
            <typeparam name="T">The scalar type</typeparam>
        </member>
        <member name="M:Z0.BitVector.natural``2(``0,System.Runtime.Intrinsics.Vector128{``1})">
            <summary>
            Defines a 128-bit bitvector of natural width
            </summary>
            <param name="n">The width selector</param>
            <param name="a">The scalar source data</param>
            <typeparam name="N">The width type</typeparam>
            <typeparam name="T">The scalar type</typeparam>
        </member>
        <member name="M:Z0.BitVector.natural``2(``1)">
            <summary>
            Defines a bitvector of natural width
            </summary>
            <param name="n">The width selector</param>
            <param name="a">The scalar source data</param>
            <typeparam name="N">The width type</typeparam>
            <typeparam name="T">The scalar type</typeparam>
        </member>
        <member name="M:Z0.BitVector.natural``2(Z0.BitString,``0,``1)">
            <summary>
            Creates a vector from a bitstring
            </summary>
            <param name="src">The source bitstring</param>
        </member>
        <member name="M:Z0.BitVector.negate``1(Z0.BitVector{``0})">
            <summary>
            Computes the two's complement bitvector z := ~x + 1 for a bitvector x
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.negate``2(Z0.BitVector{``0,``1})">
            <summary>
            Computes the two's complement bitvector z := ~x + 1 for a bitvector x
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.negate``2(Z0.BitVector128{``0,``1}@)">
            <summary>
            Computes the two's complement bitvector z := ~x + 1 for a bitvector x
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.negate(Z0.BitVector4)">
            <summary>
            Computes the two's complement bitvector z := ~x + 1 for a bitvector x
            </summary>
            <param name="x">The left bitvector</param>
        </member>
        <member name="M:Z0.BitVector.negate(Z0.BitVector8)">
            <summary>
            Computes the two's complement bitvector z := ~x + 1 for a bitvector x
            </summary>
            <param name="x">The source bitvector</param>
        </member>
        <member name="M:Z0.BitVector.negate(Z0.BitVector16)">
            <summary>
            Computes the two's complement bitvector z := ~x + 1 for a bitvector x
            </summary>
            <param name="x">The source bitvector</param>
        </member>
        <member name="M:Z0.BitVector.negate(Z0.BitVector32)">
            <summary>
            Computes the two's complement bitvector z := ~x + 1 for a bitvector x
            </summary>
            <param name="x">The source bitvector</param>
        </member>
        <member name="M:Z0.BitVector.negate(Z0.BitVector64)">
            <summary>
            Computes the two's complement bitvector z := ~x + 1 for a bitvector x
            </summary>
            <param name="x">The source bitvector</param>
        </member>
        <member name="M:Z0.BitVector.nlz``1(Z0.BitVector{``0})">
            <summary>
            Counts the number of leading zero bits
            </summary>
        </member>
        <member name="M:Z0.BitVector.nlz``2(Z0.BitVector{``0,``1})">
            <summary>
            Counts the number of leading zero bits
            </summary>
        </member>
        <member name="M:Z0.BitVector.nlz(Z0.BitVector4)">
            <summary>
            Counts the number of leading zero bits
            </summary>
        </member>
        <member name="M:Z0.BitVector.nlz(Z0.BitVector8)">
            <summary>
            Counts the number of leading zero bits
            </summary>
        </member>
        <member name="M:Z0.BitVector.nlz(Z0.BitVector16)">
            <summary>
            Counts the number of leading zero bits
            </summary>
        </member>
        <member name="M:Z0.BitVector.nlz(Z0.BitVector32)">
            <summary>
            Counts the number of leading zero bits
            </summary>
        </member>
        <member name="M:Z0.BitVector.nlz(Z0.BitVector64)">
            <summary>
            Counts the number of leading zero bits
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.BitVector.nonimpl``1(Z0.BitVector{``0},Z0.BitVector{``0})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitVector.nonimpl``2(Z0.BitVector{``0,``1},Z0.BitVector{``0,``1})" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitVector.nonimpl``2(Z0.BitVector128{``0,``1}@,Z0.BitVector128{``0,``1}@)" -->
        <member name="M:Z0.BitVector.nor``1(Z0.BitVector{``0},Z0.BitVector{``0})">
            <summary>
            Computes the bitvector z: = ~(x | y) from bitvectors x and y
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
            <typeparam name="T">The primal bitvector type</typeparam>
        </member>
        <member name="M:Z0.BitVector.nor``2(Z0.BitVector{``0,``1},Z0.BitVector{``0,``1})">
            <summary>
            Computes the bitvector z: = ~(x | y) from bitvectors x and y
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
            <typeparam name="T">The primal bitvector type</typeparam>
        </member>
        <member name="M:Z0.BitVector.nor``2(Z0.BitVector128{``0,``1}@,Z0.BitVector128{``0,``1}@)">
            <summary>
            Computes the bitvector z: = ~(x | y) from bitvectors x and y
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
            <typeparam name="T">The primal bitvector type</typeparam>
        </member>
        <member name="M:Z0.BitVector.nor(Z0.BitVector4,Z0.BitVector4)">
            <summary>
            Computes the bitvector z: = ~(x | y) from bitvectors x and y
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.nor(Z0.BitVector8,Z0.BitVector8)">
            <summary>
            Computes the bitvector z: = ~(x | y) from bitvectors x and y
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.nor(Z0.BitVector16,Z0.BitVector16)">
            <summary>
            Computes the bitvector z: = ~(x | y) from bitvectors x and y
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.nor(Z0.BitVector32,Z0.BitVector32)">
            <summary>
            Computes the bitvector z: = ~(x | y) from bitvectors x and y
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.nor(Z0.BitVector64,Z0.BitVector64)">
            <summary>
            Computes the bitvector z: = ~(x | y) from bitvectors x and y
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.not``1(Z0.BitVector{``0})">
            <summary>
            Computes the bitwise complement z:= ~x of a bitvector x
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.not``2(Z0.BitVector{``0,``1})">
            <summary>
            Computes the bitwise complement z:= ~x of a bitvector x
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.not``2(Z0.BitVector128{``0,``1}@)">
            <summary>
            Computes the bitwise complement z:= ~x of a bitvector x
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.not(Z0.BitVector4)">
            <summary>
            Computes the bitwise complement z:= ~x of a bitvector x
            </summary>
            <param name="x">The left bitvector</param>
        </member>
        <member name="M:Z0.BitVector.not(Z0.BitVector8)">
            <summary>
            Computes the bitwise complement z:= ~x of a bitvector x
            </summary>
            <param name="x">The left bitvector</param>
        </member>
        <member name="M:Z0.BitVector.not(Z0.BitVector16)">
            <summary>
            Computes the bitwise complement z:= ~x of a bitvector x
            </summary>
            <param name="x">The source bitvector</param>
        </member>
        <member name="M:Z0.BitVector.not(Z0.BitVector32)">
            <summary>
            Computes the bitwise complement z:= ~x of a bitvector x
            </summary>
            <param name="x">The source bitvector</param>
        </member>
        <member name="M:Z0.BitVector.not(Z0.BitVector64)">
            <summary>
            Computes the bitwise complement z:= ~x of a bitvector x
            </summary>
            <param name="x">The source bitvector</param>
        </member>
        <member name="M:Z0.BitVector.ntz``1(Z0.BitVector{``0}@)">
            <summary>
            Counts the number of trailing zero bits
            </summary>
        </member>
        <member name="M:Z0.BitVector.ntz``2(Z0.BitVector{``0,``1}@)">
            <summary>
            Counts the number of trailing zero bits
            </summary>
        </member>
        <member name="M:Z0.BitVector.ntz``2(Z0.BitVector128{``0,``1}@)">
            <summary>
            Counts the number of trailing zeros
            </summary>
        </member>
        <member name="M:Z0.BitVector.ntz(Z0.BitVector8)">
            <summary>
            Counts the number of trailing zero bits
            </summary>
        </member>
        <member name="M:Z0.BitVector.ntz(Z0.BitVector16)">
            <summary>
            Counts the number of trailing zero bits
            </summary>
        </member>
        <member name="M:Z0.BitVector.ntz(Z0.BitVector32)">
            <summary>
            Counts the number of trailing zero bits
            </summary>
        </member>
        <member name="M:Z0.BitVector.ntz(Z0.BitVector64)">
            <summary>
            Counts the number of trailing zero bits
            </summary>
        </member>
        <member name="M:Z0.BitVector.ones``1">
            <summary>
            Returns a generic vector with all bits enabled
            </summary>
            <typeparam name="T">The primal type upon which the vector is predicated</typeparam>
        </member>
        <member name="M:Z0.BitVector.or``1(Z0.BitVector{``0},Z0.BitVector{``0})">
            <summary>
            Computes the bitvector z := x | y from bitvectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.or``2(Z0.BitVector{``0,``1},Z0.BitVector{``0,``1})">
            <summary>
            Computes the bitvector z := x ^ y from bitvectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.or``2(Z0.BitVector128{``0,``1}@,Z0.BitVector128{``0,``1}@)">
            <summary>
            Computes the bitvector z := x ^ y from bitvectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.or(Z0.BitVector4,Z0.BitVector4)">
            <summary>
            Computes the bitvector z := x | y from bitvectors x and y
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.or(Z0.BitVector8,Z0.BitVector8)">
            <summary>
            Computes the bitvector z := x | y from bitvectors x and y
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.or(Z0.BitVector16,Z0.BitVector16)">
            <summary>
            Computes the bitvector z := x | y from bitvectors x and y
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.or(Z0.BitVector32,Z0.BitVector32)">
            <summary>
            Computes the bitvector z := x | y from bitvectors x and y
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.or(Z0.BitVector64,Z0.BitVector64)">
            <summary>
            Computes the bitvector z := x | y from bitvectors x and y
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.ord(Z0.BitVector8)">
            <summary>
            Computes the smallest integer n > 1 such that v^n = identity
            </summary>
        </member>
        <member name="M:Z0.BitVector.parity``1(Z0.BitVector{``0})">
            <summary>
            Computes the parity of a generic bitvector, which is 1 if an odd number of its components are enabled and 0 otherwise
            </summary>
            <remarks>
            The parity function p:{0,1}x...x{0,1} -> {0,1} is a boolean function that attains the
            value 1 when an odd number of its input values are 1 and 0 otherwise.
            </remarks>
        </member>
        <member name="M:Z0.BitVector.parity(Z0.BitVector4)">
            <summary>
            Computes the parity of the source vector, which is 1 if an odd number of its components are enabled and 0 otherwise
            </summary>
            <remarks>
            The parity function p:{0,1}x...x{0,1} -> {0,1} is a boolean function that attains the
            value 1 when an odd number of its input values are 1 and 0 otherwise.
            </remarks>
        </member>
        <member name="M:Z0.BitVector.parity(Z0.BitVector8)">
            <summary>
            Computes the parity of the source vector, which is 1 if an odd number of its components are enabled and 0 otherwise
            </summary>
            <remarks>
            The parity function p:{0,1}x...x{0,1} -> {0,1} is a boolean function that attains the
            value 1 when an odd number of its input values are 1 and 0 otherwise.
            </remarks>
        </member>
        <member name="M:Z0.BitVector.parity(Z0.BitVector16)">
            <summary>
            Computes the parity of the source vector, which is 1 if an odd number of its components are enabled and 0 otherwise
            </summary>
            <remarks>
            The parity function p:{0,1}x...x{0,1} -> {0,1} is a boolean function that attains the
            value 1 when an odd number of its input values are 1 and 0 otherwise.
            </remarks>
        </member>
        <member name="M:Z0.BitVector.parity(Z0.BitVector32)">
            <summary>
            Computes the parity of the source vector, which is 1 if an odd number of its components are enabled and 0 otherwise
            </summary>
            <remarks>
            The parity function p:{0,1}x...x{0,1} -> {0,1} is a boolean function that attains the
            value 1 when an odd number of its input values are 1 and 0 otherwise.
            </remarks>
        </member>
        <member name="M:Z0.BitVector.parity(Z0.BitVector64)">
            <summary>
            Computes the parity of the source vector, which is 1 if an odd number of its components are enabled and 0 otherwise
            </summary>
            <remarks>
            The parity function p:{0,1}x...x{0,1} -> {0,1} is a boolean function that attains the
            value 1 when an odd number of its input values are 1 and 0 otherwise.
            </remarks>
        </member>
        <member name="M:Z0.BitVector.parity``2(Z0.BitVector{``0,``1})">
            <summary>
            Computes the parity of a natural bitvector, which is 1 if an odd number of its components are enabled and 0 otherwise
            </summary>
            <remarks>
            The parity function p:{0,1}x...x{0,1} -> {0,1} is a boolean function that attains the
            value 1 when an odd number of its input values are 1 and 0 otherwise.
            </remarks>
        </member>
        <member name="M:Z0.BitVector.parity``2(Z0.BitVector128{``0,``1}@)">
            <summary>
            Computes the parity of the source vector
            </summary>
        </member>
        <member name="M:Z0.BitVector.perm(Z0.BitVector4,Z0.Perm@)">
            <summary>
            Permutes the vector corrding to the spec
            </summary>
            <param name="spec">The permutation</param>
        </member>
        <member name="M:Z0.BitVector.perm(Z0.BitVector8,Z0.Perm@)">
            <summary>
            Applies a permutation to a replicated vector
            </summary>
            <param name="p">The permutation</param>
        </member>
        <member name="M:Z0.BitVector.perm(Z0.BitVector16,Z0.Perm@)">
            <summary>
            Rearranges the vector in-place as specified by a permutation
            </summary>
            <param name="x">The source vector</param>
            <param name="spec">The permutation</param>
        </member>
        <member name="M:Z0.BitVector.perm(Z0.BitVector32,Z0.Perm@)">
            <summary>
            Rearranges the vector specified by a permutation
            </summary>
            <param name="src">The source vector</param>
            <param name="spec">The permutation</param>
        </member>
        <member name="M:Z0.BitVector.perm(Z0.BitVector64,Z0.Perm@)">
            <summary>
            Creates a new vector by permuting a replica of the source vector as specified by a permuation
            </summary>
            <param name="src">The source vector</param>
            <param name="spec">The permutation</param>
        </member>
        <member name="M:Z0.BitVector.perm``1(Z0.BitVector{``0},Z0.Perm@)">
            <summary>
            Rearranges the vector as specified by a permutation
            </summary>
            <param name="x">The source vector</param>
            <param name="spec">The permutation</param>
        </member>
        <member name="M:Z0.BitVector.pop(Z0.BitVector4)">
            <summary>
            Counts the number of enabled bits in the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.pop(Z0.BitVector8)">
            <summary>
            Counts the number of enabled bits in the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.pop(Z0.BitVector16)">
            <summary>
            Counts the number of enabled bits in the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.pop(Z0.BitVector32)">
            <summary>
            Counts the number of enabled bits in the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.pop(Z0.BitVector64)">
            <summary>
            Counts the number of enabled bits in the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.pow(Z0.BitVector8,System.Int32)">
            <summary>
            Raises a vector to a power
            </summary>
            <param name="x">The source vector</param>
            <param name="n">The power</param>
        </member>
        <member name="M:Z0.BitVector.left``1(Z0.BitVector{``0},Z0.BitVector{``0})">
            <summary>
            Defines the bitwise LeftProject operator
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <typeparam name="T">The primal scalar upon which the bitvector is predicated</typeparam>
        </member>
        <member name="M:Z0.BitVector.right``1(Z0.BitVector{``0},Z0.BitVector{``0})">
            <summary>
            Defines the bitwise RightProject operator
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <typeparam name="T">The primal scalar upon which the bitvector is predicated</typeparam>
        </member>
        <member name="M:Z0.BitVector.lnot``1(Z0.BitVector{``0},Z0.BitVector{``0})">
            <summary>
            Defines the bitwise LeftNot operator
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <typeparam name="T">The primal scalar upon which the bitvector is predicated</typeparam>
        </member>
        <member name="M:Z0.BitVector.rnot``1(Z0.BitVector{``0},Z0.BitVector{``0})">
            <summary>
            Defines the bitwise RightNot operator
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <typeparam name="T">The primal scalar upon which the bitvector is predicated</typeparam>
        </member>
        <member name="M:Z0.BitVector.replicate``1(Z0.BitVector{``0})">
            <summary>
            Creates a copy of the source vector
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.replicate``2(Z0.BitVector{``0,``1})">
            <summary>
            Creates a copy of the source vector
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.replicate``2(Z0.BitVector128{``0,``1}@)">
            <summary>
            Creates a copy of the source vector
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.replicate(Z0.BitVector4)">
            <summary>
            Creates a copy of the source vector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.replicate(Z0.BitVector4,Z0.N2)">
            <summary>
            Creates an 8-bit vector by concatenating the source vector with a replicant
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.replicate(Z0.BitVector8)">
            <summary>
            Creates a copy of the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.replicate(Z0.BitVector8,Z0.N2)">
            <summary>
            Creates a 16-bit vector by concatenating the source vector with a replicant
            </summary>
            <param name="x">The source vector</param>
            <param name="n">The duplication factor</param>
        </member>
        <member name="M:Z0.BitVector.replicate(Z0.BitVector8,Z0.N4)">
            <summary>
            Creates a 32-bit vector by concatenating 4 source replicants
            </summary>
            <param name="x">The source vector</param>
            <param name="n">The duplication factor</param>
        </member>
        <member name="M:Z0.BitVector.replicate(Z0.BitVector8,Z0.N8)">
            <summary>
            Creates a 64-bit vector by concatenating 8 source replicants
            </summary>
            <param name="x">The source vector</param>
            <param name="n">The duplication factor</param>
        </member>
        <member name="M:Z0.BitVector.replicate(Z0.BitVector16)">
            <summary>
            Creates a copy of the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.replicate(Z0.BitVector16,Z0.N2)">
            <summary>
            Creates a 32-bit vector by concatenating the source vector with a replicant
            </summary>
            <param name="x">The source vector</param>
            <param name="n">The duplication factor</param>
        </member>
        <member name="M:Z0.BitVector.replicate(Z0.BitVector16,Z0.N4)">
            <summary>
            Creates a 64-bit vector by concatenating 4 source replicants
            </summary>
            <param name="x">The source vector</param>
            <param name="n">The duplication factor</param>
        </member>
        <member name="M:Z0.BitVector.replicate(Z0.BitVector32)">
            <summary>
            Creates a copy of the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.replicate(Z0.BitVector32,Z0.N2)">
            <summary>
            Creates a 64-bit vector by concatenating the source vector with a replicant
            </summary>
            <param name="x">The source vector</param>
            <param name="n">The duplication factor</param>
        </member>
        <member name="M:Z0.BitVector.replicate(Z0.BitVector64)">
            <summary>
            Creates a copy of the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.reverse``1(Z0.BitVector{``0})">
            <summary>
            Reverses the bits in the source vector
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.reverse``2(Z0.BitVector{``0,``1})">
            <summary>
            Reverses the bits in the source vector
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.reverse(Z0.BitVector4)">
            <summary>
            Reverses the bits in the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.reverse(Z0.BitVector8)">
            <summary>
            Reverses the bits in the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.reverse(Z0.BitVector16)">
            <summary>
            Reverses the bits in the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.reverse(Z0.BitVector32)">
            <summary>
            Reverses the bits in the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.reverse(Z0.BitVector64)">
            <summary>
            Reverses the bits in the source vector
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector.rotl(Z0.BitVector4,System.Byte)">
            <summary>
            Rotates source bits leftward
            </summary>
            <param name="src">The source bitvector</param>
            <param name="offset">The rotation magnitude</param>
        </member>
        <member name="M:Z0.BitVector.rotl(Z0.BitVector8,System.Byte)">
            <summary>
            Rotates source bits leftward
            </summary>
            <param name="src">The source bitvector</param>
            <param name="offset">The rotation magnitude</param>
        </member>
        <member name="M:Z0.BitVector.rotl(Z0.BitVector16,System.Byte)">
            <summary>
            Rotates source bits leftward
            </summary>
            <param name="src">The source bitvector</param>
            <param name="offset">The rotation magnitude</param>
        </member>
        <member name="M:Z0.BitVector.rotl(Z0.BitVector32,System.Byte)">
            <summary>
            Rotates source bits leftward
            </summary>
            <param name="src">The source bitvector</param>
            <param name="offset">The rotation magnitude</param>
        </member>
        <member name="M:Z0.BitVector.rotl(Z0.BitVector64,System.Byte)">
            <summary>
            Rotates source bits leftward
            </summary>
            <param name="src">The source bitvector</param>
            <param name="offset">The rotation magnitude</param>
        </member>
        <member name="M:Z0.BitVector.rotl``1(Z0.BitVector{``0},System.Byte)">
            <summary>
            Rotates source bits leftward
            </summary>
            <param name="x">The source bitvector</param>
            <param name="offset">The rotation magnitude</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.rotl``2(Z0.BitVector{``0,``1},System.Byte)">
            <summary>
            Rotates source bits leftward
            </summary>
            <param name="x">The source bitvector</param>
            <param name="offset">The rotation magnitude</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.rotl``2(Z0.BitVector128{``0,``1}@,System.Byte)">
            <summary>
            Rotates source bits leftward
            </summary>
            <param name="src">The source bitvector</param>
            <param name="offset">The rotation magnitude</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.rotr(Z0.BitVector4,System.Byte)">
            <summary>
            Computes a rightward bit rotation
            </summary>
            <param name="x">The source bitvector</param>
            <param name="y">The rotation magnitude</param>
        </member>
        <member name="M:Z0.BitVector.rotr(Z0.BitVector8,System.Byte)">
            <summary>
            Computes a rightward bit rotation
            </summary>
            <param name="x">The source bitvector</param>
            <param name="y">The rotation magnitude</param>
        </member>
        <member name="M:Z0.BitVector.rotr(Z0.BitVector16,System.Byte)">
            <summary>
            Rotates source bits rightward
            </summary>
            <param name="x">The source bitvector</param>
            <param name="offset">The rotation magnitude</param>
        </member>
        <member name="M:Z0.BitVector.rotr(Z0.BitVector32,System.Byte)">
            <summary>
            Computes a rightward bit rotation
            </summary>
            <param name="x">The source bitvector</param>
            <param name="y">The rotation magnitude</param>
        </member>
        <member name="M:Z0.BitVector.rotr(Z0.BitVector64,System.Byte)">
            <summary>
            Rotates source bits rightward
            </summary>
            <param name="x">The source bitvector</param>
            <param name="offset">The rotation magnitude</param>
        </member>
        <member name="M:Z0.BitVector.rotr``1(Z0.BitVector{``0},System.Byte)">
            <summary>
            Rotates source bits rightward
            </summary>
            <param name="x">The source bitvector</param>
            <param name="offset">The rotation magnitude</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.rotr``2(Z0.BitVector{``0,``1},System.Byte)">
            <summary>
            Rotates source bits rightward
            </summary>
            <param name="x">The source bitvector</param>
            <param name="offset">The rotation magnitude</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.rotr``2(Z0.BitVector128{``0,``1}@,System.Byte)">
            <summary>
            Rotates source bits rightward
            </summary>
            <param name="x">The source bitvector</param>
            <param name="offset">The rotation magnitude</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.select``1(Z0.BitVector{``0},Z0.BitVector{``0},Z0.BitVector{``0})">
            <summary>
            Computes the bitwise ternary select for bitvector operands
            </summary>
            <param name="x">The pivot/mask vector</param>
            <param name="y">The primary choice</param>
            <param name="z">The alternative choice</param>
        </member>
        <member name="M:Z0.BitVector.select``2(Z0.BitVector{``0,``1},Z0.BitVector{``0,``1},Z0.BitVector{``0,``1})">
            <summary>
            Computes the bitvector z := x ^ y from bitvectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.select``2(Z0.BitVector128{``0,``1}@,Z0.BitVector128{``0,``1}@,Z0.BitVector128{``0,``1}@)">
            <summary>
            Computes the bitvector z := x ^ y from bitvectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.BitVector.sll(Z0.BitVector4,System.Byte)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitVector.sll(Z0.BitVector8,System.Byte)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitVector.sll(Z0.BitVector16,System.Byte)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitVector.sll(Z0.BitVector32,System.Byte)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitVector.sll(Z0.BitVector64,System.Byte)" -->
        <!-- Badly formed XML comment ignored for member "M:Z0.BitVector.sll``1(Z0.BitVector{``0},System.Byte)" -->
        <member name="M:Z0.BitVector.sll``2(Z0.BitVector{``0,``1},System.Byte)">
            <summary>
            Computes z := x >> s for a bitvector x and shift offset s
            </summary>
            <param name="x">The source bitvector</param>
            <param name="offset">The shift amount</param>
        </member>
        <member name="M:Z0.BitVector.sll``2(Z0.BitVector128{``0,``1}@,System.Byte)">
            <summary>
            Computes z := x >> s for a bitvector x and shift offset s
            </summary>
            <param name="x">The source bitvector</param>
            <param name="offset">The shift amount</param>
        </member>
        <member name="M:Z0.BitVector.srl(Z0.BitVector4,System.Byte)">
            <summary>
            Computes z := x >> s for a bitvector x and shift offset s
            </summary>
            <param name="x">The source bitvector</param>
            <param name="offset">The shift amount</param>
        </member>
        <member name="M:Z0.BitVector.srl(Z0.BitVector8,System.Byte)">
            <summary>
            Computes z := x >> s for a bitvector x and shift offset s
            </summary>
            <param name="x">The source bitvector</param>
            <param name="offset">The shift amount</param>
        </member>
        <member name="M:Z0.BitVector.srl(Z0.BitVector16,System.Byte)">
            <summary>
            Computes z := x >> s for a bitvector x and shift offset s
            </summary>
            <param name="x">The source bitvector</param>
            <param name="offset">The shift amount</param>
        </member>
        <member name="M:Z0.BitVector.srl(Z0.BitVector32,System.Byte)">
            <summary>
            Computes z := x >> s for a bitvector x and shift offset s
            </summary>
            <param name="x">The source bitvector</param>
            <param name="offset">The shift amount</param>
        </member>
        <member name="M:Z0.BitVector.srl(Z0.BitVector64,System.Byte)">
            <summary>
            Computes z := x >> s for a bitvector x and shift offset s
            </summary>
            <param name="x">The source bitvector</param>
            <param name="offset">The shift amount</param>
        </member>
        <member name="M:Z0.BitVector.srl``1(Z0.BitVector{``0},System.Byte)">
            <summary>
            Computes z := x >> s for a bitvector x and shift offset s
            </summary>
            <param name="x">The source bitvector</param>
            <param name="offset">The shift amount</param>
        </member>
        <member name="M:Z0.BitVector.srl``2(Z0.BitVector{``0,``1},System.Byte)">
            <summary>
            Computes z := x >> s for a bitvector x and shift offset s
            </summary>
            <param name="x">The source bitvector</param>
            <param name="offset">The shift amount</param>
        </member>
        <member name="M:Z0.BitVector.srl``2(Z0.BitVector128{``0,``1}@,System.Byte)">
            <summary>
            Computes z := x >> s for a bitvector x and shift offset s
            </summary>
            <param name="x">The source bitvector</param>
            <param name="offset">The shift amount</param>
        </member>
        <member name="M:Z0.BitVector.sub(Z0.BitVector4,Z0.BitVector4)">
            <summary>
            Computes the arithmetic difference z := x - y for bitvectors x and y
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.sub(Z0.BitVector8,Z0.BitVector8)">
            <summary>
            Computes the arithmetic difference z := x - y for bitvectors x and y
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.sub(Z0.BitVector16,Z0.BitVector16)">
            <summary>
            Computes the arithmetic difference z := x - y for bitvectors x and y
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.sub(Z0.BitVector32,Z0.BitVector32)">
            <summary>
            Computes the arithmetic difference z := x - y for bitvectors x and y
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.sub(Z0.BitVector64,Z0.BitVector64)">
            <summary>
            Computes the arithmetic difference z := x - y for bitvectors x and y
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.sub``1(Z0.BitVector{``0},Z0.BitVector{``0})">
            <summary>
            Computes the arithmetic difference z := x - y for generic bitvectors x and y
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.sub``2(Z0.BitVector{``0,``1},Z0.BitVector{``0,``1})">
            <summary>
            Computes the bitvector z := ~(x ^ y) from bitvectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.symbols``2(Z0.BitVector{``1},System.Byte,System.Nullable{System.Int32})">
            <summary>
            Assumes that 
            1. The source vector is a symbol tape upon which fixed-width symbols are sequentially recorded
            2. The symbol alphabet is defined by the last character of the literals defined by an enumeration
            With these preconditions, the operation returns the ordered sequence of symbols written to the tape
            </summary>
            <param name="src">The source bitvector</param>
            <param name="segwidth">The number of bits designated to represent/define a symbol value</param>
            <param name="maxbits">The maximum number bits to use if less than the bit width of the vector</param>
            <typeparam name="E">The enumeration type that defines the symbols</typeparam>
            <typeparam name="T">The primal bitvector cell type</typeparam>
        </member>
        <member name="M:Z0.BitVector.testbit``1(Z0.BitVector{``0},System.Byte)">
            <summary>
            Determines whether an index-identified bit is enabled
            </summary>
            <param name="first">The first bit position</param>
            <param name="last">The last bit position</param>
        </member>
        <member name="M:Z0.BitVector.testbit``2(Z0.BitVector{``0,``1},System.Byte)">
            <summary>
            Determines whether an index-identified bit is enabled
            </summary>
            <param name="first">The first bit position</param>
            <param name="last">The last bit position</param>
        </member>
        <member name="M:Z0.BitVector.testbit(Z0.BitVector4,System.Byte)">
            <summary>
            Determines whether a bit is enabled
            </summary>
            <param name="pos">The bit position</param>
        </member>
        <member name="M:Z0.BitVector.testbit(Z0.BitVector8,System.Byte)">
            <summary>
            Determines whether a bit is enabled
            </summary>
            <param name="pos">The bit position</param>
        </member>
        <member name="M:Z0.BitVector.testbit(Z0.BitVector16,System.Byte)">
            <summary>
            Determines whether a bit is enabled
            </summary>
            <param name="pos">The bit position</param>
        </member>
        <member name="M:Z0.BitVector.testbit(Z0.BitVector32,System.Byte)">
            <summary>
            Determines whether a bit is enabled
            </summary>
            <param name="pos">The bit position</param>
        </member>
        <member name="M:Z0.BitVector.testbit(Z0.BitVector64,System.Byte)">
            <summary>
            Determines whether a bit is enabled
            </summary>
            <param name="pos">The bit position</param>
        </member>
        <member name="M:Z0.BitVector.testc(Z0.BitVector8)">
            <summary>
            Returns true of all bits are enabled, false otherwise
            </summary>
        </member>
        <member name="M:Z0.BitVector.testc(Z0.BitVector16)">
            <summary>
            Returns true of all bits are enabled, false otherwise
            </summary>
        </member>
        <member name="M:Z0.BitVector.testc(Z0.BitVector32)">
            <summary>
            Returns true of all bits are enabled, false otherwise
            </summary>
        </member>
        <member name="M:Z0.BitVector.testc(Z0.BitVector64)">
            <summary>
            Returns true of all bits are enabled, false otherwise
            </summary>
        </member>
        <member name="M:Z0.BitVector.testc``1(Z0.BitVector{``0})">
            <summary>
            Returns true of all bits are enabled, false otherwise
            </summary>
        </member>
        <member name="M:Z0.BitVector.testc``2(Z0.BitVector{``0,``1},``0)">
            <summary>
            Returns true of all bits are enabled, false otherwise
            </summary>
        </member>
        <member name="M:Z0.BitVector.width(Z0.BitVector4)">
            <summary>
            Computes the effective width of the bitvector as determined by the number of leading zero bits
            </summary>
        </member>
        <member name="M:Z0.BitVector.width(Z0.BitVector8)">
            <summary>
            Computes the effective width of the bitvector as determined by the number of leading zero bits
            </summary>
        </member>
        <member name="M:Z0.BitVector.width(Z0.BitVector16)">
            <summary>
            Computes the effective width of the bitvector as determined by the number of leading zero bits
            </summary>
        </member>
        <member name="M:Z0.BitVector.width(Z0.BitVector64)">
            <summary>
            Computes the effective width of the bitvector as determined by the number of leading zero bits
            </summary>
        </member>
        <member name="M:Z0.BitVector.width``1(Z0.BitVector{``0})">
            <summary>
            Computes the effective width of the bitvector as determined by the number of leading zero bits
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.xnor``1(Z0.BitVector{``0},Z0.BitVector{``0})">
            <summary>
            Computes the bitvector z := ~(x ^ y) from bitvectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.xnor``2(Z0.BitVector{``0,``1},Z0.BitVector{``0,``1})">
            <summary>
            Computes the bitvector z := ~(x ^ y) from bitvectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.xnor``2(Z0.BitVector128{``0,``1}@,Z0.BitVector128{``0,``1}@)">
            <summary>
            Computes the bitvector z := ~(x ^ y) from bitvectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.xnor(Z0.BitVector4,Z0.BitVector4)">
            <summary>
            Computes the bitvector z := ~(x ^ y) from bitvectors x and y
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.xnor(Z0.BitVector8,Z0.BitVector8)">
            <summary>
            Computes the bitvector z := ~(x ^ y) from bitvectors x and y
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.xnor(Z0.BitVector16,Z0.BitVector16)">
            <summary>
            Computes the bitvector z := ~(x ^ y) from bitvectors x and y
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.xnor(Z0.BitVector32,Z0.BitVector32)">
            <summary>
            Computes the bitvector z := ~(x ^ y) from bitvectors x and y
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.xnor(Z0.BitVector64,Z0.BitVector64)">
            <summary>
            Computes the bitvector z := ~(x ^ y) from bitvectors x and y
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.xor``1(Z0.BitVector{``0},Z0.BitVector{``0})">
            <summary>
            Computes  z := x ^ y from bitvectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.xor``2(Z0.BitVector{``0,``1},Z0.BitVector{``0,``1})">
            <summary>
            Computes the bitvector z := x ^ y from bitvectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.xor``2(Z0.BitVector128{``0,``1}@,Z0.BitVector128{``0,``1}@)">
            <summary>
            Computes the bitvector z := x ^ y from bitvectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.BitVector.xor(Z0.BitVector4,Z0.BitVector4)">
            <summary>
            Computes  z := x ^ y from bitvectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector.xor(Z0.BitVector8,Z0.BitVector8)">
            <summary>
            Computes  z := x ^ y from bitvectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector.xor(Z0.BitVector16,Z0.BitVector16)">
            <summary>
            Computes  z := x ^ y from bitvectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector.xor(Z0.BitVector32,Z0.BitVector32)">
            <summary>
            Computes the bitvector z: = x ^ y from bitvectors x and y
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector.xor(Z0.BitVector64,Z0.BitVector64)">
            <summary>
            Computes  z := x ^ y from bitvectors x and y
            </summary>
            <param name="x">The left bitvector</param>
            <param name="y">The right bitvector</param>
        </member>
        <member name="M:Z0.BitVector.zero``1">
            <summary>
            Returns a generic vector with all bits disabled
            </summary>
            <typeparam name="T">The primal type upon which the vector is predicated</typeparam>
        </member>
        <member name="M:Z0.BitVector.zhi``1(Z0.BitVector{``0},System.Int32)">
            <summary>
            Disables the high bits starting at a specified position
            </summary>
            <param name="pos">The bit position</param>
        </member>
        <member name="M:Z0.BitVector.zhi``2(Z0.BitVector{``0,``1},System.Int32)">
            <summary>
            Disables the high bits starting at a specified position
            </summary>
            <param name="pos">The bit position</param>
        </member>
        <member name="M:Z0.BitVector.zhi``2(Z0.BitVector128{``0,``1}@)">
            <summary>
            Computes z := x >> s for a bitvector x and shift offset s
            </summary>
            <param name="x">The source bitvector</param>
            <param name="s">The shift amount</param>
        </member>
        <member name="M:Z0.BitVector.zhi(Z0.BitVector4,System.Int32)">
            <summary>
            Disables the high bits starting at a specified position
            </summary>
            <param name="pos">The bit position</param>
        </member>
        <member name="M:Z0.BitVector.zhi(Z0.BitVector8,System.Int32)">
            <summary>
            Disables the high bits starting at a specified position
            </summary>
            <param name="pos">The bit position</param>
        </member>
        <member name="M:Z0.BitVector.zhi(Z0.BitVector16,System.Int32)">
            <summary>
            Disables the high bits starting at a specified position
            </summary>
            <param name="pos">The bit position</param>
        </member>
        <member name="M:Z0.BitVector.zhi(Z0.BitVector32,System.Int32)">
            <summary>
            Disables the high bits starting at a specified position
            </summary>
            <param name="pos">The bit position</param>
        </member>
        <member name="M:Z0.BitVector.zhi(Z0.BitVector64,System.Int32)">
            <summary>
            Disables the high bits starting at a specified position
            </summary>
            <param name="pos">The bit position</param>
        </member>
        <member name="M:Z0.XTend.ToBitVector``1(Z0.BitString)">
            <summary>
            Constructs a generic bitvector from bitstring
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.XTend.ToBitVector(Z0.BitString,Z0.N4)">
            <summary>
            Constructs a 4-bit bitvector from bitstring
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.XTend.ToBitVector(Z0.BitString,Z0.N8)">
            <summary>
            Creates an 8-bit bitvector from bitstring
            </summary>
            <param name="src">The source bits</param>
        </member>
        <member name="M:Z0.XTend.ToBitVector(Z0.BitString,Z0.N16)">
            <summary>
            Creates a 16-bit bitvector from bitstring
            </summary>
            <param name="src">The source bits</param>
        </member>
        <member name="M:Z0.XTend.ToBitVector(Z0.BitString,Z0.N24)">
            <summary>
            Creates a 24-bit bitvector from bitstring
            </summary>
            <param name="src">The source bits</param>
        </member>
        <member name="M:Z0.XTend.ToBitVector(Z0.BitString,Z0.N32)">
            <summary>
            Creates a 32-bit bitvector from bitstring
            </summary>
            <param name="src">The source bits</param>
        </member>
        <member name="M:Z0.XTend.ToBitVector(Z0.BitString,Z0.N64)">
            <summary>
            Creates a 64-bit bitvector from bitstring
            </summary>
            <param name="src">The source bits</param>
        </member>
        <member name="M:Z0.XTend.ToBitVector``1(Z0.SpanBlock16{``0}@)">
            <summary>
            Creates a 16-bit bitvector from the leading cells of a source block
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The target width selector</param>
            <typeparam name="T">The primal cell type</typeparam>
        </member>
        <member name="M:Z0.XTend.ToBitVector``1(Z0.SpanBlock32{``0}@)">
            <summary>
            Creates a 16-bit bitvector from the leading cells of a source block
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The target width selector</param>
            <typeparam name="T">The primal cell type</typeparam>
        </member>
        <member name="M:Z0.XTend.ToBitVector``1(Z0.SpanBlock64{``0}@,Z0.N64)">
            <summary>
            Creates a 64-bit bitvector from the leading cells of a source block
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The target width selector</param>
            <typeparam name="T">The primal cell type</typeparam>
        </member>
        <member name="M:Z0.XTend.ToBitVector``1(Z0.SpanBlock256{``0}@,Z0.N8)">
            <summary>
            Creates an 8-bit bitvector from the leading cells of a source block
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The target width selector</param>
            <typeparam name="T">The primal cell type</typeparam>
        </member>
        <member name="M:Z0.XTend.ToBitVector``1(Z0.SpanBlock256{``0}@,Z0.N16)">
            <summary>
            Creates a 16-bit bitvector from the leading cells of a source block
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The target width selector</param>
            <typeparam name="T">The primal cell type</typeparam>
        </member>
        <member name="M:Z0.XTend.ToBitVector``1(Z0.SpanBlock256{``0}@,Z0.N32)">
            <summary>
            Creates a 32-bit bitvector from the leading cells of a source block
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The target width selector</param>
            <typeparam name="T">The primal cell type</typeparam>
        </member>
        <member name="M:Z0.XTend.ToBitVector``1(Z0.SpanBlock256{``0}@,Z0.N64)">
            <summary>
            Creates a 64-bit bitvector from the leading cells of a source block
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The target width selector</param>
            <typeparam name="T">The primal cell type</typeparam>
        </member>
        <member name="M:Z0.XTend.Concat(Z0.BitVector4,Z0.BitVector4)">
            <summary>
            Creates a new vector via concatenation
            </summary>
            <param name="tail">The lower bits of the new vector</param>
        </member>
        <member name="M:Z0.XTend.Concat(Z0.BitVector8,Z0.BitVector8)">
            <summary>
            Concatenates two 8-bit vectors to produce a 16-bit vector
            </summary>
            <param name="tail">The lower bits of the new vector</param>
        </member>
        <member name="M:Z0.XTend.Concat(Z0.BitVector16,Z0.BitVector16)">
            <summary>
            Concatenates two 16-bit vectors to produce a 32-bit vector
            </summary>
            <param name="tail">The lower bits of the new vector</param>
        </member>
        <member name="M:Z0.XTend.Concat(Z0.BitVector32,Z0.BitVector32)">
            <summary>
            Creates a new vector via concatenation
            </summary>
            <param name="tail">The lower bits of the new vector</param>
        </member>
        <member name="M:Z0.XTend.Format``2(Z0.BitVector{``0,``1},System.Nullable{Z0.BitFormat})">
            <summary>
            Formats the bitvector as a bitstring
            </summary>
            <param name="src">The source vector</param>
            <param name="fmt">Bitstring formatting specifications</param>
        </member>
        <member name="M:Z0.XTend.Format``1(Z0.BitVector{``0},System.Nullable{Z0.BitFormat})">
            <summary>
            Formats the bitvector as a bitstring
            </summary>
            <param name="src">The source vector</param>
            <param name="fmt">Bitstring formatting specifications</param>
        </member>
        <member name="M:Z0.XTend.Format``2(Z0.BitVector128{``0,``1},System.Nullable{Z0.BitFormat})">
            <summary>
            Formats the bitvector as a bitstring
            </summary>
            <param name="src">The source vector</param>
            <param name="fmt">Bitstring formatting specifications</param>
        </member>
        <member name="M:Z0.XTend.Format(Z0.BitVector4,System.Nullable{Z0.BitFormat})">
            <summary>
            Formats the bitvector as a bitstring
            </summary>
            <param name="src">The source vector</param>
            <param name="fmt">Bitstring formatting specifications</param>
        </member>
        <member name="M:Z0.XTend.Format(Z0.BitVector8,System.Nullable{Z0.BitFormat})">
            <summary>
            Formats the bitvector as a bitstring
            </summary>
            <param name="src">The source vector</param>
            <param name="fmt">Bitstring formatting specifications</param>
        </member>
        <member name="M:Z0.XTend.Format(Z0.BitVector32,System.Nullable{Z0.BitFormat})">
            <summary>
            Formats the bitvector as a bitstring
            </summary>
            <param name="src">The source vector</param>
            <param name="fmt">Bitstring formatting specifications</param>
        </member>
        <member name="M:Z0.XTend.Format(Z0.BitVector16,System.Nullable{Z0.BitFormat})">
            <summary>
            Formats the bitvector as a bitstring
            </summary>
            <param name="src">The source vector</param>
            <param name="fmt">Bitstring formatting specifications</param>
        </member>
        <member name="M:Z0.XTend.Format(Z0.BitVector24,System.Nullable{Z0.BitFormat})">
            <summary>
            Formats the bitvector as a bitstring
            </summary>
            <param name="src">The source vector</param>
            <param name="fmt">Bitstring formatting specifications</param>
        </member>
        <member name="M:Z0.XTend.Format(Z0.BitVector64,System.Nullable{Z0.BitFormat})">
            <summary>
            Formats the bitvector as a bitstring
            </summary>
            <param name="src">The source vector</param>
            <param name="fmt">Bitstring formatting specifications</param>
        </member>
        <member name="M:Z0.XTend.Order(Z0.BitVector8)">
            <summary>
            Computes the smallest integer n > 1 such that v^n = identity
            </summary>
        </member>
        <member name="M:Z0.XTend.Permute``1(Z0.BitVector{``0},Z0.Perm@)">
            <summary>
            Applies a permutation to a copy of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="p">The permutation</param>
            <typeparam name="T">The storage cell type</typeparam>
        </member>
        <member name="M:Z0.XTend.Permute``2(Z0.BitVector{``0,``1},Z0.Perm@)">
            <summary>
            Applies a permutation to a copy of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="p">The permutation</param>
        </member>
        <member name="M:Z0.XTend.Permute(Z0.BitVector4,Z0.Perm@)">
            <summary>
            Applies a permutation to copy of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="p">The permutation</param>
        </member>
        <member name="M:Z0.XTend.Permute(Z0.BitVector8,Z0.Perm@)">
            <summary>
            Applies a permutation to copy of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="p">The permutation</param>
        </member>
        <member name="M:Z0.XTend.Permute(Z0.BitVector16,Z0.Perm@)">
            <summary>
            Applies a permutation to copy of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="p">The permutation</param>
        </member>
        <member name="M:Z0.XTend.Permute(Z0.BitVector32,Z0.Perm@)">
            <summary>
            Applies a permutation to copy of the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="p">The permutation</param>
        </member>
        <member name="M:Z0.XTend.Permute(Z0.BitVector64,Z0.Perm@)">
            <summary>
            Applies a permutation to a replicated vector
            </summary>
            <param name="p">The permutation</param>
        </member>
        <member name="M:Z0.XTend.Replicate``1(Z0.BitVector{``0})">
            <summary>
            Creates a copy of the source vector
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The storage cell type</typeparam>
        </member>
        <member name="M:Z0.XTend.Replicate``2(Z0.BitVector{``0,``1})">
            <summary>
            Creates a copy of the source vector
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The storage cell type</typeparam>
        </member>
        <member name="M:Z0.XTend.Replicate``2(Z0.BitVector128{``0,``1})">
            <summary>
            Creates a copy of the source vector
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The storage cell type</typeparam>
        </member>
        <member name="M:Z0.XTend.Replicate(Z0.BitVector8)">
            <summary>
            Creates a copy of the vector
            </summary>
        </member>
        <member name="M:Z0.XTend.Replicate(Z0.BitVector4)">
            <summary>
            Creates a copy of the source vector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.XTend.Replicate(Z0.BitVector4,Z0.N2)">
            <summary>
            Concatenates a 4-bit vector with itself to produce a 8-bit vector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.XTend.Replicate(Z0.BitVector8,Z0.N2)">
            <summary>
            Concatenates an 8-bit vector with itself to produce a 16-bit vector
            </summary>
            <param name="x">The source vector</param>
            <param name="n">The duplication factor</param>
        </member>
        <member name="M:Z0.XTend.Replicate(Z0.BitVector8,Z0.N4)">
            <summary>
            Concatenates four copies of an 8-bit vector to produce a 32-bit vector
            </summary>
            <param name="x">The source vector</param>
            <param name="n">The duplication factor</param>
        </member>
        <member name="M:Z0.XTend.Replicate(Z0.BitVector8,Z0.N8)">
            <summary>
            Concatenates eight copies of an 8-bit vector to produce a 64-bit vector
            </summary>
            <param name="x">The source vector</param>
            <param name="n">The duplication factor</param>
        </member>
        <member name="M:Z0.XTend.Replicate(Z0.BitVector16)">
            <summary>
            Creates a copy of the vector
            </summary>
        </member>
        <member name="M:Z0.XTend.Replicate(Z0.BitVector16,Z0.N2)">
            <summary>
            Concatenates a 16-bit vector with itself to produce a 32-bit vector
            </summary>
            <param name="x">The source vector</param>
            <param name="n">The duplication factor</param>
        </member>
        <member name="M:Z0.XTend.Replicate(Z0.BitVector16,Z0.N4)">
            <summary>
            Creates a 64-bit vector by concatenating 4 source replicants
            </summary>
            <param name="x">The source vector</param>
            <param name="n">The duplication factor</param>
        </member>
        <member name="M:Z0.XTend.Replicate(Z0.BitVector32)">
            <summary>
            Creates a copy of the source vector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.XTend.Replicate(Z0.BitVector32,Z0.N2)">
            <summary>
            Creates a 64-bit vector by concatenating the source vector with a replicant
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.XTend.Replicate(Z0.BitVector64)">
            <summary>
            Creates a copy of the source vector
            </summary>
        </member>
        <member name="M:Z0.XTend.Reverse``1(Z0.BitVector{``0})">
            <summary>
            Reverses a copy of the source vector
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="T">The storage cell type</typeparam>
        </member>
        <member name="M:Z0.XTend.Reverse``2(Z0.BitVector{``0,``1})">
            <summary>
            Reverses the bits in the source vector
            </summary>
            <param name="x">The source vector</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.XTend.Reverse(Z0.BitVector4)">
            <summary>
            Reverses the vector bits
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.XTend.Reverse(Z0.BitVector8)">
            <summary>
            Reverses the vector bits
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.XTend.Reverse(Z0.BitVector16)">
            <summary>
            Reverses the vector bits
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.XTend.Reverse(Z0.BitVector32)">
            <summary>
            Reverses the vector bits
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.XTend.Reverse(Z0.BitVector64)">
            <summary>
            Reverses the vector bits
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.XTend.ToBitVector(System.UInt32,Z0.N16)">
            <summary>
            Defines a 16-bit bitvector from the lo 16 bits of the source
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.XTend.ToBitVector(System.Byte)">
            <summary>
            Constructs a canonical 8-bit bitvector from an 8-bit primal value
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.XTend.ToBitVector(System.UInt32)">
            <summary>
            Constructs a canonical 32-bit bitvector from a 32-bit primal value
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.XTend.ToBitVector(System.Int32)">
            <summary>
            Defines a 32-bit bitvector with content determined by a 32-bit usigned integer
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.XTend.ToBitVector(System.UInt16)">
            <summary>
            Constructs a 16-bit bitvector from a 16-bit scalar
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.XTend.ToBitVector(System.UInt64)">
            <summary>
            Constructs a 64-bit bitvector from a 64-bit primal value
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.XTend.ToBitVector(System.Byte,Z0.N24)">
            <summary>
            Creates a 24-bit bitvector from an 8-bit scalar
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.XTend.ToBitVector(System.UInt16,Z0.N24)">
            <summary>
            Creates a 24-bit bitvector from a 16-bit scalar
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.XTend.ToBitVector(System.UInt32,Z0.N24)">
            <summary>
            Creates a 24-bit bitvector from a 32-bit scalar
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.XTend.ToBitVector(System.UInt64,Z0.N24)">
            <summary>
            Creates a 24-bit bitvector from a 64-bit scalar
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.XTend.TestC``1(Z0.BitVector{``0})">
            <summary>
            Returns true of all bits are enabled, false otherwise
            </summary>
        </member>
        <member name="M:Z0.XTend.TestC``2(Z0.BitVector{``0,``1})">
            <summary>
            Returns true of all bits are enabled, false otherwise
            </summary>
        </member>
        <member name="M:Z0.XTend.TestC(Z0.BitVector8)">
            <summary>
            Returns true of all bits are enabled, false otherwise
            </summary>
        </member>
        <member name="M:Z0.XTend.TestC(Z0.BitVector16)">
            <summary>
            Returns true of all bits are enabled, false otherwise
            </summary>
        </member>
        <member name="M:Z0.XTend.TestC(Z0.BitVector32)">
            <summary>
            Returns true of all bits are enabled, false otherwise
            </summary>
        </member>
        <member name="M:Z0.XTend.TestC(Z0.BitVector64)">
            <summary>
            Returns true of all bits are enabled, false otherwise
            </summary>
        </member>
        <member name="M:Z0.XTend.ToBitSpan(Z0.BitVector4,System.Nullable{System.Int32})">
            <summary>
            Creates the vector's bitspan representation
            </summary>
            <param name="src">The source bitvector</param>
        </member>
        <member name="M:Z0.XTend.ToBitSpan(Z0.BitVector8,System.Nullable{System.Int32})">
            <summary>
            Creates the vector's bitspan representation
            </summary>
            <param name="src">The source bitvector</param>
        </member>
        <member name="M:Z0.XTend.ToBitSpan(Z0.BitVector16,System.Nullable{System.Int32})">
            <summary>
            Creates the vector's bitspan representation
            </summary>
            <param name="src">The source bitvector</param>
        </member>
        <member name="M:Z0.XTend.ToBitSpan(Z0.BitVector24,System.Nullable{System.Int32})">
            <summary>
            Creates the vector's bitspan representation
            </summary>
            <param name="src">The source bitvector</param>
        </member>
        <member name="M:Z0.XTend.ToBitSpan(Z0.BitVector32,System.Nullable{System.Int32})">
            <summary>
            Creates the vector's bitspan representation
            </summary>
            <param name="src">The source bitvector</param>
        </member>
        <member name="M:Z0.XTend.ToBitSpan(Z0.BitVector64,System.Nullable{System.Int32})">
            <summary>
            Creates the vector's bitspan representation
            </summary>
            <param name="src">The source bitvector</param>
        </member>
        <member name="M:Z0.XTend.ToBitString``2(Z0.BitVector128{``0,``1})">
            <summary>
            Converts the vector to a bitstring
            </summary>
        </member>
        <member name="M:Z0.XTend.ToBitString``2(Z0.BitVector{``0,``1})">
            <summary>
            Converts the vector content to a bitring representation
            </summary>
        </member>
        <member name="M:Z0.XTend.ToBitString``2(Z0.BitVector{``0,``1},System.Byte[])">
            <summary>
            Converts the vector content to a bitring representation
            </summary>
        </member>
        <member name="M:Z0.XTend.ToBitString``1(Z0.BitVector{``0})">
            <summary>
            Extracts the represented data as a bitstring
            </summary>
        </member>
        <member name="M:Z0.XTend.ToBitString``1(Z0.BitVector{``0},System.Int32)">
            <summary>
            Extracts the represented data as a bitstring truncated to a specified width
            </summary>
        </member>
        <member name="M:Z0.XTend.ToBitString(Z0.BitVector4)">
            <summary>
            Creates the vector's bitstring representation
            </summary>
            <param name="src">The source bitvector</param>
        </member>
        <member name="M:Z0.XTend.ToBitString(Z0.BitVector8)">
            <summary>
            Creates the vector's bitstring representation
            </summary>
            <param name="src">The source bitvector</param>
        </member>
        <member name="M:Z0.XTend.ToBitString(Z0.BitVector16)">
            <summary>
            Creates the vector's bitstring representation
            </summary>
            <param name="src">The source bitvector</param>
        </member>
        <member name="M:Z0.XTend.ToBitString(Z0.BitVector24)">
            <summary>
            Creates the vector's bitstring representation
            </summary>
            <param name="src">The source bitvector</param>
        </member>
        <member name="M:Z0.XTend.ToBitString(Z0.BitVector32)">
            <summary>
            Creates the vector's bitstring representation
            </summary>
            <param name="src">The source bitvector</param>
        </member>
        <member name="M:Z0.XTend.ToBitString(Z0.BitVector64)">
            <summary>
            Creates the vector's bitstring representation
            </summary>
            <param name="src">The source bitvector</param>
        </member>
        <member name="M:Z0.XTend.ToGeneric(Z0.BitVector8)">
            <summary>
            Converts the source bitvector to an equivalent generic bitvector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.XTend.ToGeneric(Z0.BitVector16)">
            <summary>
            Converts the source bitvector to an equivalent generic bitvector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.XTend.ToGeneric(Z0.BitVector32)">
            <summary>
            Converts the source bitvector to an equivalent generic bitvector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.XTend.ToGeneric(Z0.BitVector64)">
            <summary>
            Converts the source bitvector to an equivalent generic bitvector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.XTend.ToNatural(Z0.BitVector4)">
            <summary>
            Converts the source bitvector to an equivalent natural bitvector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.XTend.ToNatural(Z0.BitVector8)">
            <summary>
            Converts the source bitvector to an equivalent natural bitvector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.XTend.ToNatural(Z0.BitVector32)">
            <summary>
            Converts the source bitvector to an equivalent natural/generic bitvector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.XTend.ToNatural(Z0.BitVector64)">
            <summary>
            Converts the source bitvector to an equivalent natural/generic bitvector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.XTend.ToNatural``2(Z0.BitVector{``1},``0)">
            <summary>
            Converts a generic bitvector to natural bitvector
            </summary>
            <param name="src">The source vector</param>
            <typeparam name="N">The natural type</typeparam>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.Gf.Poly``1(System.Byte[])">
            <summary>
            Defines a binary polynomial from a monotonically decreasing exponent sequence
            </summary>
            <param name="exponents">The exponent sequence</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.Gf.Poly16(System.Byte[])">
            <summary>
            Defines a binary polynomial of degree at most 15 from a monotonically decreasing exponent sequence
            </summary>
            <param name="exponents">The exponent sequence</param>
            <typeparam name="T">The primal type</typeparam>
        </member>
        <member name="M:Z0.Gf.Poly``2(System.Byte[])">
            <summary>
            Defines a binary polynomial of natural degree N
            </summary>
            <param name="exponents">The exponent values for nonzero coefficients</param>
            <typeparam name="N">The degree of the polynomial</typeparam>
            <typeparam name="T">The polynomial scalar type</typeparam>
        </member>
        <member name="M:Z0.Gf.Poly(Z0.N3,System.Byte[])">
            <summary>
            Defines a binary polynomial of natural degree N = 3
            </summary>
            <param name="degree">The degree of the polynomial</param>
            <param name="exponents">The exponent values for nonzero coefficients</param>
        </member>
        <member name="M:Z0.Gf.Poly(Z0.N8,System.Byte[])">
            <summary>
            Defines a binary polynomial of natural degree N = 8
            </summary>
            <param name="degree">The degree of the polynomial</param>
            <param name="exponents">The exponent values for nonzero coefficients</param>
        </member>
        <member name="M:Z0.Gf.Poly(Z0.N16,System.Byte[])">
            <summary>
            Defines a binary polynomial of natural degree N = 10
            </summary>
            <param name="degree">The degree of the polynomial</param>
            <param name="exponents">The exponent values for nonzero coefficients</param>
        </member>
        <member name="M:Z0.Gf.Poly(Z0.N32,System.Byte[])">
            <summary>
            Defines a binary polynomial of natural degree N = 32
            </summary>
            <param name="degree">The degree of the polynomial</param>
            <param name="exponents">The exponent values for nonzero coefficients</param>
        </member>
        <member name="M:Z0.Gf256.clmul(System.Byte,System.Byte)">
            <summary>
            Computes the GF(256) product reduced by the canonical polynomial
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.Gf256.products(System.Byte,System.Byte,System.Byte@)">
            <summary>
            Fills caller-allocated memory with a GF(256) multiplication table
            </summary>
            <param name="min">The minimum operand value</param>
            <param name="max">The maximum operand value</param>
        </member>
        <member name="M:Z0.Gf256.products``1(``0)">
            <summary>
            Creates an N^2 multiplication table for the values [1...N]
            </summary>
            <typeparam name="N">The table order</typeparam>
        </member>
        <member name="M:Z0.Gf256.products(Z0.Matrix256{Z0.N256,System.Byte}@)">
            <summary>
            Computes the full multiplication table for GF(256) modulo the canonical polynomial
            </summary>
            <param name="dst">The target matrix</param>
        </member>
        <member name="M:Z0.Gf256.mul_ref(System.Byte,System.Byte)">
            <summary>
            The reference (slow) implementation of GF(256) multiplication reduced
            via the canonical polynomial
            </summary>
            <param name="a">The left operand</param>
            <param name="b">The right operand</param>
        </member>
        <member name="M:Z0.Gf512.products(Z0.Matrix256{Z0.N512,System.UInt16}@)">
            <summary>
            Computes the full multiplication table for GF512
            </summary>
            <param name="dst">The target matrix</param>
        </member>
        <member name="M:Z0.Gf8.products(System.Byte,System.Byte,System.Byte@)">
            <summary>
            Fills caller-allocated memory with a multiplication table
            </summary>
            <param name="min">The minimum operand value</param>
            <param name="max">The maximum operand value</param>
        </member>
        <member name="M:Z0.Gf8.products">
            <summary>
            Creates a complete multiplication table
            </summary>
            <param name="min">The minimum operand value</param>
            <param name="max">The maximum operand value</param>
        </member>
        <member name="T:Z0.GfPoly">
            <summary>
            Primitive polynomials for GF reduction
            </summary>
            <remarks>The tables at https://www.partow.net/programming/polynomials/index.html were used for the source data</remarks>
        </member>
        <member name="F:Z0.GfPoly.Gfp_2_1_0">
            <summary>
            x^2 + x^1 + x^0
            </summary>
        </member>
        <member name="F:Z0.GfPoly.Gfp_3_1_0">
            <summary>
            x^3 + x^1 + x^0
            </summary>
        </member>
        <member name="F:Z0.GfPoly.Gfp_4_1_0">
            <summary>
            x^4 + x^1 + x^0
            </summary>
        </member>
        <member name="F:Z0.GfPoly.Gfp_5_2_0">
            <summary>
            x^5 + x^2 + x^0
            </summary>
        </member>
        <member name="F:Z0.GfPoly.Gfp_6_1_0">
            <summary>
            x^6 + x^1 + x^0
            </summary>
        </member>
        <member name="F:Z0.GfPoly.Gfp_7_1_0">
            <summary>
            x^7 + x^1 + x^0
            </summary>
        </member>
        <member name="F:Z0.GfPoly.Gfp_8_4_3_2_0">
            <summary>
            x^8 + x^4 + x^3 + x^2 + x^0
            0b1_0001_1101
            </summary>
        </member>
        <member name="F:Z0.GfPoly.Gfp_9_4_0">
            <summary>
            x^9 + x^4 + x^0
            </summary>
        </member>
        <member name="F:Z0.GfPoly.Gfp_10_3_0">
            <summary>
            x^10 + x^3 + x^0
            </summary>
        </member>
        <member name="F:Z0.GfPoly.Gfp_11_2_1">
            <summary>
            x^11 + x^2 + x^0
            </summary>
        </member>
        <member name="F:Z0.GfPoly.Gfp_16_9_8_7_6_4_3_2_0">
            <summary>
            x^16 + x^9 + x^8 + x^7 + x^6 + x^4 + x^3 + x^2 + x^0
            </summary>
        </member>
        <member name="F:Z0.GfPoly.Gfp_32_22_2_1_0">
            <summary>
            x^32 + x^22 + x^2 + x^1 + x^0
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.GfPoly.Lookup``2(``0,``1)" -->
        <member name="T:Z0.GfPoly16">
            <summary>
            Represents a base-2 polynomial of degree at most N = 15. The represented polynomial is of the form
            a_i * x^i + . . . a_1 * x^1 + a_0 * x^0 where  a_i = 0 | 1 and i = 0..N
            </summary>
        </member>
        <member name="P:Z0.GfPoly16.Item(System.Byte)">
            <summary>
            Returns a bit indicating whether the coefficient for x^i is 1 or 0
            </summary>
        </member>
        <member name="P:Z0.GfPoly16.Scalar">
            <summary>
            Returns the scalar representation of the polynomial
            </summary>
        </member>
        <member name="P:Z0.GfPoly16.Degree">
            <summary>
            The degree (N) of the polynomial
            </summary>
        </member>
        <member name="P:Z0.GfPoly16.Nonzero">
            <summary>
            Specifies whether the polynomial is the zero polynomial
            </summary>
        </member>
        <member name="M:Z0.GfPoly16.ToBitVector">
            <summary>
            Converts the polynomial to a bitvector
            </summary>
        </member>
        <member name="M:Z0.GfPoly16.ToNatPoly">
            <summary>
            Converts the polynomial to a representation with natural degree
            </summary>
        </member>
        <member name="M:Z0.GfPoly16.Format">
            <summary>
            Formats the polynomial
            </summary>
        </member>
        <member name="T:Z0.GfPoly`2">
            <summary>
            Represents a base-2 polynomial of degree N. The represented polynomial is of the form
            a_i * x^i + . . . a_1 * x^1 + a_0 * x^0 where  a_i = 0 | 1 and i = 0..N
            </summary>
        </member>
        <member name="P:Z0.GfPoly`2.Item(System.Byte)">
            <summary>
            Returns a bit indicating whether the coefficient for x^i is 1 or 0
            </summary>
        </member>
        <member name="P:Z0.GfPoly`2.Scalar">
            <summary>
            Returns the scalar representation of the polynomial
            </summary>
        </member>
        <member name="P:Z0.GfPoly`2.Degree">
            <summary>
            The degree (N) of the polynomial
            </summary>
        </member>
        <member name="P:Z0.GfPoly`2.Nonzero">
            <summary>
            Specfies whether the polynomial is the zero polynomial
            </summary>
        </member>
        <member name="M:Z0.GfPoly`2.Format(System.Nullable{System.Char})">
            <summary>
            Formats the polynomial
            </summary>
        </member>
        <member name="M:Z0.BvUtil.packseq(System.ReadOnlySpan{System.Byte},System.Byte@)">
            <summary>
            Packs a bitsequence determined by the first 8 (or fewer) bytes from the source into a single byte
            </summary>
            <param name="src">The source sequence</param>
        </member>
        <member name="M:Z0.BvUtil.packseq(System.ReadOnlySpan{System.Byte},System.UInt16@)">
            <summary>
            Packs a bitsequence determined by the first 16 (or fewer) bytes from the source into an unsigned short
            </summary>
            <param name="src">The source sequence</param>
        </member>
        <member name="M:Z0.BvUtil.packseq(System.ReadOnlySpan{System.Byte},System.UInt32@)">
            <summary>
            Packs a bitsequence determined by the first 32 (or fewer) bytes from the source into an unsigned int
            </summary>
            <param name="src">The source sequence</param>
        </member>
        <member name="M:Z0.BvUtil.packseq(System.ReadOnlySpan{System.Byte},System.UInt64@)">
            <summary>
            Packs a bitsequence determined by the first 64 (or fewer) bytes from the source into an unsigned long
            </summary>
            <param name="src">The source sequence</param>
        </member>
        <member name="M:Z0.BvRng.BitVector(Z0.IDomainValues,Z0.N4)">
            <summary>
            Produces a 4-bit primal bitvector predicated on a random source
            </summary>
            <param name="random">The random source</param>
            <param name="n">The primal bitvector selector</param>
        </member>
        <member name="M:Z0.BvRng.BitVector(Z0.IPolySource,Z0.N8)">
            <summary>
            Produces an 8-bit primal bitvector predicated on a random source
            </summary>
            <param name="random">The random source</param>
            <param name="n">The primal bitvector selector</param>
        </member>
        <member name="M:Z0.BvRng.BitVector(Z0.IPolySource,Z0.N8,System.Byte)">
            <summary>
            Produces an 8-bit primal bitvector of a specified maximal effective width
            </summary>
            <param name="random">The random source</param>
            <param name="n">The primal bitvector selector</param>
            <param name="wmax">The effective width</param>
        </member>
        <member name="M:Z0.BvRng.BitVector(Z0.IPolySource,Z0.N16)">
            <summary>
            Produces a 16-bit primal bitvector
            </summary>
            <param name="random">The random source</param>
            <param name="n">The primal bitvector selector</param>
        </member>
        <member name="M:Z0.BvRng.BitVector(Z0.IPolySource,Z0.N16,System.Byte)">
            <summary>
            Produces a 16-bit primal bitvector of a specified maximal effective width
            </summary>
            <param name="random">The random source</param>
            <param name="n">The primal bitvector selector</param>
            <param name="wmax">The effected width</param>
        </member>
        <member name="M:Z0.BvRng.BitVector(Z0.IPolySource,Z0.N32)">
            <summary>
            Produces a 32-bit primal bitvector
            </summary>
            <param name="random">The random source</param>
            <param name="n">The primal bitvector selector</param>
        </member>
        <member name="M:Z0.BvRng.BitVector(Z0.IPolySource,Z0.N32,System.Byte)">
            <summary>
            Produces a 32-bit primal bitvector of a specified maximal effective width
            </summary>
            <param name="random">The random source</param>
            <param name="n">The primal bitvector selector</param>
            <param name="wmax">The maximum effected width</param>
        </member>
        <member name="M:Z0.BvRng.BitVector(Z0.IPolySource,Z0.N64)">
            <summary>
            Produces a 64-bit primal bitvector
            </summary>
            <param name="random">The random source</param>
            <param name="n">The primal bitvector selector</param>
        </member>
        <member name="M:Z0.BvRng.BitVector(Z0.IPolySource,Z0.N64,System.Byte)">
            <summary>
            Produces a 64-bit primal bitvector of maximal effective width
            </summary>
            <param name="random">The random source</param>
            <param name="n">The primal bitvector selector</param>
            <param name="wmax">The maximum effected width</param>
        </member>
        <member name="M:Z0.BvRng.BitVector(Z0.IPolyrand,Z0.N128)">
            <summary>
            Produces a 128-bit primal bitvector
            </summary>
            <param name="random">The random source</param>
            <param name="n">The primal bitvector selector</param>
        </member>
        <member name="M:Z0.BvRng.BitVectors(Z0.IPolyrand,Z0.N4)">
            <summary>
            Produces a stream of random 4-bit bitvectors
            </summary>
            <param name="random">The random source</param>
        </member>
        <member name="M:Z0.BvRng.BitVector``1(Z0.IPolyrand)">
            <summary>
            Produces a generic bitvector
            </summary>
            <param name="random">The random source</param>
            <typeparam name="T">The underlying primal type</typeparam>
        </member>
        <member name="M:Z0.BvRng.BitVector``1(Z0.IPolyrand,System.Int32)">
            <summary>
            Produces a generic bitvector of a specified maximum effective width
            </summary>
            <param name="random">The random source</param>
            <typeparam name="T">The underlying primal type</typeparam>
        </member>
        <member name="M:Z0.BvRng.BitVector``2(Z0.IPolySource,``0,``1)">
            <summary>
            Produces a natural bitvector
            </summary>
            <param name="random">The random source</param>
            <param name="n">The bit width selector</param>
            <typeparam name="N">The bit width type</typeparam>
            <typeparam name="T">The underlying primal type</typeparam>
        </member>
        <member name="T:Z0.BitVectorLogix">
            <summary>
            Implements reference bitvector operations
            </summary>
        </member>
        <member name="M:Z0.BitVectorLogix.and``1(Z0.BitVector{``0},Z0.BitVector{``0})">
            <summary>
            Computes the bitwise AND of the source vetors via component-wise logical operations to define a reference implementation
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <typeparam name="T">The primal scalar upon which the bitvector is predicated</typeparam>
        </member>
        <member name="M:Z0.BitVectorLogix.nand``1(Z0.BitVector{``0},Z0.BitVector{``0})">
            <summary>
            Computes the bitwise AND of the source vetors via component-wise logical operations to define a reference implementation
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <typeparam name="T">The primal scalar upon which the bitvector is predicated</typeparam>
        </member>
        <member name="M:Z0.BitVectorLogix.or``1(Z0.BitVector{``0},Z0.BitVector{``0})">
            <summary>
            Computes the bitwise OR of the source vetors via component-wise logical operations to define a reference implementation
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <typeparam name="T">The primal scalar upon which the bitvector is predicated</typeparam>
        </member>
        <member name="M:Z0.BitVectorLogix.nor``1(Z0.BitVector{``0},Z0.BitVector{``0})">
            <summary>
            Computes the bitwise OR of the source vetors via component-wise logical operations to define a reference implementation
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <typeparam name="T">The primal scalar upon which the bitvector is predicated</typeparam>
        </member>
        <member name="M:Z0.BitVectorLogix.xor``1(Z0.BitVector{``0},Z0.BitVector{``0})">
            <summary>
            Computes the bitwise XOR of the source vetors via component-wise logical operations to define a reference implementation
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <typeparam name="T">The primal scalar upon which the bitvector is predicated</typeparam>
        </member>
        <member name="M:Z0.BitVectorLogix.xnor``1(Z0.BitVector{``0},Z0.BitVector{``0})">
            <summary>
            Computes the bitwise XOR of the source vetors via component-wise logical operations to define a reference implementation
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <typeparam name="T">The primal scalar upon which the bitvector is predicated</typeparam>
        </member>
        <member name="M:Z0.BitVectorLogix.lnot``1(Z0.BitVector{``0},Z0.BitVector{``0})">
            <summary>
            Computes the bitwise LeftNot of the source vetors via component-wise logical operations to define a reference implementation
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <typeparam name="T">The primal scalar upon which the bitvector is predicated</typeparam>
        </member>
        <member name="M:Z0.BitVectorLogix.rnot``1(Z0.BitVector{``0},Z0.BitVector{``0})">
            <summary>
            Computes the bitwise LeftNot of the source vetors via component-wise logical operations to define a reference implementation
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <typeparam name="T">The primal scalar upon which the bitvector is predicated</typeparam>
        </member>
        <member name="M:Z0.BitVectorLogix.impl``1(Z0.BitVector{``0},Z0.BitVector{``0})">
            <summary>
            Computes the bitwise Impliction of the source vetors via component-wise logical operations to define a reference implementation
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <typeparam name="T">The primal scalar upon which the bitvector is predicated</typeparam>
        </member>
        <member name="M:Z0.BitVectorLogix.nonimpl``1(Z0.BitVector{``0},Z0.BitVector{``0})">
            <summary>
            Computes the bitwise NotImpliction of the source vetors via component-wise logical operations to define a reference implementation
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <typeparam name="T">The primal scalar upon which the bitvector is predicated</typeparam>
        </member>
        <member name="M:Z0.BitVectorLogix.cimpl``1(Z0.BitVector{``0},Z0.BitVector{``0})">
            <summary>
            Computes the bitwise ConverseImpliction of the source vetors via component-wise logical operations to define a reference implementation
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <typeparam name="T">The primal scalar upon which the bitvector is predicated</typeparam>
        </member>
        <member name="M:Z0.BitVectorLogix.cnonimpl``1(Z0.BitVector{``0},Z0.BitVector{``0})">
            <summary>
            Computes the bitwise ConverseImpliction of the source vetors via component-wise logical operations to define a reference implementation
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
            <typeparam name="T">The primal scalar upon which the bitvector is predicated</typeparam>
        </member>
        <member name="P:Z0.IScalarBits`1.Scalar">
            <summary>
            The value over which the bitvector is defined
            </summary>
        </member>
        <member name="P:Z0.IBitVector.Bytes">
            <summary>
            Presents bitvector content as a bytespan
            </summary>
        </member>
        <member name="M:Z0.IBitVector.Byte(System.UInt32)">
            <summary>
            Selects an index-identified mutable 8-bit segment from the source vector
            </summary>
            <param name="index">The byte-relative segment index</param>
        </member>
        <member name="T:Z0.BitVector128`2">
            <summary>
            Defines a natural bitvector over an intrinsic vector
            </summary>
            <typeparam name="T">The cell type</typeparam>
            <typeparam name="N">The bit-width type</typeparam>
        </member>
        <member name="M:Z0.BitVector128`2.op_Implicit(System.Runtime.Intrinsics.Vector128{`1})~Z0.BitVector128{`0,`1}">
            <summary>
            Implicitly convers a scalar to a bitvector
            </summary>
            <param name="src">The scalar value</param>
        </member>
        <member name="M:Z0.BitVector128`2.op_Implicit(Z0.BitVector128{`0,`1})~System.Runtime.Intrinsics.Vector128{`1}">
            <summary>
            Implicitly convers a bitvector to its scalar representation
            </summary>
            <param name="src">The scalar value</param>
        </member>
        <member name="M:Z0.BitVector128`2.op_BitwiseAnd(Z0.BitVector128{`0,`1}@,Z0.BitVector128{`0,`1}@)">
            <summary>
            Computes the bitwise AND between the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector128`2.op_BitwiseOr(Z0.BitVector128{`0,`1}@,Z0.BitVector128{`0,`1}@)">
            <summary>
            Computes the bitwise AND between the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector128`2.op_ExclusiveOr(Z0.BitVector128{`0,`1}@,Z0.BitVector128{`0,`1}@)">
            <summary>
            Computes the bitwise XOR between the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector128`2.op_Modulus(Z0.BitVector128{`0,`1}@,Z0.BitVector128{`0,`1}@)">
            <summary>
            Computes the scalar product of the operands
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.BitVector128`2.op_OnesComplement(Z0.BitVector128{`0,`1}@)">
            <summary>
            Computes the bitwise complement of the operand
            </summary>
            <param name="x">The source operand</param>
        </member>
        <member name="M:Z0.BitVector128`2.op_UnaryNegation(Z0.BitVector128{`0,`1}@)">
            <summary>
            Computes the two's complement negation of the operand
            </summary>
            <param name="x">The source operand</param>
        </member>
        <member name="M:Z0.BitVector128`2.op_LeftShift(Z0.BitVector128{`0,`1}@,System.Int32)">
            <summary>
            Shifts the source bits leftwards
            </summary>
            <param name="x">The source operand</param>
        </member>
        <member name="M:Z0.BitVector128`2.op_RightShift(Z0.BitVector128{`0,`1}@,System.Int32)">
            <summary>
            Shifts the source bits rightwards
            </summary>
            <param name="x">The source operand</param>
        </member>
        <member name="M:Z0.BitVector128`2.op_True(Z0.BitVector128{`0,`1}@)">
            <summary>
            Returns true if the source vector is nonzero, false otherwise
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector128`2.op_False(Z0.BitVector128{`0,`1}@)">
            <summary>
            Returns false if the source vector is the zero vector, false otherwise
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector128`2.op_Equality(Z0.BitVector128{`0,`1}@,Z0.BitVector128{`0,`1}@)">
            <summary>
            Determines whether operand content is identical
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector128`2.op_Inequality(Z0.BitVector128{`0,`1}@,Z0.BitVector128{`0,`1}@)">
            <summary>
            Determines whether operand content is non-identical
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector128`2.#ctor(System.Runtime.Intrinsics.Vector128{`1})">
            <summary>
            Initializes a bitvector with the lo N bits of a scalar source
            </summary>
            <param name="data">The scalar source value</param>
        </member>
        <member name="P:Z0.BitVector128`2.Content">
            <summary>
            The scalar representation of the vector
            </summary>
        </member>
        <member name="P:Z0.BitVector128`2.Width">
            <summary>
            The bitvector's natural width
            </summary>
        </member>
        <member name="P:Z0.BitVector128`2.Lo">
            <summary>
            The bitvector's lower 64 bits
            </summary>
        </member>
        <member name="P:Z0.BitVector128`2.Hi">
            <summary>
            The bitvector's upper 64 bits
            </summary>
        </member>
        <member name="P:Z0.BitVector128`2.Empty">
            <summary>
            Specifies whether all bits are disabled
            </summary>
        </member>
        <member name="P:Z0.BitVector128`2.NonEmpty">
            <summary>
            Specifies whether at least one bit is enabled
            </summary>
        </member>
        <member name="T:Z0.BitVector16">
            <summary>
            Defines a 16-bit bitvector
            </summary>
        </member>
        <member name="M:Z0.BitVector16.op_BitwiseAnd(Z0.BitVector16,Z0.BitVector16)">
            <summary>
            Computes the bitwise AND of the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector16.op_BitwiseOr(Z0.BitVector16,Z0.BitVector16)">
            <summary>
            Computes the bitwise OR of the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector16.op_ExclusiveOr(Z0.BitVector16,Z0.BitVector16)">
            <summary>
            Computes the bitwise XOR of the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector16.op_OnesComplement(Z0.BitVector16)">
            <summary>
            Computes the bitwise complement of the operand.
            </summary>
            <param name="x">The source operand</param>
        </member>
        <member name="M:Z0.BitVector16.op_Addition(Z0.BitVector16,Z0.BitVector16)">
            <summary>
            Computes the arithmetic sum of the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector16.op_UnaryNegation(Z0.BitVector16)">
            <summary>
            Computes the two's complement of the operand
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector16.op_Subtraction(Z0.BitVector16,Z0.BitVector16)">
            <summary>
            Computes the arithmetic difference between the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector16.op_Modulus(Z0.BitVector16,Z0.BitVector16)">
            <summary>
            Computes the scalar product of the operands
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.BitVector16.op_LeftShift(Z0.BitVector16,System.Int32)">
            <summary>
            Left-shifts the bits in the source
            </summary>
            <param name="x">The source operand</param>
        </member>
        <member name="M:Z0.BitVector16.op_RightShift(Z0.BitVector16,System.Int32)">
            <summary>
            Right-shifts the bits in the source
            </summary>
            <param name="x">The source operand</param>
        </member>
        <member name="M:Z0.BitVector16.op_Increment(Z0.BitVector16)">
            <summary>
            Arithmetically increments the source vector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector16.op_Decrement(Z0.BitVector16)">
            <summary>
            Arithmetically decrements the source vector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector16.op_True(Z0.BitVector16)">
            <summary>
            Returns true if the source vector is nonzero, false otherwise
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector16.op_False(Z0.BitVector16)">
            <summary>
            Returns false if the source vector is the zero vector, false otherwise
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector16.op_LogicalNot(Z0.BitVector16)">
            <summary>
            Computes the operand's logical negation: if x = 0 then 1 else 0
            </summary>
            <param name="src">The ource operand</param>
        </member>
        <member name="M:Z0.BitVector16.op_Equality(Z0.BitVector16,Z0.BitVector16)">
            <summary>
            Determines whether operand content is identical
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector16.op_Inequality(Z0.BitVector16,Z0.BitVector16)">
            <summary>
            Determines whether operand content is non-identical
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector16.op_LessThan(Z0.BitVector16,Z0.BitVector16)">
            <summary>
            Determines whether the left operand is arithmetically less than the second
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector16.op_GreaterThan(Z0.BitVector16,Z0.BitVector16)">
            <summary>
            Determines whether the left operand is arithmetically greater than the second
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector16.op_LessThanOrEqual(Z0.BitVector16,Z0.BitVector16)">
            <summary>
            Determines whether the left operand is arithmetically less than or equal to the second
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector16.#ctor(System.UInt16)">
            <summary>
            Initializes the vector with the source value it represents
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="P:Z0.BitVector16.Scalar">
            <summary>
            Extracts the scalar represented by the vector
            </summary>
        </member>
        <member name="P:Z0.BitVector16.Width">
            <summary>
            The number of bits represented by the vector
            </summary>
        </member>
        <member name="P:Z0.BitVector16.Empty">
            <summary>
            Returns true if no bits are enabled, false otherwise
            </summary>
        </member>
        <member name="P:Z0.BitVector16.NonEmpty">
            <summary>
            Returns true if the vector has at least one enabled bit; false otherwise
            </summary>
        </member>
        <member name="P:Z0.BitVector16.Lo">
            <summary>
            The vector's 8 least significant bits
            </summary>
        </member>
        <member name="P:Z0.BitVector16.Hi">
            <summary>
            The vector's 8 most significant bits
            </summary>
        </member>
        <member name="P:Z0.BitVector16.Bytes">
            <summary>
            Presents bitvector content as a bytespan
            </summary>
        </member>
        <member name="P:Z0.BitVector16.Item(System.Int32)">
            <summary>
            Gets/Sets an identified bit
            </summary>
        </member>
        <member name="P:Z0.BitVector16.Item(System.Byte,System.Byte)">
            <summary>
            Selects a contiguous range of bits
            </summary>
            <param name="first">The position of the first bit</param>
            <param name="last">The position of the last bit</param>
        </member>
        <member name="T:Z0.BitVector24">
            <summary>
            Defines a 32-bit bitvector
            </summary>
        </member>
        <member name="P:Z0.BitVector24.Zero">
            <summary>
            Allocates a vector with all bits disabled
            </summary>
        </member>
        <member name="P:Z0.BitVector24.One">
            <summary>
            Allocates a vector that has the least bit enabled and all others disabled
            </summary>
        </member>
        <member name="P:Z0.BitVector24.Ones">
            <summary>
            Allocates a vector with all bits enabled
            </summary>
        </member>
        <member name="M:Z0.BitVector24.op_Implicit(System.UInt32)~Z0.BitVector24">
            <summary>
            Implicitly converts a scalar value to a 32-bit bitvector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector24.op_Implicit(System.Byte)~Z0.BitVector24">
            <summary>
            Implicitly converts a scalar value to a 32-bit bitvector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector24.op_Implicit(System.UInt16)~Z0.BitVector24">
            <summary>
            Implicitly converts a scalar value to a 32-bit bitvector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector24.op_Implicit(System.ValueTuple{System.UInt16,System.Byte})~Z0.BitVector24">
            <summary>
            Implicitly constructs a bitvector from a tuple
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector24.op_ExclusiveOr(Z0.BitVector24,Z0.BitVector24)">
            <summary>
            Computes the bitwise XOR of the source operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector24.op_BitwiseAnd(Z0.BitVector24,Z0.BitVector24)">
            <summary>
            Computes the bitwise AND of the source operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector24.op_Modulus(Z0.BitVector24,Z0.BitVector24)">
            <summary>
            Computes the scalar product of the operands
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.BitVector24.op_BitwiseOr(Z0.BitVector24,Z0.BitVector24)">
            <summary>
            Computes the bitwise OR of the source operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector24.op_OnesComplement(Z0.BitVector24)">
            <summary>
            Computes the bitwise complement of the operand.
            </summary>
            <param name="x">The source operand</param>
        </member>
        <member name="M:Z0.BitVector24.op_UnaryNegation(Z0.BitVector24)">
            <summary>
            Computes the two's complement of the operand
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector24.op_LeftShift(Z0.BitVector24,System.Int32)">
            <summary>
            Left-shifts the bits in the source
            </summary>
            <param name="x">The source operand</param>
        </member>
        <member name="M:Z0.BitVector24.op_RightShift(Z0.BitVector24,System.Int32)">
            <summary>
            Right-shifts the bits in the source
            </summary>
            <param name="x">The source operand</param>
        </member>
        <member name="M:Z0.BitVector24.op_True(Z0.BitVector24)">
            <summary>
            Returns true if the source vector is nonzero, false otherwise
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector24.op_False(Z0.BitVector24)">
            <summary>
            Returns false if the source vector is the zero vector, false otherwise
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector24.op_LogicalNot(Z0.BitVector24)">
            <summary>
            Computes the operand's logical negation: if x = 0 then 1 else 0
            </summary>
            <param name="src">The ource operand</param>
        </member>
        <member name="M:Z0.BitVector24.op_Equality(Z0.BitVector24,Z0.BitVector24)">
            <summary>
            Determines whether operand content is identical
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector24.op_Inequality(Z0.BitVector24,Z0.BitVector24)">
            <summary>
            Determines whether operand content is non-identical
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector24.op_LessThan(Z0.BitVector24,Z0.BitVector24)">
            <summary>
            Determines whether the left operand is arithmetically less than the second
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector24.op_GreaterThan(Z0.BitVector24,Z0.BitVector24)">
            <summary>
            Determines whether the left operand is arithmetically greater than the second
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector24.op_LessThanOrEqual(Z0.BitVector24,Z0.BitVector24)">
            <summary>
            Determines whether the left operand is arithmetically less than or equal to the second
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector24.op_GreaterThanOrEqual(Z0.BitVector24,Z0.BitVector24)">
            <summary>
            Determines whether the left operand is arithmetically greater than or equal to the second
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector24.#ctor(System.UInt32)">
            <summary>
            Initializes the vector
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.BitVector24.#ctor(System.UInt16,System.Byte)">
            <summary>
            Initializes the vector
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="P:Z0.BitVector24.Scalar">
            <summary>
            Extracts the scalar represented by the vector
            </summary>
        </member>
        <member name="P:Z0.BitVector24.Width">
            <summary>
            The number of bits represented by the vector
            </summary>
        </member>
        <member name="P:Z0.BitVector24.Lo8">
            <summary>
            The first 8 bits of the vector
            </summary>
        </member>
        <member name="P:Z0.BitVector24.Mid8">
            <summary>
            The middle 8 bits of the vector
            </summary>
        </member>
        <member name="P:Z0.BitVector24.Hi8">
            <summary>
            The upper 8 bits of the vector
            </summary>
        </member>
        <member name="P:Z0.BitVector24.Lo16">
            <summary>
            The first 16 bits of the vector
            </summary>
        </member>
        <member name="P:Z0.BitVector24.Hi16">
            <summary>
            The last 16 bits of the vector
            </summary>
        </member>
        <member name="P:Z0.BitVector24.Bytes">
            <summary>
            Presents bitvector content as a bytespan
            </summary>
        </member>
        <member name="P:Z0.BitVector24.Empty">
            <summary>
            Returns true if no bits are enabled, false otherwise
            </summary>
        </member>
        <member name="P:Z0.BitVector24.NonEmpty">
            <summary>
            Returns true if the vector has at least one enabled bit; false otherwise
            </summary>
        </member>
        <member name="P:Z0.BitVector24.Item(System.Int32)">
            <summary>
            Queries/Manipulates index-identified bits
            </summary>
        </member>
        <member name="P:Z0.BitVector24.Item(System.Byte,System.Byte)">
            <summary>
            Selects a contiguous range of bits defined by an inclusive 0-based index range
            </summary>
            <param name="first">The position of the first bit</param>
            <param name="last">The position of the last bit</param>
            <remarks>Unfortuantely, the range spec/select syntanx [a..b] results in about 50 extra bytes
            of assembly (!) of the jmp/cmp/test variety. So, defining a range operator for
            performance-sensitive types is hard no-go </remarks>
        </member>
        <member name="T:Z0.BitVector32">
            <summary>
            Defines a 32-bit bitvector
            </summary>
        </member>
        <member name="P:Z0.BitVector32.Zero">
            <summary>
            Allocates a vector with all bits disabled
            </summary>
        </member>
        <member name="P:Z0.BitVector32.One">
            <summary>
            Allocates a vector that has the least bit enabled and all others disabled
            </summary>
        </member>
        <member name="P:Z0.BitVector32.Ones">
            <summary>
            Allocates a vector with all bits enabled
            </summary>
        </member>
        <member name="M:Z0.BitVector32.op_Implicit(System.Byte)~Z0.BitVector32">
            <summary>
            Implicitly converts a scalar value to a 32-bit bitvector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector32.op_Implicit(System.UInt16)~Z0.BitVector32">
            <summary>
            Implicitly converts a scalar value to a 32-bit bitvector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector32.op_Implicit(System.UInt32)~Z0.BitVector32">
            <summary>
            Implicitly converts a scalar value to a 32-bit bitvector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector32.op_ExclusiveOr(Z0.BitVector32,Z0.BitVector32)">
            <summary>
            Computes the bitwise XOR of the source operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector32.op_BitwiseAnd(Z0.BitVector32,Z0.BitVector32)">
            <summary>
            Computes the bitwise AND of the source operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector32.op_Modulus(Z0.BitVector32,Z0.BitVector32)">
            <summary>
            Computes the scalar product of the operands
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.BitVector32.op_BitwiseOr(Z0.BitVector32,Z0.BitVector32)">
            <summary>
            Computes the bitwise OR of the source operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector32.op_OnesComplement(Z0.BitVector32)">
            <summary>
            Computes the bitwise complement of the operand.
            </summary>
            <param name="x">The source operand</param>
        </member>
        <member name="M:Z0.BitVector32.op_Addition(Z0.BitVector32,Z0.BitVector32)">
            <summary>
            Computes the arithmetic sum of the source operands.
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.BitVector32.op_Increment(Z0.BitVector32)">
            <summary>
            Arithmetically increments the source vector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector32.op_Decrement(Z0.BitVector32)">
            <summary>
            Arithmetically decrements the source vector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector32.op_Subtraction(Z0.BitVector32,Z0.BitVector32)">
            <summary>
            Computes the arithmetic difference between the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector32.op_UnaryNegation(Z0.BitVector32)">
            <summary>
            Computes the two's complement of the operand
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector32.op_LeftShift(Z0.BitVector32,System.Int32)">
            <summary>
            Left-shifts the bits in the source
            </summary>
            <param name="x">The source operand</param>
        </member>
        <member name="M:Z0.BitVector32.op_RightShift(Z0.BitVector32,System.Int32)">
            <summary>
            Right-shifts the bits in the source
            </summary>
            <param name="x">The source operand</param>
        </member>
        <member name="M:Z0.BitVector32.op_True(Z0.BitVector32)">
            <summary>
            Returns true if the source vector is nonzero, false otherwise
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector32.op_False(Z0.BitVector32)">
            <summary>
            Returns false if the source vector is the zero vector, false otherwise
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector32.op_LogicalNot(Z0.BitVector32)">
            <summary>
            Computes the operand's logical negation: if x = 0 then 1 else 0
            </summary>
            <param name="src">The ource operand</param>
        </member>
        <member name="M:Z0.BitVector32.op_Equality(Z0.BitVector32,Z0.BitVector32)">
            <summary>
            Determines whether operand content is identical
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector32.op_Inequality(Z0.BitVector32,Z0.BitVector32)">
            <summary>
            Determines whether operand content is non-identical
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector32.op_LessThan(Z0.BitVector32,Z0.BitVector32)">
            <summary>
            Determines whether the left operand is arithmetically less than the second
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector32.op_GreaterThan(Z0.BitVector32,Z0.BitVector32)">
            <summary>
            Determines whether the left operand is arithmetically greater than the second
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector32.op_LessThanOrEqual(Z0.BitVector32,Z0.BitVector32)">
            <summary>
            Determines whether the left operand is arithmetically less than or equal to the second
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector32.op_GreaterThanOrEqual(Z0.BitVector32,Z0.BitVector32)">
            <summary>
            Determines whether the left operand is arithmetically greater than or equal to the second
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector32.#ctor(System.UInt32)">
            <summary>
            Initializes the vector with the source value it represents
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="P:Z0.BitVector32.Scalar">
            <summary>
            Extracts the scalar represented by the vector
            </summary>
        </member>
        <member name="P:Z0.BitVector32.Width">
            <summary>
            The number of bits represented by the vector
            </summary>
        </member>
        <member name="P:Z0.BitVector32.Bytes">
            <summary>
            Presents bitvector content as a bytespan
            </summary>
        </member>
        <member name="P:Z0.BitVector32.Empty">
            <summary>
            Returns true if no bits are enabled, false otherwise
            </summary>
        </member>
        <member name="P:Z0.BitVector32.NonEmpty">
            <summary>
            Returns true if the vector has at least one enabled bit; false otherwise
            </summary>
        </member>
        <member name="P:Z0.BitVector32.Item(System.Int32)">
            <summary>
            Queries/Manipulates index-identified bits
            </summary>
        </member>
        <member name="P:Z0.BitVector32.Item(System.Byte,System.Byte)">
            <summary>
            Selects a contiguous range of bits defined by an inclusive 0-based index range
            </summary>
            <param name="first">The position of the first bit</param>
            <param name="last">The position of the last bit</param>
            <remarks>Unfortuantely, the range spec/select syntanx [a..b] results in about 50 extra bytes
            of assembly (!) of the jmp/cmp/test variety. So, defining a range operator for
            performance-sensitive types is hard no-go </remarks>
        </member>
        <member name="T:Z0.BitVector4">
            <summary>
            Defines a 4-bit bitvector
            </summary>
        </member>
        <member name="M:Z0.BitVector4.op_ExclusiveOr(Z0.BitVector4@,Z0.BitVector4@)">
            <summary>
            Computes the XOR of the source operands.
            Note that this operator is equivalent to the addition operator (+)
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.BitVector4.op_BitwiseAnd(Z0.BitVector4@,Z0.BitVector4@)">
            <summary>
            Computes the bitwise AND of the source operands
            Note that the AND operator is equivalent to the (*) operator
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector4.op_BitwiseOr(Z0.BitVector4@,Z0.BitVector4@)">
            <summary>
            Computes the bitwise OR of the source operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector4.op_OnesComplement(Z0.BitVector4)">
            <summary>
            Computes the bitwise complement
            </summary>
            <param name="x">The left bitvector</param>
        </member>
        <member name="M:Z0.BitVector4.op_Addition(Z0.BitVector4,Z0.BitVector4)">
            <summary>
            Computes the arithmetic sum of the source operands.
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.BitVector4.op_Multiply(Z0.BitVector4@,Z0.BitVector4@)" -->
        <member name="M:Z0.BitVector4.op_Modulus(Z0.BitVector4,Z0.BitVector4)">
            <summary>
            Computes the scalar product of the operands
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.BitVector4.op_Subtraction(Z0.BitVector4,Z0.BitVector4)">
            <summary>
            Subtracts the second operand from the first.
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector4.op_Equality(Z0.BitVector4,Z0.BitVector4)">
            <summary>
            Determines whether operand content is identical
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector4.op_Inequality(Z0.BitVector4,Z0.BitVector4)">
            <summary>
            Determines whether operand content is non-identical
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector4.op_LessThan(Z0.BitVector4,Z0.BitVector4)">
            <summary>
            Determines whether the left operand is arithmetically less than the second
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector4.op_GreaterThan(Z0.BitVector4,Z0.BitVector4)">
            <summary>
            Determines whether the left operand is arithmetically greater than than the second
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector4.op_LessThanOrEqual(Z0.BitVector4,Z0.BitVector4)">
            <summary>
            Determines whether the left operand is arithmetically less than or equal to the second
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector4.op_GreaterThanOrEqual(Z0.BitVector4,Z0.BitVector4)">
            <summary>
            Determines whether the left operand is arithmetically greater than or equal to the second
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="P:Z0.BitVector4.Scalar">
            <summary>
            Extracts the scalar represented by the vector
            </summary>
        </member>
        <member name="P:Z0.BitVector4.Width">
            <summary>
            The number of bits represented by the vector
            </summary>
        </member>
        <member name="P:Z0.BitVector4.Empty">
            <summary>
            Returns true if all bits are disabled, false otherwise
            </summary>
        </member>
        <member name="P:Z0.BitVector4.NonEmpty">
            <summary>
            Returns true if at least one bit is enabled, false otherwise
            </summary>
        </member>
        <member name="T:Z0.BitVector64">
            <summary>
            Defines a 64-bit bitvector
            </summary>
        </member>
        <member name="M:Z0.BitVector64.op_Implicit(System.UInt64)~Z0.BitVector64">
            <summary>
            Implicitly converts an unsigned 64-bit integer to a 64-bit bitvector
            </summary>
            <param name="src">The source integer</param>
        </member>
        <member name="M:Z0.BitVector64.op_Implicit(Z0.BitVector64)~System.UInt64">
            <summary>
            Implicitly converts a bitvector to a 64-bit unsigned integer
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector64.op_Explicit(Z0.BitVector64)~Z0.BitVector4">
            <summary>
            Explicitly converts a a 64-bit bitvector to an 8-bit bitvector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector64.op_Explicit(Z0.BitVector64)~Z0.BitVector8">
            <summary>
            Explicitly converts a a 64-bit bitvector to an 8-bit bitvector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector64.op_Explicit(Z0.BitVector64)~Z0.BitVector16">
            <summary>
            Explicitly converts a a 64-bit bitvector to a 16-bit bitvector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector64.op_Explicit(Z0.BitVector64)~Z0.BitVector32">
            <summary>
            Explicitly converts a a 64-bit bitvector to a 32-bit bitvector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector64.op_Implicit(System.Byte)~Z0.BitVector64">
            <summary>
            Implicitly converts a scalar value to a 64-bit bitvector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector64.op_Implicit(System.UInt16)~Z0.BitVector64">
            <summary>
            Implicitly converts a scalar value to a 64-bit bitvector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector64.op_Implicit(System.UInt32)~Z0.BitVector64">
            <summary>
            Implicitly converts a scalar value to a 64-bit bitvector
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector64.op_ExclusiveOr(Z0.BitVector64,Z0.BitVector64)">
            <summary>
            Computes the bitwise XOR of the source operands
            Note that the XOR operator is equivalent to the (+) operator
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector64.op_BitwiseAnd(Z0.BitVector64,Z0.BitVector64)">
            <summary>
            Computes the bitwise AND of the source operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector64.op_BitwiseOr(Z0.BitVector64,Z0.BitVector64)">
            <summary>
            Computes the bitwise OR of the source operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector64.op_Modulus(Z0.BitVector64,Z0.BitVector64)">
            <summary>
            Computes the scalar product of the operands
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.BitVector64.op_Addition(Z0.BitVector64,Z0.BitVector64)">
            <summary>
            Computes the arithmetic sum of the source operands.
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.BitVector64.op_OnesComplement(Z0.BitVector64)">
            <summary>
            Computes the bitwise complement of the operand
            </summary>
            <param name="src">The source operand</param>
        </member>
        <member name="M:Z0.BitVector64.op_UnaryNegation(Z0.BitVector64)">
            <summary>
            Negates the operand via two's complement
            </summary>
            <param name="x">The source operand</param>
        </member>
        <member name="M:Z0.BitVector64.op_Subtraction(Z0.BitVector64,Z0.BitVector64)">
            <summary>
            Arithmetically subtracts the second operand from the first.
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector64.op_LeftShift(Z0.BitVector64,System.Int32)">
            <summary>
            Shifts the source bits leftwards
            </summary>
            <param name="x">The source operand</param>
        </member>
        <member name="M:Z0.BitVector64.op_RightShift(Z0.BitVector64,System.Int32)">
            <summary>
            Shifts the source bits rightwards
            </summary>
            <param name="x">The source operand</param>
        </member>
        <member name="M:Z0.BitVector64.op_Increment(Z0.BitVector64)">
            <summary>
            Increments the vector arithmetically
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector64.op_Decrement(Z0.BitVector64)">
            <summary>
            Decrements the vector arithmetically
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector64.op_True(Z0.BitVector64)">
            <summary>
            Returns true if the source vector is nonzero, false otherwise
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector64.op_False(Z0.BitVector64)">
            <summary>
            Returns false if the source vector is the zero vector, false otherwise
            </summary>
            <param name="x">The source vector</param>
        </member>
        <member name="M:Z0.BitVector64.op_LogicalNot(Z0.BitVector64)">
            <summary>
            Computes the operand's logical negation: if x = 0 then 1 else 0
            </summary>
            <param name="src">The ource operand</param>
        </member>
        <member name="M:Z0.BitVector64.op_Equality(Z0.BitVector64,Z0.BitVector64)">
            <summary>
            Determines whether operand content is identical
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector64.op_Inequality(Z0.BitVector64,Z0.BitVector64)">
            <summary>
            Determines whether operand content is non-identical
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector64.op_LessThan(Z0.BitVector64,Z0.BitVector64)">
            <summary>
            Determines whether the left operand is arithmetically less than the second
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector64.op_GreaterThan(Z0.BitVector64,Z0.BitVector64)">
            <summary>
            Determines whether the left operand is arithmetically greater than the second
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector64.op_LessThanOrEqual(Z0.BitVector64,Z0.BitVector64)">
            <summary>
            Determines whether the left operand is arithmetically less than or equal to the second
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector64.op_GreaterThanOrEqual(Z0.BitVector64,Z0.BitVector64)">
            <summary>
            Determines whether the left operand is arithmetically greater than or equal to the second
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector64.#ctor(System.UInt64)">
            <summary>
            Initializes a vector with the primal source value it represents
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="P:Z0.BitVector64.Scalar">
            <summary>
            Extracts the scalar represented by the vector
            </summary>
        </member>
        <member name="P:Z0.BitVector64.Width">
            <summary>
            The actual number of bits represented by the vector
            </summary>
        </member>
        <member name="P:Z0.BitVector64.Bytes">
            <summary>
            Presents bitvector content as a bytespan
            </summary>
        </member>
        <member name="P:Z0.BitVector64.Empty">
            <summary>
            Returns true if no bits are enabled, false otherwise
            </summary>
        </member>
        <member name="P:Z0.BitVector64.NonEmpty">
            <summary>
            Returns true if the vector has at least one enabled bit; false otherwise
            </summary>
        </member>
        <member name="P:Z0.BitVector64.AllOn">
            <summary>
            Tests whether all bits are on
            </summary>
        </member>
        <member name="P:Z0.BitVector64.Lo">
            <summary>
            The vector's 32 least significant bits
            </summary>
        </member>
        <member name="P:Z0.BitVector64.Hi">
            <summary>
            The vector's 32 most significant bits
            </summary>
        </member>
        <member name="P:Z0.BitVector64.Item(System.Int32)">
            <summary>
            Reads/Manipulates a source bit at a specified position
            </summary>
        </member>
        <member name="P:Z0.BitVector64.Item(System.Byte,System.Byte)">
            <summary>
            Selects a contiguous range of bits
            </summary>
            <param name="first">The position of the first bit</param>
            <param name="last">The position of the last bit</param>
        </member>
        <member name="M:Z0.BitVector64.Byte(System.Int32)">
            <summary>
            Selects an index-identified byte where index = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7
            </summary>
            <param name="index">The 0-based byte-relative position</param>
        </member>
        <member name="M:Z0.BitVector8.op_Implicit(Z0.Hex8Seq)~Z0.BitVector8">
            <summary>
            Implicitly converts a byte classifier to a vector
            </summary>
            <param name="src">The classifier</param>
        </member>
        <member name="M:Z0.BitVector8.op_Implicit(Z0.BitVector8)~Z0.Hex8Seq">
            <summary>
            Implicitly converts a vector to a byte classifier
            </summary>
            <param name="src">The vector</param>
        </member>
        <member name="M:Z0.BitVector8.op_Implicit(Z0.BitVector8)~System.Byte">
            <summary>
            Converts the source vector to the underlying scalar
            </summary>
            <param name="src">The source vector</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.BitVector8.op_BitwiseAnd(Z0.BitVector8,Z0.BitVector8)" -->
        <member name="M:Z0.BitVector8.op_BitwiseOr(Z0.BitVector8,Z0.BitVector8)">
            <summary>
            Computes the bitwise OR of the source operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.BitVector8.op_ExclusiveOr(Z0.BitVector8,Z0.BitVector8)" -->
        <member name="M:Z0.BitVector8.op_LeftShift(Z0.BitVector8,System.Int32)">
            <summary>
            Left-shifts the bits in the source
            </summary>
            <param name="x">The source operand</param>
        </member>
        <member name="M:Z0.BitVector8.op_RightShift(Z0.BitVector8,System.Int32)">
            <summary>
            Right-shifts the bits in the source
            </summary>
            <param name="x">The source operand</param>
        </member>
        <member name="M:Z0.BitVector8.op_OnesComplement(Z0.BitVector8)">
            <summary>
            Computes the one's complement of the operand.
            </summary>
            <param name="x">The source operand</param>
        </member>
        <member name="M:Z0.BitVector8.op_UnaryNegation(Z0.BitVector8)">
            <summary>
            Computes the two's complement of the operand
            </summary>
            <param name="x">The source operand</param>
        </member>
        <member name="M:Z0.BitVector8.op_Addition(Z0.BitVector8,Z0.BitVector8)">
            <summary>
            Computes the arithmetic sum of the source operands.
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.BitVector8.op_Multiply(Z0.BitVector8,Z0.BitVector8)">
            <summary>
            Computes the product of the operands.
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.BitVector8.op_Subtraction(Z0.BitVector8,Z0.BitVector8)">
            <summary>
            Computes the arithmetic difference between the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector8.op_ExclusiveOr(Z0.BitVector8,System.Int32)">
            <summary>
            Raises a vector b to a power n where n >= 0
            </summary>
            <param name="b">The base vector</param>
            <param name="n">The power</param>
        </member>
        <member name="M:Z0.BitVector8.op_Modulus(Z0.BitVector8,Z0.BitVector8)">
            <summary>
            Computes the scalar product of the operands
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.BitVector8.op_Increment(Z0.BitVector8)">
            <summary>
            Arithmetically increments the bitvector
            </summary>
            <param name="lhs">The source operand</param>
        </member>
        <member name="M:Z0.BitVector8.op_Decrement(Z0.BitVector8)">
            <summary>
            Arithmetically decrements the bitvector
            </summary>
            <param name="lhs">The source operand</param>
        </member>
        <member name="M:Z0.BitVector8.op_True(Z0.BitVector8)">
            <summary>
            Returns true if the source vector is nonzero, false otherwise
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector8.op_False(Z0.BitVector8)">
            <summary>
            Returns false if the source vector is the zero vector, false otherwise
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector8.op_LogicalNot(Z0.BitVector8)">
            <summary>
            Computes the operand's logical negation: if x = 0 then 1 else 0
            </summary>
            <param name="src">The ource operand</param>
        </member>
        <member name="M:Z0.BitVector8.op_Equality(Z0.BitVector8,Z0.BitVector8)">
            <summary>
            Determines whether operand content is identical
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector8.op_Inequality(Z0.BitVector8,Z0.BitVector8)">
            <summary>
            Determines whether operand content is non-identical
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector8.op_LessThan(Z0.BitVector8,Z0.BitVector8)">
            <summary>
            Determines whether the left operand is arithmetically less than the second
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector8.op_GreaterThan(Z0.BitVector8,Z0.BitVector8)">
            <summary>
            Determines whether the left operand is arithmetically greater than than the second
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector8.op_LessThanOrEqual(Z0.BitVector8,Z0.BitVector8)">
            <summary>
            Determines whether the left operand is arithmetically less than or equal to the second
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector8.op_GreaterThanOrEqual(Z0.BitVector8,Z0.BitVector8)">
            <summary>
            Determines whether the left operand is arithmetically greater than or equal to the second
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="P:Z0.BitVector8.Scalar">
            <summary>
            Extracts the scalar represented by the vector
            </summary>
        </member>
        <member name="P:Z0.BitVector8.Width">
            <summary>
            The number of bits represented by the vector
            </summary>
        </member>
        <member name="P:Z0.BitVector8.Bytes">
            <summary>
            Presents bitvector content as a bytespan
            </summary>
        </member>
        <member name="P:Z0.BitVector8.Empty">
            <summary>
            Returns true if no bits are enabled, false otherwise
            </summary>
        </member>
        <member name="P:Z0.BitVector8.NonEmpty">
            <summary>
            Returns true if the vector has at least one enabled bit; false otherwise
            </summary>
        </member>
        <member name="P:Z0.BitVector8.AllOn">
            <summary>
            Returns true if all bits are enabled, false otherwise
            </summary>
        </member>
        <member name="P:Z0.BitVector8.Hi">
            <summary>
            The vector's 4 most significant bits
            </summary>
        </member>
        <member name="P:Z0.BitVector8.Lo">
            <summary>
            The vector's 4 least significant bits
            </summary>
        </member>
        <member name="P:Z0.BitVector8.Item(System.Int32)">
            <summary>
            Gets/sets the state of an index-identified bit
            </summary>
        </member>
        <member name="P:Z0.BitVector8.Item(System.Byte,System.Byte)">
            <summary>
            Selects a contiguous range of bits
            </summary>
            <param name="first">The position of the first bit</param>
            <param name="last">The position of the last bit</param>
        </member>
        <member name="T:Z0.BitVector`2">
            <summary>
            Defines a natural bitvector over a primal cell
            </summary>
            <typeparam name="T">The cell type</typeparam>
            <typeparam name="N">The bit-width type</typeparam>
            <remarks>There are three notions of width that are applicable to this data structure.
            First, the bit width of the primal cell which determines the maximum number of
            bits that can be covered. Next is the natural parametric width that defines an
            upper bound for the effective width. Finally, is the effective bitvector width, a value
            which is bounded above by the the natural width
            </remarks>
        </member>
        <member name="P:Z0.BitVector`2.MaxWidth">
            <summary>
            The physical width of the vector
            </summary>
        </member>
        <member name="P:Z0.BitVector`2.MaxValue">
            <summary>
            The maximum arithmetic value of the vector, constrained by the natural width
            </summary>
        </member>
        <member name="M:Z0.BitVector`2.Inject(`1)">
            <summary>
            Directly assigns a value to a vector storage cell, bypassing masked initialization
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.BitVector`2.op_Implicit(`1)~Z0.BitVector{`0,`1}">
            <summary>
            Implicitly convers a scalar to a bitvector
            </summary>
            <param name="src">The scalar value</param>
        </member>
        <member name="M:Z0.BitVector`2.op_Implicit(Z0.BitVector{`0,`1})~`1">
            <summary>
            Implicitly convers a bitvector to its scalar representation
            </summary>
            <param name="src">The scalar value</param>
        </member>
        <member name="M:Z0.BitVector`2.op_Implicit(Z0.BitVector{`0,`1})~Z0.BitVector{`1}">
            <summary>
            Implicitly convers a bitvector to its scalar representation
            </summary>
            <param name="src">The scalar value</param>
        </member>
        <member name="M:Z0.BitVector`2.op_BitwiseAnd(Z0.BitVector{`0,`1},Z0.BitVector{`0,`1})">
            <summary>
            Computes the bitwias AND between the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector`2.op_BitwiseOr(Z0.BitVector{`0,`1},Z0.BitVector{`0,`1})">
            <summary>
            Computes the bitwias AND between the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector`2.op_ExclusiveOr(Z0.BitVector{`0,`1},Z0.BitVector{`0,`1})">
            <summary>
            Computes the bitwise XOR between the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector`2.op_Modulus(Z0.BitVector{`0,`1},Z0.BitVector{`0,`1})">
            <summary>
            Computes the scalar product of the operands
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.BitVector`2.op_OnesComplement(Z0.BitVector{`0,`1})">
            <summary>
            Computes the bitwise complement of the operand
            </summary>
            <param name="x">The source operand</param>
        </member>
        <member name="M:Z0.BitVector`2.op_Increment(Z0.BitVector{`0,`1})">
            <summary>
            Computes the bitwise complement of the operand
            </summary>
            <param name="x">The source operand</param>
        </member>
        <member name="M:Z0.BitVector`2.op_Decrement(Z0.BitVector{`0,`1})">
            <summary>
            Computes the bitwise complement of the operand
            </summary>
            <param name="x">The source operand</param>
        </member>
        <member name="M:Z0.BitVector`2.op_Addition(Z0.BitVector{`0,`1},Z0.BitVector{`0,`1})">
            <summary>
            Computes the N-modular arithmetic sum between the operands
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.BitVector`2.op_Subtraction(Z0.BitVector{`0,`1},Z0.BitVector{`0,`1})">
            <summary>
            Computes the N-modular arithmetic difference between the operands
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.BitVector`2.op_UnaryNegation(Z0.BitVector{`0,`1})">
            <summary>
            Computes the two's complement negation of the operand
            </summary>
            <param name="x">The source operand</param>
        </member>
        <member name="M:Z0.BitVector`2.op_LeftShift(Z0.BitVector{`0,`1},System.Int32)">
            <summary>
            Shifts the source bits leftwards
            </summary>
            <param name="x">The source operand</param>
        </member>
        <member name="M:Z0.BitVector`2.op_RightShift(Z0.BitVector{`0,`1},System.Int32)">
            <summary>
            Shifts the source bits rightwards
            </summary>
            <param name="x">The source operand</param>
        </member>
        <member name="M:Z0.BitVector`2.op_LessThan(Z0.BitVector{`0,`1},Z0.BitVector{`0,`1})">
            <summary>
            Computes the arithmetic less than between the operands
            </summary>
            <param name="x">The first vector</param>
            <param name="y">The second vector</param>
        </member>
        <member name="M:Z0.BitVector`2.op_GreaterThan(Z0.BitVector{`0,`1},Z0.BitVector{`0,`1})">
            <summary>
            Computes the arithmetic greater than between the operands
            </summary>
            <param name="x">The first vector</param>
            <param name="y">The second vector</param>
        </member>
        <member name="M:Z0.BitVector`2.op_LessThanOrEqual(Z0.BitVector{`0,`1},Z0.BitVector{`0,`1})">
            <summary>
            Computes the arithmetic less than or equal between the operands
            </summary>
            <param name="x">The first vector</param>
            <param name="y">The second vector</param>
        </member>
        <member name="M:Z0.BitVector`2.op_GreaterThanOrEqual(Z0.BitVector{`0,`1},Z0.BitVector{`0,`1})">
            <summary>
            Computes the arithmetic greater than or equal between the operands
            </summary>
            <param name="x">The first vector</param>
            <param name="y">The second vector</param>
        </member>
        <member name="M:Z0.BitVector`2.op_True(Z0.BitVector{`0,`1})">
            <summary>
            Returns true if the source vector is nonzero, false otherwise
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector`2.op_False(Z0.BitVector{`0,`1})">
            <summary>
            Returns false if the source vector is the zero vector, false otherwise
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector`2.op_Equality(Z0.BitVector{`0,`1},Z0.BitVector{`0,`1})">
            <summary>
            Determines whether operand content is identical
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector`2.op_Inequality(Z0.BitVector{`0,`1},Z0.BitVector{`0,`1})">
            <summary>
            Determines whether operand content is non-identical
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector`2.#ctor(`1)">
            <summary>
            Intializes a bitvector with the lo N bits of a scalar source
            </summary>
            <param name="data">The scalar source value</param>
        </member>
        <member name="P:Z0.BitVector`2.Scalar">
            <summary>
            The scalar representation of the vector
            </summary>
        </member>
        <member name="P:Z0.BitVector`2.Width">
            <summary>
            The bitvector width
            </summary>
        </member>
        <member name="P:Z0.BitVector`2.Empty">
            <summary>
            Specifies whether all bits are disabled
            </summary>
        </member>
        <member name="P:Z0.BitVector`2.NonEmpty">
            <summary>
            Specifies whether at least one bit is enabled
            </summary>
        </member>
        <member name="P:Z0.BitVector`2.Item(System.Int32)">
            <summary>
            Reads/Manipulates a single bit
            </summary>
        </member>
        <member name="P:Z0.BitVector`2.Item(System.Byte,System.Byte)">
            <summary>
            Extracts a contiguous sequence of bits defined by an inclusive range
            </summary>
            <param name="first">The first bit position</param>
            <param name="last">The last bit position</param>
        </member>
        <member name="M:Z0.BitVector`2.As``1">
            <summary>
            Creates a new vector by converting the underlying cell to the target type
            </summary>
            <typeparam name="U">The target type</typeparam>
        </member>
        <member name="T:Z0.BitVector`1">
            <summary>
            Defines a generic bitvector over a primal cell
            </summary>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.BitVector`1.op_BitwiseAnd(Z0.BitVector{`0},Z0.BitVector{`0})">
            <summary>
            Computes the bitwise AND between the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector`1.op_BitwiseOr(Z0.BitVector{`0},Z0.BitVector{`0})">
            <summary>
            Computes the bitwise AND between the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector`1.op_ExclusiveOr(Z0.BitVector{`0},Z0.BitVector{`0})">
            <summary>
            Computes the bitwise XOR between the operands
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector`1.op_Modulus(Z0.BitVector{`0},Z0.BitVector{`0})">
            <summary>
            Computes the scalar product of the operands
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.BitVector`1.op_OnesComplement(Z0.BitVector{`0})">
            <summary>
            Computes the bitwise complement of the operand
            </summary>
            <param name="x">The source operand</param>
        </member>
        <member name="M:Z0.BitVector`1.op_UnaryNegation(Z0.BitVector{`0})">
            <summary>
            Computes the two's complement negation of the operand
            </summary>
            <param name="x">The source operand</param>
        </member>
        <member name="M:Z0.BitVector`1.op_LeftShift(Z0.BitVector{`0},System.Int32)">
            <summary>
            Shifts the source bits leftwards
            </summary>
            <param name="x">The source operand</param>
        </member>
        <member name="M:Z0.BitVector`1.op_RightShift(Z0.BitVector{`0},System.Int32)">
            <summary>
            Shifts the source bits rightwards
            </summary>
            <param name="x">The source operand</param>
        </member>
        <member name="M:Z0.BitVector`1.op_True(Z0.BitVector{`0})">
            <summary>
            Returns true if the source vector is nonzero, false otherwise
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector`1.op_False(Z0.BitVector{`0})">
            <summary>
            Returns false if the source vector is the zero vector, false otherwise
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector`1.op_Increment(Z0.BitVector{`0})">
            <summary>
            Increments the vector arithmetically
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector`1.op_Decrement(Z0.BitVector{`0})">
            <summary>
            Decrements the vector arithmetically
            </summary>
            <param name="src">The source vector</param>
        </member>
        <member name="M:Z0.BitVector`1.op_Addition(Z0.BitVector{`0},Z0.BitVector{`0})">
            <summary>
            Computes the arithmetic sum of the source operands.
            </summary>
            <param name="x">The left operand</param>
            <param name="y">The right operand</param>
        </member>
        <member name="M:Z0.BitVector`1.op_Subtraction(Z0.BitVector{`0},Z0.BitVector{`0})">
            <summary>
            Arithmetically subtracts the second operand from the first.
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector`1.op_Equality(Z0.BitVector{`0},Z0.BitVector{`0})">
            <summary>
            Determines whether operand content is identical
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector`1.op_Inequality(Z0.BitVector{`0},Z0.BitVector{`0})">
            <summary>
            Determines whether operand content is non-identical
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector`1.op_LessThan(Z0.BitVector{`0},Z0.BitVector{`0})">
            <summary>
            Determines whether the left operand is arithmetically less than the second
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector`1.op_GreaterThan(Z0.BitVector{`0},Z0.BitVector{`0})">
            <summary>
            Determines whether the left operand is arithmetically greater than the second
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector`1.op_LessThanOrEqual(Z0.BitVector{`0},Z0.BitVector{`0})">
            <summary>
            Determines whether the left operand is arithmetically less than or equal to the second
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="M:Z0.BitVector`1.op_GreaterThanOrEqual(Z0.BitVector{`0},Z0.BitVector{`0})">
            <summary>
            Determines whether the left operand is arithmetically greater than or equal to the second
            </summary>
            <param name="x">The left vector</param>
            <param name="y">The right vector</param>
        </member>
        <member name="P:Z0.BitVector`1.Scalar">
            <summary>
            Specifies the data over which the vector is defined
            </summary>
        </member>
        <member name="P:Z0.BitVector`1.Lo">
            <summary>
            Extracts the lower bits
            </summary>
        </member>
        <member name="P:Z0.BitVector`1.Hi">
            <summary>
            Extracts the upper bits
            </summary>
        </member>
        <member name="P:Z0.BitVector`1.Width">
            <summary>
            The number of bits represented by the vector
            </summary>
        </member>
        <member name="P:Z0.BitVector`1.Bytes">
            <summary>
            Converts the encapsulated data to a bytespan
            </summary>
        </member>
        <member name="P:Z0.BitVector`1.Empty">
            <summary>
            Specifies whether all bits are disabled
            </summary>
        </member>
        <member name="P:Z0.BitVector`1.NonEmpty">
            <summary>
            Specifies whether at least one bit is enabled
            </summary>
        </member>
        <member name="P:Z0.BitVector`1.Item(System.Int32)">
            <summary>
            Reads/Manipulates a single bit
            </summary>
        </member>
        <member name="P:Z0.BitVector`1.Item(System.Byte)">
            <summary>
            Reads/Manipulates a single bit
            </summary>
        </member>
        <member name="P:Z0.BitVector`1.Item(System.Byte,System.Byte)">
            <summary>
            Extracts a contiguous sequence of bits defined by an inclusive range
            </summary>
            <param name="first">The first bit position</param>
            <param name="last">The last bit position</param>
        </member>
        <member name="M:Z0.BitVectorX.Extend(Z0.BitVector4,Z0.N8)">
            <summary>
            Zero extends the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The target width</param>
        </member>
        <member name="M:Z0.BitVectorX.Extend(Z0.BitVector8,Z0.N16)">
            <summary>
            Zero extends the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The target width</param>
        </member>
        <member name="M:Z0.BitVectorX.Extend(Z0.BitVector16,Z0.N32)">
            <summary>
            Zero extends the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The target width</param>
        </member>
        <member name="M:Z0.BitVectorX.Extend(Z0.BitVector32,Z0.N64)">
            <summary>
            Zero extends the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The target width</param>
        </member>
        <member name="M:Z0.BitVectorX.Extend(Z0.BitVector64,Z0.N128)">
            <summary>
            Zero extends the source vector
            </summary>
            <param name="src">The source vector</param>
            <param name="n">The target width</param>
        </member>
    </members>
</doc>
