# TLS
---------------------------------------------------------------------------------------------------------------
| Offset (PE32/ PE32+) | Size (PE32/ PE32+) | Field                | Description                                                                                                                                                                                                                                                                                                                             |
| 0                    | 4/8                | Raw Data Start VA    | The starting address of the TLS template. The template is a block of data that is used to initialize TLS data. The system copies all of this data each time a thread is created, so it must not be corrupted. Note that this address is not an RVA; it is an address for which there should be a base relocation in the .reloc section. |
| 4/8                  | 4/8                | Raw Data End VA      | The address of the last byte of the TLS, except for the zero fill. As with the Raw Data Start VA field, this is a VA, not an RVA.                                                                                                                                                                                                       |
| 8/16                 | 4/8                | Address of Index     | The location to receive the TLS index, which the loader assigns. This location is in an ordinary data section, so it can be given a symbolic name that is accessible to the program.                                                                                                                                                    |
| 12/24                | 4/8                | Address of Callbacks | The pointer to an array of TLS callback functions. The array is null-terminated, so if no callback function is supported, this field points to 4Â bytes set to zero. For information about the prototype for these functions, see TLS Callback Functions .                                                                               |
| 16/32                | 4                  | Size of Zero Fill    | The size in bytes of the template, beyond the initialized data delimited by the Raw Data Start VA and Raw Data End VA fields. The total template size should be the same as the total size of TLS data in the image file. The zero fill is the amount of data that comes after the initialized nonzero data.                            |
| 20/36                | 4                  | Characteristics      | The four bits [23:20] describe alignment info. Possible values are those defined as IMAGE_SCN_ALIGN_*, which are also used to describe alignment of section in object files. The other 28 bits are reserved for future use.                                                                                                             |

# Description
The .tls section provides direct PE and COFF support for static thread local storage (TLS). 
TLS is a special storage class that Windows supports in which a data object is not an 
automatic (stack) variable, yet is local to each individual thread that runs the code. Thus, 
each thread can maintain a different value for a variable declared by using TLS

Note that any amount of TLS data can be supported by using the API calls TlsAlloc, 
TlsFree, TlsSetValue, and TlsGetValue. The PE or COFF implementation is an alternative 
approach to using the API and has the advantage of being simpler from the high-level-language 
programmer's viewpoint. This implementation enables TLS data to be defined and initialized 
similarly to ordinary static variables in a program. For example, 
in Visual C++, a static TLS variable can be defined as follows, without using the Windows API:

__declspec (thread) int tlsFlag = 1;

To support this programming construct, the PE and COFF .tls section specifies the following 
information: initialization data, callback routines for per-thread initialization and termination, 
and the TLS index, which are explained in the following discussion.

Executable code accesses a static TLS data object through the following steps:

* At link time, the linker sets the Address of Index field of the TLS directory. This field points to 
a location where the program expects to receive the TLS index.

* The Microsoft run-time library facilitates this process by defining a memory image of the TLS 
directory and giving it the special name "__tls_used" (Intel x86 platforms) or "_tls_used" (other platforms). 
The linker looks for this memory image and uses the data there to create the TLS directory. 
Other compilers that support TLS and work with the Microsoft linker must use this same technique.

* When a thread is created, the loader communicates the address of the thread's TLS array by 
placing the address of the thread environment block (TEB) in the FS register. A pointer to the TLS array 
is at the offset of 0x2C from the beginning of TEB. This behavior is Intel x86-specific.

* The loader assigns the value of the TLS index to the place that was indicated by the Address of Index field.

* The executable code retrieves the TLS index and also the location of the TLS array.

* The code uses the TLS index and the TLS array location (multiplying the index by 4 and using it as an offset 
to the array) to get the address of the TLS data area for the given program and module. Each thread has its 
own TLS data area, but this is transparent to the program, which does not need to know how data is allocated for 
individual threads.

* An individual TLS data object is accessed as some fixed offset into the TLS data area.

The TLS array is an array of addresses that the system maintains for each thread. Each address in this array 
gives the location of TLS data for a given module (EXE or DLL) within the program. The TLS index indicates 
which member of the array to use. The index is a number (meaningful only to the system) that identifies the module.