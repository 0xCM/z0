# TLS
# Description
The .tls section provides direct PE and COFF support for static thread local storage (TLS). 
TLS is a special storage class that Windows supports in which a data object is not an 
automatic (stack) variable, yet is local to each individual thread that runs the code. Thus, 
each thread can maintain a different value for a variable declared by using TLS

Note that any amount of TLS data can be supported by using the API calls TlsAlloc, 
TlsFree, TlsSetValue, and TlsGetValue. The PE or COFF implementation is an alternative 
approach to using the API and has the advantage of being simpler from the high-level-language 
programmer's viewpoint. This implementation enables TLS data to be defined and initialized 
similarly to ordinary static variables in a program. For example, 
in Visual C++, a static TLS variable can be defined as follows, without using the Windows API:

__declspec (thread) int tlsFlag = 1;

To support this programming construct, the PE and COFF .tls section specifies the following 
information: initialization data, callback routines for per-thread initialization and termination, 
and the TLS index, which are explained in the following discussion.

Executable code accesses a static TLS data object through the following steps:

* At link time, the linker sets the Address of Index field of the TLS directory. This field points to 
a location where the program expects to receive the TLS index.

* The Microsoft run-time library facilitates this process by defining a memory image of the TLS 
directory and giving it the special name "__tls_used" (Intel x86 platforms) or "_tls_used" (other platforms). 
The linker looks for this memory image and uses the data there to create the TLS directory. 
Other compilers that support TLS and work with the Microsoft linker must use this same technique.

* When a thread is created, the loader communicates the address of the thread's TLS array by 
placing the address of the thread environment block (TEB) in the FS register. A pointer to the TLS array 
is at the offset of 0x2C from the beginning of TEB. This behavior is Intel x86-specific.

* The loader assigns the value of the TLS index to the place that was indicated by the Address of Index field.

* The executable code retrieves the TLS index and also the location of the TLS array.

* The code uses the TLS index and the TLS array location (multiplying the index by 4 and using it as an offset 
to the array) to get the address of the TLS data area for the given program and module. Each thread has its 
own TLS data area, but this is transparent to the program, which does not need to know how data is allocated for 
individual threads.

* An individual TLS data object is accessed as some fixed offset into the TLS data area.

The TLS array is an array of addresses that the system maintains for each thread. Each address in this array 
gives the location of TLS data for a given module (EXE or DLL) within the program. The TLS index indicates 
which member of the array to use. The index is a number (meaningful only to the system) that identifies the module.