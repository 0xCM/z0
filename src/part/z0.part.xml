<?xml version="1.0"?>
<doc>
    <assembly>
        <name>z0.part</name>
    </assembly>
    <members>
        <member name="T:ApiClass">
            <summary>
            Defines operand kind identity classifiers
            </summary>
        </member>
        <member name="F:ApiClass.None">
            <summary>
            The empty identity
            </summary>
        </member>
        <member name="F:ApiClass.Nonz">
            <summary>
            Classifies a unary operator that returns true iff its operand has a non-zero value
            </summary>
        </member>
        <member name="F:ApiClass.AddS">
            <summary>
            Saturated addition
            </summary>
        </member>
        <member name="F:ApiClass.AddH">
            <summary>
            Horizontal addition
            </summary>
        </member>
        <member name="F:ApiClass.AddHS">
            <summary>
            Horizontal saturated addition
            </summary>
        </member>
        <member name="F:ApiClass.Sad">
            <summary>
            Sum absolute differences
            </summary>
        </member>
        <member name="F:ApiClass.Sub">
            <summary>
            Horizontal subtraction
            </summary>
        </member>
        <member name="F:ApiClass.Test">
            <summary>
            Identifies an operation that evaluates one or more operands to determine that a subject is, or is not, of some target kind
            </summary>
        </member>
        <member name="F:ApiClass.Switch">
            <summary>
            Identifies an operation that reifies a switch expression
            </summary>
        </member>
        <member name="F:ApiClass.EffWidth">
            <summary>
            Identifies an operation that computes the effective bit-width of a value
            </summary>
        </member>
        <member name="F:ApiClass.EffSize">
            <summary>
            Identifies an operation that computes the effective byte-width of a value
            </summary>
        </member>
        <member name="F:ApiClass.Zip">
            <summary>
            Identifies a function that accepts two homogenous values, and perhaps other ingredients, and produces
            an output value where each target component represents a join, via some means, of corresponding operand components
            </summary>
        </member>
        <member name="F:ApiClass.Opaque">
            <summary>
            Identifies a function that invokes framework/system operations which are located in an external scope that does not dissolve
            </summary>
        </member>
        <member name="M:Z0.XTend.SelectMany``2(``0[],System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            Defines an array-specific join operator
            </summary>
            <param name="source"></param>
            <param name="selector"></param>
            <typeparam name="S"></typeparam>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Z0.XTend.Join``1(``0[][])">
            <summary>
            Sequentially condenses a sequence of arrays into a single array
            </summary>
            <param name="src">The many</param>
            <typeparam name="T">The array element type</typeparam>
        </member>
        <member name="M:Z0.XTend.Mapi``2(``0[],System.Func{System.Int32,``0,``1})">
            <summary>
            Transforms an array via an indexed mapping function
            </summary>
            <param name="src">The source array</param>
            <param name="f">The mapping function</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.XTend.Reverse``1(``0[])">
            <summary>
            Reverses an array in-place
            </summary>
            <param name="src">The source array</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XTend.Cast``1(System.Object[])">
            <summary>
            Populates a target array by casting each elements of a source aray to the target element type
            </summary>
            <param name="src"></param>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Z0.XTend.Select``2(``0[],System.Func{``0,``1})">
            <summary>
            Defines an array-specific select operator
            </summary>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
            <param name="src">The source sequence</param>
            <param name="f">The mapping function</param>
        </member>
        <member name="M:Z0.XTend.Where``1(``0[],System.Func{``0,System.Boolean})">
            <summary>
            Linq where operator specialized for arrays
            </summary>
            <param name="src">The source array</param>
            <param name="f"></param>
            <typeparam name="T">The array element type</typeparam>        
        </member>
        <member name="M:Z0.XTend.Where``2(``0[],System.Func{``0,System.Boolean},System.Func{``0,``1})">
            <summary>
            Result = Filter + Project
            </summary>
            <param name="src"></param>
            <param name="test"></param>
            <param name="project"></param>
            <typeparam name="S"></typeparam>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Z0.XTend.TryFind``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns the first element of the sequence that satisifies the predicate, if any.
            </summary>
            <param name="src">The sequence to search</param>
            <param name="predicate">The predicate to satiisfy</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.XTend.TryFind``2(System.Collections.Generic.Dictionary{``0,``1},``0)">
            <summary>
            Retrieves the key-identified value if possible
            </summary>
            <typeparam name="K">The key</typeparam>
            <typeparam name="V">The type of value identified by the key</typeparam>
            <param name="subject">The collection to query</param>
            <param name="key">The key that identifies the value</param>
        </member>
        <member name="M:Z0.XTend.TryFind``2(System.Collections.Generic.IReadOnlyDictionary{``0,``1},``0)">
            <summary>
            Retrieves the key-identified value if possible
            </summary>
            <typeparam name="K">The key</typeparam>
            <typeparam name="V">The type of value identified by the key</typeparam>
            <param name="subject">The collection to query</param>
            <param name="key">The key that identifies the value</param>
        </member>
        <member name="M:Z0.XTend.TryDequeue``1(System.Collections.Concurrent.ConcurrentQueue{``0})">
            <summary>
            Removes an element from the queue if one exists
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="q">the queue</param>
        </member>
        <member name="M:Z0.XTend.TryRemove``2(System.Collections.Concurrent.ConcurrentDictionary{``0,``1},``0)">
            <summary>
            Removes the key-identified value if possible
            </summary>
            <typeparam name="K">The key</typeparam>
            <typeparam name="V">The type of value identified by the key</typeparam>
            <param name="subject">The collection to query</param>
            <param name="key">The key that identifies the value</param>
        </member>
        <member name="M:Z0.XTend.TryTake``1(System.Collections.Concurrent.ConcurrentBag{``0})">
            <summary>
            A functional rendition of <see cref="M:System.Collections.Concurrent.ConcurrentBag`1.TryTake(`0@)"/> 
            </summary>
            <typeparam name="T">The item type</typeparam>
            <param name="source">The collection to search</param>
        </member>
        <member name="M:Z0.XTend.TryGetSingle``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Returns a value if the source stream yeilds exactly one value; otherwise, returns none
            </summary>
            <param name="src">The source stream</param>
            <typeparam name="T">The stream element type</typeparam>
        </member>
        <member name="M:Z0.XTend.TryGetSingle``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Returns a value if the source stream yeilds exactly one value that satisfied a predicate; otherwise, returns none
            </summary>
            <param name="stream">The stream to search</param>
            <param name="predicate">The predicate to match</param>
            <typeparam name="T">The stream item type</typeparam>
        </member>
        <member name="M:Z0.XTend.First``1(Z0.Option{``0[]})">
            <summary>
            Returns the value of the first element of an optional array, if extant; otherwise, raises an exception
            </summary>
            <param name="src">The optional array</param>
            <typeparam name="P">The array element type</typeparam>
        </member>
        <member name="M:Z0.XTend.FirstOrDefault``1(Z0.Option{``0[]})">
            <summary>
            Returns the value of the first element of an optional array, if extant; otherwise, returns a parametric default
            </summary>
            <param name="src">The optional array</param>
            <typeparam name="P">The array element type</typeparam>
        </member>
        <member name="M:Z0.XTend.TryGetFirst``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>
            Searches for the first element in the stream that satisfies a predicate and returns the element if found; otherwise, returns None
            </summary>
            <typeparam name="X">The stream item type</typeparam>
            <param name="src">The stream to search</param>
            <param name="predicate">The predicate to match</param>
        </member>
        <member name="M:Z0.XTend.TryGetFirst``1(System.Collections.Generic.IEnumerable{Z0.Option{``0}})">
            <summary>
            Returns the the first realized value as a valued option, if extant, from a stream of potential values; 
            otherwise, returns a non-valued option
            </summary>
            <param name="src">The potentials</param>
            <typeparam name="T">The potential value type</typeparam>
        </member>
        <member name="M:Z0.XTend.TryPop``1(System.Collections.Generic.Queue{``0})">
            <summary>
            Removes an element from the queue if one exists
            </summary>
            <typeparam name="T">The element type</typeparam>
            <param name="q">the queue</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.XTend.Values``1(System.Collections.Generic.IEnumerable{Z0.Option{``0}})" -->
        <member name="M:Z0.XTend.ToOption``1(System.Nullable{``0})">
            <summary>
            Lifts a nullable value type into the option monad
            </summary>
            <param name="src">The potential value</param>
            <typeparam name="T">The potential value type</typeparam>
        </member>
        <member name="M:Z0.XTend.ToNullable``1(Z0.Option{``0})">
            <summary>
            Extracts a nulluable value from an option over a nullable value type
            </summary>
            <param name="src">The potential value</param>
            <typeparam name="T">The potential value type</typeparam>
        </member>
        <member name="M:Z0.XTend.ToOption(System.Type)">
            <summary>
            Lifts a type value to an option that is valued iff the source type is non-void
            </summary>
            <param name="src">The value to lift</param>
        </member>
        <member name="M:Z0.XTend.MapRequired``2(Z0.Option{``0},System.Func{``0,``1})">
            <summary>
            Applies a map to a valued option; otherwise, raises an exception
            </summary>
            <param name="x">The optional value</param>
            <param name="f">The mapping function</param>
            <typeparam name="X">The source type</typeparam>
            <typeparam name="Y">The target type</typeparam>
        </member>
        <member name="M:Z0.XTend.Value``1(Z0.Option{``0})">
            <summary>
            Extracts the encapsluated value if present; otherwise returns the default value of the type
            </summary>
            <typeparam name="T">The value type</typeparam>
            <param name="x">The optional value</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.XTend.WhereNone``1(System.Collections.Generic.IEnumerable{Z0.Option{``0}})" -->
        <member name="M:Z0.XTend.WhereSome``1(System.Collections.Generic.IEnumerable{Z0.Option{``0}})">
            <summary>
            Selects the subsequence for which values exist, if any
            </summary>
            <typeparam name="T">The potential value type</typeparam>
            <param name="options">The sequence of options to examine</param>
        </member>
        <member name="M:Z0.XTend.Satisfies``1(Z0.Option{``0},System.Predicate{``0})">
            <summary>
            Returns true if an optioal value exists an a specified predicate over the value is satisfied
            </summary>
            <typeparam name="T">The value type</typeparam>
            <param name="x">The value to examine</param>
            <param name="predicate">The adjudicating predicate</param>
        </member>
        <member name="M:Z0.XTend.Split``1(System.Collections.Generic.IEnumerable{Z0.Option{``0}})">
            <summary>
            Bifurcates a stream of optional values into the haves/have nots
            </summary>
            <typeparam name="T">The optional value type</typeparam>
            <param name="options">The stream of options to evaluate</param>
        </member>
        <member name="M:Z0.XTend.All(Z0.IOption[])">
            <summary>
            Evaluates to true iff all options have values
            </summary>
            <param name="options">The options to evaluate</param>
        </member>
        <member name="M:Z0.XTend.WhenAll``2(Z0.Option{``0},Z0.Option{``1},System.Action{``0,``1})">
            <summary>
            Invokes an action when all supplied options have value
            </summary>
            <typeparam name="X1">The type of the first potential item</typeparam>
            <typeparam name="X2">The type of the second potential item</typeparam>
            <param name="x1">The first potential value</param>
            <param name="x2">The second potential value</param>
            <param name="f">The action to conditionally invoke</param>
        </member>
        <member name="M:Z0.XTend.WhenAll``3(Z0.Option{``0},Z0.Option{``1},Z0.Option{``2},System.Action{``0,``1,``2})">
            <summary>
            Invokes the supplied action if all values exist
            </summary>
            <typeparam name="X1">The type of the first potential value</typeparam>
            <typeparam name="X2">The type of the second potential value</typeparam>
            <typeparam name="X3">The type of the third potential value</typeparam>
            <param name="x1">The first potential value</param>
            <param name="x2">The second potential value</param>
            <param name="x3">The third potential value</param>
            <param name="f">The action to conditionally invoke</param>
        </member>
        <member name="M:Z0.XTend.OnValue``1(System.Nullable{``0},System.Action{``0})">
            <summary>
            Invokes an action if a nullable value type is valued
            </summary>
            <param name="src">The potential source value</param>
            <param name="f">The action to invoke over a realized value, if extant</param>
            <typeparam name="T">The potential value type</typeparam>
        </member>
        <member name="M:Z0.XTend.ValueOrDefault``1(Z0.Option{System.Nullable{``0}},System.Nullable{``0})">
            <summary>
            Extracts the encapsluated value if present; otherwise reutrns the underlying value type default
            </summary>
            <param name="x">The optional value</param>
            <typeparam name="T">The value type</typeparam>
        </member>
        <member name="M:Z0.XTend.ValueOrNone``1(System.Nullable{``0})">
            <summary>
            Transforms a nulluble value into an optional value
            </summary>
            <typeparam name="T">The underlying value type</typeparam>
            <param name="x">The potential value</param>
        </member>
        <member name="M:Z0.XTend.Map``2(System.Nullable{``0},System.Func{``0,``1})">
            <summary>
            Projects a source value, if non-null, onto a target value; otherwise, returns the target's default value
            </summary>
            <param name="src">The source value</param>
            <param name="f">The projector</param>
            <typeparam name="S">The source value type</typeparam>
            <typeparam name="T">The target value type</typeparam>
        </member>
        <member name="M:Z0.XTend.Map``2(System.Nullable{``0},System.Func{``0,``1},System.Func{``1})">
            <summary>
            Projects a source value, if non-null, onto a target value; otherwise, returns value raised by a caller-supplied emitter
            </summary>
            <param name="src">The source value</param>
            <param name="some">The projector</param>
            <param name="none">The alternative emitter</param>
            <typeparam name="S">The source value type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.XTend.Ignored(System.Reflection.MemberInfo)">
            <summary>
            Returns true if the [Ignore] attributed is applied to the target 
            </summary>
            <param name="target">The target</param>
        </member>
        <member name="M:Z0.XTend.NotIgnored(System.Reflection.MemberInfo)">
            <summary>
            Returns true if the target is not attributed with the [Ignore] attribute
            </summary>
            <param name="target">The target</param>
        </member>
        <member name="M:Z0.XTend.Ignore``1(``0[])">
            <summary>
            Excludes members with ignored metadata
            </summary>
            <param name="src">The members to filter</param>
        </member>
        <member name="M:Z0.XTend.Ignore``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Excludes members with ignored metadata
            </summary>
            <param name="src">The members to filter</param>
        </member>
        <member name="M:Z0.XTend.Angled(System.String)">
            <summary>
            Encloses text between less than and greater than characters
            </summary>
            <param name="content">The content to enclose</param>
        </member>
        <member name="M:Z0.XTend.CommaSeparated(System.Int16)">
            <summary>
            Formamats a number with comma separators
            </summary>
            <param name="src">The source number</param>
        </member>
        <member name="M:Z0.XTend.CommaSeparated(System.UInt16)">
            <summary>
            Formamats a number with comma separators
            </summary>
            <param name="src">The source number</param>
        </member>
        <member name="M:Z0.XTend.CommaSeparated(System.Int32)">
            <summary>
            Formamats a number with comma separators
            </summary>
            <param name="src">The source number</param>
        </member>
        <member name="M:Z0.XTend.CommaSeparated(System.UInt32)">
            <summary>
            Formamats a number with comma separators
            </summary>
            <param name="src">The source number</param>
        </member>
        <member name="M:Z0.XTend.CommaSeparated(System.Int64)">
            <summary>
            Formamats a number with comma separators
            </summary>
            <param name="src">The source number</param>
        </member>
        <member name="M:Z0.XTend.CommaSeparated(System.UInt64)">
            <summary>
            Formamats a number with comma separators
            </summary>
            <param name="src">The source number</param>
        </member>
        <member name="M:Z0.XTend.CommaSeparated(System.Single)">
            <summary>
            Formamats a number with comma separators
            </summary>
            <param name="src">The source number</param>
        </member>
        <member name="M:Z0.XTend.CommaSeparated(System.Double)">
            <summary>
            Formamats a number with comma separators
            </summary>
            <param name="src">The source number</param>
        </member>
        <member name="M:Z0.XTend.Partition(System.String,System.Int32)">
            <summary>
            Partitions a string into parts of a specified maximum width
            </summary>
            <param name="src">The source string</param>
            <param name="maxlen">The maximum length of a partition</param>
        </member>
        <member name="M:Z0.XTend.Remove(System.String,System.String)">
            <summary>
            Removes a substring from the source string if it exists
            </summary>
            <param name="s">The string to manipulate</param>
            <param name="substring">The substring to remove</param>
        </member>
        <member name="M:Z0.XTend.RemoveLast(System.String)">
            <summary>
            Creates a new string from the first n - 1 characters of a string of length n
            </summary>
            <param name="s">The source string</param>
        </member>
        <member name="M:Z0.XTend.RemoveSubstring(System.Collections.Generic.IEnumerable{System.String},System.String)">
            <summary>
            Removes all occurrences of a substring from the source strings where extant
            </summary>
            <param name="s">The strings to manipulate</param>
            <param name="substring">The substring to remove</param>
        </member>
        <member name="M:Z0.XTend.Replicate(System.String,System.Int32)">
            <summary>
            Creates a stream of replicated strings
            </summary>
            <param name="src">The character to replicate</param>
            <param name="count">The replication count</param>
        </member>
        <member name="M:Z0.XTend.Replicate(System.Char,System.Int32)">
            <summary>
            Creates a span of replicated characters
            </summary>
            <param name="src">The character to replicate</param>
            <param name="count">The replication count</param>
        </member>
        <member name="M:Z0.XTend.IsSome(Z0.CellWidth)">
            <summary>
            Determines whether the kind has a nonzero value
            </summary>
            <param name="src">The source kind</param>
        </member>
        <member name="T:Z0.ApiDataTypeAttribute">
            <summary>
            Marks a type as an api data type
            </summary>
        </member>
        <member name="T:Z0.ApiHostAttribute">
            <summary>
            Identifies an api host
            </summary>
        </member>
        <member name="T:Z0.ApiProviderAttribute">
            <summary>
            Applied to an exposed surface to classify its role/purpose
            </summary>
        </member>
        <member name="T:Z0.CmdAttribute">
            <summary>
            Identifies a concreate <see cref='!:ICmdSpec'/> realization
            </summary>
        </member>
        <member name="P:Z0.CmdAttribute.Name">
            <summary>
            The commoan name that serves as a contextual identifier
            </summary>
        </member>
        <member name="T:Z0.CmdWorkerAttribute">
            <summary>
            Applied to a method to indicate that it can execute a <see cref='!:CmdSpec'/>
            </summary>
        </member>
        <member name="T:Z0.FunctionalServiceAttribute">
            <summary>
            Identifies a type that defines an interface-contracted api surface
            </summary>
        </member>
        <member name="M:Z0.IdentityProviderAttribute.#ctor">
            <summary>
            Use of this constructor implies that the attribution target provides identies
            for what are likely unattributable types, such as framework-defined types, for example
            </summary>
        </member>
        <member name="T:Z0.IgnoreAttribute">
            <summary>
            Applies to an element to exclude it from metadata discovery processes
            </summary>
        </member>
        <member name="T:Z0.NumericBaseAttribute">
            <summary>
            Indicates the target's numeric base preference
            </summary>
        </member>
        <member name="T:Z0.OpAttribute">
            <summary>
            Identifies a formal operation for inclusing in the identity assignment and catalog system
            </summary>
        </member>
        <member name="T:Z0.OpKindAttribute">
            <summary>
            Identifies a formal operation and its kind
            </summary>
        </member>
        <member name="T:Z0.RenderFunctionAttribute">
            <summary>
            Identifies operations of the form source -> target:IRenderBuffer
            </summary>
        </member>
        <member name="T:Z0.RenderUtilityAttribute">
            <summary>
            Identifies operations that are general-purpose text formatting/render utilities
            </summary>
        </member>
        <member name="T:Z0.SpanOpAttribute">
            <summary>
            Identifies operations that accept one or more spans and computes a result that is stored in a caller-supplied target span
            </summary>
        </member>
        <member name="T:Z0.TextUtilityAttribute">
            <summary>
            Identifies operations that are general-purpose text processing utilities
            </summary>
        </member>
        <member name="T:Z0.ToolCmdAttribute">
            <summary>
            Identifies a tool command
            </summary>
        </member>
        <member name="T:Z0.TypedLiteralProviderAttribute">
            <summary>
            Applied to a type to advertise type literal definitions
            </summary>
        </member>
        <member name="P:Z0.TypedLiteralProviderAttribute.LiteralType">
            <summary>
            The defining literal type
            </summary>
        </member>
        <member name="T:Z0.ArithmeticApiClass">
            <summary>
            Identifies arithmetic operation kinds
            </summary>
        </member>
        <member name="F:Z0.ArithmeticApiClass.None">
            <summary>
            The empty identity
            </summary>
        </member>
        <member name="T:Z0.BinaryArithmeticApiClass">
            <summary>
            Identifies binary arithmetic operators classes
            </summary>
        </member>
        <member name="F:Z0.BinaryArithmeticApiClass.None">
            <summary>
            The empty identity
            </summary>
        </member>
        <member name="T:Z0.BinaryBitLogicApiClass">
            <summary>
            Classifies binary boolean and bitwise logical operations
            </summary>
        </member>
        <member name="F:Z0.BinaryBitLogicApiClass.None">
            <summary>
            The empty identity which, unfortunately conflicts with the inescapable defintion of 'False'
            </summary>
        </member>
        <member name="F:Z0.BinaryBitLogicApiClass.False">
            <summary>
            Classifies a logical  binary operator false(a,b) := bv(0000)
            </summary>
            <remarks>
            bv(0000) = id(True)
            </remarks>
        </member>
        <member name="F:Z0.BinaryBitLogicApiClass.And">
            <summary>
            Classifies a logical binary operator and(a,b) := bv(1000)
            </summary>
            <remarks>
            bv(1000) = id(Nor)
            0 0 0
            1 0 0
            0 1 0
            1 1 1
            </remarks>
        </member>
        <member name="F:Z0.BinaryBitLogicApiClass.CNonImpl">
            <summary>
            Classifies a logical binary operator cnotimply(a,b) := and(a, ~b) = bv(0010)
            </summary>
            <remarks>
            bv(0010) = id(ConverseNonimplication)
            Truth table:
            0 0 0
            1 0 1
            0 1 0
            1 1 0
            </remarks>
        </member>
        <member name="F:Z0.BinaryBitLogicApiClass.LProject">
            <summary>
            Classifies a logical binary operator left(a,b) := a = bv(1010)
            </summary>
            <remarks>
            bv(1010) = id(RightNot)
            Truth Table:
            0 0 0
            1 0 1
            0 1 0
            1 1 1
            </remarks>
        </member>
        <member name="F:Z0.BinaryBitLogicApiClass.NonImpl">
            <summary>
            Identifies a logical binary operator notimply(a,b) := and(~a, b) = bv(0100)
            </summary>
            <remarks>
            bv(0100) = id(Nonimplication)
            Truth table:
            0 0 0
            1 0 0
            0 1 1
            1 1 0
            </remarks>
        </member>
        <member name="F:Z0.BinaryBitLogicApiClass.RProject">
            <summary>
            Classifies a logical binary operator right(a,b) := b = bv(1100)
            </summary>
            <remarks>
            bv(1100) = id(LeftNot)
            Truth table:
            0 0 0
            1 0 0
            0 1 1
            1 1 1
            </remarks>
        </member>
        <member name="F:Z0.BinaryBitLogicApiClass.Xor">
            <summary>
            Classifies a logical binary operator xor(a,b) := bv(0110)
            </summary>
            <remarks>
            bv(0110) = id(XOr)
            Truth Table:
            0 0 0
            1 0 1
            0 1 1
            1 1 0
            </remarks>
        </member>
        <member name="F:Z0.BinaryBitLogicApiClass.Or">
            <summary>
            Classifies a logical binary operator or(a,b) := bv(1110)
            </summary>
            <remarks>
            bv(1110) = id(Nand)
            Truth Table:
            0 0 0
            1 0 1
            0 1 1
            1 1 1
            </remarks>
        </member>
        <member name="F:Z0.BinaryBitLogicApiClass.Nor">
            <summary>
            Classifies a logical binary operator that computes nor(a,b) := not(or(a,b)) = bv(0001)
            </summary>
            <remarks>
            bv(0001) = id(And)
            Truth Table:
            0 0 1
            1 0 0
            0 1 0
            1 1 0
            </remarks>
        </member>
        <member name="F:Z0.BinaryBitLogicApiClass.Xnor">
            <summary>
            Classifies a binary operator xnor(a,b) := not(xor(a,b)) = bv(1001)
            </summary>
            <remarks>
            bv(1001) = id(Xnor)
            Truth Table:
            0 0 1
            1 0 0
            0 1 0
            1 1 1
            </remarks>
        </member>
        <member name="F:Z0.BinaryBitLogicApiClass.RNot">
            <summary>
            Classifies a logical binary operator rnot(a,b) := not(b) = bv(0011)
            </summary>
            <remarks>
            bv(0011) = id(LeftProject)
            Truth table:
            0 0 1
            1 0 1
            0 1 0
            1 1 0
            </remarks>
        </member>
        <member name="F:Z0.BinaryBitLogicApiClass.Impl">
            <summary>
            Classifies a logical binary operator imply(a,b) := or(a, not(b)) = bv(1011)
            </summary>
            <remarks>
            bv(1011) = id(Implication)
            Truth table:
            0 0 1
            1 0 1
            0 1 0
            1 1 1
            </remarks>
        </member>
        <member name="F:Z0.BinaryBitLogicApiClass.LNot">
            <summary>
            Classifies a logical binary operator lnot(a,b) := not(a) = bv(0101)
            </summary>
            <remarks>
            bv(0101) = id(RightProject)
            Truth table:
            0 0 1
            1 0 0
            0 1 1
            1 1 0
            </remarks>
        </member>
        <member name="F:Z0.BinaryBitLogicApiClass.CImpl">
            <summary>
            Classifies a logical binary operator cimpl(a,b) := or(not(a), b) = bv(1101)
            </summary>
            bv(1101) = id(ConverseImplication)
            <remarks>
            Truth table:
            0 0 1
            1 0 0
            0 1 1
            1 1 1
            </remarks>
        </member>
        <member name="F:Z0.BinaryBitLogicApiClass.Nand">
            <summary>
            Classifies a logical binary operator nand(a,b) := not(and(a,b)) = bv(0111)
            </summary>
            <remarks>
            bv(0111) = id(Or)
            Truth Table:
            0 0 1
            1 0 1
            0 1 1
            1 1 0
            </remarks>
        </member>
        <member name="F:Z0.BinaryBitLogicApiClass.True">
            <summary>
            Classifies a logical binary operator true(a,b) = bv(1111)
            </summary>
            <remarks>
            bv(1111) = id(False)
            </remarks>
        </member>
        <member name="T:Z0.BinaryComparisonApiClass">
            <summary>
            Identifies binary comparison predicates
            </summary>
        </member>
        <member name="F:Z0.BinaryComparisonApiClass.None">
            <summary>
            The empty identity
            </summary>
        </member>
        <member name="F:Z0.BinaryComparisonApiClass.Eq">
            <summary>
            Classifies a binary operator that returns true iff its operands are equal
            </summary>
        </member>
        <member name="F:Z0.BinaryComparisonApiClass.Lt">
            <summary>
            Classifies a binary operator that returns true if the left operand is strictly smaller than the left operand
            </summary>
        </member>
        <member name="F:Z0.BinaryComparisonApiClass.LtEq">
            <summary>
            Classifies a binary operator that returns true if the left operand is smaller than or equal to the left operand
            </summary>
        </member>
        <member name="F:Z0.BinaryComparisonApiClass.Gt">
            <summary>
            Classifies a binary operator that returns true if the left operand is strictly greater than the left operand
            </summary>
        </member>
        <member name="F:Z0.BinaryComparisonApiClass.GtEq">
            <summary>
            Classifies a binary operator that returns true if the left operand is greater than or equal to the left operand
            </summary>
        </member>
        <member name="F:Z0.BinaryComparisonApiClass.Neq">
            <summary>
            Classifies a binary operator that returns true iff its operands are not equal
            </summary>
        </member>
        <member name="T:Z0.BitFunctionApiClass">
            <summary>
            Identifies bitwise operations in an arity-neutral way
            </summary>
        </member>
        <member name="T:Z0.BitShiftApiClass">
            <summary>
            Identifies bitwise shift operators
            </summary>
        </member>
        <member name="F:Z0.BitShiftApiClass.None">
            <summary>
            The empty identity
            </summary>
        </member>
        <member name="F:Z0.BitShiftApiClass.Sll">
            <summary>
            Identifies a logical left-shift operator
            </summary>
        </member>
        <member name="F:Z0.BitShiftApiClass.Sllv">
            <summary>
            Identifies a variable logical left-shift operator
            </summary>
        </member>
        <member name="F:Z0.BitShiftApiClass.Srl">
            <summary>
            Identifies a logical right-shift operator
            </summary>
        </member>
        <member name="F:Z0.BitShiftApiClass.Srlv">
            <summary>
            Identifies a variable logical right-shift operator
            </summary>
        </member>
        <member name="F:Z0.BitShiftApiClass.Sal">
            <summary>
            Identifies an arithmetic left-shift operator
            </summary>
        </member>
        <member name="F:Z0.BitShiftApiClass.Sra">
            <summary>
            Identifies an arithmetic right-shift operator
            </summary>
        </member>
        <member name="F:Z0.BitShiftApiClass.Rotl">
            <summary>
            Identifies a left circular shift operator
            </summary>
        </member>
        <member name="F:Z0.BitShiftApiClass.Rotr">
            <summary>
            Identifies a right circular shift operator
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Z0.BitShiftApiClass.XorSl" -->
        <member name="F:Z0.BitShiftApiClass.XorSr">
            <summary>
            Identifies a composite shift operator of the form a^(a >> offset)
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Z0.BitShiftApiClass.Xors" -->
        <member name="T:Z0.CanonicalApiClass">
            <summary>
            Classifies binary boolean and bitwise logical operations
            </summary>
        </member>
        <member name="F:Z0.CanonicalApiClass.Zero">
            <summary>
            Classifies an operation that produces an additive monoidal identity value
            </summary>
        </member>
        <member name="F:Z0.CanonicalApiClass.One">
            <summary>
            Classifies an operation that produces a multiplicative monoidal identity value
            </summary>
        </member>
        <member name="F:Z0.CanonicalApiClass.Test">
            <summary>
            Classifies an operation that evaluates one or more operands to determine that a subject is, or is not, of some target kind
            </summary>
        </member>
        <member name="F:Z0.CanonicalApiClass.Ones">
            <summary>
            Pervasive truth
            </summary>
        </member>
        <member name="F:Z0.CanonicalApiClass.Zeroes">
            <summary>
            The unbearable nothingness of the void
            </summary>
        </member>
        <member name="F:Z0.CanonicalApiClass.Switch">
            <summary>
            Classifies an operation that implements a switch statement
            </summary>
        </member>
        <member name="T:Z0.ComparisonApiClass">
            <summary>
            Identifies comparison (predicate) kinds
            </summary>
        </member>
        <member name="F:Z0.ComparisonApiClass.None">
            <summary>
            The empty identity
            </summary>
        </member>
        <member name="F:Z0.ComparisonApiClass.Eq">
            <summary>
            Classifies a binary operator that returns true iff its operands are equal
            </summary>
        </member>
        <member name="F:Z0.ComparisonApiClass.Lt">
            <summary>
            Classifies a binary operator that returns true if the left operand is strictly smaller than the left operand
            </summary>
        </member>
        <member name="F:Z0.ComparisonApiClass.LtEq">
            <summary>
            Classifies a binary operator that returns true if the left operand is smaller than or equal to the left operand
            </summary>
        </member>
        <member name="F:Z0.ComparisonApiClass.Gt">
            <summary>
            Classifies a binary operator that returns true if the left operand is strictly greater than the left operand
            </summary>
        </member>
        <member name="F:Z0.ComparisonApiClass.GtEq">
            <summary>
            Classifies a binary operator that returns true if the left operand is greater than or equal to the left operand
            </summary>
        </member>
        <member name="F:Z0.ComparisonApiClass.Neq">
            <summary>
            Classifies a binary operator that returns true iff its operands are not equal
            </summary>
        </member>
        <member name="F:Z0.MemoryApiClass.Alloc">
            <summary>
            Identifies operations that allocate memory/resources
            </summary>
        </member>
        <member name="F:Z0.MemoryApiClass.Store">
            <summary>
            Identifies operations that move data from A -> B
            </summary>
        </member>
        <member name="F:Z0.MemoryApiClass.Load">
            <summary>
            Identifies operations that move data from B -> A
            </summary>
        </member>
        <member name="F:Z0.MemoryApiClass.Recover">
            <summary>
            Identifies an operation that accepts a memory buffer, such as a memory segmented covered by an S-span,
            and returns the buffer unaltered but with an alternate presentation, such as a T-span
            </summary>
        </member>
        <member name="T:Z0.NumericApiClass">
            <summary>
            Defines numeric identifiers for primal numeric types
            </summary>
        </member>
        <member name="F:Z0.SystemApiClass.Alloc">
            <summary>
            Identifies operations that allocate memory/resources
            </summary>
        </member>
        <member name="F:Z0.SystemApiClass.Store">
            <summary>
            Identifies operations that move data from A -> B
            </summary>
        </member>
        <member name="F:Z0.SystemApiClass.Load">
            <summary>
            Identifies operations that move data from B -> A
            </summary>
        </member>
        <member name="F:Z0.SystemApiClass.Init">
            <summary>
            Identifies operations that initialize a resource where allocation may be required...or not
            </summary>
        </member>
        <member name="F:Z0.SystemApiClass.Kind">
            <summary>
            Identifies operations assign kind classifiers
            </summary>
        </member>
        <member name="T:Z0.TranscendentalApiClass">
            <summary>
            Identifies transcental operation kinds
            </summary>
        </member>
        <member name="T:Z0.UnaryArithmeticApiClass">
            <summary>
            Classifies unary arithmetic operators
            </summary>
        </member>
        <member name="T:Z0.AsmAttribute">
            <summary>
            Identifies a formal operation and its kind
            </summary>
        </member>
        <member name="T:Z0.ImmAttribute">
            <summary>
            Identifies a parameter that accepts an immediate value
            </summary>
        </member>
        <member name="T:Z0.KindFactoryAttribute">
            <summary>
            Identifies a parameter that accepts an immediate value
            </summary>
        </member>
        <member name="T:Z0.NaturalsAttribute">
            <summary>
            Specifies closures over natural number types
            </summary>
        </member>
        <member name="T:Z0.NatPairsAttribute">
            <summary>
            Specifies closures over pairs of natural number types
            </summary>
        </member>
        <member name="T:Z0.NumericClosuresAttribute">
            <summary>
            Applies to a generic type/method to advertise the types over which type parameter(s) may be closed
            </summary>
        </member>
        <member name="T:Z0.VectorAttribute">
            <summary>
            Applied to a user-defined type to identify it as an intrinsic vector (or, rather, should be treated/classified as one)
            </summary>
        </member>
        <member name="T:Z0.WidthAttribute">
            <summary>
            Applied directly to a type, or subclassed, to specify the physical or logical type width
            </summary>
        </member>
        <member name="P:Z0.WidthAttribute.TypeWidth">
            <summary>
            The logical width of the attributed type
            </summary>
        </member>
        <member name="F:Z0.ImmClosureKind.Individuals">
            <summary>
            Indicates closure is specified for an explicitly-specified set of immediates
            </summary>
        </member>
        <member name="F:Z0.ImmClosureKind.Range">
            <summary>
            Indicates closure is specified for a range of immediates
            </summary>
        </member>
        <member name="F:Z0.ImmClosureKind.Powers2">
            <summary>
            Indicates closure is specified for an inclusive range of powers of 2
            </summary>
        </member>
        <member name="T:Z0.ApiOperatorClass">
            <summary>
            Classifies operators of arity up to 3
            </summary>
        </member>
        <member name="F:Z0.ApiOperatorClass.None">
            <summary>
            The empty class
            </summary>
        </member>
        <member name="F:Z0.ApiOperatorClass.Emitter">
            <summary>
            Classifies an emitter as an operator
            </summary>
        </member>
        <member name="F:Z0.ApiOperatorClass.Operator">
            <summary>
            Classifies functions for which operands and return type are homogenous
            </summary>
        </member>
        <member name="F:Z0.ApiOperatorClass.UnaryOp">
            <summary>
            Classifies operators that accept one argument
            </summary>
        </member>
        <member name="F:Z0.ApiOperatorClass.BinaryOp">
            <summary>
            Classifies operators that accept two arguments
            </summary>
        </member>
        <member name="F:Z0.ApiOperatorClass.TernaryOp">
            <summary>
            Classifies operators that accept three arguments
            </summary>
        </member>
        <member name="F:Z0.ApiOperatorClass.ShiftOp">
            <summary>
            Classifies shift operators
            </summary>
        </member>
        <member name="F:Z0.ApiOperatorClass.UnaryShiftOp">
            <summary>
            Classifies shift operators with one operand under shift
            </summary>
        </member>
        <member name="F:Z0.ApiOperatorClass.BinaryShiftOp">
            <summary>
            Classifies shift operators with two operands under shift
            </summary>
        </member>
        <member name="F:Z0.ApiPredicateClass.None">
            <summary>
            The empty class
            </summary>
        </member>
        <member name="F:Z0.ApiPredicateClass.Predicate">
            <summary>
            Classifies functions that return a system boolean value or a bit value
            </summary>
        </member>
        <member name="F:Z0.ApiPredicateClass.UnaryPredicate">
            <summary>
            Classifies predicates that accept one argument
            </summary>
        </member>
        <member name="F:Z0.ApiPredicateClass.BinaryPredicate">
            <summary>
            Classifies predicates that accept two arguments
            </summary>
        </member>
        <member name="F:Z0.ApiPredicateClass.TernaryPredicate">
            <summary>
            Classifies predicates that accept three arguments
            </summary>
        </member>
        <member name="F:Z0.ArityKind.None">
            <summary>
            Classifies nothing
            </summary>
        </member>
        <member name="F:Z0.ArityKind.Nullary">
            <summary>
            Classifies operations of arity 0
            </summary>
        </member>
        <member name="F:Z0.ArityKind.Unary">
            <summary>
            Classifies operations of arity 1
            </summary>
        </member>
        <member name="F:Z0.ArityKind.Binary">
            <summary>
            Classifies operations of arity 2
            </summary>
        </member>
        <member name="F:Z0.ArityKind.Ternary">
            <summary>
            Classifies operations of arity 3
            </summary>
        </member>
        <member name="T:Z0.CellOperatorKind">
            <summary>
            Defines operator classifiers
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.None">
            <summary>
            Classifies nothing
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.FixedSigClass">
            <summary>
            Classifies functions with fixed operand and return types
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.FixedSlot">
            <summary>
            Classifies a signature position
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Operand">
            <summary>
            Classifies a fixed operand type
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Return">
            <summary>
            Classifies a fixed return type
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Slot0">
            <summary>
            The first slot
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Slot1">
            <summary>
            The second slot
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Slot2">
            <summary>
            The third slot
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Slot3">
            <summary>
            The fourth slot
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Slot4">
            <summary>
            The pentultimate slot
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Slot5">
            <summary>
            The last slot
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.SigSpec">
            <summary>
            The signature specification lower bound
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Function">
            <summary>
            The function signature specification lower bound
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Operator">
            <summary>
            The operator signature specification lower bound
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.UnaryFunc1x1">
            <summary>
            A unary function f:w1 -> w1
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.UnaryFunc1x8">
            <summary>
            A unary function f:w1 -> w8
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.UnaryFunc1x16">
            <summary>
            A unary function f:w1 -> w16
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.UnaryFunc1x32">
            <summary>
            A unary function f:w1 -> w32
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.UnaryFunc1x64">
            <summary>
            A unary function f:w1 -> w64
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.UnaryOp1">
            <summary>
            A 1-bit unary operator
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.UnaryOp8">
            <summary>
            An 8-bit unary operator
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.UnaryOp16">
            <summary>
            An 16-bit unary operator
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.UnaryOp32">
            <summary>
            An 32-bit unary operator
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.UnaryOp64">
            <summary>
            An 64-bit unary operator
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.UnaryOp128">
            <summary>
            An 128-bit unary operator
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.UnaryOp256">
            <summary>
            An 256-bit unary operator
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.UnaryOp512">
            <summary>
            An 512-bit unary operator
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.BinaryOp1">
            <summary>
            A 1-bit binary operator
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.BinaryOp8">
            <summary>
            An 8-bit binary operator
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.BinaryOp16">
            <summary>
            An 16-bit binary operator
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.BinaryOp32">
            <summary>
            An 32-bit binary operator
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.BinaryOp64">
            <summary>
            An 64-bit binary operator
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.BinaryOp128">
            <summary>
            An 128-bit binary operator
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.BinaryOp256">
            <summary>
            An 256-bit binary operator
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.BinaryOp512">
            <summary>
            An 512-bit binary operator
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.TernaryOp1">
            <summary>
            A 1-bit ternary operator
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.TernaryOp8">
            <summary>
            An 8-bit ternary operator
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.TernaryOp16">
            <summary>
            An 16-bit ternary operator
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.TernaryOp32">
            <summary>
            An 32-bit ternary operator
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.TernaryOp64">
            <summary>
            An 64-bit ternary operator
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.TernaryOp128">
            <summary>
            An 128-bit ternary operator
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.TernaryOp256">
            <summary>
            An 256-bit ternary operator
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.TernaryOp512">
            <summary>
            An 512-bit ternary operator
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.FixedSlot1">
            <summary>
            1-bit value in slot
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.FixedSlot8">
            <summary>
            8-bit value in slot
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.FixedSlot16">
            <summary>
            16-bit value in slot
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.FixedSlot32">
            <summary>
            32-bit value in slot
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.FixedSlot64">
            <summary>
            54-bit value in slot
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.FixedSlot128">
            <summary>
            128-bit value in slot
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.FixedSlot256">
            <summary>
            256-bit value in slot
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.FixedSlot512">
            <summary>
            512-bit value in slot
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Operand0">
            <summary>
            The first operand slot
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Operand1">
            <summary>
            The second operand slot
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Operand2">
            <summary>
            The third operand slot
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Operand3">
            <summary>
            The fourth operand slot
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Operand4">
            <summary>
            The fifth operand slot
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.ReturnSlot">
            <summary>
            The retun slot
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed1x0">
            <summary>
            1-bit operand in slot 0
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed1x1">
            <summary>
            1-bit operand in slot 1
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed1x2">
            <summary>
            1-bit operand in slot 2
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed1x3">
            <summary>
            1-bit operand in slot 3
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed1x4">
            <summary>
            1-bit operand in slot 4
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed8x0">
            <summary>
            8-bit operand in slot 0
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed8x1">
            <summary>
            8-bit operand in slot 1
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed8x2">
            <summary>
            8-bit operand in slot 2
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed8x3">
            <summary>
            8-bit operand in slot 3
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed8x4">
            <summary>
            8-bit operand in slot 4
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed16x0">
            <summary>
            16-bit operand in slot 0
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed16x1">
            <summary>
            16-bit operand in slot 1
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed16x2">
            <summary>
            16-bit operand in slot 2
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed16x3">
            <summary>
            16-bit operand in slot 3
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed16x4">
            <summary>
            16-bit operand in slot 4
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed32x0">
            <summary>
            32-bit operand in slot 0
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed32x1">
            <summary>
            32-bit operand in slot 1
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed32x2">
            <summary>
            32-bit operand in slot 2
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed32x3">
            <summary>
            32-bit operand in slot 3
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed32x4">
            <summary>
            32-bit operand in slot 4
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed64x0">
            <summary>
            64-bit operand in slot 0
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed64x1">
            <summary>
            64-bit operand in slot 1
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed64x2">
            <summary>
            64-bit operand in slot 2
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed64x3">
            <summary>
            64-bit operand in slot 3
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed64x4">
            <summary>
            64-bit operand in slot 4
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed128x0">
            <summary>
            64-bit operand in slot 0
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed128x1">
            <summary>
            128-bit operand in slot 1
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed128x2">
            <summary>
            128-bit operand in slot 2
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed128x3">
            <summary>
            128-bit operand in slot 3
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed128x4">
            <summary>
            128-bit operand in slot 4
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed256x0">
            <summary>
            64-bit operand in slot 0
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed256x1">
            <summary>
            256-bit operand in slot 1
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed256x2">
            <summary>
            256-bit operand in slot 2
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed256x3">
            <summary>
            256-bit operand in slot 3
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed256x4">
            <summary>
            256-bit operand in slot 4
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed512x0">
            <summary>
            64-bit operand in slot 0
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed512x1">
            <summary>
            512-bit operand in slot 1
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed512x2">
            <summary>
            512-bit operand in slot 2
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed512x3">
            <summary>
            512-bit operand in slot 3
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Fixed512x4">
            <summary>
            512-bit operand in slot 4
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Return1">
            <summary>
            1-bit return in last slot
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Return8">
            <summary>
            8-bit return in last slot
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Return16">
            <summary>
            16-bit return in last slot
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Return32">
            <summary>
            32-bit return in last slot
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Return64">
            <summary>
            64-bit return in last slot
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Return128">
            <summary>
            128-bit return in last slot
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Return256">
            <summary>
            256-bit return in last slot
            </summary>
        </member>
        <member name="F:Z0.CellOperatorKind.Return512">
            <summary>
            512-bit return in last slot
            </summary>
        </member>
        <member name="T:Z0.IdentityTargetKind">
            <summary>
            Enumerates the identifiable things
            </summary>
        </member>
        <member name="F:Z0.IdentityTargetKind.Type">
            <summary>
            Designates type identity
            </summary>
        </member>
        <member name="F:Z0.IdentityTargetKind.Method">
            <summary>
            Designates operation identity
            </summary>
        </member>
        <member name="T:Z0.ImmFunctionClass">
            <summary>
            Classifies operations according to their immediate needs
            </summary>
        </member>
        <member name="F:Z0.ImmFunctionClass.None">
            <summary>
            The empty class
            </summary>
        </member>
        <member name="F:Z0.ImmFunctionClass.Imm8">
            <summary>
            Classifies operations that accept one or more immediate values
            </summary>
        </member>
        <member name="F:Z0.ImmFunctionClass.ImmSlot0">
            <summary>
            Classifies operations that accept immediate values in the first parameter
            </summary>
        </member>
        <member name="F:Z0.ImmFunctionClass.ImmSlot1">
            <summary>
            Classifies operations that accept immediate values in the second parameter
            </summary>
        </member>
        <member name="F:Z0.ImmFunctionClass.ImmSlot2">
            <summary>
            Classifies operations that accept immediate values in the third parameter
            </summary>
        </member>
        <member name="F:Z0.ImmFunctionClass.ImmSlot3">
            <summary>
            Classifies operations that accept immediate values in the fourth parameter
            </summary>
        </member>
        <member name="F:Z0.ImmFunctionClass.ImmSlot4">
            <summary>
            Classifies operations that accept immediate values in the fifth parameter
            </summary>
        </member>
        <member name="F:Z0.ImmFunctionClass.ImmCount1">
            <summary>
            Classifies operations that immediate one immediate value
            </summary>
        </member>
        <member name="F:Z0.ImmFunctionClass.ImmCount2">
            <summary>
            Classifies operations that immediate two immediate values
            </summary>
        </member>
        <member name="F:Z0.ImmFunctionClass.UnaryImm8">
            <summary>
            F:A -> byte -> A
            </summary>
        </member>
        <member name="F:Z0.ImmFunctionClass.BinaryImm8">
            <summary>
            F:A -> A -> byte -> A
            </summary>
        </member>
        <member name="F:Z0.ImmFunctionClass.TernaryImm8">
            <summary>
            F:A -> A -> A -> byte -> A
            </summary>
        </member>
        <member name="F:Z0.ImmFunctionClass.UnaryImm8x2">
            <summary>
            F:A -> byte -> byte -> A
            </summary>
        </member>
        <member name="F:Z0.ImmFunctionClass.BinaryImm8x2">
            <summary>
            F:A -> A -> byte -> byte -> A
            </summary>
        </member>
        <member name="F:Z0.ImmFunctionClass.TernaryImm8x2">
            <summary>
            F:A -> A -> A -> byte -> byte -> A
            </summary>
        </member>
        <member name="T:Z0.OperationKind">
            <summary>
            Classifies an operation in various ways
            </summary>
        </member>
        <member name="F:Z0.OperationKind.None">
            <summary>
            The empty class
            </summary>
        </member>
        <member name="F:Z0.OperationKind.Nullary">
            <summary>
            Classifies operations of arity 0
            </summary>
        </member>
        <member name="F:Z0.OperationKind.Unary">
            <summary>
            Classifies operations of arity 1
            </summary>
        </member>
        <member name="F:Z0.OperationKind.Binary">
            <summary>
            Classifies operations of arity 2
            </summary>
        </member>
        <member name="F:Z0.OperationKind.Ternary">
            <summary>
            Classifies operations of arity 3
            </summary>
        </member>
        <member name="F:Z0.OperationKind.Action">
            <summary>
            Classifies operations with void return
            </summary>
        </member>
        <member name="F:Z0.OperationKind.Function">
            <summary>
            Classifies operations as those with non-void return
            </summary>
        </member>
        <member name="F:Z0.OperationKind.Operator">
            <summary>
            Classifies functions for which operands and return type are homogenous
            </summary>
        </member>
        <member name="F:Z0.OperationKind.Predicate">
            <summary>
            Classifies functions that return a system boolean value or a bit value
            </summary>
        </member>
        <member name="F:Z0.OperationKind.Shift">
            <summary>
            Classifies functions that shift/rotate bits
            </summary>
        </member>
        <member name="F:Z0.OperationKind.System">
            <summary>
            Classifies system-level operations
            </summary>
        </member>
        <member name="F:Z0.OperationKind.LastClass">
            <summary>
            The last pure classifier
            </summary>
        </member>
        <member name="F:Z0.OperationKind.Receiver">
            <summary>
            Classifies actions that accept one argument
            </summary>
        </member>
        <member name="F:Z0.OperationKind.UnaryAction">
            <summary>
            Classifies actions that accept one argument
            </summary>
        </member>
        <member name="F:Z0.OperationKind.BinaryAction">
            <summary>
            Classifies actions that accept two arguments
            </summary>
        </member>
        <member name="F:Z0.OperationKind.TernaryAction">
            <summary>
            Classifies actions that accept three arguments
            </summary>
        </member>
        <member name="F:Z0.OperationKind.Emitter">
            <summary>
            Classifies functions that accept no arguments
            </summary>
        </member>
        <member name="F:Z0.OperationKind.UnaryFunc">
            <summary>
            Classifies functions that accept one argument
            </summary>
        </member>
        <member name="F:Z0.OperationKind.BinaryFunc">
            <summary>
            Classifies functions that accept two arguments
            </summary>
        </member>
        <member name="F:Z0.OperationKind.TernaryFunc">
            <summary>
            Classifies functions that accept three arguments
            </summary>
        </member>
        <member name="F:Z0.OperationKind.UnaryOp">
            <summary>
            Classifies operators that accept one argument
            </summary>
        </member>
        <member name="F:Z0.OperationKind.BinaryOp">
            <summary>
            Classifies operators that accept two arguments
            </summary>
        </member>
        <member name="F:Z0.OperationKind.TernaryOp">
            <summary>
            Classifies operators that accept three arguments
            </summary>
        </member>
        <member name="F:Z0.OperationKind.ShiftOp">
            <summary>
            Classifies shift functions that accept two argument types: the value to shift and the magnitude of the shift
            </summary>
        </member>
        <member name="F:Z0.OperationKind.UnaryShiftOp">
            <summary>
            Classifies shift operators with two arguments
            </summary>
        </member>
        <member name="F:Z0.OperationKind.BinaryShiftOp">
            <summary>
            Classifies shift operators with three arguments
            </summary>
        </member>
        <member name="F:Z0.OperationKind.UnaryPredicate">
            <summary>
            Classifies an operation as a unary predicate
            </summary>
        </member>
        <member name="F:Z0.OperationKind.BinaryPredicate">
            <summary>
            Classifies an operation as a binary predicate
            </summary>
        </member>
        <member name="F:Z0.OperationKind.TernaryPredicate">
            <summary>
            Classifies an operation as a ternary predicate
            </summary>
        </member>
        <member name="F:Z0.NatClosureKind.Individuals">
            <summary>
            Indicates closure is specified for an explicitly-specified set naturals
            </summary>
        </member>
        <member name="F:Z0.NatClosureKind.Range">
            <summary>
            Indicates closure is specified for an inclusive range of naturals
            </summary>
        </member>
        <member name="F:Z0.NatClosureKind.Powers2">
            <summary>
            Indicates closure is specified for an inclusive power-of-two range specified by a min/max pair
            </summary>
        </member>
        <member name="F:Z0.NatClosureKind.ExplicitPairs">
            <summary>
            Indicates closure is specified for explicit pairs of natural numbers
            </summary>
        </member>
        <member name="F:Z0.WidthClosureKind.Individuals">
            <summary>
            Indicates closure is specified for an explicitly-specified set naturals
            </summary>
        </member>
        <member name="F:Z0.WidthClosureKind.Range">
            <summary>
            Indicates closure is specified for a continuous power-of-two sequence
            </summary>
        </member>
        <member name="T:Z0.Limits">
            <summary>
            Defines literals that specify numeric type limits
            </summary>
        </member>
        <member name="F:Z0.Limits.Min1u">
            <summary>
            The minimum representable <see cref='!:BitSeq1'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Max1u">
            <summary>
            The maximum representable <see cref='!:BitSeq1'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Min2u">
            <summary>
            The minimum representable <see cref='!:BitSeq2'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Max2u">
            <summary>
            The maximum representable <see cref='!:BitSeq2'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Min3u">
            <summary>
            The minimum representable <see cref='!:BitSeq3'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Max3u">
            <summary>
            The maximum representable <see cref='!:BitSeq3'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Min4u">
            <summary>
            The minimum representable <see cref='!:BitSeq4'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Max4u">
            <summary>
            The maximum representable <see cref='!:BitSeq4'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Min5u">
            <summary>
            The minimum representable <see cref='!:BitSeq5'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Max5u">
            <summary>
            The maximum representable <see cref='!:BitSeq5'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Min6u">
            <summary>
            The minimum representable <see cref='!:BitSeq6'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Max6u">
            <summary>
            The maximum representable <see cref='!:BitSeq6'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Min7u">
            <summary>
            The minimum representable <see cref='!:BitSeq7'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Max7u">
            <summary>
            The maximum representable <see cref='!:BitSeq7'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Min8i">
            <summary>
            The minimum representable <see cref='T:System.SByte'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Max8i">
            <summary>
            The maximum representable <see cref='T:System.SByte'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Min8u">
            <summary>
            The minimum representable <see cref='T:System.Byte'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Max8u">
            <summary>
            The maximum representable <see cref='T:System.Byte'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Min16i">
            <summary>
            The minimum representable <see cref='T:System.Int16'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Max16i">
            <summary>
            The maximum representable <see cref='T:System.Int16'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Min16u">
            <summary>
            The minimum representable <see cref='T:System.UInt16'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Max16u">
            <summary>
            The maximum representable <see cref='T:System.UInt16'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Min24u">
            <summary>
            The minimum representable uint24 value
            </summary>
        </member>
        <member name="F:Z0.Limits.Max24u">
            <summary>
            The maximum representable <see cref='T:System.UInt16'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Min32i">
            <summary>
            The minimum representable <see cref='T:System.Int32'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Max32i">
            <summary>
            The maximum representable <see cref='T:System.Int32'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Min32u">
            <summary>
            The minimum representable <see cref='T:System.UInt32'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Max32u">
            <summary>
            The maximum representable <see cref='T:System.UInt32'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Min64i">
            <summary>
            The minimum representable <see cref='T:System.Int64'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Max64i">
            <summary>
            The maximum representable <see cref='T:System.Int64'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Min64u">
            <summary>
            The minimum representable <see cref='T:System.UInt64'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Max64u">
            <summary>
            The maximum representable <see cref='T:System.UInt64'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Min32f">
            <summary>
            The minimum representable <see cref='T:System.Single'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Max32f">
            <summary>
            The maximum representable <see cref='T:System.Single'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Min64f">
            <summary>
            The minimum representable <see cref='T:System.Double'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Max64f">
            <summary>
            The maximum representable <see cref='T:System.Double'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Min128f">
            <summary>
            The minimum representable <see cref='T:System.Decimal'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Max128f">
            <summary>
            The maximum representable <see cref='T:System.Decimal'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Min16c">
            <summary>
            The minimum representable <see cref='T:System.Char'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits.Max16c">
            <summary>
            The maximum representable <see cref='T:System.Char'/> value
            </summary>
        </member>
        <member name="T:Z0.Limits16i">
            <summary>
            Defines lower/upper bounds for <see cref='T:System.Int16'/> values
            </summary>
        </member>
        <member name="F:Z0.Limits16i.Min">
            <summary>
            The minimum representable <see cref='T:System.Int16'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits16i.Max">
            <summary>
            The maximum representable <see cref='T:System.Int16'/> value
            </summary>
        </member>
        <member name="T:Z0.Limits16u">
            <summary>
            Defines lower/upper bounds for <see cref='T:System.UInt16'/> values
            </summary>
        </member>
        <member name="F:Z0.Limits16u.Min">
            <summary>
            The minimum representable <see cref='T:System.UInt16'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits16u.Max">
            <summary>
            The maximum representable <see cref='T:System.UInt16'/> value
            </summary>
        </member>
        <member name="T:Z0.Limits1u">
            <summary>
            Defines lower/upper bounds for a <see cref='!:BitSeq1'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits1u.Min">
            <summary>
            The minimum representable <see cref='!:BitSeq1'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits1u.Max">
            <summary>
            The maximum representable <see cref='!:BitSeq1'/> value
            </summary>
        </member>
        <member name="T:Z0.Limits24u">
            <summary>
            Defines lower/upper bounds for uint24 values
            </summary>
        </member>
        <member name="F:Z0.Limits24u.Min">
            <summary>
            The minimum representable uint24 value
            </summary>
        </member>
        <member name="F:Z0.Limits24u.Max">
            <summary>
            The maximum representable uint24 value
            </summary>
        </member>
        <member name="T:Z0.Limits2u">
            <summary>
            Defines lower/upper bounds for a <see cref='!:BitSeq2'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits2u.Min">
            <summary>
            The minimum representable <see cref='!:BitSeq2'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits2u.Max">
            <summary>
            The maximum representable <see cref='!:BitSeq2'/> value
            </summary>
        </member>
        <member name="T:Z0.Limits32i">
            <summary>
            Defines lower/upper bounds for <see cref='T:System.Int32'/> values
            </summary>
        </member>
        <member name="F:Z0.Limits32i.Min">
            <summary>
            The minimum representable <see cref='T:System.Int32'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits32i.Max">
            <summary>
            The maximum representable <see cref='T:System.Int32'/> value
            </summary>
        </member>
        <member name="T:Z0.Limits32u">
            <summary>
            Defines lower/upper bounds for <see cref='T:System.UInt32'/> values
            </summary>
        </member>
        <member name="F:Z0.Limits32u.Min">
            <summary>
            The minimum representable <see cref='T:System.UInt32'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits32u.Max">
            <summary>
            The maximum representable <see cref='T:System.UInt32'/> value
            </summary>
        </member>
        <member name="T:Z0.Limits3u">
            <summary>
            Defines lower/upper bounds for a <see cref='!:BitSeq3'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits3u.Min">
            <summary>
            The minimum representable <see cref='!:BitSeq3'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits3u.Max">
            <summary>
            The maximum representable <see cref='!:BitSeq3'/> value
            </summary>
        </member>
        <member name="T:Z0.Limits4u">
            <summary>
            Defines lower/upper bounds for a <see cref='!:BitSeq4'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits4u.Min">
            <summary>
            The minimum representable <see cref='!:BitSeq4'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits4u.Max">
            <summary>
            The maximum representable <see cref='!:BitSeq4'/> value
            </summary>
        </member>
        <member name="T:Z0.Limits5u">
            <summary>
            Defines lower/upper bounds for a <see cref='!:BitSeq5'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits5u.Min">
            <summary>
            The minimum representable <see cref='!:BitSeq5'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits5u.Max">
            <summary>
            The maximum representable <see cref='!:BitSeq5'/> value
            </summary>
        </member>
        <member name="T:Z0.Limits64i">
            <summary>
            Defines lower/upper bounds for <see cref='T:System.Int64'/> values
            </summary>
        </member>
        <member name="F:Z0.Limits64i.Min">
            <summary>
            The minimum representable <see cref='T:System.Int64'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits64i.Max">
            <summary>
            The maximum representable <see cref='T:System.Int64'/> value
            </summary>
        </member>
        <member name="T:Z0.Limits64u">
            <summary>
            Defines lower/upper bounds for <see cref='T:System.UInt64'/> values
            </summary>
        </member>
        <member name="F:Z0.Limits64u.Min">
            <summary>
            The minimum representable <see cref='T:System.UInt64'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits64u.Max">
            <summary>
            The maximum representable <see cref='T:System.UInt64'/> value
            </summary>
        </member>
        <member name="T:Z0.Limits6u">
            <summary>
            Defines lower/upper bounds for a <see cref='!:BitSeq6'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits6u.Min">
            <summary>
            The minimum representable <see cref='!:BitSeq6'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits6u.Max">
            <summary>
            The maximum representable <see cref='!:BitSeq6'/> value
            </summary>
        </member>
        <member name="T:Z0.Limits7u">
            <summary>
            Defines lower/upper bounds for a <see cref='!:BitSeq7'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits7u.Min">
            <summary>
            The minimum representable <see cref='!:BitSeq7'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits7u.Max">
            <summary>
            The maximum representable <see cref='!:BitSeq7'/> value
            </summary>
        </member>
        <member name="T:Z0.Limits8i">
            <summary>
            Defines lower/upper bounds for <see cref='T:System.SByte'/> values
            </summary>
        </member>
        <member name="F:Z0.Limits8i.Min">
            <summary>
            The minimum representable <see cref='T:System.SByte'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits8i.Max">
            <summary>
            The maximum representable <see cref='T:System.SByte'/> value
            </summary>
        </member>
        <member name="T:Z0.Limits8u">
            <summary>
            Defines lower/upper bounds for <see cref='T:System.Byte'/> values
            </summary>
        </member>
        <member name="F:Z0.Limits8u.Min">
            <summary>
            The minimum representable <see cref='T:System.Byte'/> value
            </summary>
        </member>
        <member name="F:Z0.Limits8u.Max">
            <summary>
            The maximum representable <see cref='T:System.Byte'/> value
            </summary>
        </member>
        <member name="T:Z0.EnumScalarKind">
            <summary>
            Restricts the numeric kind classifier to reflect the numeric kinds
            that an Enum type may refine
            </summary>
        </member>
        <member name="F:Z0.EnumScalarKind.U8">
            <summary>
            An alias for <see cref='F:Z0.PrimalKind.U8'/>
            </summary>
        </member>
        <member name="F:Z0.EnumScalarKind.U16">
            <summary>
            An alias for <see cref='F:Z0.PrimalKind.U16'/>
            </summary>
        </member>
        <member name="F:Z0.EnumScalarKind.U32">
            <summary>
            An alias for <see cref='F:Z0.PrimalKind.U32'/>
            </summary>
        </member>
        <member name="F:Z0.EnumScalarKind.U64">
            <summary>
            An alias for <see cref='F:Z0.PrimalKind.U64'/>
            </summary>
        </member>
        <member name="F:Z0.EnumScalarKind.I8">
            <summary>
            An alias for <see cref='F:Z0.PrimalKind.I8'/>
            </summary>
        </member>
        <member name="F:Z0.EnumScalarKind.I16">
            <summary>
            An alias for <see cref='F:Z0.PrimalKind.I16'/>
            </summary>
        </member>
        <member name="F:Z0.EnumScalarKind.I32">
            <summary>
            An alias for <see cref='F:Z0.PrimalKind.I32'/>
            </summary>
        </member>
        <member name="F:Z0.EnumScalarKind.I64">
            <summary>
            An alias for <see cref='F:Z0.PrimalKind.I64'/>
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Z0.EnumTypeCode" -->
        <member name="F:Z0.EnumTypeCode.I8">
            <summary>
            An alias for <see cref='F:System.TypeCode.SByte'/>
            </summary>
        </member>
        <member name="F:Z0.EnumTypeCode.U8">
            <summary>
            An alias for <see cref='F:System.TypeCode.Byte'/>
            </summary>
        </member>
        <member name="F:Z0.EnumTypeCode.I16">
            <summary>
            An alias for <see cref='F:System.TypeCode.Int16'/>
            </summary>
        </member>
        <member name="F:Z0.EnumTypeCode.U16">
            <summary>
            An alias for <see cref='F:System.TypeCode.UInt16'/>
            </summary>
        </member>
        <member name="F:Z0.EnumTypeCode.I32">
            <summary>
            An alias for <see cref='F:System.TypeCode.Int32'/>
            </summary>
        </member>
        <member name="F:Z0.EnumTypeCode.U32">
            <summary>
            An alias for <see cref='F:System.TypeCode.UInt32'/>
            </summary>
        </member>
        <member name="F:Z0.EnumTypeCode.I64">
            <summary>
            An alias for <see cref='F:System.TypeCode.Int64'/>
            </summary>
        </member>
        <member name="F:Z0.EnumTypeCode.U64">
            <summary>
            An alias for <see cref='F:System.TypeCode.UInt64'/>
            </summary>
        </member>
        <member name="T:Z0.LiteralKind">
            <summary>
            Defines a <see cref='T:Z0.PrimalKind'/> subset that corresponds to primal types that can be used as compile-time literals
            </summary>
        </member>
        <member name="F:Z0.LiteralKind.U1">
            <summary>
            An alias for <see cref='F:Z0.PrimalKind.U1'/>
            </summary>
        </member>
        <member name="F:Z0.LiteralKind.U8">
            <summary>
            An alias for <see cref='F:Z0.PrimalKind.U8'/>
            </summary>
        </member>
        <member name="F:Z0.LiteralKind.U16">
            <summary>
            An alias for <see cref='F:Z0.PrimalKind.U16'/>
            </summary>
        </member>
        <member name="F:Z0.LiteralKind.U32">
            <summary>
            An alias for <see cref='F:Z0.PrimalKind.U32'/>
            </summary>
        </member>
        <member name="F:Z0.LiteralKind.U64">
            <summary>
            An alias for <see cref='F:Z0.PrimalKind.U64'/>
            </summary>
        </member>
        <member name="F:Z0.LiteralKind.I8">
            <summary>
            An alias for <see cref='F:Z0.PrimalKind.I8'/>
            </summary>
        </member>
        <member name="F:Z0.LiteralKind.I16">
            <summary>
            An alias for <see cref='F:Z0.PrimalKind.I16'/>
            </summary>
        </member>
        <member name="F:Z0.LiteralKind.I32">
            <summary>
            An alias for <see cref='F:Z0.PrimalKind.I32'/>
            </summary>
        </member>
        <member name="F:Z0.LiteralKind.I64">
            <summary>
            An alias for <see cref='F:Z0.PrimalKind.I64'/>
            </summary>
        </member>
        <member name="F:Z0.LiteralKind.F32">
            <summary>
            An alias for <see cref='F:Z0.PrimalKind.F32'/>
            </summary>
        </member>
        <member name="F:Z0.LiteralKind.F64">
            <summary>
            An alias for <see cref='F:Z0.PrimalKind.F64'/>
            </summary>
        </member>
        <member name="F:Z0.LiteralKind.F128">
            <summary>
            An alias for <see cref='F:Z0.PrimalKind.F128'/>
            </summary>
        </member>
        <member name="F:Z0.LiteralKind.C16">
            <summary>
            An alias for <see cref='F:Z0.PrimalKind.C16'/>
            </summary>
        </member>
        <member name="F:Z0.LiteralKind.String">
            <summary>
            An alias for <see cref='F:Z0.PrimalKind.String'/>
            </summary>
        </member>
        <member name="M:Z0.LiteralKinds.kind``1">
            <summary>
            Returns the <see cref='T:Z0.LiteralKind'/> classification of a parametrically-identified primitive
            </summary>
            <typeparam name="T">The type to classify</typeparam>
        </member>
        <member name="M:Z0.LiteralKinds.numeric``1">
            <summary>
            Returns the <see cref='T:Z0.LiteralKind'/> classification of a parametrically-identified numeric primitive
            </summary>
            <typeparam name="T">The type to classify</typeparam>
        </member>
        <member name="T:Z0.NumericBaseKind">
            <summary>
            Defines common numeric bases
            </summary>
        </member>
        <member name="F:Z0.NumericBaseKind.Base2">
            <summary>
            Identifies base 2, binary
            </summary>
        </member>
        <member name="F:Z0.NumericBaseKind.Base3">
            <summary>
            Identifies base 3, ternary
            </summary>
        </member>
        <member name="F:Z0.NumericBaseKind.Base8">
            <summary>
            Identifies base 8, octal
            </summary>
        </member>
        <member name="F:Z0.NumericBaseKind.Base10">
            <summary>
            Identifies base 10, decimal
            </summary>
        </member>
        <member name="F:Z0.NumericBaseKind.Base16">
            <summary>
            Identifies base 16, hex
            </summary>
        </member>
        <member name="T:Z0.NumericKind">
            <summary>
            Classifies system-defined numeric primitive types
            </summary>
        </member>
        <member name="F:Z0.NumericKind.Signed">
            <summary>
            When enabled, indicates a signed integral type
            </summary>
        </member>
        <member name="F:Z0.NumericKind.Float">
            <summary>
            When enabled, indicates a floating-point type
            </summary>
        </member>
        <member name="F:Z0.NumericKind.Unsigned">
            <summary>
            When enabled, indicates an unsigned integral type
            </summary>
        </member>
        <member name="F:Z0.NumericKind.U8">
            <summary>
            Identifies an unsigned 8-bit integral type
            </summary>
        </member>
        <member name="F:Z0.NumericKind.I8">
            <summary>
            Identifies a signed 8-bit integral type
            </summary>
        </member>
        <member name="F:Z0.NumericKind.U16">
            <summary>
            Identifies an unsigned 16-bit integral type
            </summary>
        </member>
        <member name="F:Z0.NumericKind.I16">
            <summary>
            Identifies a signed 16-bit integral type
            </summary>
        </member>
        <member name="F:Z0.NumericKind.U32">
            <summary>
            Identifies an unsigned 32-bit integral type
            </summary>
        </member>
        <member name="F:Z0.NumericKind.I32">
            <summary>
            Identifies a signed 32-bit integral type
            </summary>
        </member>
        <member name="F:Z0.NumericKind.U64">
            <summary>
            Identifies an unsigned 64-bit integral type
            </summary>
        </member>
        <member name="F:Z0.NumericKind.I64">
            <summary>
            Identifies a signed 64-bit integral type
            </summary>
        </member>
        <member name="F:Z0.NumericKind.F32">
            <summary>
            Identifies a 32-bit floating-point type
            </summary>
        </member>
        <member name="F:Z0.NumericKind.F64">
            <summary>
            Identifies a 64-bit floating-point type
            </summary>
        </member>
        <member name="F:Z0.NumericKind.SignedInts">
            <summary>
            Defines a classification that includes all signed primal integral types and no others
            </summary>
        </member>
        <member name="F:Z0.NumericKind.UnsignedInts">
            <summary>
            Defines a classification that includes all unsigned primal integral types and no others
            </summary>
        </member>
        <member name="F:Z0.NumericKind.Integers">
            <summary>
            Defines a classification that includes all primal integral types and no others
            </summary>
        </member>
        <member name="F:Z0.NumericKind.Floats">
            <summary>
            Defines a classification that includes all primal floating-point types and no others
            </summary>
        </member>
        <member name="F:Z0.NumericKind.All">
            <summary>
            Defines a classification that includes all kinds
            </summary>
        </member>
        <member name="F:Z0.NumericKind.Width8">
            <summary>
            Defines a classification that includes kinds of width 8
            </summary>
        </member>
        <member name="F:Z0.NumericKind.Width16">
            <summary>
            Defines a classification that includes kinds of width 16
            </summary>
        </member>
        <member name="F:Z0.NumericKind.Width32">
            <summary>
            Defines a classification that includes kinds of width 32
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Z0.NumericKind.Width64" -->
        <member name="T:Z0.PrimalBits.Field">
            <summary>
            Defines positional identifiers for each bitfield segment
            </summary>
        </member>
        <member name="F:Z0.PrimalBits.Field.Width">
            <summary>
            Identifies the bitfield segment that specifies a primitive width
            </summary>
        </member>
        <member name="F:Z0.PrimalBits.Field.KindId">
            <summary>
            Identifies the bitfield segment that specifies a primitive kind identifier
            </summary>
        </member>
        <member name="F:Z0.PrimalBits.Field.Sign">
            <summary>
            Identifies the bitfield segment that specifies a primitive sign classifier
            </summary>
        </member>
        <member name="F:Z0.PrimalBits.SegMask.Size">
            <summary>
            The Size field mask
            </summary>
        </member>
        <member name="F:Z0.PrimalBits.SegMask.KindId">
            <summary>
            The KindId field mask
            </summary>
        </member>
        <member name="F:Z0.PrimalBits.SegMask.Sign">
            <summary>
            The Sign field mask
            </summary>
        </member>
        <member name="T:Z0.PrimalBits.SegPos">
            <summary>
            Defines integers that correspond to the position of the first bit of each bitfield segment
            that implies the following segmentation: [s kkkk www] where s denotes the sign bit, k denotes
            a kind identity bit and w denotes a width bit expressed in log2-form
            </summary>
        </member>
        <member name="F:Z0.PrimalBits.SegPos.Width">
            <summary>
            The starting index of the width field
            </summary>
        </member>
        <member name="F:Z0.PrimalBits.SegPos.KindId">
            <summary>
            The starting index of the id field
            </summary>
        </member>
        <member name="F:Z0.PrimalBits.SegPos.Sign">
            <summary>
            The index of the sign flag
            </summary>
        </member>
        <member name="T:Z0.PrimalBits.SegWidth">
            <summary>
            Defines the widths of the primal kind bitfield segments
            </summary>
        </member>
        <member name="F:Z0.PrimalBits.SegWidth.Width">
            <summary>
            The bit-width of the Size segment
            </summary>
        </member>
        <member name="F:Z0.PrimalBits.SegWidth.KindId">
            <summary>
            The bit-width of the KindId segment
            </summary>
        </member>
        <member name="F:Z0.PrimalBits.SegWidth.Sign">
            <summary>
            The bit-width of the Sign segment
            </summary>
        </member>
        <member name="F:Z0.PrimalBits.SegCount">
            <summary>
            The bitfield segment count
            </summary>
        </member>
        <member name="F:Z0.PrimalBits.TotalWidth">
            <summary>
            The total bitfield width
            </summary>
        </member>
        <member name="P:Z0.PrimalBits.Fields">
            <summary>
            The defined fields
            </summary>
        </member>
        <member name="P:Z0.PrimalBits.Masks">
            <summary>
            Segment mask filters
            </summary>
        </member>
        <member name="P:Z0.PrimalBits.Positions">
            <summary>
            The segment starting positions
            </summary>
        </member>
        <member name="P:Z0.PrimalBits.Widths">
            <summary>
            Segment widths
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Z0.PrimalKind" -->
        <member name="F:Z0.PrimalKind.U1">
            <summary>
            Specifies a boolean value
            </summary>
        </member>
        <member name="F:Z0.PrimalKind.I8">
            <summary>
            Specifies a signed 8-bit integer
            </summary>
        </member>
        <member name="F:Z0.PrimalKind.U8">
            <summary>
            Specifies an unsigned 8-bit integer
            </summary>
        </member>
        <member name="F:Z0.PrimalKind.I16">
            <summary>
            Specifies a signed 16-bit integer
            </summary>
        </member>
        <member name="F:Z0.PrimalKind.C16">
            <summary>
            Specifies a 16-bit unicode character
            </summary>
        </member>
        <member name="F:Z0.PrimalKind.U16">
            <summary>
            Specifies an unsigned 16-bit integer
            </summary>
        </member>
        <member name="F:Z0.PrimalKind.I32">
            <summary>
            Specifies a signed 32-bit integer
            </summary>
        </member>
        <member name="F:Z0.PrimalKind.U32">
            <summary>
            Specifies an unsigned 32-bit integer
            </summary>
        </member>
        <member name="F:Z0.PrimalKind.U64">
            <summary>
            Specifies an unsigned 64-bit integer
            </summary>
        </member>
        <member name="F:Z0.PrimalKind.I64">
            <summary>
            Specifies a signed 64-bit integer
            </summary>
        </member>
        <member name="F:Z0.PrimalKind.F32">
            <summary>
            Specifies a signed 32-bit floating-point number
            </summary>
        </member>
        <member name="F:Z0.PrimalKind.F64">
            <summary>
            Specifies a signed 64-bit floating-point number
            </summary>
        </member>
        <member name="F:Z0.PrimalKind.F128">
            <summary>
            Specifies a signed 64-bit floating-point number
            </summary>
        </member>
        <member name="F:Z0.PrimalKind.String">
            <summary>
            Specifies a 16-bit unicode character
            </summary>
        </member>
        <member name="F:Z0.PrimalKind.Object">
            <summary>
            Specifies System.Object
            </summary>
        </member>
        <member name="F:Z0.PrimalKind.DBNull">
            <summary>
            Specifies System.DBNull
            </summary>
        </member>
        <member name="F:Z0.PrimalKind.DateTime">
            <summary>
            Specifies System.DateTime
            </summary>
        </member>
        <member name="T:Z0.PrimalNumericKind">
            <summary>
            Defines a <see cref='T:Z0.PrimalKind'/> subset that corresponds to primal numeric kinds
            </summary>
        </member>
        <member name="F:Z0.PrimalNumericKind.U8">
            <summary>
            An alias for <see cref='F:Z0.PrimalKind.U8'/>
            </summary>
        </member>
        <member name="F:Z0.PrimalNumericKind.U16">
            <summary>
            An alias for <see cref='F:Z0.PrimalKind.U16'/>
            </summary>
        </member>
        <member name="F:Z0.PrimalNumericKind.U32">
            <summary>
            An alias for <see cref='F:Z0.PrimalKind.U32'/>
            </summary>
        </member>
        <member name="F:Z0.PrimalNumericKind.U64">
            <summary>
            An alias for <see cref='F:Z0.PrimalKind.U64'/>
            </summary>
        </member>
        <member name="F:Z0.PrimalNumericKind.I8">
            <summary>
            An alias for <see cref='F:Z0.PrimalKind.I8'/>
            </summary>
        </member>
        <member name="F:Z0.PrimalNumericKind.I16">
            <summary>
            An alias for <see cref='F:Z0.PrimalKind.I16'/>
            </summary>
        </member>
        <member name="F:Z0.PrimalNumericKind.I32">
            <summary>
            An alias for <see cref='F:Z0.PrimalKind.I32'/>
            </summary>
        </member>
        <member name="F:Z0.PrimalNumericKind.I64">
            <summary>
            An alias for <see cref='F:Z0.PrimalKind.I64'/>
            </summary>
        </member>
        <member name="F:Z0.PrimalNumericKind.F32">
            <summary>
            An alias for <see cref='F:Z0.PrimalKind.F32'/>
            </summary>
        </member>
        <member name="F:Z0.PrimalNumericKind.F64">
            <summary>
            An alias for <see cref='F:Z0.PrimalKind.F64'/>
            </summary>
        </member>
        <member name="F:Z0.PrimalNumericKind.F128">
            <summary>
            An alias for <see cref='F:Z0.PrimalKind.F128'/>
            </summary>
        </member>
        <member name="T:Z0.PrimalTypeCode">
            <summary>
            Identifies primal system types with 8-bit unsigned integers that capture the (grossly overallocated) 32-bit integer type code values.
            </summary>
        </member>
        <member name="F:Z0.PrimalTypeCode.Object">
            <summary>
            An alias for <see cref='F:System.TypeCode.Object'/>
            </summary>
        </member>
        <member name="F:Z0.PrimalTypeCode.DBNull">
            <summary>
            An alias for <see cref='!:TC.DbNull'/>
            </summary>
        </member>
        <member name="F:Z0.PrimalTypeCode.U1">
            <summary>
            An alias for <see cref='F:System.TypeCode.Boolean'/>
            </summary>
        </member>
        <member name="F:Z0.PrimalTypeCode.C16">
            <summary>
            An alias for <see cref='F:System.TypeCode.Char'/>
            </summary>
        </member>
        <member name="F:Z0.PrimalTypeCode.I8">
            <summary>
            An alias for <see cref='F:System.TypeCode.SByte'/>
            </summary>
        </member>
        <member name="F:Z0.PrimalTypeCode.U8">
            <summary>
            An alias for <see cref='F:System.TypeCode.Byte'/>
            </summary>
        </member>
        <member name="F:Z0.PrimalTypeCode.I16">
            <summary>
            An alias for <see cref='F:System.TypeCode.Int16'/>
            </summary>
        </member>
        <member name="F:Z0.PrimalTypeCode.U16">
            <summary>
            An alias for <see cref='F:System.TypeCode.UInt16'/>
            </summary>
        </member>
        <member name="F:Z0.PrimalTypeCode.I32">
            <summary>
            An alias for <see cref='F:System.TypeCode.Int32'/>
            </summary>
        </member>
        <member name="F:Z0.PrimalTypeCode.U32">
            <summary>
            An alias for <see cref='F:System.TypeCode.UInt32'/>
            </summary>
        </member>
        <member name="F:Z0.PrimalTypeCode.I64">
            <summary>
            An alias for <see cref='F:System.TypeCode.Int64'/>
            </summary>
        </member>
        <member name="F:Z0.PrimalTypeCode.U64">
            <summary>
            An alias for <see cref='F:System.TypeCode.UInt64'/>
            </summary>
        </member>
        <member name="F:Z0.PrimalTypeCode.F32">
            <summary>
            An alias for <see cref='F:System.TypeCode.Single'/>
            </summary>
        </member>
        <member name="F:Z0.PrimalTypeCode.F64">
            <summary>
            An alias for <see cref='F:System.TypeCode.Double'/>
            </summary>
        </member>
        <member name="F:Z0.PrimalTypeCode.F128">
            <summary>
            An alias for <see cref='F:System.TypeCode.Decimal'/>
            </summary>
        </member>
        <member name="F:Z0.PrimalTypeCode.DateTime">
            <summary>
            An alias for <see cref='F:System.TypeCode.DateTime'/>
            </summary>
        </member>
        <member name="F:Z0.PrimalTypeCode.String">
            <summary>
            An alias for <see cref='F:System.TypeCode.String'/>
            </summary>
        </member>
        <member name="T:Z0.ScalarRefinementKind">
            <summary>
            Defines immediate value classifiers
            </summary>
        </member>
        <member name="F:Z0.ScalarRefinementKind.Unrefined">
            <summary>
            Indicates immediate is a primal literal with no additional type information
            </summary>
        </member>
        <member name="F:Z0.ScalarRefinementKind.Refined">
            <summary>
            Indicates immediate is is a refined primitive, constrained to a particular domain
            </summary>
        </member>
        <member name="T:Z0.Sign16Kind">
            <summary>
            Classifies the sign aspect of a 16-bit value
            </summary>
        </member>
        <member name="F:Z0.Sign16Kind.Unsigned">
            <summary>
            Indicates a value is greater than or equal to zero
            </summary>
        </member>
        <member name="F:Z0.Sign16Kind.Signed">
            <summary>
            Indicates a value is less than zero
            </summary>
        </member>
        <member name="T:Z0.Sign32Kind">
            <summary>
            Classifies the sign aspect of a 32-bit value
            </summary>
        </member>
        <member name="F:Z0.Sign32Kind.Unsigned">
            <summary>
            Indicates a value is greater than or equal to zero
            </summary>
        </member>
        <member name="F:Z0.Sign32Kind.Signed">
            <summary>
            Indicates a value is less than zero
            </summary>
        </member>
        <member name="T:Z0.Sign64Kind">
            <summary>
            Classifies the sign aspect of a 64-bit value
            </summary>
        </member>
        <member name="T:Z0.Sign8Kind">
            <summary>
            Classifies the sign aspect of an 8-bit value
            </summary>
        </member>
        <member name="F:Z0.Sign8Kind.Unsigned">
            <summary>
            Indicates a value is greater than or equal to zero
            </summary>
        </member>
        <member name="F:Z0.Sign8Kind.Signed">
            <summary>
            Indicates a value is less than zero
            </summary>
        </member>
        <member name="T:Z0.SignKind">
            <summary>
            Defines polarity classifiers
            </summary>
        </member>
        <member name="F:Z0.SignKind.Unsigned">
            <summary>
            Indicates a value is greater than or equal to zero
            </summary>
        </member>
        <member name="F:Z0.SignKind.Signed">
            <summary>
            Indicates a value is less than zero
            </summary>
        </member>
        <member name="T:Z0.TypeSignKind">
            <summary>
            Defines an equivalence class over types of integral numeric kind
            </summary>
        </member>
        <member name="F:Z0.TypeSignKind.Signed">
            <summary>
            Specifies that a type is defined over both signed and unsigned values
            </summary>
        </member>
        <member name="F:Z0.TypeSignKind.Unsigned">
            <summary>
            Specifies that a type is defined only over unsigned values
            </summary>
        </member>
        <member name="T:Z0.SegBlockKind">
            <summary>
            Classifies concrete storage blocks of total width w over segments of width t and sign indicator s where:
            w = kind[0..15]
            t = kind[16..23]
            s = {u | i | f} as determined by kind[30..31]
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b8">
            <summary>
            A 8-bit block
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b16">
            <summary>
            A 16-bit block
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b32">
            <summary>
            A 32-bit block
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b64">
            <summary>
            A 64-bit block
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b128">
            <summary>
            A 128-bit block
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b256">
            <summary>
            A 256-bit block
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b512">
            <summary>
            A 512-bit block
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b16x8u">
            <summary>
            A 16-bit block covering 2 unsigned 8-bit segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b16x8i">
            <summary>
            A 16-bit block covering 2 signed 8-bit segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b16x16u">
            <summary>
            A 16-bit block covering an unsigned 16-bit segment
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b16x16i">
            <summary>
            A 16-bit block covering an unsigned 16-bit segment
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b32x8u">
            <summary>
            A 32-bit block covering 4 unsigned 8-bit segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b32x8i">
            <summary>
            A 32-bit block covering 4 unsigned 8-bit segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b32x16u">
            <summary>
            A 32-bit block covering 2 unsigned 16-bit segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b32x16i">
            <summary>
            A 32-bit block covering 2 signed 16-bit segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b32x32u">
            <summary>
            A 32-bit block covering an unsigned 32-bit segment
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b32x32i">
            <summary>
            A 32-bit block covering a signed 32-bit segment
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b32x32f">
            <summary>
            A 32-bit block covering a floating-point 32-bit segment
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b64x8u">
            <summary>
            A 64-bit block covering 8 unsigned 8-bit segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b64x8i">
            <summary>
            A 64-bit block covering 8 signed 8-bit segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b64x16u">
            <summary>
            A 64-bit block covering 4 unsigned 16-bit segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b64x16i">
            <summary>
            A 64-bit block covering 4 signed 16-bit segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b64x32u">
            <summary>
            A 64-bit block covering 2 unsigned 32-bit segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b64x32i">
            <summary>
            A 64-bit block covering 2 signed 32-bit segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b64x64u">
            <summary>
            A 64-bit block covering an unsigned 64-bit segment
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b64x64i">
            <summary>
            A 64-bit block covering a signed 64-bit segment
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b64x32f">
            <summary>
            A 64-bit block covering 2 32-bit floating-point segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b64x64f">
            <summary>
            A 64-bit block covering a 64-bit floating-point segment
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b128x8u">
            <summary>
            A 128-bit block covering 16 8-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b128x8i">
            <summary>
            A 128-bit block covering 16 8-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b128x16u">
            <summary>
            A 128-bit block covering 8 16-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b128x16i">
            <summary>
            A 128-bit block covering 8 16-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b128x32u">
            <summary>
            A 128-bit block covering 4 32-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b128x32i">
            <summary>
            A 128-bit block covering 4 32-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b128x64u">
            <summary>
            A 128-bit block covering 2 64-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b128x64i">
            <summary>
            A 128-bit block covering 2 64-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b128x32f">
            <summary>
            A 128-bit block covering 4 32-bit floating-point segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b128x64f">
            <summary>
            A 128-bit block covering 2 64-bit floating-point segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b256x8u">
            <summary>
            A 256-bit block covering 32 8-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b256x8i">
            <summary>
            A 256-bit block covering 32 8-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b256x16u">
            <summary>
            A 256-bit block covering 16 16-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b256x16i">
            <summary>
            A 256-bit block covering 16 16-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b256x32u">
            <summary>
            A 256-bit block covering 8 32-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b256x32i">
            <summary>
            A 256-bit block covering 8 32-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b256x64u">
            <summary>
            A 256-bit block covering 4 64-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b256x64i">
            <summary>
            A 256-bit block covering 4 64-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b256x32f">
            <summary>
            A 256-bit block covering 8 32-bit floating-point segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b256x64f">
            <summary>
            A 256-bit block covering 4 64-bit floating-point segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b512x8u">
            <summary>
            A 512-bit block covering 32 8-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b512x8i">
            <summary>
            A 512-bit block covering 32 8-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b512x16u">
            <summary>
            A 512-bit block covering 16 16-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b512x16i">
            <summary>
            A 512-bit block covering 16 16-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b512x32u">
            <summary>
            A 512-bit block covering 8 32-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b512x32i">
            <summary>
            A 512-bit block covering 8 32-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b512x64u">
            <summary>
            A 512-bit block covering 4 64-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b512x64i">
            <summary>
            A 512-bit block covering 4 64-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b512x32f">
            <summary>
            A 512-bit block covering 8 32-bit floating-point segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.b512x64f">
            <summary>
            A 512-bit block covering 4 64-bit floating-point segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.Seg8u">
            <summary>
            A block defined over 8-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.Seg8i">
            <summary>
            A block defined over 8-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.Seg16u">
            <summary>
            A block defined over 16-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.Seg16i">
            <summary>
            A block defined over 16-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.Seg32u">
            <summary>
            A block defined over 32-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.Seg32i">
            <summary>
            A block defined over 32-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.Seg64u">
            <summary>
            A block defined over 64-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.Seg64i">
            <summary>
            A block defined over 64-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.Seg32f">
            <summary>
            A block defined over 32-bit floating-point segments
            </summary>
        </member>
        <member name="F:Z0.SegBlockKind.Seg64f">
            <summary>
            A block defined over 64-bit floating-point segments
            </summary>
        </member>
        <member name="T:Z0.VectorKind">
            <summary>
            Classifies concrete intrinsic vectors of total width w over components of width t and sign indicator s where:
            w = kind[0..15]
            t = kind[16..23]
            s = {u | i | f} as determined by kind[30..31]
            </summary>
        </member>
        <member name="F:Z0.VectorKind.v128x8u">
            <summary>
            A 128-bit vector covering 16 8-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.VectorKind.v128x8i">
            <summary>
            A 128-bit vector covering 16 8-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.VectorKind.v128x16u">
            <summary>
            A 128-bit vector covering 8 16-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.VectorKind.v128x16i">
            <summary>
            A 128-bit vector covering 8 16-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.VectorKind.v128x32u">
            <summary>
            A 128-bit vector covering 4 32-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.VectorKind.v128x32i">
            <summary>
            A 128-bit vector covering 4 32-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.VectorKind.v128x64u">
            <summary>
            A 128-bit vector covering 2 64-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.VectorKind.v128x64i">
            <summary>
            A 128-bit vector covering 2 64-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.VectorKind.v128x32f">
            <summary>
            A 128-bit vector covering 4 32-bit floating-point segments
            </summary>
        </member>
        <member name="F:Z0.VectorKind.v128x64f">
            <summary>
            A 128-bit vector covering 2 64-bit floating-point segments
            </summary>
        </member>
        <member name="F:Z0.VectorKind.v256x8u">
            <summary>
            A 256-bit vector covering 32 8-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.VectorKind.v256x8i">
            <summary>
            A 256-bit vector covering 32 8-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.VectorKind.v256x16u">
            <summary>
            A 256-bit vector covering 16 16-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.VectorKind.v256x16i">
            <summary>
            A 256-bit vector covering 16 16-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.VectorKind.v256x32i">
            <summary>
            A 256-bit vector covering 8 32-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.VectorKind.v256x32u">
            <summary>
            A 256-bit vector covering 8 32-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.VectorKind.v256x64u">
            <summary>
            A 256-bit vector covering 4 64-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.VectorKind.v256x64i">
            <summary>
            A 256-bit vector covering 4 64-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.VectorKind.v256x32f">
            <summary>
            A 256-bit vector covering 8 32-bit floating-point segments
            </summary>
        </member>
        <member name="F:Z0.VectorKind.v256x64f">
            <summary>
            A 256-bit vector covering 4 64-bit floating-point segments
            </summary>
        </member>
        <member name="F:Z0.VectorKind.v512x8u">
            <summary>
            A 512-bit vector covering 32 8-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.VectorKind.v512x8i">
            <summary>
            A 512-bit vector covering 32 8-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.VectorKind.v512x16u">
            <summary>
            A 512-bit vector covering 16 16-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.VectorKind.v512x16i">
            <summary>
            A 512-bit vector covering 16 16-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.VectorKind.v512x32u">
            <summary>
            A 512-bit vector covering 8 32-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.VectorKind.v512x32i">
            <summary>
            A 512-bit vector covering 8 32-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.VectorKind.v512x64u">
            <summary>
            A 512-bit vector covering 4 64-bit unsigned segments
            </summary>
        </member>
        <member name="F:Z0.VectorKind.v512x64i">
            <summary>
            A 512-bit vector covering 4 64-bit signed segments
            </summary>
        </member>
        <member name="F:Z0.VectorKind.v512x32f">
            <summary>
            A 512-bit vector covering 8 32-bit floating-point segments
            </summary>
        </member>
        <member name="F:Z0.VectorKind.v512x64f">
            <summary>
            A 512-bit vector covering 4 64-bit floating-point segments
            </summary>
        </member>
        <member name="T:Z0.ClrArtifactKind">
            <summary>
            Artifact classifiers that align with literals defined by <see cref='T:System.AttributeTargets'/>
            </summary>
        </member>
        <member name="T:Z0.ClrTypeKind">
            <summary>
            Defines classifiers that correspond to the basic CLR types
            </summary>
        </member>
        <member name="T:Z0.IIdentified">
            <summary>
            Characterizes an identifier
            </summary>
        </member>
        <member name="T:Z0.IOperationalClass">
            <summary>
            Identifies a class that classifies operations
            </summary>
        </member>
        <member name="T:Z0.IOperationalClass`1">
            <summary>
            Characterizes a class-parametric operation class
            </summary>
            <typeparam name="E">The class type</typeparam>
        </member>
        <member name="T:Z0.IOperationalClass`2">
            <summary>
            Characterizes an operation class that both operand and class parametric
            </summary>
            <typeparam name="T">The operand type</typeparam>
            <typeparam name="E">The class type</typeparam>
        </member>
        <member name="T:Z0.IOperationalClassHost`2">
            <summary>
            Characterizes an operation class that is both class-parametric and F-bound polymorphic
            </summary>
            <typeparam name="F">The reification type</typeparam>
            <typeparam name="E">The class type</typeparam>
        </member>
        <member name="T:Z0.IOperationalClassHost`3">
            <summary>
            Characterizes an operation class that is operand, class parametric, and F-bound polymorphic
            </summary>
            <typeparam name="T">The operand type</typeparam>
            <typeparam name="E">The class type</typeparam>
        </member>
        <member name="T:Z0.IRenderBuffer">
            <summary>
            Characterizes a render buffer
            </summary>
        </member>
        <member name="T:Z0.IRenderBuffer`1">
            <summary>
            Characterizes an that produces accumulated content as T-cells
            </summary>
            <typeparam name="T">The emission target type</typeparam>
        </member>
        <member name="T:Z0.IRenderBuffer`2">
            <summary>
            Characterizes an S-cell aggregator that produces accumulated S-cells as T-cells
            </summary>
            <typeparam name="S">The input source type</typeparam>
            <typeparam name="T">The emission target type</typeparam>
        </member>
        <member name="T:Z0.IService">
            <summary>
            Characterizes nothing but is a marker for a type that, perhaps, defines something useful to someone
            </summary>
        </member>
        <member name="T:Z0.IService`1">
            <summary>
            Characterizes a service that extends a parametric context with operational semantics.
            </summary>
            <typeparam name="C">The context type</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Z0.IServiceAllocation" -->
        <member name="F:Z0.ApiProviderKind.DataStructure">
            <summary>
            Indicates a classical or domain-specific value type that organizes data by some principle
            </summary>
        </member>
        <member name="F:Z0.SpanIndicators.Span">
            <summary>
            Indicates a system-defined mutable span type
            </summary>
        </member>
        <member name="F:Z0.SpanIndicators.ReadOnly">
            <summary>
            Indicates an system-defined readonly span
            </summary>
        </member>
        <member name="F:Z0.SpanIndicators.Natural">
            <summary>
            Indicates a custom span type predicated parametrically on natrural number types
            </summary>
        </member>
        <member name="T:Z0.IClassifier">
            <summary>
            Metaclassification
            </summary>
        </member>
        <member name="T:Z0.IClassF`1">
            <summary>
            Characterizes an F-bound polymorphic classifier reification
            </summary>
            <typeparam name="T">The parametric type</typeparam>
        </member>
        <member name="T:Z0.IClassT`1">
            <summary>
            Characterizes a T-parametric classifier
            </summary>
            <typeparam name="T">The parametric type</typeparam>
        </member>
        <member name="T:Z0.IClass`2">
            <summary>
            Characterizes an F-bound polymorphic T-parametric classifier reification
            </summary>
            <typeparam name="T">The parametric type</typeparam>
        </member>
        <member name="T:Z0.IFactory`1">
            <summary>
            Characterizes a factory where the production type is T-parametric
            </summary>
            <typeparam name="T">A type which paremetrizes the production type</typeparam>
        </member>
        <member name="T:Z0.Factory`1">
            <summary>
            Refies a factory that produces no T-parametric values; the use case is
            to make it convenient to create factories that do produce values that are T-parametric
            </summary>
            <typeparam name="T">A type which paremetrizes the production type</typeparam>
        </member>
        <member name="T:Z0.IHashed">
            <summary>
            Characterizes a hash code provider
            </summary>
        </member>
        <member name="P:Z0.IHashed.Hash">
            <summary>
            The hash code as an unsigned 32-bit integer
            </summary>
        </member>
        <member name="P:Z0.IHashed.HashCode">
            <summary>
            The hash code that C# knows/loves as an inappropriately-ubiquitous signed 32-bit integer
            </summary>
        </member>
        <member name="T:Z0.IHashed`1">
            <summary>
            Characterizes a refied structural <see cref='T:Z0.IHashed'/> reification
            </summary>
            <typeparam name="F">The reification type</typeparam>
            <typeparam name="C">The hashed content type</typeparam>
        </member>
        <member name="T:Z0.ILabeled">
            <summary>
            Characterizes type that defines a Label facet
            </summary>
        </member>
        <member name="T:Z0.ILabeled`1">
            <summary>
            Characterizes an F-bound polymorphic type that defines a label facet
            </summary>
        </member>
        <member name="T:Z0.ILink`2">
            <summary>
            Characterizes an association between two parties of heterogenous type
            </summary>
            <typeparam name="S">The first party type</typeparam>
            <typeparam name="T">The second party type</typeparam>
        </member>
        <member name="T:Z0.ILink`1">
            <summary>
            Characterizes an association between two parties of homogenous type
            </summary>
            <typeparam name="T">The party type</typeparam>
        </member>
        <member name="T:Z0.IReified`1">
            <summary>
            Characterizes an F-bound polymorphic reifiable abstraction
            </summary>
            <typeparam name="F">The reifying type</typeparam>
        </member>
        <member name="T:Z0.ITextual`1">
            <summary>
            Characterizes a type that formats a parametrically-specified type
            </summary>
        </member>
        <member name="F:Z0.FpErrorMode.Raise">
            <summary>
            Raise exceptions upon error
            </summary>
        </member>
        <member name="F:Z0.FpErrorMode.Suppress">
            <summary>
            Suppress exceptions upon error
            </summary>
        </member>
        <member name="F:Z0.FpRoundDir.Default">
            <summary>
            _MM_FROUND_TO_NEAREST_INT, the default mode effects rounding to the nearest integer
            </summary>
        </member>
        <member name="F:Z0.FpRoundDir.NegInf">
            <summary>
            _MM_FROUND_TO_NEG_INF, Round toward negative infinity
            </summary>
        </member>
        <member name="F:Z0.FpRoundDir.PosInf">
            <summary>
            _MM_FROUND_TO_POS_INF, Round toward positive infinity
            </summary>
        </member>
        <member name="F:Z0.FpRoundDir.Zero">
            <summary>
            _MM_FROUND_TO_ZERO, round toward 0
            </summary>
        </member>
        <member name="F:Z0.FpRoundDir.Current">
            <summary>
            _MM_FROUND_CUR_DIRECTION, round toward the current direction as specified by __MM_SET_ROUNDING_MODE
            </summary>
        </member>
        <member name="F:Z0.FpRoundDir.Ceil">
            <summary>
            _MM_FROUND_CEIL, round toward positive infinity and do not suppress exceptions
            </summary>
        </member>
        <member name="F:Z0.FpRoundDir.Floor">
            <summary>
            _MM_FROUND_FLOOR, round toward negative infinity and do not suppress exceptions
            </summary>
        </member>
        <member name="F:Z0.FpRoundDir.Trunc">
            <summary>
            _MM_FROUND_TRUNC, Round toward zero and do not supress exceptions
            </summary>
        </member>
        <member name="F:Z0.FpRoundDir.Nearby">
            <summary>
            _MM_FROUND_NEARBYINT, round toward the current direction and suppress exceptions
            </summary>
        </member>
        <member name="T:Z0.FpCmpMode">
            <summary>
            Floating point comparison mode
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.EQ_OQ">
            <summary>
            0: ordered, equal, non-signaling
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.OrderedEqualNonSignaling">
            <summary>
            Overly-verbose alias for EQ_OQ
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.LT_OS">
            <summary>
            1: ordered, less than, signaling
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.OrderedLessThanSignaling">
            <summary>
            Overly-verbose alias for LT_OS
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.LE_OS">
            <summary>
            2: ordered, less than or equal, signaling
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.OrderedLessThanOrEqualSignaling">
            <summary>
            Overly-verbose alias for LE_OS
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.UNORD_Q">
            <summary>
            3: unordered, non-signaling
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.UnorderedNonSignaling">
            <summary>
            Overly-verbose alias for UNORD_Q
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.NEQ_UQ">
            <summary>
            4: unordered, not equal, non-signaling
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.UnorderedNotEqualNonSignaling">
            <summary>
            Overly-verbose alias for NEQ_UQ
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.NLT_US">
            <summary>
            5: unordered, not less than, signaling
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.UnorderedNotLessThanSignaling">
            <summary>
            Overly-verbose alias for NLT_US
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.NLE_US">
            <summary>
            6: unordered, not less than or equal, signaling
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.UnorderedNotLessThanOrEqualSignaling">
            <summary>
            Ridiculously verbose alias for NLE_US
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.ORD_Q">
            <summary>
            7: ordered, non-signaling
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.OrderedNonSignaling">
            <summary>
            Overly-verbose alias for ORD_Q
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.EQ_UQ">
            <summary>
            8: unordered, equal, non-signaling
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.UnorderedEqualNonSignaling">
            <summary>
            Overly-verbose alias for EQ_UQ
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.NGE_US">
            <summary>
            9: unordered, not greater than or equal, signaling
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.UnorderedNotGreaterThanOrEqualSignaling">
            <summary>
            Ridiculously verbose alias for NGE_US
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.NGT_US">
            <summary>
            9:unordered, not greater than, signaling
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.UnorderedNotGreaterThanSignaling">
            <summary>
            Ridiculously verbose alias for NGT_US
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.FALSE_OQ">
            <summary>
            10: ordered, false, non-signaling
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.OrderedFalseNonSignaling">
            <summary>
            Overly-verbose alias for FALSE_OQ
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.NEQ_OQ">
            <summary>
            12: ordered, not equal, non-signaling
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.OrderedNotEqualNonSignaling">
            <summary>
            Overly-verbose alias for NGT_US
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.GE_OS">
            <summary>
            13: ordered, greater than or equal, signaling
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.OrderedGreaterThanOrEqualSignaling">
            <summary>
            Ridiculously verbose alias for GE_OS
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.GT_OS">
            <summary>
            14: ordered, greater than, signaling
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.OrderedGreaterThanSignaling">
            <summary>
            Overly-verbose alias for GT_OS
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.TRUE_UQ">
            <summary>
            15: unordered, true, non-signaling
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.UnorderedTrueNonSignaling">
            <summary>
            Overly-verbose alias for TRUE_UQ
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.EQ_OS">
            <summary>
            16: ordered, equal, signaling
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.OrderedEqualSignaling">
            <summary>
            Overly-verbose alias for EQ_OS
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.LT_OQ">
            <summary>
            17: ordered, less than, non-signaling
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.OrderedLessThanNonSignaling">
            <summary>
            Overly-verbose alias for LT_OQ
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.LE_OQ">
            <summary>
            18: ordered, less than or equal, non-signaling
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.OrderedLessThanOrEqualNonSignaling">
            <summary>
            Ridiculously verbose alias for LE_OQ
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.UNORD_S">
            <summary>
            19: unordered, signaling
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.UnorderedSignaling">
            <summary>
            Overly-verbose alias for LE_OQ
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.NEQ_US">
            <summary>
            20: unordered, not equal, signaling
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.UnorderedNotEqualSignaling">
            <summary>
            Overly-verbose alias for NEQ_US
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.NLT_UQ">
            <summary>
            21: unordered, not less, non-signaling
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.UnorderedNotLessThanNonSignaling">
            <summary>
            Ridicuously verbose alias for NLT_UQ
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.NLE_UQ">
            <summary>
            22: unordered, not less than or equal, non-signaling
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.UnorderedNotLessThanOrEqualNonSignaling">
            <summary>
            Ridiculously verbose alias for NLE_UQ
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.ORD_S">
            <summary>
            23: ordered, signaling
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.OrderedSignaling">
            <summary>
            Overly-verbose alias for ORD_S
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.EQ_US">
            <summary>
            24: unordered,equal, signaling
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.UnorderedEqualSignaling">
            <summary>
            Overly-verbose alias for EQ_US
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.NGE_UQ">
            <summary>
            25: unordered, not greater than or equan, non-signaling
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.UnorderedNotGreaterThanOrEqualNonSignaling">
            <summary>
            Infuriatingly verbose alias for NGE_UQ
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.NGT_UQ">
            <summary>
            26: unordered, not greater than, non-signaling
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.UnorderedNotGreaterThanNonSignaling">
            <summary>
            Infuriatingly verbose alias for NGT_UQ
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.FALSE_OS">
            <summary>
            27: ordered, false, signaling
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.OrderedFalseSignaling">
            <summary>
            Overly-verbose alias for FALSE_OS
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.NEQ_OS">
            <summary>
            28: ordered, not equal, signaling
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.OrderedNotEqualSignaling">
            <summary>
            Overly-verbose alias for NEQ_OS
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.GE_OQ">
            <summary>
            29: ordered, greater than or equal, non-signaling
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.OrderedGreaterThanOrEqualNonSignaling">
            <summary>
            Infuriatingly verbose alias for LE_OQ
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.GT_OQ">
            <summary>
            30: ordered, greater than, non-signaling
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.OrderedGreaterThanNonSignaling">
            <summary>
            Overly-verbose alias for GT_OQ
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.TRUE_US">
            <summary>
            31: ordered, true, signaling
            </summary>
        </member>
        <member name="F:Z0.FpCmpMode.UnorderedTrueSignaling">
            <summary>
            Overly-verbose alias for TRUE_US
            </summary>
        </member>
        <member name="T:Z0.Hashed">
            <summary>
            Captures a hash code
            </summary>
        </member>
        <member name="T:Z0.Hashed`1">
            <summary>
            Captures a hash code for structured content
            </summary>
        </member>
        <member name="M:Z0.IInvertible`1.Invert">
            <summary>
            Unary structural negation
            </summary>
        </member>
        <member name="P:Z0.IEquivalenceClass`1.Rep">
            <summary>
            The class representative
            </summary>
        </member>
        <member name="T:Z0.IEquivalenceClass`2">
            <summary>
            Characterizes an equivalence class, i.e. a segment of a partition effected via
            an equivalence relation
            </summary>
            <typeparam name="T">The classified type</typeparam>
        </member>
        <member name="T:Z0.IQuotientSet`2">
            <summary>
            Characterizes a partition over a set effected via an equivalence relation.
            In this context, a partition is a collection of mutually disjoint subsets
            of a given set whose union recovers the original set
            </summary>
            <typeparam name="C">The equivalence class type</typeparam>
            <typeparam name="T">The set domain</typeparam>
        </member>
        <member name="M:Z0.IQuotientSet`2.Partition">
            <summary>
            Effects a partition via the equivalence
            </summary>
        </member>
        <member name="M:Z0.IQuotientSet`2.Project(`1)">
            <summary>
            The canonical surjective projection from the underlying set to the equivalence
            partitions that maps a given element to the equivalence class in which it
            resides
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="T:Z0.ISetoid`2">
            <summary>
            Characterizes a discrete partition over a discrete set and, consequently,
            is a constructive presentation of an equivalence relation. In this context, a partition
            is a collection of mutually disjoint subsets of a given set whose union
            is recovers the original set
            </summary>
            <typeparam name="T">The element type</typeparam>
            <remarks>See https://en.wikipedia.org/wiki/Setoid</remarks>
        </member>
        <member name="T:Z0.IAny`1">
            <summary>
            Characterizes any equatable value
            </summary>
            <typeparam name="T">The value type</typeparam>
        </member>
        <member name="T:Z0.IAny`2">
            <summary>
            Characterizes an equatable value reification
            </summary>
            <typeparam name="F">The reification type</typeparam>
            <typeparam name="T">The value type</typeparam>
        </member>
        <member name="T:Z0.IConstSet`1">
            <summary>
            Characterizes a set over elements of parametric type
            </summary>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.IConstSet`1.Contains(`0)">
            <summary>
            Determines whether a value is a member
            </summary>
            <param name="candidate">The potential member</param>
        </member>
        <member name="T:Z0.IConstSet`2">
            <summary>
            Characterizes a reified set over elements of parametric type
            </summary>
            <typeparam name="F">The reifying type</typeparam>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.IConstSet`2.IsSubset(`0,System.Boolean)">
            <summary>
            Determines whether the current set is a subset of a specified set.
            </summary>
            <param name="rhs">The candidate superset</param>
            <param name="proper">Specifies whether only proper subsets are considered "subsets"</param>
        </member>
        <member name="M:Z0.IConstSet`2.IsSuperset(`0,System.Boolean)">
            <summary>
            Determines whether the current set is a superset of a specified set.
            </summary>
            <param name="rhs">The candidate subset</param>
            <param name="proper">Specifies whether only proper subsets are considered "subsets"</param>
        </member>
        <member name="T:Z0.IContainer`1">
            <summary>
            Characterizes a parametric container
            </summary>
            <typeparam name="C"></typeparam>
        </member>
        <member name="T:Z0.IReadOnly`1">
            <summary>
            Characterizes an immutable container
            </summary>
            <typeparam name="C">The content type</typeparam>
        </member>
        <member name="T:Z0.IReadOnly`2">
            <summary>
            Characterizes a reified immutable container
            </summary>
            <typeparam name="F">The reifying type</typeparam>
            <typeparam name="C">The content type</typeparam>
        </member>
        <member name="T:Z0.IReadOnly`3">
            <summary>
            Characterizes a reified immutable container with T-stratified content
            </summary>
            <typeparam name="F">The reifying type</typeparam>
            <typeparam name="C">The content type</typeparam>
            <typeparam name="T">The type over which the content is stratified</typeparam>
        </member>
        <member name="T:Z0.IFreeMonoid`1">
            <summary>
            Characterizes a (finite) free monoidal structure
            </summary>
            <typeparam name="S">The structure type</typeparam>
            <typeparam name="T">The underlying type</typeparam>
        </member>
        <member name="T:Z0.IConcatenable`2">
            <summary>
            Characterizes a reification that defines an intrinsic concatentation operator
            </summary>
            <typeparam name="S">The reifying type</typeparam>
        </member>
        <member name="M:Z0.IConcatenable`2.Concat(`0)">
            <summary>
            Concatenates the intrinsic value with a suplied value
            </summary>
            <param name="rhs">The right value supplied to the concatenation operator</param>
        </member>
        <member name="T:Z0.IReversible`2">
            <summary>
            Characterizes a reversible structure
            </summary>
            <typeparam name="S">The structure type</typeparam>
        </member>
        <member name="T:Z0.IContented`1">
            <summary>
            Characterizes a container that owns content
            </summary>
            <typeparam name="C">The content type</typeparam>
        </member>
        <member name="T:Z0.IContented`2">
            <summary>
            Characterizes reified container
            </summary>
            <typeparam name="F">The reifying type</typeparam>
            <typeparam name="C">The content type</typeparam>
        </member>
        <member name="M:Z0.IContented`2.WithContent(`1)">
            <summary>
            Assigns content; whether existing content is replaced, accrued or
            if a new container is created is determined by the reifying type
            and its purpose in life
            </summary>
            <param name="content">The source content</param>
        </member>
        <member name="T:Z0.IContented`3">
            <summary>
            Characterizes a reified container with T-stratified content
            </summary>
            <typeparam name="F">The reifying type</typeparam>
            <typeparam name="C">The content type</typeparam>
            <typeparam name="T">The type over which the content is stratified</typeparam>
        </member>
        <member name="T:Z0.ICounted">
            <summary>
            Characterizes a finite thing that yields a count value that does not require computation/enumeration
            to reveal; in other words, the count function for counted things is free, as evinced by
            the default implementation
            </summary>
        </member>
        <member name="P:Z0.ICounted.Count">
            <summary>
            The count value
            </summary>
        </member>
        <member name="T:Z0.IDeferred`1">
            <summary>
            Characterizes a container over discrete/enumerable content which need not be finite
            </summary>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="T:Z0.IDeferred`2">
            <summary>
            Characterizes a reified container over discrete/enumerable content which need not be finite
            </summary>
            <typeparam name="F">The reifying type</typeparam>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="T:Z0.IDeferredSet`2">
            <summary>
            Characterizes a reified set over elements of parametric type
            </summary>
            <typeparam name="F">The reifying type</typeparam>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.IDeferredSet`2.Contains(`1)">
            <summary>
            Determines whether a value is a member
            </summary>
            <param name="candidate">The potential member</param>
        </member>
        <member name="M:Z0.IDeferredSet`2.IsSubset(`0,System.Boolean)">
            <summary>
            Determines whether the current set is a subset of a specified set.
            </summary>
            <param name="rhs">The candidate superset</param>
            <param name="proper">Specifies whether only proper subsets are considered "subsets"</param>
        </member>
        <member name="M:Z0.IDeferredSet`2.IsSuperset(`0,System.Boolean)">
            <summary>
            Determines whether the current set is a superset of a specified set.
            </summary>
            <param name="rhs">The candidate subset</param>
            <param name="proper">Specifies whether only proper subsets are considered "subsets"</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.IDeferredSet`2.Union(`0)" -->
        <member name="M:Z0.IDeferredSet`2.Intersect(`0)">
            <summary>
            Calculates the intersection between the current set and a specified set and
            returns a new set that embodies this result
            </summary>
            <param name="rhs">The set with which to intersect</param>
        </member>
        <member name="M:Z0.IDeferredSet`2.Difference(`0,System.Boolean)">
            <summary>
            Calculates the set difference, or symmetric difference, between the current 
            set and a specified set and returns a new set that embodies this result
            </summary>
            <param name="rhs">The set that should be differenced</param>
            <remarks>See https://en.wikipedia.org/wiki/Symmetric_difference</remarks>
        </member>
        <member name="T:Z0.IFinite">
            <summary>
            Characterizes a type for which a well-defined Count() function can be implemented
            such types will be referred to as "countable" although this terminology unfortunately conflicts
            with mathematical countability which only requires the existence of a bijection with
            the subject and the natural numbers which does imply that the cardinality is finite
            </summary>
        </member>
        <member name="M:Z0.IFinite.Count">
            <summary>
            Counts the finite things
            </summary>
        </member>
        <member name="T:Z0.IFiniteDeferral`1">
            <summary>
            Characterizes a finite deferred T-sequence
            </summary>
            <typeparam name="T">The sequence element type</typeparam>
        </member>
        <member name="M:Z0.IFiniteDeferral`1.Force">
            <summary>
            Brings the deferral to life
            </summary>
        </member>
        <member name="T:Z0.IFiniteDeferral`2">
            <summary>
            Characterizes a reified finite sequence
            </summary>
            <typeparam name="S">The reifying type</typeparam>
            <typeparam name="T">The sequence element type</typeparam>
        </member>
        <member name="T:Z0.IConcatenableOps`1">
            <summary>
            Characterizes an operator that merges two elements into one with preservation
            of constituent order if such an ordering is defined. In the situation where
            no ordering exist, the concatenation operator is effectively reduced to
            an addition operator
            </summary>
            <typeparam name="T">The element type</typeparam>
        </member>
        <!-- Badly formed XML comment ignored for member "T:Z0.IFreeMonoidOps`1" -->
        <member name="T:Z0.IKind">
            <summary>
            Characterizes a metaclass stratifier
            </summary>
        </member>
        <member name="T:Z0.IMeasured">
            <summary>
            Characterizes a type that exhibits a notion of finite length
            </summary>
        </member>
        <member name="T:Z0.IMeasured`1">
            <summary>
            Characterizes a reified type that  exhibits a notion of length
            </summary>
        </member>
        <member name="T:Z0.IMonoid`2">
            <summary>
            Characterizes monoidal structure
            </summary>
            <typeparam name="S">The classified structure</typeparam>
            <typeparam name="T">The underlying type</typeparam>
        </member>
        <member name="T:Z0.INonEmpty`1">
            <summary>
            Characterizes a reification of the counterpoint to a nullary thing
            </summary>
            <typeparam name="F">The thing which cannot be empty</typeparam>
        </member>
        <member name="T:Z0.INonEmpty`2">
            <summary>
            Characterizes a T-parametric nonempty thing that provides evidence of non-absence
            </summary>
            <typeparam name="F">The thing which cannot be empty</typeparam>
        </member>
        <member name="P:Z0.INonEmpty`2.Individual">
            <summary>
            Proof
            </summary>
        </member>
        <member name="T:Z0.INullaryOps`1">
            <summary>
            Characterizes operations over a nullary type
            </summary>
            <typeparam name="T">The unit type</typeparam>
            <remarks>
            It is tempting to subclass Additive here, but there are cases where
            it makes sense for something have a zero element and yet not be
            additive, e.g. a string can be empty, and they can be added (via concatentation)
            but consider the set of singleton/atomic strings over some alphabet. In
            this case, there can be no (closed) concatenation operation and yet
            the concept of nothingness (the empty string) is still meaningful
            </remarks>
        </member>
        <member name="T:Z0.INullary`1">
            <summary>
            Characterizes an additive structure S for which there exists a distinguished
            element 0:S such that for every s:S, s + 0 = s
            </summary>
            <typeparam name="T">The zero value type</typeparam>
        </member>
        <member name="P:Z0.INullary`1.Zero">
            <summary>
            Specifies the zero value
            </summary>
        </member>
        <member name="T:Z0.INullity">
            <summary>
            Characterizes a type for which nullity can be adjudicated
            </summary>
        </member>
        <member name="M:Z0.ISemigroupOps`1.Equals(`0,`0)">
            <summary>
            Adjudicates equality between semigroup members
            </summary>
            <param name="lhs">The first operand</param>
            <param name="rhs">The second operand</param>
        </member>
        <member name="T:Z0.ISet`2">
            <summary>
            Characterizes a reified set over elements of parametric type
            </summary>
            <typeparam name="F">The reifying type</typeparam>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.ISet`2.Contains(`1)">
            <summary>
            Determines whether a value is a member
            </summary>
            <param name="candidate">The potential member</param>
        </member>
        <member name="M:Z0.ISet`2.IsSubset(`0,System.Boolean)">
            <summary>
            Determines whether the current set is a subset of a specified set.
            </summary>
            <param name="rhs">The candidate superset</param>
            <param name="proper">Specifies whether only proper subsets are considered "subsets"</param>
        </member>
        <member name="M:Z0.ISet`2.IsSuperset(`0,System.Boolean)">
            <summary>
            Determines whether the current set is a superset of a specified set.
            </summary>
            <param name="rhs">The candidate subset</param>
            <param name="proper">Specifies whether only proper subsets are considered "subsets"</param>
        </member>
        <!-- Badly formed XML comment ignored for member "M:Z0.ISet`2.Union(`0)" -->
        <member name="M:Z0.ISet`2.Intersect(`0)">
            <summary>
            Calculates the intersection between the current set and a specified set and
            returns a new set that embodies this result
            </summary>
            <param name="rhs">The set with which to intersect</param>
        </member>
        <member name="M:Z0.ISet`2.Difference(`0,System.Boolean)">
            <summary>
            Calculates the set difference, or symmetric difference, between the current
            set and a specified set and returns a new set that embodies this result
            </summary>
            <param name="rhs">The set that should be differenced</param>
            <remarks>See https://en.wikipedia.org/wiki/Symmetric_difference</remarks>
        </member>
        <member name="T:Z0.ISink">
            <summary>
            Sink interface root
            </summary>
        </member>
        <member name="T:Z0.ISink`1">
            <summary>
            Characterizes a sink that accepts a single input value
            </summary>
            <typeparam name="A">The input type</typeparam>
        </member>
        <member name="M:Z0.ISink`1.Deposit(`0)">
            <summary>
            Receives supplied input
            </summary>
            <param name="src">The input</param>
        </member>
        <member name="T:Z0.ISource">
            <summary>
            Root interface for value production services
            </summary>
        </member>
        <member name="T:Z0.ISource`1">
            <summary>
            Characterizes an unlimited emitter that produces one element at a time
            </summary>
            <typeparam name="T">The production element type</typeparam>
        </member>
        <member name="M:Z0.ISource`1.Next">
            <summary>
            Retrieves the next item from the source
            </summary>
        </member>
        <member name="T:Z0.IUnital`1">
            <summary>
            Advertises a distinguished value One:T such that for every t:T, One*t = t*One = t
            for binary operator * over T
            </summary>
            <typeparam name="T">The unital value type</typeparam>
        </member>
        <member name="T:Z0.IUnital`2">
            <summary>
            Characterizes a structure with unit
            </summary>
            <typeparam name="S">The unital value type</typeparam>
        </member>
        <member name="T:Z0.DocStructureKind">
            <summary>
            Defines classifiers for structured content
            </summary>
        </member>
        <member name="T:Z0.DocContentKind">
            <summary>
            Defines resource content categories
            </summary>
        </member>
        <member name="T:Z0.ILiteral">
            <summary>
            Describes a literal value from a non-parametric perspective
            </summary>
        </member>
        <member name="P:Z0.ILiteral.Name">
            <summary>
            A locally-scoped identifier
            </summary>
        </member>
        <member name="P:Z0.ILiteral.Data">
            <summary>
            The literal data
            </summary>
        </member>
        <member name="P:Z0.ILiteral.Text">
            <summary>
            The literal's text representation
            </summary>
        </member>
        <member name="T:Z0.ILiteral`1">
            <summary>
            Characterizes a reified literal description
            </summary>
        </member>
        <member name="T:Z0.ILiteral`2">
            <summary>
            Characterizes a reified T-parametric literal description
            </summary>
        </member>
        <member name="P:Z0.ILiteral`2.Data">
            <summary>
            The literal data
            </summary>
        </member>
        <member name="T:Z0.ILiteralCover`1">
            <summary>
            Characterizes a type that defines views over captured literals
            </summary>
            <typeparam name="K">The covered literal type</typeparam>
        </member>
        <member name="T:Z0.ILiteralCover`2">
            <summary>
            Characterizes a type that defines views over captured literals
            </summary>
            <typeparam name="C">The cover type</typeparam>
            <typeparam name="K">The covered literal type</typeparam>
        </member>
        <member name="T:Z0.ILiteralCover`3">
            <summary>
            Characterizes a type that defines views over captured literals
            </summary>
            <typeparam name="C">The cover type</typeparam>
            <typeparam name="K1">A covered literal type</typeparam>
            <typeparam name="K2">A covered literal type</typeparam>
        </member>
        <member name="T:Z0.ILiteralKind`1">
            <summary>
            Characterizes a parametric literal: typed literals that support kind partitioning
            </summary>
            <typeparam name="E">The classifying enum type</typeparam>
        </member>
        <member name="T:Z0.ILiteralKind`2">
            <summary>
            Characterizes an F-bound polymorphic E-parametric literal reification
            </summary>
            <typeparam name="F">The reification type</typeparam>
            <typeparam name="E">The classifier type</typeparam>
        </member>
        <member name="T:Z0.ILiteralKind`3">
            <summary>
            Characterizes a T-parametric literal kind 
            </summary>
            <typeparam name="K">The literal kind </typeparam>
            <typeparam name="E">The kind classifier type</typeparam>
            <typeparam name="T">Free</typeparam>
        </member>
        <member name="T:Z0.ILiteralType`2">
            <summary>
            Characterizes an E-parametric literal that supports T-parametric stratification
            </summary>
            <typeparam name="E">The classifier type</typeparam>
            <typeparam name="T">The stratification type</typeparam>
        </member>
        <member name="T:Z0.ILiteralType`3">
            <summary>
            Characterizes a T-parametric F-bound polymorphic E-parametric literal reification
            </summary>
            <typeparam name="F">The reification type</typeparam>
            <typeparam name="E">The classifier type</typeparam>
            <typeparam name="T">The stratification type</typeparam>
        </member>
        <member name="T:Z0.ITypedLiteral`1">
            <summary>
            Characterizes type classifiers predicated on enumerations
            </summary>
            <typeparam name="E">The enum type that defines the classifier superset</typeparam>
        </member>
        <member name="T:Z0.ITypedLiteral`2">
            <summary>
            Characterizes parametric typed literals
            </summary>
            <typeparam name="E">The enum type that defines the classifier superset</typeparam>
            <typeparam name="T">The numeric type refined by the enum</typeparam>
        </member>
        <member name="T:Z0.ITypedLiteral`3">
            <summary>
            Characterizes F-bound polymorphic numeric-parametric typed literals
            </summary>
            <typeparam name="F">The reification type</typeparam>
            <typeparam name="E">The enum type that defines the classifier superset</typeparam>
            <typeparam name="T">The numeric type refined by the enum</typeparam>
        </member>
        <member name="T:Z0.ITypedLiteralType`1">
            <summary>
            Characterizes a typed literal type definition
            </summary>
            <typeparam name="H">The reified typed literal</typeparam>
        </member>
        <member name="T:Z0.ITypedLiteralType`2">
            <summary>
            Characterizes a typed literal type definition
            </summary>
            <typeparam name="H">The reified typed literal</typeparam>
            <typeparam name="L">The literal type</typeparam>
        </member>
        <member name="T:Z0.TypedLiteral`1">
            <summary>
            Lifts an enumeration literal to a type
            </summary>
        </member>
        <member name="P:Z0.TypedLiteral`1.Class">
            <summary>
            The classifying literal
            </summary>
        </member>
        <member name="M:Z0.ArrayBuilder.copy``1(System.Collections.Generic.List{``0},System.UInt32,System.Span{``0})">
            <summary>
            Copies the accumulated items to the target beginning at a specified offset
            </summary>
            <param name="dst">The data target</param>
            <param name="offset">The target offset</param>
        </member>
        <member name="M:Z0.Arrays.alloc``1(System.Int32)">
            <summary>
            Allocates a new array
            </summary>
            <param name="length">The array length</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.Arrays.alloc``1(System.Int32,``0)">
            <summary>
            Allocates a new array and populates it with a specified value
            </summary>
            <param name="length">The array length</param>
            <param name="src">The value with which to populate the array</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.Arrays.clear``1(``0[])">
            <summary>
            Fills an array with the element type's default value
            </summary>
            <param name="dst">The source array</param>
            <typeparam name="T">The array element type</typeparam>
        </member>
        <member name="M:Z0.Arrays.concat``1(System.Collections.Generic.IEnumerable{``0[]})">
            <summary>
            Concatenates a sequence of arrays
            </summary>
            <param name="src">The source arrays</param>
        </member>
        <member name="M:Z0.Arrays.concat``1(``0[],``0[])">
            <summary>
            Concatenates two arrays
            </summary>
            <param name="left">The first array</param>
            <param name="right">The second array</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.Arrays.concat(System.Byte[],System.Byte[])">
            <summary>
            Concatenates two byte arrays
            </summary>
            <param name="left">The first array</param>
            <param name="right">The second array</param>
            <remarks>See https://stackoverflow.com/questions/415291/best-way-to-combine-two-or-more-byte-arrays-in-c-sharp</remarks>
        </member>
        <member name="M:Z0.Arrays.concat``1(``0[][])">
            <summary>
            Concatenates a sequence of parameter arrays
            </summary>
            <param name="src">The source arrays</param>
        </member>
        <member name="M:Z0.Arrays.empty``1">
            <summary>
            Returns an empty array
            </summary>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.Arrays.empty``1(``0[])">
            <summary>
            Tests whether an array is empty
            </summary>
            <param name="src">The array to test</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.Arrays.fill``1(``0[],``0)">
            <summary>
            Fills an array, in-place, with a specified value
            </summary>
            <param name="dst">The target array</param>
            <param name="dst">The source value</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.Arrays.first``1(``0[])">
            <summary>
            Returns a reference to the location of the first element
            </summary>
            <param name="src">The source array</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.Arrays.replicate``1(``0,System.Int32)">
            <summary>
            Constructs an array filled with a replicated value
            </summary>
            <param name="value">The value to replicate</param>
            <param name="count">The number of replicants</param>
            <typeparam name="T">The replicant type</typeparam>
        </member>
        <member name="M:Z0.Arrays.seek``1(``0[],System.Int32)">
            <summary>
            Adds an offset to the head of an array, measured relative to the reference type
            </summary>
            <param name="src">The source span</param>
            <param name="bytes">The number of elements to advance</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.Arrays.skip``1(``0[],System.Int32)">
            <summary>
            Adds an offset to the head of an array, measured relative to the reference type
            </summary>
            <param name="src">The source span</param>
            <param name="bytes">The number of elements to advance</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.ArrayBuilder`1.CopyTo(System.Span{`0},System.UInt32)">
            <summary>
            Copies the accumulated items to the target beginning at a specified offset
            </summary>
            <param name="dst">The data target</param>
            <param name="offset">The target offset</param>
        </member>
        <member name="M:Z0.memory.add``1(``0@,System.Int32)">
            <summary>
            Adds an offset to a reference
            </summary>
            <param name="src">The source reference</param>
            <param name="count">The T-cell count to add</param>
            <typeparam name="T">The reference type</typeparam>
            <remarks>
            u8:  movsxd rax,edx -> add rax,rcx
            u16: movsxd rax,edx -> lea rax,[rcx+rax*2]
            u32: movsxd rax,edx -> lea rax,[rcx+rax*4]
            u64: movsxd rax,edx -> lea rax,[rcx+rax*8]
            </remarks>
        </member>
        <member name="M:Z0.memory.add``1(``0@,System.UInt32)">
            <summary>
            Adds an offset to a reference
            </summary>
            <param name="src">The source reference</param>
            <param name="count">The T-cell count to add</param>
            <typeparam name="T">The reference type</typeparam>
            <remarks>
            u8:  movsxd rax,edx -> add rax,rcx
            u16: movsxd rax,edx -> lea rax,[rcx+rax*2]
            u32: movsxd rax,edx -> lea rax,[rcx+rax*4]
            u64: movsxd rax,edx -> lea rax,[rcx+rax*8]
            </remarks>
        </member>
        <member name="M:Z0.memory.add``1(``0@,System.Byte)">
            <summary>
            Adds an offset to a reference
            </summary>
            <param name="src">The source reference</param>
            <param name="count">The T-cell count to add</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.memory.add``1(``0@,System.UInt16)">
            <summary>
            Adds an offset to a reference
            </summary>
            <param name="src">The source reference</param>
            <param name="count">The T-cell count to add</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.memory.add``1(``0@,System.UInt64)">
            <summary>
            Adds an offset to a reference
            </summary>
            <param name="src">The source reference</param>
            <param name="count">The T-cell count to add</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.memory.as``2(``0@)">
            <summary>
            Presents an S-cell as a T-cell
            </summary>
            <param name="src">The source cell</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.memory.as``2(``0@,``1@)">
            <summary>
            Presents an S-cell as a T-cell
            </summary>
            <param name="src">The source cell</param>
            <param name="src">The target cell</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.memory.cover``2(``0@,System.UInt32)">
            <summary>
            Creates a T-counted T-span from an S-cell data source
            </summary>
            <param name="src">The data source</param>
            <param name="count">The T-counted target count</param>
            <typeparam name="S">The source cell type</typeparam>
            <typeparam name="T">The target cell type</typeparam>
        </member>
        <member name="M:Z0.memory.cover``1(``0*,System.UInt32)">
            <summary>
            Covers a pointer-identified T-counted buffer with a span
            </summary>
            <param name="pSrc">The memory source</param>
            <param name="count">The number of cells to cover</param>
            <typeparam name="T">The span cell type</typeparam>
        </member>
        <member name="M:Z0.memory.cover``1(``0@,System.Int32)">
            <summary>
            Covers a reference-identified T-counted buffer with a span
            </summary>
            <param name="src">A reference to the leading cell</param>
            <param name="count">The number of T-cells to cover</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.memory.cover``1(``0@,System.UInt32)">
            <summary>
            Covers a reference-identified T-counted buffer with a span
            </summary>
            <param name="src">A reference to the leading cell</param>
            <param name="count">The number of T-cells to cover</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.memory.cover``1(``0@,System.UInt64)">
            <summary>
            Covers a reference-identified T-counted buffer with a span
            </summary>
            <param name="src">A reference to the leading cell</param>
            <param name="count">The number of T-cells to cover</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.memory.edit``1(``0@)">
            <summary>
            Transforms a readonly T-cell into an editable T-cell
            </summary>
            <param name="src">The source cell</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.memory.edit(System.String)">
            <summary>
            Are you sure you want to do this?
            </summary>
            <param name="src">The immutable, and possibly interned string that were are going to modify</param>
        </member>
        <member name="M:Z0.memory.edit``1(System.ReadOnlySpan{``0})">
            <summary>
            Covers the content of a readonly span with an editable span
            </summary>
            <param name="src">The memory source</param>
            <param name="count">The number of source cells to read</param>
            <typeparam name="T">The cell type</typeparam>
            <returns>Obviously, this trick could be particularly dangerous</returns>
        </member>
        <member name="M:Z0.memory.edit``2(``0@)">
            <summary>
            Transforms a readonly S-cell into an editable T-cell
            </summary>
            <param name="src">The source cell</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.memory.edit``2(``0@,``1@)">
            <summary>
            Transforms a readonly S-cell into an editable T-cell
            </summary>
            <param name="src">The source cell</param>
            <param name="dst">The target cell</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.memory.first``1(System.Span{``0})">
            <summary>
            Returns a reference to the head of a readonly span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.memory.first``1(``0[])">
            <summary>
            Returns a reference to the location of the first element
            </summary>
            <param name="src">The source array</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.memory.first``1(System.ReadOnlySpan{``0})">
            <summary>
            Returns a reference to the head of a readonly span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.memory.first(System.ReadOnlySpan{System.Char})">
            <summary>
            Returns a readonly reference to the first source cell
            </summary>
            <param name="src">The source span</param>
        </member>
        <member name="M:Z0.memory.gptr``1(``0@,System.Int32)">
            <summary>
            Presents a readonly reference to an unmanaged value as a pointer displaced
            by a specified element offset
            </summary>
            <param name="src">The memory reference</param>
            <param name="offset">The number of elements to skip</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.memory.gptr``2(``0@)">
            <summary>
            Presents a generic reference r:T as a generic pointer p:T
            </summary>
            <param name="r">The memory reference</param>
            <typeparam name="T">The source reference type</typeparam>
            <typeparam name="P">The target pointer type</typeparam>
        </member>
        <member name="M:Z0.memory.pchar(System.String)">
            <summary>
            Retrieves a pointer to a string that, hopefully (shouldn't)  move
            </summary>
            <param name="src">The source string</param>
        </member>
        <member name="M:Z0.memory.read``1(System.ReadOnlySpan{System.Byte})">
            <summary>
            Reads a T-cell from a bytespan
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.memory.read``1(``0*,System.Int32,``0@)">
            <summary>
            Deposits a source value, identified by pointer and offset, into a target reference
            </summary>
            <param name="pSrc">The data source</param>
            <param name="offset">The value offset</param>
            <param name="dst">The receiving reference</param>
            <typeparam name="T">The value type</typeparam>
            <remarks>u8:  movsxd rax,edx -> movzx eax,byte ptr [rcx+rax] -> mov [r8],al -> mov rax,r8 </remarks>
            <remarks>u16: movsxd rax,edx -> movzx eax,word ptr [rcx+rax*2] -> mov [r8],ax -> mov rax,r8 </remarks>
            <remarks>u32: movsxd rax,edx -> mov eax,[rcx+rax*4] -> mov [r8],eax -> mov rax,r8 </remarks>
            <remarks>u64: movsxd rax,edx -> mov rax,[rcx+rax*8] -> mov [r8],rax -> mov rax,r8 </remarks>
        </member>
        <member name="M:Z0.memory.read``1(``0*,System.Int32,``0@,System.Int32)">
            <summary>
            Deposits a range of source values into a target reference
            </summary>
            <param name="pSrc">The data source</param>
            <param name="offset">The value offset</param>
            <param name="dst">The receiving reference</param>
            <param name="count">The number of values to extract/deposit</param>
            <typeparam name="T">The value type</typeparam>
        </member>
        <member name="M:Z0.memory.read``2(``0@)">
            <summary>
            Reads a T-value from an S-source
            </summary>
            <param name="src">The data source</param>
            <typeparam name="S">The source cell type</typeparam>
            <typeparam name="T">The target cell type</typeparam>
        </member>
        <member name="M:Z0.memory.read``2(``0@,System.Int32)">
            <summary>
            Reads a T-value from an S-source after skipping a specified count of S-elements
            </summary>
            <param name="src">The data source</param>
            <param name="offset">The number of S-cells to skip</param>
            <typeparam name="S">The source cell type</typeparam>
            <typeparam name="T">The target cell type</typeparam>
        </member>
        <member name="M:Z0.memory.read``1(System.Byte@)">
            <summary>
            Reads a T-cell from a specified data source
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.memory.read``1(System.SByte@)">
            <summary>
            Reads a T-cell from a specified data source
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.memory.read``1(System.Int16@)">
            <summary>
            Reads a T-cell from a specified data source
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.memory.read``1(System.UInt16@)">
            <summary>
            Reads a T-cell from a specified data source
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.memory.read``1(System.Int32@)">
            <summary>
            Reads a T-cell from a specified data source
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.memory.read``1(System.UInt32@)">
            <summary>
            Reads a T-cell from a specified data source
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.memory.read``1(System.Int64@)">
            <summary>
            Reads a T-cell from a specified data source
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.memory.read``1(System.UInt64@)">
            <summary>
            Reads a T-cell from a specified data source
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.memory.read``1(System.Single@)">
            <summary>
            Reads a T-cell from a specified data source
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.memory.read``1(System.Double@)">
            <summary>
            Reads a T-cell from a specified data source
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.memory.read``1(System.Boolean@)">
            <summary>
            Reads a T-cell from a specified data source
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.memory.read``1(System.Char@)">
            <summary>
            Reads a T-cell from a specified data source
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.memory.read``1(System.Decimal@)">
            <summary>
            Reads a T-cell from a specified data source
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.memory.read``1(System.Byte@,System.Int32)">
            <summary>
            Reads a T-cell from a specified data source after skipping a specified number of source cells
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.memory.read``1(System.SByte@,System.Int32)">
            <summary>
            Reads a T-cell from a specified data source after skipping a specified number of source cells
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.memory.read``1(System.Int16@,System.Int32)">
            <summary>
            Reads a T-cell from a specified data source after skipping a specified number of source cells
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.memory.read``1(System.UInt16@,System.Int32)">
            <summary>
            Reads a T-cell from a specified data source after skipping a specified number of source cells
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.memory.read``1(System.Int32@,System.Int32)">
            <summary>
            Reads a T-cell from a specified data source after skipping a specified number of source cells
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.memory.read``1(System.UInt32@,System.Int32)">
            <summary>
            Reads a T-cell from a specified data source after skipping a specified number of source cells
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.memory.read``1(System.Int64@,System.Int32)">
            <summary>
            Reads a T-cell from a specified data source after skipping a specified number of source cells
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.memory.read``1(System.UInt64@,System.Int32)">
            <summary>
            Reads a T-cell from a specified data source after skipping a specified number of source cells
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.memory.read``1(System.Single@,System.Int32)">
            <summary>
            Reads a T-cell from a specified data source after skipping a specified number of source cells
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.memory.read``1(System.Double@,System.Int32)">
            <summary>
            Reads a T-cell from a specified data source after skipping a specified number of source cells
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.memory.read``1(System.Boolean@,System.Int32)">
            <summary>
            Reads a T-cell from a specified data source after skipping a specified number of source cells
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.memory.read``1(System.Char@,System.Int32)">
            <summary>
            Reads a T-cell from a specified data source after skipping a specified number of source cells
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.memory.read``1(System.Decimal@,System.Int32)">
            <summary>
            Reads a T-cell from a specified data source after skipping a specified number of source cells
            </summary>
            <param name="src">The data source</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.memory.recover``2(System.Span{``0})">
            <summary>
            Presents a span of S-cells as a span of T-cells
            </summary>
            <param name="src">The data source</param>
            <typeparam name="S">The source cell type</typeparam>
            <typeparam name="T">The target cell type</typeparam>
        </member>
        <member name="M:Z0.memory.recover``2(System.ReadOnlySpan{``0})">
            <summary>
            Presents a readonly span of S-cells as a readonly span of T-cells
            </summary>
            <param name="src">The data source</param>
            <typeparam name="S">The source cell type</typeparam>
            <typeparam name="T">The target cell type</typeparam>
        </member>
        <member name="M:Z0.memory.recover``1(System.ReadOnlySpan{System.SByte})">
            <summary>
            Presents a <see cref='T:System.SByte'/> span as a T-span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The target span cell type</typeparam>
            <remarks>
            width[T] = 8: mov rax,[rdx] => [rcx],rax => mov dword ptr [rcx+8],1 => mov rax,rcx
            width[T] = 16: mov rax,[rdx] => [rcx],rax => mov dword ptr [rcx+8],2 => mov rax,rcx
            width[T] = 32: mov rax,[rdx] => [rcx],rax => mov dword ptr [rcx+8],4 => mov rax,rcx
            width[T] = 64: mov rax,[rdx] => [rcx],rax => mov dword ptr [rcx+8],8 => mov rax,rcx
            </remarks>
        </member>
        <member name="M:Z0.memory.recover``1(System.ReadOnlySpan{System.Byte})">
            <summary>
            Presents a <see cref='T:System.Byte'/> span as a T-span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The target span cell type</typeparam>
            <remarks>
            Using the system-supplid cast function:
            0000h sub rsp,28h
            0004h nop
            0005h mov rax,[rcx]
            0008h mov ecx,[rcx+8]
            000bh cmp ecx,1
            000eh jl short 0018h
            0010h movzx eax,byte ptr [rax]
            0013h add rsp,28h
            0017h ret
            0018h mov ecx,28h
            </remarks>
        </member>
        <member name="M:Z0.memory.recover``1(System.ReadOnlySpan{System.Int16})">
            <summary>
            Presents a <see cref='T:System.Int16'/> span as a T-span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The target span cell type</typeparam>
        </member>
        <member name="M:Z0.memory.recover``1(System.ReadOnlySpan{System.UInt16})">
            <summary>
            Presents a <see cref='T:System.UInt16'/> span as a T-span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The target span cell type</typeparam>
        </member>
        <member name="M:Z0.memory.recover``1(System.ReadOnlySpan{System.Int32})">
            <summary>
            Presents a <see cref='T:System.Int32'/> span as a T-span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The target span cell type</typeparam>
        </member>
        <member name="M:Z0.memory.recover``1(System.ReadOnlySpan{System.UInt32})">
            <summary>
            Presents a <see cref='T:System.UInt32'/> span as a T-span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The target span cell type</typeparam>
        </member>
        <member name="M:Z0.memory.recover``1(System.ReadOnlySpan{System.Int64})">
            <summary>
            Presents a <see cref='T:System.Int64'/>-cell span as a T-cell span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The target span cell type</typeparam>
        </member>
        <member name="M:Z0.memory.recover``1(System.ReadOnlySpan{System.UInt64})">
            <summary>
            Presents a <see cref='T:System.UInt64'/>-cell span as a T-cell span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The target span cell type</typeparam>
        </member>
        <member name="M:Z0.memory.recover``1(System.ReadOnlySpan{System.Single})">
            <summary>
            Presents a <see cref='T:System.Single'/>-cell span as a T-cell span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The target span cell type</typeparam>
        </member>
        <member name="M:Z0.memory.recover``1(System.ReadOnlySpan{System.Double})">
            <summary>
            Presents a <see cref='T:System.Double'/>-cell span as a T-cell span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The target span cell type</typeparam>
        </member>
        <member name="M:Z0.memory.recover``1(System.ReadOnlySpan{System.Decimal})">
            <summary>
            Presents a <see cref='T:System.Decimal'/>-cell span as a T-cell span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The target span cell type</typeparam>
        </member>
        <member name="M:Z0.memory.recover``1(System.Span{System.Byte})">
            <summary>
            Presents a source span as a T-span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The target span cell type</typeparam>
        </member>
        <member name="M:Z0.memory.recover``1(System.Span{System.UInt32})">
            <summary>
            Presents a source span as a T-span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The target span cell type</typeparam>
        </member>
        <member name="M:Z0.memory.recover``1(System.Span{System.SByte})">
            <summary>
            Presents a source span as a T-span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The target span cell type</typeparam>
        </member>
        <member name="M:Z0.memory.recover``1(System.Span{System.Int16})">
            <summary>
            Presents a source span as a T-span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The target span cell type</typeparam>
        </member>
        <member name="M:Z0.memory.recover``1(System.Span{System.UInt16})">
            <summary>
            Presents a source span as a T-span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The target span cell type</typeparam>
        </member>
        <member name="M:Z0.memory.recover``1(System.Span{System.Int32})">
            <summary>
            Presents a source span as a T-span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The target span cell type</typeparam>
        </member>
        <member name="M:Z0.memory.recover``1(System.Span{System.Int64})">
            <summary>
            Presents a source span as a T-span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The target span cell type</typeparam>
        </member>
        <member name="M:Z0.memory.recover``1(System.Span{System.UInt64})">
            <summary>
            Presents a source span as a T-span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The target span cell type</typeparam>
        </member>
        <member name="M:Z0.memory.recover``1(System.Span{System.Single})">
            <summary>
            Presents a source span as a T-span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The target span cell type</typeparam>
        </member>
        <member name="M:Z0.memory.recover``1(System.Span{System.Double})">
            <summary>
            Presents a source span as a T-span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The target span cell type</typeparam>
        </member>
        <member name="M:Z0.memory.recover``1(System.Span{System.Decimal})">
            <summary>
            Presents a source span as a T-span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The target span cell type</typeparam>
        </member>
        <member name="M:Z0.memory.ref``1(``0*)">
            <summary>
            Presents a pointer as a reference
            </summary>
            <param name="ptr">The source pointer</param>
            <typeparam name="T">The reference type</typeparam>
            <remarks>For all T, effects: mov rax,rcx</remarks>
        </member>
        <member name="M:Z0.memory.ref``1(System.Void*)">
            <summary>
            Presents a void pointer as a reference
            </summary>
            <param name="pSrc">The source pointer</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.memory.ref``2(``0*)">
            <summary>
            Presents an S-pointer as a T-reference
            </summary>
            <param name="pSrc">The source pointer</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.memory.refptr``1(``0@)">
            <summary>
            Presents generic reference as a generic pointer
            </summary>
            <param name="src">The memory reference</param>
            <typeparam name="T">The reference type</typeparam>
            <remarks>For all T, effects: mov rax,rcx</remarks>
        </member>
        <member name="M:Z0.memory.refptr``1(``0@,System.Int32)">
            <summary>
            Presents generic reference as a generic pointer displaced by an element offset
            </summary>
            <param name="src">The memory reference</param>
            <param name="offset">The number of elements to skip</param>
            <typeparam name="T">The reference type</typeparam>
            <remarks>
            Effects
            width[T]=8:  movsxd rax,edx => add rax,rcx
            width[T]=16: movsxd rax,edx => lea rax,[rcx+rax*2]
            width[T]=32: movsxd rax,edx => lea rax,[rcx+rax*4]
            width[T]=64: movsxd rax,edx => lea rax,[rcx+rax*8]
            </remarks>
        </member>
        <member name="M:Z0.memory.refptr``2(``0@)">
            <summary>
            Presents a generic reference r:T as a generic pointer p:T
            </summary>
            <param name="r">The memory reference</param>
            <typeparam name="T">The source reference type</typeparam>
            <typeparam name="P">The target pointer type</typeparam>
        </member>
        <member name="M:Z0.memory.seek``2(``0@,System.UInt32)">
            <summary>
            Advances an S-reference in units measured by T-cells and returns
            the resulting T-cell reference
            </summary>
            <param name="src">The data source</param>
            <param name="count">The number of T-cells to advance</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.memory.seek``1(System.Span{``0},System.UInt32)">
            <summary>
            Returns a reference to a T-measured offset-identified cell
            </summary>
            <param name="src">The data source</param>
            <param name="offset">The T-measured offset count</param>
            <typeparam name="T">The cell type</typeparam>
            <remarks>
            Effects
            width[T]=8:  mov rax,[rcx] => movsxd rdx,edx => add rax,rdx
            width[T]=16: mov rax,[rcx] => movsxd rdx,edx => lea rax,[rax+rdx*2]
            width[T]=32: mov rax,[rcx] => movsxd rdx,edx => lea rax,[rax+rdx*4]
            width[T]=64: mov rax,[rcx] => movsxd rdx,edx => lea rax,[rax+rdx*8]
            </remarks>
        </member>
        <member name="M:Z0.memory.seek``1(System.Span{``0},System.UInt64)">
            <summary>
            Returns a reference to a T-measured offset-identified cell
            </summary>
            <param name="src">The data source</param>
            <param name="offset">The T-measured offset count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.memory.seek``1(System.Span{``0},System.Byte)">
            <summary>
            Returns a reference to a T-measured offset-identified cell
            </summary>
            <param name="src">The data source</param>
            <param name="offset">The T-measured offset count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.memory.seek``1(System.Span{``0},System.UInt16)">
            <summary>
            Returns a reference to a T-measured offset-identified cell
            </summary>
            <param name="src">The data source</param>
            <param name="offset">The T-measured offset count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.memory.seek``1(``0@,System.Byte)">
            <summary>
            Returns a reference to a T-measured offset-identified cell
            </summary>
            <param name="src">The data source</param>
            <param name="offset">The T-measured offset count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.memory.seek``1(``0@,System.UInt16)">
            <summary>
            Returns a reference to a T-measured offset-identified cell
            </summary>
            <param name="src">The data source</param>
            <param name="offset">The T-measured offset count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.memory.seek``1(``0@,System.UInt32)">
            <summary>
            Returns a reference to a T-measured offset-identified cell
            </summary>
            <param name="src">The data source</param>
            <param name="offset">The T-measured offset count</param>
            <typeparam name="T">The cell type</typeparam>
            <remarks>
            Effects
            width[T]=8:  movsxd rax,edx => add rax,rcx
            width[T]=16: movsxd rax,edx => lea rax,[rcx+rax*2]
            width[T]=32: movsxd rax,edx => lea rax,[rcx+rax*4]
            width[T]=64: movsxd rax,edx => lea rax,[rcx+rax*8]
            </remarks>
        </member>
        <member name="M:Z0.memory.seek``1(``0@,System.UInt64)">
            <summary>
            Returns a reference to a T-measured offset-identified cell
            </summary>
            <param name="src">The data source</param>
            <param name="offset">The T-measured offset count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.memory.seek``1(``0@,System.Int32)">
            <summary>
            Returns a reference to a T-measured offset-identified cell
            </summary>
            <param name="src">The data source</param>
            <param name="offset">The T-measured offset count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.memory.skip``1(``0@,System.Byte)">
            <summary>
            Skips a specified number of source elements and returns a readonly reference to the result
            </summary>
            <param name="src">The source reference</param>
            <param name="count">The number of elements to skip</param>
            <typeparam name="T">The source element type</typeparam>
        </member>
        <member name="M:Z0.memory.skip``1(``0@,System.UInt16)">
            <summary>
            Skips a specified number of source elements and returns a readonly reference to the result
            </summary>
            <param name="src">The source reference</param>
            <param name="count">The number of elements to skip</param>
            <typeparam name="T">The source element type</typeparam>
        </member>
        <member name="M:Z0.memory.skip``1(``0@,System.UInt32)">
            <summary>
            Skips a specified number of source elements and returns a readonly reference to the result
            </summary>
            <param name="src">The source reference</param>
            <param name="count">The number of elements to skip</param>
            <typeparam name="T">The source element type</typeparam>
        </member>
        <member name="M:Z0.memory.skip``1(``0@,System.UInt64)">
            <summary>
            Skips a specified number of source elements and returns a readonly reference to the result
            </summary>
            <param name="src">The source reference</param>
            <param name="count">The number of elements to skip</param>
            <typeparam name="T">The source element type</typeparam>
        </member>
        <member name="M:Z0.memory.skip``1(``0@,System.Int64)">
            <summary>
            Skips a specified number of source elements and returns a readonly reference to the result
            </summary>
            <param name="src">The source reference</param>
            <param name="count">The number of elements to skip</param>
            <typeparam name="T">The source element type</typeparam>
        </member>
        <member name="M:Z0.memory.skip``1(``0[],System.Double)">
            <summary>
            Skips a specified number of source elements and returns a readonly reference to the result
            </summary>
            <param name="src">The source reference</param>
            <param name="count">The number of elements to skip</param>
            <typeparam name="T">The source element type</typeparam>
        </member>
        <member name="M:Z0.memory.slice``1(System.ReadOnlySpan{``0},System.UInt32)">
            <summary>
            Selects a segment [offset, length(src) - 1] from a source span src:ReadOnlySpan[T]
            </summary>
            <param name="src">The data source</param>
            <param name="offset">The T-measured offset count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.memory.slice``1(System.ReadOnlySpan{``0},System.UInt64)">
            <summary>
            Selects a segment [offset, length(src) - 1] from a source span src:ReadOnlySpan[T]
            </summary>
            <param name="src">The data source</param>
            <param name="offset">The T-measured offset count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.memory.slice``1(System.ReadOnlySpan{``0},System.Int32)">
            <summary>
            Selects a segment [offset, length(src) - 1] from a source span src:ReadOnlySpan[T]
            </summary>
            <param name="src">The data source</param>
            <param name="offset">The T-measured offset count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.memory.slice``1(System.ReadOnlySpan{``0},System.Int32,System.Int32)">
            <summary>
            Draws a specified count of T-cells from a source span beginning at a specified offset
            </summary>
            <param name="src">The data source</param>
            <param name="offset">The T-measured offset count</param>
            <param name="length"></param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.memory.slice``1(System.ReadOnlySpan{``0},System.UInt32,System.UInt32)">
            <summary>
            Draws a specified count of T-cells from a source span beginning at a specified offset
            </summary>
            <param name="src">The data source</param>
            <param name="offset">The T-measured offset count</param>
            <param name="length"></param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.memory.slice``1(System.ReadOnlySpan{``0},System.UInt64,System.UInt64)">
            <summary>
            Draws a specified count of T-cells from a source span beginning at a specified offset
            </summary>
            <param name="src">The data source</param>
            <param name="offset">The T-measured offset count</param>
            <param name="length"></param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.memory.slice``1(System.Span{``0},System.Int32)">
            <summary>
            Selects a segment [offset, length(src) - 1] from a source span src:Span[T]
            </summary>
            <param name="src">The data source</param>
            <param name="offset">The T-measured offset count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.memory.slice``1(System.Span{``0},System.UInt32)">
            <summary>
            Selects a segment [offset, length(src) - 1] from a source span src:Span[T]
            </summary>
            <param name="src">The data source</param>
            <param name="offset">The T-measured offset count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.memory.slice``1(System.Span{``0},System.Int32,System.Int32)">
            <summary>
            Draws a specified count of T-cells from a source span beginning at a specified offset
            </summary>
            <param name="src">The data source</param>
            <param name="offset">The T-measured offset count</param>
            <param name="length"></param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.memory.slice``1(System.Span{``0},System.UInt32,System.UInt32)">
            <summary>
            Draws a specified count of T-cells from a source span beginning at a specified offset
            </summary>
            <param name="src">The data source</param>
            <param name="offset">The T-measured offset count</param>
            <param name="length"></param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.memory.slice``1(System.Span{``0},System.UInt64,System.UInt64)">
            <summary>
            Draws a specified count of T-cells from a source span beginning at a specified offset
            </summary>
            <param name="src">The data source</param>
            <param name="offset">The T-measured offset count</param>
            <param name="length"></param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.memory.span``2(``0@,System.Int32)">
            <summary>
            Creates a T-span from an S-reference
            </summary>
            <param name="src">A reference to the leading source cell</param>
            <param name="count">The source cell count</param>
            <typeparam name="S">The source cell type</typeparam>
            <typeparam name="T">The target cell type</typeparam>
        </member>
        <member name="M:Z0.memory.span``2(``0@)">
            <summary>
            Creates a T-span from a single S-reference
            </summary>
            <param name="src">A reference to the source cell</param>
            <typeparam name="S">The source cell type</typeparam>
            <typeparam name="T">The target cell type</typeparam>
        </member>
        <member name="M:Z0.memory.span``1(System.Int64)">
            <summary>
            Allocates storage for a specified number of T-cells
            </summary>
            <param name="count">The cell allocation count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.memory.span``1(System.UInt32)">
            <summary>
            Allocates storage for a specified number of T-cells
            </summary>
            <param name="count">The cell allocation count</param>
            <typeparam name="T">The cell type</typeparam>
        </member>
        <member name="M:Z0.memory.span``1(System.ReadOnlySpan{``0})">
            <summary>
            Constructs a span from a readonly span
            </summary>
            <param name="src">The source span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.memory.span``1(System.Collections.Generic.IEnumerable{``0},System.Int32,System.Int32)">
            <summary>
            Constructs a span of specified length from the sequence obtained by skipping a specified number of leading elements
            </summary>
            <param name="src">The source sequence</param>
            <param name="offset">The number of elements to skip</param>
            <param name="length">The length of the result span</param>
            <typeparam name="T">The element type</typeparam>
        </member>
        <member name="M:Z0.memory.subtract``1(``0@,System.UInt64)">
            <summary>
            Subtracts an offset from a reference
            </summary>
            <param name="src">The source reference</param>
            <param name="count">The T-cell count to subtract</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="M:Z0.memory.subtract``1(``0@,System.Int64)">
            <summary>
            Subtracts an offset from a reference
            </summary>
            <param name="src">The source reference</param>
            <param name="count">The T-cell count to subtract</param>
            <typeparam name="T">The reference type</typeparam>
        </member>
        <member name="T:Z0.IEither">
            <summary>
            Defines nonparametric either attributes 
            </summary>
        </member>
        <member name="P:Z0.IEither.IsLeft">
            <summary>
            Specifies whether the left alternative exists
            </summary>
        </member>
        <member name="P:Z0.IEither.IsRight">
            <summary>
            Specifies whether the right alternative exists
            </summary>
        </member>
        <member name="T:Z0.IEither`2">
            <summary>
            Characterizes a parametric disjoint union of arity two, where exactly one state
            is populated for a given instantitation
            </summary>
            <typeparam name="L">The left potential value</typeparam>
            <typeparam name="R">The right potential value</typeparam>
        </member>
        <member name="P:Z0.IEither`2.Left">
            <summary>
            If <see cref="!:IsLeft"/> is true, specifies the value of the left alternative
            </summary>
        </member>
        <member name="P:Z0.IEither`2.Right">
            <summary>
            If <see cref="!:IsRight"/> is true, specifies the value of the right alternative
            </summary>
        </member>
        <member name="T:Z0.IInfallibleParser`1">
            <summary>
            Characterizes a parser that cannot fail (in theory)
            </summary>
            <typeparam name="T">The parsed type</typeparam>
            <remarks>For this scheme to work, it is incumbent upon the reifying type to return a monoidal zero if malformed text is encountered</remarks>
        </member>
        <member name="T:Z0.IMonadic">
            <summary>
            Characterizes nothing, but defines a root interface for things monadic
            </summary>
        </member>
        <member name="T:Z0.IOption">
            <summary>
            Characterizes an untyped optional value
            </summary>
        </member>
        <member name="P:Z0.IOption.IsSome">
            <summary>
            True if a value exists, false otherwise
            </summary>
        </member>
        <member name="P:Z0.IOption.IsNone">
            <summary>
            True if a value does not exist, false otherwise
            </summary>
        </member>
        <member name="T:Z0.IOption`1">
            <summary>
            Characterizes a parametric option
            </summary>
            <typeparam name="T">The potential value type</typeparam>
        </member>
        <member name="P:Z0.IOption`1.Value">
            <summary>
            If extant, specifies the option value
            </summary>
        </member>
        <member name="T:Z0.IOption`2">
            <summary>
            Characterizes an F-bound polymorphic option
            </summary>
            <typeparam name="F">The reification type</typeparam>
            <typeparam name="T">The potential value type</typeparam>
        </member>
        <member name="T:Z0.IParametricParser">
            <summary>
            Characterizes a non-parametric text parser that defines a parametric parse function
            </summary>
        </member>
        <member name="M:Z0.IParametricParser.Parse``1(System.String)">
            <summary>
            Attemps to parse the source text as a parametrically-identified target type
            </summary>
            <param name="text">The source text</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.IParametricParser.Parse``1(System.String,``0)">
            <summary>
            Returns a successfully parsed value, if possible; otherwise returns a caller-supplied default value
            </summary>
            <param name="src">The text to parse</param>
            <param name="@default">The value returned if the parse function fails</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="T:Z0.IParametricParser`1">
            <summary>
            Characterizes a source-parametric parser that defines a parametric parse function
            </summary>
        </member>
        <member name="M:Z0.IParametricParser`1.Parse``1(`0)">
            <summary>
            Attemps to parse the source as a parametrically-identified target type
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.IParametricParser`1.Parse``1(`0,``0)">
            <summary>
            Returns a successfully parsed value, if possible; otherwise returns a caller-supplied default value
            </summary>
            <param name="src">The value to parse</param>
            <param name="@default">The value returned if the parse function fails</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="T:Z0.ITextParser`1">
            <summary>
            Characterizes a parser that yields values of a parametrically-identified type
            </summary>
            <typeparam name="T">The type of value that the parser can parse</typeparam>
        </member>
        <member name="T:Z0.Parse`1">
            <summary>
            Defines the signature of a canonical text -> T parser
            </summary>
            <param name="src">The source text</param>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="T:Z0.Parse`2">
            <summary>
            Defines the signature of a canonical S -> T parser
            </summary>
            <param name="src">The source value</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="T:Z0.Either">
            <summary>
            Constructs and manipulates <see cref="T:Z0.IEither"/> values
            </summary>
            <remarks>
            API surface inspired by https://github.com/ekmett/either
            </remarks>
        </member>
        <member name="M:Z0.Either.make``2(``0)">
            <summary>
            Constructs a left-valued either
            </summary>
            <typeparam name="L">The left value type</typeparam>
            <typeparam name="R">The right value type</typeparam>
            <param name="left">The right value</param>
        </member>
        <member name="M:Z0.Either.left``2(``0)">
            <summary>
            Constructs a left-valued either
            </summary>
            <typeparam name="L">The left value type</typeparam>
            <typeparam name="R">The right value type</typeparam>
            <param name="left">The right value</param>
        </member>
        <member name="M:Z0.Either.right``2(``1)">
            <summary>
            Constructs a right-valued either
            </summary>
            <typeparam name="L">The left value type</typeparam>
            <typeparam name="R">The right value type</typeparam>
            <param name="left">The right value</param>
        </member>
        <member name="M:Z0.Either.make``2(``1)">
            <summary>
            Constructs a right-valued either
            </summary>
            <typeparam name="L">The left value type</typeparam>
            <typeparam name="R">The right value type</typeparam>
            <param name="right">The right value</param>
        </member>
        <member name="M:Z0.Either.left``2(Z0.Either{``0,``1})">
            <summary>
            If either is Left, returns the left value; otherwise, raises an error
            </summary>
            <typeparam name="L">The left type</typeparam>
            <typeparam name="R">The right type</typeparam>
            <param name="e">The either</param>
        </member>
        <member name="M:Z0.Either.right``2(Z0.Either{``0,``1})">
            <summary>
            If either is Left, returns the left value; otherwise, raises an error
            </summary>
            <typeparam name="L">The left type</typeparam>
            <typeparam name="R">The right type</typeparam>
            <param name="e">The either</param>
        </member>
        <member name="M:Z0.Either.map``4(System.Func{``0,``2},System.Func{``1,``3},Z0.Either{``0,``1})">
            <summary>
            Applies the left function if the either is left-values and the right function if right
            </summary>
            <typeparam name="L">The left value type</typeparam>
            <typeparam name="R">The right value type</typeparam>
            <typeparam name="X">The left codomain</typeparam>
            <typeparam name="Y">The right codomain</typeparam>
            <param name="lf">The left function</param>
            <param name="rf">The right function</param>
            <param name="e">The either</param>
        </member>
        <member name="M:Z0.Either.map``3(System.Func{``0,``2},Z0.Either{``0,``1})">
            <summary>
            Applies a left function if the either is left-valued; otherwise, passes the right
            value through untransformed
            </summary>
            <typeparam name="L">The left value type</typeparam>
            <typeparam name="R">The right value type</typeparam>
            <typeparam name="Y">The codomain of the left function</typeparam>
            <param name="lf">The function to apply to the left value if present</param>
            <param name="e">The either</param>
        </member>
        <member name="M:Z0.Either.map``3(System.Func{``1,``2},Z0.Either{``0,``1})">
            <summary>
            Applies a right function if the either is right-valued; otherwise, passes the left
            value through untransformed
            </summary>
            <typeparam name="L">The left value type</typeparam>
            <typeparam name="R">The right value type</typeparam>
            <typeparam name="Y">The codomain of the right function</typeparam>
            <param name="rf">The function to apply to the right value if present</param>
            <param name="e">The either</param>
        </member>
        <member name="M:Z0.Either.isLeft``2(Z0.Either{``0,``1})">
            <summary>
            Determines whether the either is left-valued
            </summary>
            <typeparam name="L">The left type</typeparam>
            <typeparam name="R">The right type</typeparam>
            <param name="e">The either</param>
        </member>
        <member name="M:Z0.Either.isRight``2(Z0.Either{``0,``1})">
            <summary>
            Determines whether the either is right-valued
            </summary>
            <typeparam name="L">The left type</typeparam>
            <typeparam name="R">The right type</typeparam>
            <param name="e">The either</param>
        </member>
        <member name="T:Z0.Copair`2">
            <summary>
            Characterizes (to the extent that the language conveniently supports) a disjoint union 
            of parametric arity 2, a categorically natural dual to a pairing
            </summary>
            <typeparam name="L">The type of the potential left value</typeparam>
            <typeparam name="R">The type of the potential left value</typeparam>
        </member>
        <member name="F:Z0.Copair`2.Left">
            <summary>
            The potential left value
            </summary>
        </member>
        <member name="F:Z0.Copair`2.Right">
            <summary>
            The potential right value
            </summary>
        </member>
        <member name="T:Z0.Either`2">
            <summary>
            A value that realizes exactly one of two alternatives
            </summary>
            <typeparam name="L">The type of the left alternative</typeparam>
            <typeparam name="R">The type of the right alternative</typeparam>
        </member>
        <member name="P:Z0.Either`2.Selected">
            <summary>
            Tracks the chosen alternative
            </summary>
        </member>
        <member name="P:Z0.Either`2.Left">
            <summary>
            Specifies the left alternative
            </summary>
        </member>
        <member name="P:Z0.Either`2.Right">
            <summary>
            Specivies the right alternative
            </summary>
        </member>
        <member name="M:Z0.Either`2.#ctor(`0)">
            <summary>
            Constructs a left-valued alternative
            </summary>
            <param name="left">The alternative value</param>
        </member>
        <member name="M:Z0.Either`2.#ctor(`1)">
            <summary>
            Constructs a right-valued alternative
            </summary>
            <param name="right">The alternative value</param>
        </member>
        <member name="P:Z0.Either`2.IsLeft">
            <summary>
            Indicates whether the left alternative is specified
            </summary>
        </member>
        <member name="P:Z0.Either`2.IsRight">
            <summary>
            Indicates whether the right alternative is specified
            </summary>
        </member>
        <member name="M:Z0.Either`2.OnLeft(System.Action{`0})">
            <summary>
            Invokes an action if the alternative is left-valued
            </summary>
            <param name="action">The action to invoke</param>
        </member>
        <member name="M:Z0.Either`2.OnRight(System.Action{`1})">
            <summary>
            Invokes an action if the alternative is right values
            </summary>
            <param name="action">The action to invoke</param>
        </member>
        <member name="M:Z0.Either`2.OnEither(System.Action{`0},System.Action{`1})">
            <summary>
            Invokes exactly one of two alternative actions
            </summary>
            <param name="left">The action to invoke when the altenative is left-valued</param>
            <param name="right">The action to invoke when the altenative is right-valued</param>
        </member>
        <member name="M:Z0.Either`2.Map``1(System.Func{`0,``0},System.Func{`1,``0})">
            <summary>
            Applies exactly one of two transformations
            </summary>
            <typeparam name="Y">The type of the output value</typeparam>
            <param name="left">The transformation to invoke when the alternative is left-valued</param>
            <param name="right">The transformation to invoke when the alternative is right-valued</param>
        </member>
        <member name="M:Z0.Either`2.Select``1(System.Func{`1,``0})">
            <summary>
            Defines a right-biased Linq-monad projector
            </summary>
            <param name="f">A function that projects a right value, if extant, onto a target value</param>
            <typeparam name="Y">The target value type</typeparam>
        </member>
        <member name="M:Z0.Either`2.SelectMany``2(System.Func{`1,Z0.Either{`0,``0}},System.Func{`1,``0,``1})">
            <summary>
            Defines a right-biased Linq-modad join
            </summary>
            <param name="f">A function that lifts a right value, if extant, into monadic space</param>
            <param name="g">A function that projects a right monadic source value onto a target-parametric target monadic value</param>
            <typeparam name="Y">The join type</typeparam>
            <typeparam name="Z">The target type</typeparam>
        </member>
        <member name="M:Z0.Either`2.Equals(Z0.Either{`0,`1})">
            <summary>
            Determines structural equality
            </summary>
            <param name="src">The other either</param>
        </member>
        <member name="T:Z0.Option`1">
            <summary>
            Represents a potential value
            </summary>
            <typeparam name="T">The potential value type</typeparam>
        </member>
        <member name="F:Z0.Option`1.value">
            <summary>
            The encapsulated value, iff Exists is true
            </summary>
        </member>
        <member name="P:Z0.Option`1.Exists">
            <summary>
            Specifies whether the option has a value
            </summary>
        </member>
        <member name="P:Z0.Option`1.Value">
            <summary>
            Exposes the underlying data, if extant; otherwise, yeilds the default potential value, which may of course be null
            </summary>
        </member>
        <member name="M:Z0.Option`1.None">
            <summary>
            Defines a non-valued option
            </summary>
        </member>
        <member name="M:Z0.Option`1.Some(`0)">
            <summary>
            Defines a valued option
            </summary>
            <param name="Value">The encapsulated value</param>
        </member>
        <member name="M:Z0.Option`1.op_Equality(Z0.Option{`0},Z0.Option{`0})">
            <summary>
            Implmements value-based equality
            </summary>
            <param name="lhs">The first value</param>
            <param name="rhs">The second value</param>
        </member>
        <member name="M:Z0.Option`1.op_Inequality(Z0.Option{`0},Z0.Option{`0})">
            <summary>
            Implements value-based equality negation
            </summary>
            <param name="lhs">The first value</param>
            <param name="rhs">The second value</param>
        </member>
        <member name="M:Z0.Option`1.op_True(Z0.Option{`0})">
            <summary>
            Returns true if the option has a value and false otherwise
            </summary>
            <param name="x">The option to test</param>
        </member>
        <member name="M:Z0.Option`1.op_False(Z0.Option{`0})">
            <summary>
            Returns false if the option is non-valued and true otherwise
            </summary>
            <param name="x">The option to test</param>
        </member>
        <member name="M:Z0.Option`1.op_LogicalNot(Z0.Option{`0})">
            <summary>
            Returns false if the option is non-valued and true otherwise
            </summary>
            <param name="x">The option to test</param>
        </member>
        <member name="M:Z0.Option`1.IsSome">
            <summary>
            Returns true if the value exists
            </summary>
        </member>
        <member name="M:Z0.Option`1.IsNone">
            <summary>
            Returns true if the value does not exist
            </summary>
        </member>
        <member name="M:Z0.Option`1.IfSome``1(System.Func{`0,``0})">
            <summary>
            Applies the a function to evaluate the underlying value if it exists
            </summary>
            <param name="F">The function to apply, if possible</param>
            <typeparam name="X">The mapped value type</typeparam>
        </member>
        <member name="M:Z0.Option`1.OnSome(System.Action{`0})">
            <summary>
            Invokes an action if the value exists
            </summary>
            <param name="ifSome">The action to potentially ivoke</param>
        </member>
        <member name="M:Z0.Option`1.OnNone(System.Action)">
            <summary>
            Invokes an action if the value doesn't exist
            </summary>
            <param name="ifNone">The action to invoke</param>
        </member>
        <member name="M:Z0.Option`1.Require(System.String,System.String,System.Nullable{System.Int32})">
            <summary>
            Yields the encapulated value if present; otherwise, raises an exception
            </summary>
        </member>
        <member name="P:Z0.Option`1.ValueType">
            <summary>
            The type of the encapsulated value, if present
            </summary>
        </member>
        <member name="M:Z0.Option`1.ValueOrDefault(`0)">
            <summary>
            Extracts the encapulated value if it exists; otherwise, returns the default value for
            the underlying type which is NULL for reference types
            </summary>
            <param name="default">The value to return if the option is non-valued</param>
        </member>
        <member name="M:Z0.Option`1.ValueOrElse(System.Func{`0})">
            <summary>
            Returns the encapsulated value if it exists; otherwise, invokes the supplied fallback function 
            </summary>
            <param name="fallback">The function called to produce a value when there is no value in the source</param>
        </member>
        <member name="M:Z0.Option`1.ValueOrElse(`0)">
            <summary>
            Returns the encapsulated value if it exists; otherwise, returns the supplied value
            </summary>
            <param name="fallback">The function called to produce a value when there is no value in the source</param>
        </member>
        <member name="M:Z0.Option`1.Map``1(System.Func{`0,``0},System.Func{``0})">
            <summary>
            Applies supplied function to value if present, otherwise returns the 
            value obtained by invoking the fallback function
            </summary>
            <typeparam name="S">The output type</typeparam>
            <param name="f">The function to apply when value exists</param>
            <param name="fallback">The function to invoke when no value exists</param>
        </member>
        <member name="M:Z0.Option`1.Map``1(System.Func{`0,``0},``0)">
            <summary>
            Applies supplied function to value if present, otherwise returns the fallback value
            </summary>
            <typeparam name="S">The output type</typeparam>
            <param name="f">The function to apply when value exists</param>
            <param name="fallback">The function to invoke when no value exists</param>
        </member>
        <member name="M:Z0.Option`1.TryMap``1(System.Func{`0,``0})">
            <summary>
            Applies a function to value if present, otherwise returns None
            </summary>
            <typeparam name="S">The output type</typeparam>
            <param name="f">The function to apply when value exists</param>
        </member>
        <member name="M:Z0.Option`1.MapValueOrElse``1(System.Func{`0,``0},System.Func{``0})">
            <summary>
            Transforms the value, if present, otherwise invokes a function
            to produce an appropriate value of the target type if not
            </summary>
            <typeparam name="S">The target type</typeparam>
            <param name="ifSome">The transformer</param>
            <param name="fallback">The alternate transformer</param>
        </member>
        <member name="M:Z0.Option`1.MapValueOrDefault``1(System.Func{`0,``0},``0)">
            <summary>
            Applies a function to the encapsulated value if it exists; otherwise, returns a default value
            </summary>
            <typeparam name="S">The projected value type</typeparam>
            <param name="ifSome">The function to apply when a value exists</param>
            <param name="default">The value to return when no value exists</param>
        </member>
        <member name="M:Z0.Option`1.MapValueOrNull``1(System.Func{`0,``0})">
            <summary>
            Maps an optional source value to a nullable value type
            </summary>
            <param name="x">The optional source value</param>
            <param name="f">The transfomation function</param>
            <typeparam name="S">The type of the project value if value exists</typeparam>
        </member>
        <member name="M:Z0.Option`1.Bind``1(System.Func{`0,Z0.Option{``0}})">
            <summary>
            Implements the canonical bind operation
            </summary>
            <typeparam name="X">The source domain type</typeparam>
            <typeparam name="Y">The target domain type</typeparam>
            <param name="x">The point in the monadic space over X</param>
            <param name="f">The function to apply to effect the bind</param>
        </member>
        <member name="M:Z0.Option`1.Select``1(System.Func{`0,``0})">
            <summary>
            LINQ integration function
            </summary>
            <param name="apply">The application projector</param>
            <typeparam name="Y">The application range</typeparam>
        </member>
        <member name="M:Z0.Option`1.SelectMany``2(System.Func{`0,Z0.Option{``0}},System.Func{`0,``0,``1})">
            <summary>
            LINQ integration function
            </summary>
            <param name="eval">The evaluator</param>
            <param name="project">The lifting projector</param>
            <typeparam name="Y">The evaluator range type</typeparam>
            <typeparam name="Z">The projector range type</typeparam>
        </member>
        <member name="M:Z0.Option`1.Where(System.Func{`0,System.Boolean})">
            <summary>
            LINQ integration function
            </summary>
            <param name="predicate">The predicate to evaluate</param>
        </member>
        <member name="P:Z0.ParseResult.Source">
            <summary>
            The content that was parsed...or not
            </summary>
        </member>
        <member name="P:Z0.ParseResult.TargetType">
            <summary>
            The target value type
            </summary>
        </member>
        <member name="P:Z0.ParseResult.SourceType">
            <summary>
            The source type
            </summary>
        </member>
        <member name="P:Z0.ParseResult.Succeeded">
            <summary>
            Specifies whether the parse attempt succeed, and thus the Value field is meaningful
            </summary>
        </member>
        <member name="P:Z0.ParseResult.Value">
            <summary>
            The parsed value, if the parse operaion succeeded; otherwise best not look there
            </summary>
        </member>
        <member name="P:Z0.ParseResult.Reason">
            <summary>
            If the parse attempt failed, the reason for the failure, if available
            </summary>
        </member>
        <member name="M:Z0.ParseResult.Success``1(System.String,``0)">
            <summary>
            Defines a successful parse result
            </summary>
            <param name="source">The input text</param>
            <param name="value">The parsed value</param>
            <typeparam name="T">The parsed value type</typeparam>
        </member>
        <member name="M:Z0.ParseResult.Success``2(``0,``1)">
            <summary>
            Defines a successful parse result
            </summary>
            <param name="source">The input value</param>
            <param name="value">The parsed value</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.ParseResult.Fail``2(``0,System.Object)">
            <summary>
            Defines a parse result that signals failure
            </summary>
            <param name="source">The input value</param>
            <param name="reason">The failure reason, if available</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="P:Z0.ParseResult`2.Source">
            <summary>
            The content that was parsed...or not
            </summary>
        </member>
        <member name="P:Z0.ParseResult`2.Succeeded">
            <summary>
            Specifies whether the parse attempt succeed, and thus the Value field is meaningful
            </summary>
        </member>
        <member name="P:Z0.ParseResult`2.Value">
            <summary>
            Upon successful parse attempt, holds the parsed value; otherwise it may or may not hold something else
            </summary>
        </member>
        <member name="M:Z0.ParseResult`2.OnSuccess(System.Action{`1})">
            <summary>
            Invokes an action if the value exists
            </summary>
            <param name="ifSome">The action to potentially ivoke</param>
        </member>
        <member name="M:Z0.ParseResult`2.OnFailure(System.Action)">
            <summary>
            Invokes an action if the value doesn't exist
            </summary>
            <param name="f">The action to invoke</param>
        </member>
        <member name="M:Z0.ParseResult`2.OnFailure(System.Action{Z0.ParseResult{`0,`1}})">
            <summary>
            Invokes an action if the value doesn't exist
            </summary>
            <param name="f">The action to invoke</param>
        </member>
        <member name="M:Z0.ParseResult`2.MapValueOrSource``1(System.Func{`1,``0},System.Func{`0,``0})">
            <summary>
            Maps the parsed value upon success and the source text upon failure
            </summary>
            <param name="success">The success projector</param>
            <param name="failure">The failure projector</param>
            <typeparam name="Y">The target type</typeparam>
        </member>
        <member name="M:Z0.ParseResult`2.ValueOrDefault(`1)">
            <summary>
            Extracts the encapulated value if it exists; otherwise, returns the default value for
            the underlying type which is NULL for reference types
            </summary>
            <param name="default">The value to return if the option is non-valued</param>
        </member>
        <member name="M:Z0.ParseResult`2.ValueOrElse(System.Func{`1})">
            <summary>
            Returns the encapsulated value if it exists; otherwise, invokes the supplied fallback function 
            </summary>
            <param name="fallback">The function called to produce a value when there is no value in the source</param>
        </member>
        <member name="M:Z0.ParseResult`2.TryMap``1(System.Func{`1,``0})">
            <summary>
            Applies a function to value if present, otherwise returns None
            </summary>
            <typeparam name="S">The output type</typeparam>
            <param name="f">The function to apply when value exists</param>
        </member>
        <member name="M:Z0.ParseResult`2.Bind``1(System.Func{`1,Z0.ParseResult{`0,``0}})">
            <summary>
            Implements the canonical bind operation
            </summary>
            <typeparam name="X">The source domain type</typeparam>
            <typeparam name="Y">The target domain type</typeparam>
            <param name="x">The point in the monadic space over X</param>
            <param name="f">The function to apply to effect the bind</param>
        </member>
        <member name="M:Z0.ParseResult`2.Select``1(System.Func{`1,``0})">
            <summary>
            LINQ integration function
            </summary>
            <param name="apply">The application projector</param>
            <typeparam name="Y">The application range</typeparam>
        </member>
        <member name="M:Z0.ParseResult`2.SelectMany``2(System.Func{`1,Z0.ParseResult{`0,``0}},System.Func{`1,``0,``1})">
            <summary>
            LINQ integration function
            </summary>
            <param name="eval">The evaluator</param>
            <param name="project">The lifting projector</param>
            <typeparam name="Y">The evaluator range type</typeparam>
            <typeparam name="Z">The projector range type</typeparam>
        </member>
        <member name="P:Z0.ParseResult`1.Source">
            <summary>
            The text that was parsed...or not
            </summary>
        </member>
        <member name="P:Z0.ParseResult`1.Succeeded">
            <summary>
            Specifies whether the parse attempt succeed, and thus the Value field is meaningful
            </summary>
        </member>
        <member name="P:Z0.ParseResult`1.Value">
            <summary>
            Upon successful parse attempt, holds the parsed value; otherwise it may or may not hold something else
            </summary>
        </member>
        <member name="M:Z0.ParseResult`1.OnSuccess(System.Action{`0})">
            <summary>
            Invokes an action if the value exists
            </summary>
            <param name="ifSome">The action to potentially invoke</param>
        </member>
        <member name="M:Z0.ParseResult`1.OnFailure(System.Action)">
            <summary>
            Invokes an action if the value doesn't exist
            </summary>
            <param name="f">The action to invoke</param>
        </member>
        <member name="M:Z0.ParseResult`1.OnFailure(System.Action{Z0.ParseResult})">
            <summary>
            Invokes an action if the value doesn't exist
            </summary>
            <param name="f">The action to invoke</param>
        </member>
        <member name="M:Z0.ParseResult`1.MapValueOrSource``1(System.Func{`0,``0},System.Func{System.String,``0})">
            <summary>
            Maps the parsed value upon success and the source text upon failure
            </summary>
            <param name="success">The success projector</param>
            <param name="failure">The failure projector</param>
            <typeparam name="Y">The target type</typeparam>
        </member>
        <member name="M:Z0.ParseResult`1.ValueOrDefault(`0)">
            <summary>
            Extracts the encapsulated value if it exists; otherwise, returns the default value for
            the underlying type which is NULL for reference types
            </summary>
            <param name="default">The value to return if the option is non-valued</param>
        </member>
        <member name="M:Z0.ParseResult`1.ValueOrElse(System.Func{`0})">
            <summary>
            Returns the encapsulated value if it exists; otherwise, invokes the supplied fallback function
            </summary>
            <param name="fallback">The function called to produce a value when there is no value in the source</param>
        </member>
        <member name="M:Z0.ParseResult`1.TryMap``1(System.Func{`0,``0})">
            <summary>
            Applies a function to value if present, otherwise returns None
            </summary>
            <typeparam name="S">The output type</typeparam>
            <param name="f">The function to apply when value exists</param>
        </member>
        <member name="M:Z0.ParseResult`1.Bind``1(System.Func{`0,Z0.ParseResult{``0}})">
            <summary>
            Implements the canonical bind operation
            </summary>
            <typeparam name="X">The source domain type</typeparam>
            <typeparam name="Y">The target domain type</typeparam>
            <param name="x">The point in the monadic space over X</param>
            <param name="f">The function to apply to effect the bind</param>
        </member>
        <member name="M:Z0.ParseResult`1.Select``1(System.Func{`0,``0})">
            <summary>
            LINQ integration function
            </summary>
            <param name="apply">The application projector</param>
            <typeparam name="Y">The application range</typeparam>
        </member>
        <member name="M:Z0.ParseResult`1.SelectMany``2(System.Func{`0,Z0.ParseResult{``0}},System.Func{`0,``0,``1})">
            <summary>
            LINQ integration function
            </summary>
            <param name="eval">The evaluator</param>
            <param name="project">The lifting projector</param>
            <typeparam name="Y">The evaluator range type</typeparam>
            <typeparam name="Z">The projector range type</typeparam>
        </member>
        <member name="T:Z0.Parser`2">
            <summary>
            Defines a parser predicated on a supplied parse function
            </summary>
        </member>
        <member name="T:Z0.StringParser`1">
            <summary>
            Defines a parser predicated on a supplied parse function
            </summary>
        </member>
        <member name="M:Z0.Option.from``1(``0)">
            <summary>
            Creates an option from a reference type instance, returning a valued option if the
            refernce is not null; otherwise, returns none
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.Option.from``1(System.Nullable{``0})">
            <summary>
            Creates an option from a value type, returning a valued option if the
            refernce is not null; otherwise, returns none
            </summary>
            <param name="src">The source value</param>
            <typeparam name="T">The source type</typeparam>
        </member>
        <member name="M:Z0.Option.none``1">
            <summary>
            Defines a non-valued option
            </summary>
            <typeparam name="T">The value type, if the value existed</typeparam>
        </member>
        <member name="M:Z0.Option.some``1(``0)">
            <summary>
            Defines a valued option
            </summary>
            <param name="value">The value</param>
            <typeparam name="T">The type of the extant value</typeparam>
        </member>
        <member name="M:Z0.Option.eval``1(``0)">
            <summary>
            Classifies the value as some or none and manufactures the appropriate option encapsulation
            </summary>
            <typeparam name="T">The type of value</typeparam>
            <param name="value">The value to lift into option-space</param>
        </member>
        <member name="M:Z0.Option.eval``1(System.Nullable{``0})">
            <summary>
            Classifies the value as some or none and manufactures the appropriate option encapsulation
            </summary>
            <typeparam name="T">The type of value</typeparam>
            <param name="value">The value to lift into option-space</param>
        </member>
        <member name="M:Z0.Option.Try``1(System.Func{``0},System.Action{System.Exception})">
            <summary>
            Evaluates a function within a try block and returns the value of the computation if
            successful; otherwise, returns None and invokes an error handler if supplied
            </summary>
            <typeparam name="T">The result type</typeparam>
            <param name="f">The function to evaluate</param>
        </member>
        <member name="M:Z0.Option.Try``1(System.Func{Z0.Option{``0}},System.Action{System.Exception})">
            <summary>
            Evaluates a function within a try block and returns the value of the computation if
            successful; otherwise, returns None together with the reported exception
            </summary>
            <param name="f">The function to evaluate</param>
            <typeparam name="T">The function result type, if successful</typeparam>
        </member>
        <member name="M:Z0.Option.Try(System.Action,System.Action{System.Exception})">
            <summary>
            Invokes an action within a try block and, upon error, calls
            the handler if specified. If no handler is specified, the exception
            message is emitted to stderr
            </summary>
            <param name="f">The action to invoke</param>
            <param name="onerror">The error handler to call, if specified</param>
        </member>
        <member name="M:Z0.Option.Try``2(``0,System.Func{``0,``1},System.Action{``0,System.Exception})">
            <summary>
            Evaluates a function within a try block and returns the value of the computation if
            successful; otherwise, returns None together with the reported exception
            </summary>
            <typeparam name="X">The input type</typeparam>
            <typeparam name="Y">The output type</typeparam>
            <param name="x">The input value</param>
            <param name="f">The function to evaluate</param>
        </member>
        <member name="M:Z0.Option.TryCast``1(System.Object)">
            <summary>
            Casts a value if possible, otherwise returns none
            </summary>
            <typeparam name="T">The target type</typeparam>
            <param name="item">The object to cast</param>
        </member>
        <member name="M:Z0.Option.ifNotNull``2(``0,System.Func{``0,``1},``1)">
            <summary>
            Evaluates a function over a value if the value is not null; otherwise, returns the default result value
            </summary>
            <typeparam name="X">The operand type</typeparam>
            <typeparam name="Y">The return type</typeparam>
            <param name="x">The operand</param>
            <param name="f1">The function to potentially evaluate</param>
        </member>
        <member name="T:Z0.BinaryLiteralAttribute">
            <summary>
            Attaches a binary literal value to a target
            </summary>
        </member>
        <member name="T:Z0.CmdHostAttribute">
            <summary>
            Identifies a command host
            </summary>
        </member>
        <member name="T:Z0.ConstAttribute">
            <summary>
            Identifies a referentially-transparent method that produces literal values, structural values or sequences of such values
            </summary>
        </member>
        <member name="T:Z0.ConversionProviderAttribute">
            <summary>
            Applied to a type to identify an applicable conversion provider
            </summary>
        </member>
        <member name="T:Z0.FactoryAttribute">
            <summary>
            Identifies a factory method which, by definition, is an emitter or a unary function
            </summary>
        </member>
        <member name="T:Z0.HexLiteralAttribute">
            <summary>
            Attaches a hex literal to a target
            </summary>
        </member>
        <member name="T:Z0.IndicatorAttribute">
            <summary>
            Attaches a binary literal value to a target or identifies a literal field
            </summary>
        </member>
        <member name="T:Z0.LabelAttribute">
            <summary>
            Labels anything since the system-defined DisplayNameAttribute has ridiculously stupid target restrictions
            </summary>
        </member>
        <member name="M:Z0.LabelAttribute.TargetLabel(System.Reflection.MemberInfo)">
            <summary>
            Returns the a target label, if attributed; otherwise, returns the target's system-defined name
            </summary>
            <typeparam name="T">The label target</typeparam>
        </member>
        <member name="M:Z0.LabelAttribute.TargetLabel``1">
            <summary>
            Returns the label of a parametric type, if attributed; otherwise, returns the type's name
            </summary>
            <typeparam name="T">The label target</typeparam>
        </member>
        <member name="T:Z0.LiteralAttribute">
            <summary>
            Describes an attributed literal
            </summary>
        </member>
        <member name="T:Z0.LiteralCoverAttribute">
            <summary>
            Identifies a specialized literal cover
            </summary>
        </member>
        <member name="T:Z0.LiteralProviderAttribute">
            <summary>
            Applied to a structural artifact or member field, method or property to indicate that the target provides some sort of literal data
            </summary>
        </member>
        <member name="T:Z0.LiteralResourceAttribute">
            <summary>
            Advertises that a type defines literal resources with with content that
            could potentially be modified by a build step
            </summary>
        </member>
        <member name="T:Z0.MeaningAttribute">
            <summary>
            Describes anything, or at least something
            </summary>
        </member>
        <member name="M:Z0.MeaningAttribute.ContentValue(System.Reflection.MemberInfo)">
            <summary>
            Returns the a target description, if attributed; otherwise, returns the target's system-defined name
            </summary>
            <typeparam name="T">The label target</typeparam>
        </member>
        <member name="M:Z0.MeaningAttribute.ContentValue(System.Reflection.ParameterInfo)">
            <summary>
            Returns the a target description, if attributed; otherwise, returns the target's system-defined name
            </summary>
            <typeparam name="T">The label target</typeparam>
        </member>
        <member name="T:Z0.MultiLiteralAttribute">
            <summary>
            Attaches a muliliteral to a target
            </summary>
        </member>
        <member name="T:Z0.NameAttribute">
            <summary>
            Describes anything, or at least something
            </summary>
        </member>
        <member name="M:Z0.NameAttribute.TargetName(System.Reflection.MemberInfo)">
            <summary>
            Returns the a target description, if attributed; otherwise, returns the target's system-defined name
            </summary>
            <typeparam name="T">The label target</typeparam>
        </member>
        <member name="M:Z0.NameAttribute.TargetName``1">
            <summary>
            Returns the description of a parametric type, if attributed; otherwise, returns the type's name
            </summary>
            <typeparam name="T">The label target</typeparam>
        </member>
        <member name="T:Z0.SizeAttribute">
            <summary>
            Defines the size, in bytes, of the target element
            </summary>
        </member>
        <member name="P:Z0.SizeAttribute.Size">
            <summary>
            The number of bytes occupied by an instance of the targeted element
            </summary>
        </member>
        <member name="T:Z0.StatelessAttribute">
            <summary>
            Identifies a stateless service
            </summary>
        </member>
        <member name="T:Z0.StringLiteralAttribute">
            <summary>
            Attaches a binary literal value to a target or identifies a literal field
            </summary>
        </member>
        <member name="T:Z0.TableAttribute">
            <summary>
            Identifies a structural type that be serialized as a record, of some sort
            </summary>
        </member>
        <member name="T:Z0.IContext">
            <summary>
            Characterizes a shared execution environment that may be stateful or stateless
            </summary>
        </member>
        <member name="T:Z0.IContextual`1">
            <summary>
            Characterizes a component that maintains readonly-access to encapsulated state, here and throughout referred to as a context
            </summary>
        </member>
        <member name="M:Z0.Part.id(System.Reflection.Assembly)">
            <summary>
            Retrieves the part identifier, if any, of a specified assembly
            </summary>
            <param name="src">The source assembly</param>
        </member>
        <member name="P:Z0.Part.ExecutingPart">
            <summary>
            Retrieves the part identifier, if any, of the entry assembly
            </summary>
        </member>
        <member name="M:Z0.Part.map``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,``1})">
            <summary>
            Applies a function to an input sequence to yield a transformed output sequence
            </summary>
            <param name="src">The source sequence</param>
            <param name="f">The projector</param>
            <typeparam name="S">The source type</typeparam>
            <typeparam name="T">The target type</typeparam>
        </member>
        <member name="M:Z0.Part.where``1(System.ReadOnlySpan{``0},System.Func{``0,System.Boolean})">
            <summary>
            Allocates and populates a new array by filtering the source array with a specified predicate
            </summary>
            <param name="src">The source array</param>
            <param name="f">The predicate</param>
            <typeparam name="T">The array element type</typeparam>
        </member>
        <member name="F:Z0.Part.WidthOffset">
            <summary>
            The number of bits to shift a field specifier left/right to reveal/specify the width of an identified field
            </summary>
        </member>
        <member name="F:Z0.Part.NumericWidths">
            <summary>
            Specifies the widths of system-supported primal numeric data types
            </summary>
        </member>
        <member name="F:Z0.Part.UnsignedInts">
            <summary>
            Specifies unsigned integral types of widths <see cref='F:Z0.Part.NumericWidths'/>
            </summary>
        </member>
        <member name="F:Z0.Part.SignedInts">
            <summary>
            Specifies signed integral types of widths <see cref='F:Z0.Part.NumericWidths'/>
            </summary>
        </member>
        <member name="F:Z0.Part.Integers">
            <summary>
            Specifies signed and unsigned integral types of widths <see cref='F:Z0.Part.NumericWidths'/>
            </summary>
        </member>
        <member name="T:Z0.ReflectionFlags">
            <summary>
            Defines useful collection of reflection binding flags
            </summary>
        </member>
        <member name="F:Z0.ReflectionFlags.BF_Public">
            <summary>
             All declared non-public members
            </summary>
        </member>
        <member name="F:Z0.ReflectionFlags.BF_NonPublic">
            <summary>
             All declared non-public members
            </summary>
        </member>
        <member name="F:Z0.ReflectionFlags.BF_Static">
            <summary>
            All declared static members
            </summary>
        </member>
        <member name="F:Z0.ReflectionFlags.BF_Instance">
            <summary>
             All instance members
            </summary>
        </member>
        <member name="F:Z0.ReflectionFlags.BF_DeclaredInstance">
            <summary>
            All declared instance members
            </summary>
        </member>
        <member name="F:Z0.ReflectionFlags.BF_PublicStatic">
            <summary>
             All public static members, declared or inherited
            </summary>
        </member>
        <member name="F:Z0.ReflectionFlags.BF_PublicInstance">
            <summary>
             All public instance members, declared or inherited
            </summary>
        </member>
        <member name="F:Z0.ReflectionFlags.BF_NonPublicStatic">
            <summary>
             All declared non-public static members
            </summary>
        </member>
        <member name="F:Z0.ReflectionFlags.BF_NonPublicInstance">
            <summary>
             All declared non-public instance members
            </summary>
        </member>
        <member name="F:Z0.ReflectionFlags.BF_World">
            <summary>
            All of the knowable things
            </summary>
        </member>
        <member name="F:Z0.ReflectionFlags.BF_All">
            <summary>
             All members, declared or inherited
            </summary>
        </member>
        <member name="T:Z0.IExecutable">
            <summary>
            Characterizes a thread of execution control that has whatever context it needs, if any, to do something of use
            </summary>
        </member>
        <member name="P:Z0.IPartId.Id">
            <summary>
            The part identifier
            </summary>
        </member>
        <member name="P:Z0.IPart.Owner">
            <summary>
            The resolved assembly
            </summary>
        </member>
        <member name="P:Z0.IPart.Name">
            <summary>
            The part name, equivalent to the simple assembly name
            </summary>
        </member>
        <member name="P:Z0.IPart.Z0#IPartId#Id">
            <summary>
            The part identifier, known from the assembly
            </summary>
        </member>
        <member name="P:Z0.IPart`1.Z0#IPart#Owner">
            <summary>
            The assembly, known from the reifying type
            </summary>
        </member>
        <member name="P:Z0.Part`1.Resolved">
            <summary>
            The resolved part
            </summary>
        </member>
        <member name="F:Z0.ArrowSymbols.RightArrow">
            <summary>
            The '→' character
            </summary>
        </member>
        <member name="F:Z0.ArrowSymbols.LeftArrow">
            <summary>
            The '←' character
            </summary>
        </member>
        <member name="F:Z0.ArrowSymbols.LongRightArrow">
            <summary>
            The '⟶' character
            </summary>
        </member>
        <member name="F:Z0.ArrowSymbols.MapsTo">
            <summary>
            The '↦' character
            </summary>
        </member>
        <member name="T:Z0.AsciChar">
            <summary>
            All of the asci characters belong to us
            </summary>
        </member>
        <member name="F:Z0.AsciChar.Null">
            <summary>
            Asci null
            </summary>
        </member>
        <member name="F:Z0.AsciChar.a">
            <summary>
            The 'a' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.b">
            <summary>
            The 'b' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.c">
            <summary>
            The 'c' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.d">
            <summary>
            The 'd' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.e">
            <summary>
            The 'e' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.f">
            <summary>
            The 'f' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.g">
            <summary>
            The 'g' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.h">
            <summary>
            The 'h' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.i">
            <summary>
            The 'i' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.j">
            <summary>
            The 'j' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.k">
            <summary>
            The 'k' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.l">
            <summary>
            The 'l' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.m">
            <summary>
            The 'm' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.n">
            <summary>
            The 'n' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.o">
            <summary>
            The 'o' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.p">
            <summary>
            The 'p' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.q">
            <summary>
            The 'q' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.r">
            <summary>
            The 'r' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.s">
            <summary>
            The 's' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.t">
            <summary>
            The 't' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.u">
            <summary>
            The 'u' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.v">
            <summary>
            The 'v' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.w">
            <summary>
            The 'w' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.x">
            <summary>
            The 'x' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.y">
            <summary>
            The 'y' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.z">
            <summary>
            The 'z' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.A">
            <summary>
            The 'A' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.B">
            <summary>
            The 'B' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.C">
            <summary>
            The 'C' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.D">
            <summary>
            The 'D' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.E">
            <summary>
            The 'E' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.F">
            <summary>
            The 'F' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.G">
            <summary>
            The 'G' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.H">
            <summary>
            The 'H' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.I">
            <summary>
            The 'I' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.J">
            <summary>
            The 'J' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.K">
            <summary>
            The 'K' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.L">
            <summary>
            The 'L' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.M">
            <summary>
            The 'M' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.N">
            <summary>
            The 'N' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.O">
            <summary>
            The 'O' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.P">
            <summary>
            The 'P' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.Q">
            <summary>
            The 'Q' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.R">
            <summary>
            The 'R' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.S">
            <summary>
            The 'S' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.T">
            <summary>
            The 'T' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.U">
            <summary>
            The 'U' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.V">
            <summary>
            The 'V' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.W">
            <summary>
            The 'W' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.X">
            <summary>
            The 'X' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.Y">
            <summary>
            The 'Y' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.Z">
            <summary>
            The 'Z' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciChar.d0">
            <summary>
            Specifies 0 base 10, asci code 48
            </summary>
        </member>
        <member name="F:Z0.AsciChar.d1">
            <summary>
            Specifies 1 base 10, asci code 49
            </summary>
        </member>
        <member name="F:Z0.AsciChar.d2">
            <summary>
            Specifies 2 base 10, asci code 50
            </summary>
        </member>
        <member name="F:Z0.AsciChar.d3">
            <summary>
            Specifies 3 base 10, asci code 51
            </summary>
        </member>
        <member name="F:Z0.AsciChar.d4">
            <summary>
            Specifies 4 base 10, asci code 52
            </summary>
        </member>
        <member name="F:Z0.AsciChar.d5">
            <summary>
            Specifies 5 base 10, asci code 53
            </summary>
        </member>
        <member name="F:Z0.AsciChar.d6">
            <summary>
            Specifies 6 base 10, asci code 54
            </summary>
        </member>
        <member name="F:Z0.AsciChar.d7">
            <summary>
            Specifies 7 base 10, asci code 55
            </summary>
        </member>
        <member name="F:Z0.AsciChar.d8">
            <summary>
            Specifies 8 base 10, asci code 56
            </summary>
        </member>
        <member name="F:Z0.AsciChar.d9">
            <summary>
            Specifies 9 base 10, asci code 57
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Z0.AsciChar.Amp" -->
        <member name="F:Z0.AsciChar.At">
            <summary>
            The '@' character
            </summary>
        </member>
        <member name="F:Z0.AsciChar.Bang">
            <summary>
            The '!' character
            </summary>
        </member>
        <member name="F:Z0.AsciChar.BS">
            <summary>
            The backslash character
            </summary>
        </member>
        <member name="F:Z0.AsciChar.Caret">
            <summary>
            The '^' character
            </summary>
        </member>
        <member name="F:Z0.AsciChar.Colon">
            <summary>
            The ':' character
            </summary>
        </member>
        <member name="F:Z0.AsciChar.Comma">
            <summary>
            The ',' character
            </summary>
        </member>
        <member name="F:Z0.AsciChar.Dash">
            <summary>
            The '-' character
            </summary>
        </member>
        <member name="F:Z0.AsciChar.Dollar">
            <summary>
            The '$' character
            </summary>
        </member>
        <member name="F:Z0.AsciChar.Dot">
            <summary>
            The '.' character
            </summary>
        </member>
        <member name="F:Z0.AsciChar.Eq">
            <summary>
            The '=' character
            </summary>
        </member>
        <member name="F:Z0.AsciChar.FS">
            <summary>
            The '/' character
            </summary>
        </member>
        <member name="F:Z0.AsciChar.GT">
            <summary>
            The '>' character
            </summary>
        </member>
        <member name="F:Z0.AsciChar.Hash">
            <summary>
            The '#' character
            </summary>
        </member>
        <member name="F:Z0.AsciChar.LBrace">
            <summary>
            The '{' character
            </summary>
        </member>
        <member name="F:Z0.AsciChar.LB">
            <summary>
            The '[' character
            </summary>
        </member>
        <member name="F:Z0.AsciChar.LParen">
            <summary>
            The '(' character
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Z0.AsciChar.LT" -->
        <member name="F:Z0.AsciChar.Percent">
            <summary>
            The '%' character
            </summary>
        </member>
        <member name="F:Z0.AsciChar.Pipe">
            <summary>
            The '|' character
            </summary>
        </member>
        <member name="F:Z0.AsciChar.Plus">
            <summary>
            The '+' character
            </summary>
        </member>
        <member name="F:Z0.AsciChar.Question">
            <summary>
            The '?' character
            </summary>
        </member>
        <member name="F:Z0.AsciChar.DQuote">
            <summary>
            The '"' character
            </summary>
        </member>
        <member name="F:Z0.AsciChar.RParen">
            <summary>
            The ')' character
            </summary>
        </member>
        <member name="F:Z0.AsciChar.RBrace">
            <summary>
            The '}' character
            </summary>
        </member>
        <member name="F:Z0.AsciChar.RBracket">
            <summary>
            The ']' character
            </summary>
        </member>
        <member name="F:Z0.AsciChar.Semicolon">
            <summary>
            The ',' character
            </summary>
        </member>
        <member name="F:Z0.AsciChar.Space">
            <summary>
            The ' ' character
            </summary>
        </member>
        <member name="F:Z0.AsciChar.SQuote">
            <summary>
            The ''' character
            </summary>
        </member>
        <member name="F:Z0.AsciChar.Mul">
            <summary>
            The '*' character
            </summary>
        </member>
        <member name="F:Z0.AsciChar.Tilde">
            <summary>
            The '~' character
            </summary>
        </member>
        <member name="F:Z0.AsciChar.US">
            <summary>
            The '_' character
            </summary>
        </member>
        <member name="F:Z0.AsciChar.Tab">
            <summary>
            The tab character
            </summary>
        </member>
        <member name="F:Z0.AsciChar.NL">
            <summary>
            The line-feed character
            </summary>
        </member>
        <member name="F:Z0.AsciChar.CR">
            <summary>
            The carriage-return character
            </summary>
        </member>
        <member name="F:Z0.AsciChar.Del">
            <summary>
            The delete control symbol
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.Null">
            <summary>
            The asci code for null
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.Tab">
            <summary>
            The tab character code 9
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.NL">
            <summary>
            The new-line character code 10
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.CR">
            <summary>
            The line-feed character code 13
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.Space">
            <summary>
            The ' ' character code 32
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.Bang">
            <summary>
            The '!' character code 33
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.Quote">
            <summary>
            The '"' character code 34
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.Hash">
            <summary>
            The '#' character code 35
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.Dollar">
            <summary>
            The '$' character code 36
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.Percent">
            <summary>
            The '%' character code 37
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Z0.AsciCharCode.Amp" -->
        <member name="F:Z0.AsciCharCode.SQuote">
            <summary>
            The ''' character code 39
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.LParen">
            <summary>
            The '(' character code 40
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.RParen">
            <summary>
            The ')' character code 41
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.RBrace">
            <summary>
            The '}' character code 41
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.Star">
            <summary>
            The '*' character code 42
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.Plus">
            <summary>
            The '+' character code 43
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.Comma">
            <summary>
            The ,' character code 44
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.Dash">
            <summary>
            The '-' character code 45
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.Dot">
            <summary>
            The '.' character code 46
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.FSlash">
            <summary>
            The '/' character code 47
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.d0">
            <summary>
            Specifies the asci code for the digit '0'
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.d1">
            <summary>
            Specifies the asci code for the digit '1'
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.d2">
            <summary>
            Specifies the asci code for the digit '2'
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.d3">
            <summary>
            Specifies the asci code for the digit '3'
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.d4">
            <summary>
            Specifies the asci code for the digit '4'
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.d5">
            <summary>
            Specifies the asci code for the digit '5'
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.d6">
            <summary>
            Specifies the asci code for the digit '6'
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.d7">
            <summary>
            Specifies the asci code for the digit '7'
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.d8">
            <summary>
            Specifies the asci code for the digit '8'
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.d9">
            <summary>
            Specifies the asci code for the digit '9'
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.a">
            <summary>
            The 'a' symbol code 97
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.b">
            <summary>
            The 'b' symbol code 98
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.c">
            <summary>
            The 'c' symbol code 99
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.d">
            <summary>
            The 'd' symbol code 100
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.e">
            <summary>
            The 'e' symbol code 101
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.f">
            <summary>
            The 'f' symbol code 102
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.g">
            <summary>
            The 'g' symbol code 103
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.h">
            <summary>
            The 'h' symbol code 104
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.i">
            <summary>
            The 'i' symbol code 105
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.j">
            <summary>
            The 'j' symbol code 106
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.k">
            <summary>
            The 'k' symbol code 107
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.l">
            <summary>
            The 'l' symbol code 108
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.m">
            <summary>
            The 'm' symbol code 109
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.n">
            <summary>
            The 'n' symbol code 110
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.o">
            <summary>
            The 'o' symbol code 111
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.p">
            <summary>
            The 'p' symbol code 112
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.q">
            <summary>
            The 'q' symbol code 113
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.r">
            <summary>
            The 'r' symbol code 114
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.s">
            <summary>
            The 's' symbol code 115
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.t">
            <summary>
            The 't' symbol code 116
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.u">
            <summary>
            The 'u' symbol code 117
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.v">
            <summary>
            The 'v' symbol code 118
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.w">
            <summary>
            The 'w' symbol code 119
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.x">
            <summary>
            The 'x' symbol code 120
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.y">
            <summary>
            The 'y' symbol code 121
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.z">
            <summary>
            The 'z' symbol code 122
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.A">
            <summary>
            The 'A' symbol code 65
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.B">
            <summary>
            The 'B' symbol code 66
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.C">
            <summary>
            The 'C' symbol code 67
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.D">
            <summary>
            The 'D' symbol code 68
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.E">
            <summary>
            The 'E' symbol code 69
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.F">
            <summary>
            The 'F' symbol code 70
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.G">
            <summary>
            The 'G' symbol code 71
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.H">
            <summary>
            The 'H' symbol code 72
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.I">
            <summary>
            The 'I' symbol code 73
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.J">
            <summary>
            The 'J' symbol code 74
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.K">
            <summary>
            The 'K' symbol code 75
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.L">
            <summary>
            The 'L' symbol code 76
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.M">
            <summary>
            The 'M' symbol code 77
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.N">
            <summary>
            The 'N' symbol code 78
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.O">
            <summary>
            The 'O' symbol code 79
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.P">
            <summary>
            The 'P' symbol code 80
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.Q">
            <summary>
            The 'Q' symbol code 81
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.R">
            <summary>
            The 'R' symbol code 82
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.S">
            <summary>
            The 'S' symbol code 83
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.T">
            <summary>
            The 'T' symbol code 84
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.U">
            <summary>
            The 'U' symbol code 85
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.V">
            <summary>
            The 'V' symbol code 86
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.W">
            <summary>
            The 'W' symbol code 87
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.X">
            <summary>
            The 'X' symbol code 88
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.Y">
            <summary>
            The 'Y' symbol code 89
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.Z">
            <summary>
            The 'Z' symbol code 90
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.Colon">
            <summary>
            The ':' character code 58
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.Semicolon">
            <summary>
            The ,' character code 59
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.At">
            <summary>
            The '@' character code 64
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.BSlash">
            <summary>
            The backslash character code 92
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.Caret">
            <summary>
            The '^' character code 94
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.Eq">
            <summary>
            The '=' character code 61
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.Gt">
            <summary>
            The '>' character code 62
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.LBrace">
            <summary>
            The '{' character code 128
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.LBracket">
            <summary>
            The '[' character code 91
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Z0.AsciCharCode.Lt" -->
        <member name="F:Z0.AsciCharCode.Pipe">
            <summary>
            The '|' character code 124
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.Question">
            <summary>
            The '?' character code 63
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.RBracket">
            <summary>
            The ']' character code 93
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.SYM">
            <summary>
            The '~' character code 126
            </summary>
        </member>
        <member name="F:Z0.AsciCharCode.Underscore">
            <summary>
            The '~' character code 95
            </summary>
        </member>
        <member name="T:Z0.AsciCharText">
            <summary>
            Defines asci string literals
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.a">
            <summary>
            The 'a' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.b">
            <summary>
            The 'b' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.c">
            <summary>
            The 'c' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.d">
            <summary>
            The 'd' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.e">
            <summary>
            The 'e' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.f">
            <summary>
            The 'f' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.g">
            <summary>
            The 'g' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.h">
            <summary>
            The 'h' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.i">
            <summary>
            The 'i' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.j">
            <summary>
            The 'j' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.k">
            <summary>
            The 'k' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.l">
            <summary>
            The 'l' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.m">
            <summary>
            The 'm' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.n">
            <summary>
            The 'n' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.o">
            <summary>
            The 'o' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.p">
            <summary>
            The 'p' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.q">
            <summary>
            The 'q' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.r">
            <summary>
            The 'r' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.s">
            <summary>
            The 's' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.t">
            <summary>
            The 't' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.u">
            <summary>
            The 'u' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.v">
            <summary>
            The 'y' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.w">
            <summary>
            The 'w' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.x">
            <summary>
            The 'x' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.y">
            <summary>
            The 'y' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.z">
            <summary>
            The 'z' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.A">
            <summary>
            The 'A' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.B">
            <summary>
            The 'B' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.C">
            <summary>
            The 'D' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.D">
            <summary>
            The 'D' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.E">
            <summary>
            The 'E' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.F">
            <summary>
            The 'G' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.G">
            <summary>
            The 'G' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.H">
            <summary>
            The 'H' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.I">
            <summary>
            The 'I' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.J">
            <summary>
            The 'J' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.K">
            <summary>
            The 'K' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.L">
            <summary>
            The 'L' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.M">
            <summary>
            The 'M' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.N">
            <summary>
            The 'N' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.O">
            <summary>
            The 'O' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.P">
            <summary>
            The 'P' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.Q">
            <summary>
            The 'Q' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.R">
            <summary>
            The 'R' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.S">
            <summary>
            The 'S' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.T">
            <summary>
            The 'T' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.U">
            <summary>
            The 'U' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.V">
            <summary>
            The 'V' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.W">
            <summary>
            The 'W' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.X">
            <summary>
            The 'X' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.Y">
            <summary>
            The 'Y' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciCharText.Z">
            <summary>
            The 'Z' character represented as text
            </summary>
        </member>
        <member name="T:Z0.AsciControl">
            <summary>
            Defines asci control symbols
            </summary>
        </member>
        <member name="F:Z0.AsciControl.Null">
            <summary>
            The '\0' control symbol
            </summary>
        </member>
        <member name="F:Z0.AsciControl.SOH">
            <summary>
            Start of heading
            </summary>
        </member>
        <member name="F:Z0.AsciControl.SOT">
            <summary>
            Start of text
            </summary>
        </member>
        <member name="F:Z0.AsciControl.EOT">
            <summary>
            End of text
            </summary>
        </member>
        <member name="F:Z0.AsciControl.EOTR">
            <summary>
            End of transmission
            </summary>
        </member>
        <member name="F:Z0.AsciControl.ENQ">
            <summary>
            Enquiry
            </summary>
        </member>
        <member name="F:Z0.AsciControl.ACK">
            <summary>
            Acknowledgement
            </summary>
        </member>
        <member name="F:Z0.AsciControl.Bell">
            <summary>
            Hell's bells, asci code 7
            </summary>
        </member>
        <member name="F:Z0.AsciControl.BS">
            <summary>
            The backspace control symbol '\b', asci code 8
            </summary>
        </member>
        <member name="F:Z0.AsciControl.Tab">
            <summary>
            A horizontal tab
            </summary>
        </member>
        <member name="F:Z0.AsciControl.NL">
            <summary>
            The new-line control symbol \n', asci code 10
            </summary>
        </member>
        <member name="F:Z0.AsciControl.FF">
            <summary>
            The form-feed control symbol '\f', asci code 12
            </summary>
        </member>
        <member name="F:Z0.AsciControl.CR">
            <summary>
            The carriage return control symbol '\r', asci code 13
            </summary>
        </member>
        <member name="F:Z0.AsciControl.Del">
            <summary>
            The delete control symbol
            </summary>
        </member>
        <member name="T:Z0.AsciControlCode">
            <summary>
            Defines asci control codes
            </summary>
        </member>
        <member name="F:Z0.AsciControlCode.BS">
            <summary>
            The backspace control symbol code
            </summary>
        </member>
        <member name="F:Z0.AsciControlCode.Tab">
            <summary>
            The tab control symbol, asci code 9
            </summary>
        </member>
        <member name="F:Z0.AsciControlCode.NL">
            <summary>
            The line-feed/new-line control symbol, asci code 10
            </summary>
        </member>
        <member name="F:Z0.AsciControlCode.FF">
            <summary>
            The form-feed control symbol, asci code 12
            </summary>
        </member>
        <member name="F:Z0.AsciControlCode.CR">
            <summary>
            The carriage return control symbol, asci code 13
            </summary>
        </member>
        <member name="F:Z0.AsciDigit.d0">
            <summary>
            Specifies '0', asci code 48
            </summary>
        </member>
        <member name="F:Z0.AsciDigit.d1">
            <summary>
            Specifies '1', asci code 49
            </summary>
        </member>
        <member name="F:Z0.AsciDigit.d2">
            <summary>
            Specifies '2', asci code 50
            </summary>
        </member>
        <member name="F:Z0.AsciDigit.d3">
            <summary>
            Specifies '3',  asci code 51
            </summary>
        </member>
        <member name="F:Z0.AsciDigit.d4">
            <summary>
            Specifies '4', asci code 52
            </summary>
        </member>
        <member name="F:Z0.AsciDigit.d5">
            <summary>
            Specifies '5'  asci code 53
            </summary>
        </member>
        <member name="F:Z0.AsciDigit.d6">
            <summary>
            Specifies '6'  asci code 54
            </summary>
        </member>
        <member name="F:Z0.AsciDigit.d7">
            <summary>
            Specifies '7'  asci code 55
            </summary>
        </member>
        <member name="F:Z0.AsciDigit.d8">
            <summary>
            Specifies '8', asci code 56
            </summary>
        </member>
        <member name="F:Z0.AsciDigit.d9">
            <summary>
            Specifies 9, asci code 57
            </summary>
        </member>
        <member name="T:Z0.AsciDigitCode">
            <summary>
            Defines the symbols that represent the base-10 digits
            </summary>
        </member>
        <member name="F:Z0.AsciDigitCode.d0">
            <summary>
            Specifies the asci code for the digit '0'
            </summary>
        </member>
        <member name="F:Z0.AsciDigitCode.d1">
            <summary>
            Specifies the asci code for the digit '1'
            </summary>
        </member>
        <member name="F:Z0.AsciDigitCode.d2">
            <summary>
            Specifies the asci code for the digit '2'
            </summary>
        </member>
        <member name="F:Z0.AsciDigitCode.d3">
            <summary>
            Specifies the asci code for the digit '3'
            </summary>
        </member>
        <member name="F:Z0.AsciDigitCode.d4">
            <summary>
            Specifies the asci code for the digit '4'
            </summary>
        </member>
        <member name="F:Z0.AsciDigitCode.d5">
            <summary>
            Specifies the asci code for the digit '5'
            </summary>
        </member>
        <member name="F:Z0.AsciDigitCode.d6">
            <summary>
            Specifies the asci code for the digit '6'
            </summary>
        </member>
        <member name="F:Z0.AsciDigitCode.d7">
            <summary>
            Specifies the asci code for the digit '7'
            </summary>
        </member>
        <member name="F:Z0.AsciDigitCode.d8">
            <summary>
            Specifies the asci code for the digit '8'
            </summary>
        </member>
        <member name="F:Z0.AsciDigitCode.d9">
            <summary>
            Specifies the asci code for the digit '9'
            </summary>
        </member>
        <member name="F:Z0.AsciDigitCode.First">
            <summary>
            The first declared code
            </summary>
        </member>
        <member name="F:Z0.AsciDigitCode.Last">
            <summary>
            The last declared code
            </summary>
        </member>
        <member name="F:Z0.AsciDigitCode.Count">
            <summary>
            The code declaration count
            </summary>
        </member>
        <member name="T:Z0.AsciDigitText">
            <summary>
            Defines asci string literals
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.A">
            <summary>
            The 'A' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.B">
            <summary>
            The 'B' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.C">
            <summary>
            The 'C' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.D">
            <summary>
            The 'D' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.E">
            <summary>
            The 'E' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.F">
            <summary>
            The 'F' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.G">
            <summary>
            The 'G' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.H">
            <summary>
            The 'H' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.I">
            <summary>
            The 'I' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.J">
            <summary>
            The 'J' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.K">
            <summary>
            The 'K' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.L">
            <summary>
            The 'L' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.M">
            <summary>
            The 'M' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.N">
            <summary>
            The 'N' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.O">
            <summary>
            The 'O' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.P">
            <summary>
            The 'P' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.Q">
            <summary>
            The 'Q' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.R">
            <summary>
            The 'R' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.S">
            <summary>
            The 'S' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.T">
            <summary>
            The 'T' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.U">
            <summary>
            The 'U' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.V">
            <summary>
            The 'V' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.W">
            <summary>
            The 'W' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.X">
            <summary>
            The 'X' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.Y">
            <summary>
            The 'Y' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.Z">
            <summary>
            The 'Z' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.a">
            <summary>
            The 'a' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.b">
            <summary>
            The 'b' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.c">
            <summary>
            The 'c' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.d">
            <summary>
            The 'd' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.e">
            <summary>
            The 'e' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.f">
            <summary>
            The 'f' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.g">
            <summary>
            The 'g' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.h">
            <summary>
            The 'h' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.i">
            <summary>
            The 'i' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.j">
            <summary>
            The 'j' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.k">
            <summary>
            The 'k' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.l">
            <summary>
            The 'l' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.m">
            <summary>
            The 'm' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.n">
            <summary>
            The 'n' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.o">
            <summary>
            The 'o' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.p">
            <summary>
            The 'p' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.q">
            <summary>
            The 'q' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.r">
            <summary>
            The 'r' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.s">
            <summary>
            The 's' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.t">
            <summary>
            The 't' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.u">
            <summary>
            The 'u' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.v">
            <summary>
            The 'v' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.w">
            <summary>
            The 'w' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.x">
            <summary>
            The 'x' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.y">
            <summary>
            The 'y' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetter.z">
            <summary>
            The 'z' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.A">
            <summary>
            The 'A' symbol code 65
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.B">
            <summary>
            The 'B' symbol code 66
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.C">
            <summary>
            The 'C' symbol code 67
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.D">
            <summary>
            The 'D' symbol code 68
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.E">
            <summary>
            The 'E' symbol code 69
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.F">
            <summary>
            The 'F' symbol code 70
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.G">
            <summary>
            The 'G' symbol code 71
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.H">
            <summary>
            The 'H' symbol code 72
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.I">
            <summary>
            The 'I' symbol code 73
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.J">
            <summary>
            The 'J' symbol code 74
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.K">
            <summary>
            The 'K' symbol code 75
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.L">
            <summary>
            The 'L' symbol code 76
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.M">
            <summary>
            The 'M' symbol code 77
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.N">
            <summary>
            The 'N' symbol code 78
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.O">
            <summary>
            The 'O' symbol code 79
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.P">
            <summary>
            The 'P' symbol code 80
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.Q">
            <summary>
            The 'Q' symbol code 81
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.R">
            <summary>
            The 'R' symbol code 82
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.S">
            <summary>
            The 'S' symbol code 83
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.T">
            <summary>
            The 'T' symbol code 84
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.U">
            <summary>
            The 'U' symbol code 85
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.V">
            <summary>
            The 'V' symbol code 86
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.W">
            <summary>
            The 'W' symbol code 87
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.X">
            <summary>
            The 'X' symbol code 88
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.Y">
            <summary>
            The 'Y' symbol code 89
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.Z">
            <summary>
            The 'Z' symbol code 90
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.a">
            <summary>
            The 'a' symbol code 97
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.b">
            <summary>
            The 'b' symbol code 98
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.c">
            <summary>
            The 'c' symbol code 99
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.d">
            <summary>
            The 'd' symbol code 100
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.e">
            <summary>
            The 'e' symbol code 101
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.f">
            <summary>
            The 'f' symbol code 102
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.g">
            <summary>
            The 'g' symbol code 103
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.h">
            <summary>
            The 'h' symbol code 104
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.i">
            <summary>
            The 'i' symbol code 105
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.j">
            <summary>
            The 'j' symbol code 106
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.k">
            <summary>
            The 'k' symbol code 107
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.l">
            <summary>
            The 'l' symbol code 108
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.m">
            <summary>
            The 'm' symbol code 109
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.n">
            <summary>
            The 'n' symbol code 110
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.o">
            <summary>
            The 'o' symbol code 111
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.p">
            <summary>
            The 'p' symbol code 112
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.q">
            <summary>
            The 'q' symbol code 113
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.r">
            <summary>
            The 'r' symbol code 114
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.s">
            <summary>
            The 's' symbol code 115
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.t">
            <summary>
            The 't' symbol code 116
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.u">
            <summary>
            The 'u' symbol code 117
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.v">
            <summary>
            The 'v' symbol code 118
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.w">
            <summary>
            The 'w' symbol code 119
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.x">
            <summary>
            The 'x' symbol code 120
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.y">
            <summary>
            The 'y' symbol code 121
            </summary>
        </member>
        <member name="F:Z0.AsciLetterCode.z">
            <summary>
            The 'z' symbol code 122
            </summary>
        </member>
        <member name="T:Z0.AsciLetterLo">
            <summary>
            Defines symbols corresponding to the letters a,...z
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLo.a">
            <summary>
            The 'a' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLo.b">
            <summary>
            The 'b' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLo.c">
            <summary>
            The 'c' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLo.d">
            <summary>
            The 'd' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLo.e">
            <summary>
            The 'e' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLo.f">
            <summary>
            The 'f' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLo.g">
            <summary>
            The 'g' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLo.h">
            <summary>
            The 'h' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLo.i">
            <summary>
            The 'i' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLo.j">
            <summary>
            The 'j' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLo.k">
            <summary>
            The 'k' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLo.l">
            <summary>
            The 'l' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLo.m">
            <summary>
            The 'm' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLo.n">
            <summary>
            The 'n' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLo.o">
            <summary>
            The 'o' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLo.p">
            <summary>
            The 'p' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLo.q">
            <summary>
            The 'q' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLo.r">
            <summary>
            The 'r' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLo.s">
            <summary>
            The 's' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLo.t">
            <summary>
            The 't' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLo.u">
            <summary>
            The 'u' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLo.v">
            <summary>
            The 'v' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLo.w">
            <summary>
            The 'w' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLo.x">
            <summary>
            The 'x' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLo.y">
            <summary>
            The 'y' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLo.z">
            <summary>
            The 'z' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLo.First">
            <summary>
            The first declared symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLo.Last">
            <summary>
            The last declared symbol
            </summary>
        </member>
        <member name="T:Z0.AsciLetterLoCode">
            <summary>
            Defines asci codes corresponding to the letters a,...z
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoCode.a">
            <summary>
            The 'a' symbol code 97
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoCode.b">
            <summary>
            The 'b' symbol code 98
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoCode.c">
            <summary>
            The 'c' symbol code 99
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoCode.d">
            <summary>
            The 'd' symbol code 100
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoCode.e">
            <summary>
            The 'e' symbol code 101
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoCode.f">
            <summary>
            The 'f' symbol code 102
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoCode.g">
            <summary>
            The 'g' symbol code 103
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoCode.h">
            <summary>
            The 'h' symbol code 104
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoCode.i">
            <summary>
            The 'i' symbol code 105
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoCode.j">
            <summary>
            The 'j' symbol code 106
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoCode.k">
            <summary>
            The 'k' symbol code 107
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoCode.l">
            <summary>
            The 'l' symbol code 108
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoCode.m">
            <summary>
            The 'm' symbol code 109
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoCode.n">
            <summary>
            The 'n' symbol code 110
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoCode.o">
            <summary>
            The 'o' symbol code 111
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoCode.p">
            <summary>
            The 'p' symbol code 112
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoCode.q">
            <summary>
            The 'q' symbol code 113
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoCode.r">
            <summary>
            The 'r' symbol code 114
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoCode.s">
            <summary>
            The 's' symbol code 115
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoCode.t">
            <summary>
            The 't' symbol code 116
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoCode.u">
            <summary>
            The 'u' symbol code 117
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoCode.v">
            <summary>
            The 'v' symbol code 118
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoCode.w">
            <summary>
            The 'w' symbol code 119
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoCode.x">
            <summary>
            The 'x' symbol code 120
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoCode.y">
            <summary>
            The 'y' symbol code 121
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoCode.z">
            <summary>
            The 'z' symbol code 122
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoCode.First">
            <summary>
            The first declared code, 97
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoCode.Last">
            <summary>
            The last declared code, 122
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoCode.Count">
            <summary>
            The code declaration count, 26
            </summary>
        </member>
        <member name="T:Z0.AsciLetterLoText">
            <summary>
            Defines asci string literals
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoText.a">
            <summary>
            The 'a' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoText.b">
            <summary>
            The 'b' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoText.c">
            <summary>
            The 'c' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoText.d">
            <summary>
            The 'd' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoText.e">
            <summary>
            The 'e' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoText.f">
            <summary>
            The 'f' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoText.g">
            <summary>
            The 'g' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoText.h">
            <summary>
            The 'h' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoText.i">
            <summary>
            The 'i' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoText.j">
            <summary>
            The 'j' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoText.k">
            <summary>
            The 'k' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoText.l">
            <summary>
            The 'l' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoText.m">
            <summary>
            The 'm' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoText.n">
            <summary>
            The 'n' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoText.o">
            <summary>
            The 'o' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoText.p">
            <summary>
            The 'p' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoText.q">
            <summary>
            The 'q' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoText.r">
            <summary>
            The 'r' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoText.s">
            <summary>
            The 's' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoText.t">
            <summary>
            The 't' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoText.u">
            <summary>
            The 'u' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoText.v">
            <summary>
            The 'y' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoText.w">
            <summary>
            The 'w' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoText.x">
            <summary>
            The 'x' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoText.y">
            <summary>
            The 'y' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterLoText.z">
            <summary>
            The 'z' character represented as text
            </summary>
        </member>
        <member name="T:Z0.AsciLetterUp">
            <summary>
            Defines symbols corresponding to the letters A,..Z
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUp.A">
            <summary>
            The 'A' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUp.B">
            <summary>
            The 'B' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUp.C">
            <summary>
            The 'C' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUp.D">
            <summary>
            The 'D' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUp.E">
            <summary>
            The 'E' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUp.F">
            <summary>
            The 'F' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUp.G">
            <summary>
            The 'G' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUp.H">
            <summary>
            The 'H' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUp.I">
            <summary>
            The 'I' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUp.J">
            <summary>
            The 'J' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUp.K">
            <summary>
            The 'K' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUp.L">
            <summary>
            The 'L' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUp.M">
            <summary>
            The 'M' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUp.N">
            <summary>
            The 'N' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUp.O">
            <summary>
            The 'O' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUp.P">
            <summary>
            The 'P' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUp.Q">
            <summary>
            The 'Q' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUp.R">
            <summary>
            The 'R' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUp.S">
            <summary>
            The 'S' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUp.T">
            <summary>
            The 'T' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUp.U">
            <summary>
            The 'U' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUp.V">
            <summary>
            The 'V' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUp.W">
            <summary>
            The 'W' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUp.X">
            <summary>
            The 'X' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUp.Y">
            <summary>
            The 'Y' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUp.Z">
            <summary>
            The 'Z' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUp.First">
            <summary>
            The first declared symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUp.Last">
            <summary>
            The last declared symbol
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUp.Count">
            <summary>
            The symbol declaration count
            </summary>
        </member>
        <member name="T:Z0.AsciLetterUpCode">
            <summary>
            Defines asci codes corresponding to the letters A,..Z
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpCode.A">
            <summary>
            The 'A' symbol code 65
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpCode.B">
            <summary>
            The 'B' symbol code 66
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpCode.C">
            <summary>
            The 'C' symbol code 67
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpCode.D">
            <summary>
            The 'D' symbol code 68
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpCode.E">
            <summary>
            The 'E' symbol code 69
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpCode.F">
            <summary>
            The 'F' symbol code 70
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpCode.G">
            <summary>
            The 'G' symbol code 71
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpCode.H">
            <summary>
            The 'H' symbol code 72
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpCode.I">
            <summary>
            The 'I' symbol code 73
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpCode.J">
            <summary>
            The 'J' symbol code 74
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpCode.K">
            <summary>
            The 'K' symbol code 75
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpCode.L">
            <summary>
            The 'L' symbol code 76
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpCode.M">
            <summary>
            The 'M' symbol code 77
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpCode.N">
            <summary>
            The 'N' symbol code 78
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpCode.O">
            <summary>
            The 'O' symbol code 79
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpCode.P">
            <summary>
            The 'P' symbol code 80
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpCode.Q">
            <summary>
            The 'Q' symbol code 81
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpCode.R">
            <summary>
            The 'R' symbol code 82
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpCode.S">
            <summary>
            The 'S' symbol code 83
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpCode.T">
            <summary>
            The 'T' symbol code 84
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpCode.U">
            <summary>
            The 'U' symbol code 85
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpCode.V">
            <summary>
            The 'V' symbol code 86
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpCode.W">
            <summary>
            The 'W' symbol code 87
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpCode.X">
            <summary>
            The 'X' symbol code 88
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpCode.Y">
            <summary>
            The 'Y' symbol code 89
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpCode.Z">
            <summary>
            The 'Z' symbol code 90
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpCode.First">
            <summary>
            The first declared code, 65
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpCode.Last">
            <summary>
            The last declared code, 90
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpCode.Count">
            <summary>
            The code declaration count, 26
            </summary>
        </member>
        <member name="T:Z0.AsciLetterUpText">
            <summary>
            Defines asci string literals
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpText.A">
            <summary>
            The 'A' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpText.B">
            <summary>
            The 'B' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpText.C">
            <summary>
            The 'D' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpText.D">
            <summary>
            The 'D' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpText.E">
            <summary>
            The 'E' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpText.F">
            <summary>
            The 'G' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpText.G">
            <summary>
            The 'G' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpText.H">
            <summary>
            The 'H' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpText.I">
            <summary>
            The 'I' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpText.J">
            <summary>
            The 'J' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpText.K">
            <summary>
            The 'K' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpText.L">
            <summary>
            The 'L' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpText.M">
            <summary>
            The 'M' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpText.N">
            <summary>
            The 'N' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpText.O">
            <summary>
            The 'O' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpText.P">
            <summary>
            The 'P' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpText.Q">
            <summary>
            The 'Q' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpText.R">
            <summary>
            The 'R' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpText.S">
            <summary>
            The 'S' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpText.T">
            <summary>
            The 'T' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpText.U">
            <summary>
            The 'U' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpText.V">
            <summary>
            The 'V' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpText.W">
            <summary>
            The 'W' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpText.X">
            <summary>
            The 'X' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpText.Y">
            <summary>
            The 'Y' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciLetterUpText.Z">
            <summary>
            The 'Z' character represented as text
            </summary>
        </member>
        <member name="F:Z0.AsciMath.Eq">
            <summary>
            The '=' character
            </summary>
        </member>
        <member name="F:Z0.AsciMath.GT">
            <summary>
            The '>' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciMath.LT">
            <summary>
            The ',' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciMath.Exp">
            <summary>
            The '^' character
            </summary>
        </member>
        <member name="F:Z0.AsciMath.Add">
            <summary>
            The '+' character
            </summary>
        </member>
        <member name="F:Z0.AsciMath.Sub">
            <summary>
            The '-' character
            </summary>
        </member>
        <member name="F:Z0.AsciMath.Mul">
            <summary>
            The '*' character
            </summary>
        </member>
        <member name="F:Z0.AsciMath.Div">
            <summary>
            The '/' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciMath.Mod">
            <summary>
            The '%' character
            </summary>
        </member>
        <member name="F:Z0.AsciMath.Complement">
            <summary>
            The '~' character
            </summary>
        </member>
        <member name="F:Z0.AsciMath.Not">
            <summary>
            The '!' character
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Z0.AsciMath.And" -->
        <member name="F:Z0.AsciMath.Or">
            <summary>
            The '|' character
            </summary>
        </member>
        <member name="F:Z0.AsciMath.Xor">
            <summary>
            The '^' character
            </summary>
        </member>
        <member name="F:Z0.AsciMathCode.Not">
            <summary>
            The '!' character code 33
            </summary>
        </member>
        <member name="F:Z0.AsciMathCode.Mod">
            <summary>
            The '%' character code 37
            </summary>
        </member>
        <member name="F:Z0.AsciMathCode.Mul">
            <summary>
            The '*' character code 42
            </summary>
        </member>
        <member name="F:Z0.AsciMathCode.Add">
            <summary>
            The '+' character code 43
            </summary>
        </member>
        <member name="F:Z0.AsciMathCode.Sub">
            <summary>
            The '-' character code 45
            </summary>
        </member>
        <member name="F:Z0.AsciMathCode.Div">
            <summary>
            The '/' character code 47
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Z0.AsciMathCode.LT" -->
        <member name="F:Z0.AsciMathCode.Eq">
            <summary>
            The '=' character code 61
            </summary>
        </member>
        <member name="F:Z0.AsciMathCode.GT">
            <summary>
            The '>' character code 62
            </summary>
        </member>
        <member name="F:Z0.AsciMathCode.Exp">
            <summary>
            The '^' character code 94
            </summary>
        </member>
        <member name="F:Z0.AsciMathCode.Complement">
            <summary>
            The '~' character code 126
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Z0.AsciSymCode.Amp" -->
        <member name="F:Z0.AsciSymCode.Dot">
            <summary>
            The '.' character code 46
            </summary>
        </member>
        <member name="F:Z0.AsciSymCode.Space">
            <summary>
            The ' ' character code 32
            </summary>
        </member>
        <member name="F:Z0.AsciSymCode.Hash">
            <summary>
            The '#' character code 35
            </summary>
        </member>
        <member name="F:Z0.AsciSymCode.Dollar">
            <summary>
            The '$' character code 36
            </summary>
        </member>
        <member name="F:Z0.AsciSymCode.FS">
            <summary>
            The '/' character code 47
            </summary>
        </member>
        <member name="F:Z0.AsciSymCode.At">
            <summary>
            The '@' character code 64
            </summary>
        </member>
        <member name="F:Z0.AsciSymCode.BS">
            <summary>
            The '\\' character code 92
            </summary>
        </member>
        <member name="F:Z0.AsciSymCode.US">
            <summary>
            The '_' character code 95
            </summary>
        </member>
        <member name="F:Z0.AsciSymCode.Comma">
            <summary>
            The ',' character code 44
            </summary>
        </member>
        <member name="F:Z0.AsciSymCode.Pipe">
            <summary>
            The '|' character code 124
            </summary>
        </member>
        <member name="F:Z0.AsciSymCode.Question">
            <summary>
            The '?' character code 63
            </summary>
        </member>
        <member name="F:Z0.AsciSymCode.DQuote">
            <summary>
            The '"' character code 34
            </summary>
        </member>
        <member name="F:Z0.AsciSymCode.SQuote">
            <summary>
            The ''' character code 39
            </summary>
        </member>
        <member name="F:Z0.AsciSymCode.LParen">
            <summary>
            The '(' character code 40
            </summary>
        </member>
        <member name="F:Z0.AsciSymCode.RParen">
            <summary>
            The ')' character code 41
            </summary>
        </member>
        <member name="F:Z0.AsciSymCode.Colon">
            <summary>
            The ':' character code 58
            </summary>
        </member>
        <member name="F:Z0.AsciSymCode.Semicolon">
            <summary>
            The ';' character code 59
            </summary>
        </member>
        <member name="F:Z0.AsciSymCode.LB">
            <summary>
            The '[' character code 91
            </summary>
        </member>
        <member name="F:Z0.AsciSymCode.RB">
            <summary>
            The ']' character code 93
            </summary>
        </member>
        <member name="F:Z0.AsciSymCode.LBrace">
            <summary>
            The '{' character code 123
            </summary>
        </member>
        <member name="F:Z0.AsciSymCode.RBrace">
            <summary>
            The '}' character code 125
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Z0.AsciSymSymbol.Amp" -->
        <member name="F:Z0.AsciSymSymbol.Dot">
            <summary>
            The '.' character
            </summary>
        </member>
        <member name="F:Z0.AsciSymSymbol.At">
            <summary>
            The '@' character
            </summary>
        </member>
        <member name="F:Z0.AsciSymSymbol.Comma">
            <summary>
            The ',' character
            </summary>
        </member>
        <member name="F:Z0.AsciSymSymbol.Dollar">
            <summary>
            The '$' character
            </summary>
        </member>
        <member name="F:Z0.AsciSymSymbol.Hash">
            <summary>
            The '#' character
            </summary>
        </member>
        <member name="F:Z0.AsciSymSymbol.Pipe">
            <summary>
            The '|' character
            </summary>
        </member>
        <member name="F:Z0.AsciSymSymbol.Question">
            <summary>
            The '?' character
            </summary>
        </member>
        <member name="F:Z0.AsciSymSymbol.US">
            <summary>
            The '_' character
            </summary>
        </member>
        <member name="F:Z0.AsciSymSymbol.Space">
            <summary>
            The ' ' character
            </summary>
        </member>
        <member name="F:Z0.AsciSymSymbol.BS">
            <summary>
            The '\\' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciSymSymbol.FS">
            <summary>
            The '\/' symbol
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Z0.AsciSymSymbol.LBrace" -->
        <member name="F:Z0.AsciSymSymbol.RBrace">
            <summary>
            The '}' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciSymSymbol.LB">
            <summary>
            The '[' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciSymSymbol.RB">
            <summary>
            The ']' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciSymSymbol.LParen">
            <summary>
            The '(' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciSymSymbol.RParen">
            <summary>
            The ')' symbol
            </summary>
        </member>
        <member name="F:Z0.AsciSymSymbol.Colon">
            <summary>
            The ':' character
            </summary>
        </member>
        <member name="F:Z0.AsciSymSymbol.Semicolon">
            <summary>
            The ';' character
            </summary>
        </member>
        <member name="F:Z0.AsciSymSymbol.DQuote">
            <summary>
            The '"' (double-quote) character
            </summary>
        </member>
        <member name="F:Z0.AsciSymSymbol.SQuote">
            <summary>
            The ''' (single-quote) character
            </summary>
        </member>
        <member name="T:Z0.BinaryDigit">
            <summary>
            Defines literals that correspond to base-2 digits
            </summary>
        </member>
        <member name="F:Z0.BinaryDigit.b0">
            <summary>
            Specifies 0 base 2
            </summary>
        </member>
        <member name="F:Z0.BinaryDigit.b1">
            <summary>
            Specifies 1 base 2
            </summary>
        </member>
        <member name="F:Z0.BinaryDigitCode.b0">
            <summary>
            Specifies the asci code for the eponymous binary digit
            </summary>
        </member>
        <member name="F:Z0.BinaryDigitCode.b1">
            <summary>
            Specifies the asci code for the eponymous binary digit
            </summary>
        </member>
        <member name="T:Z0.BinarySym">
            <summary>
            Defines the symbols that represent the base-2 digits
            </summary>
        </member>
        <member name="F:Z0.BinarySym.None">
            <summary>
            The symbolic void
            </summary>
        </member>
        <member name="F:Z0.BinarySym.b0">
            <summary>
            Specifies 0 base 2, asci code 48
            </summary>
        </member>
        <member name="F:Z0.BinarySym.b1">
            <summary>
            Specifies 1 base 2, asci code 49
            </summary>
        </member>
        <member name="T:Z0.BinarySymFacet">
            <summary>
            Defines <see cref='T:Z0.BinarySym' /> characteristics
            </summary>
        </member>
        <member name="F:Z0.BinarySymFacet.First">
            <summary>
            The first declared symbol
            </summary>
        </member>
        <member name="F:Z0.BinarySymFacet.Last">
            <summary>
            The last declared symbol
            </summary>
        </member>
        <member name="T:Z0.Chars">
            <summary>
            Defines an arbitrary collection of character literals
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Z0.Chars.Amp" -->
        <member name="F:Z0.Chars.At">
            <summary>
            The '@' character
            </summary>
        </member>
        <member name="F:Z0.Chars.Bang">
            <summary>
            The '!' character
            </summary>
        </member>
        <member name="F:Z0.Chars.BSlash">
            <summary>
            The backslash character
            </summary>
        </member>
        <member name="F:Z0.Chars.Caret">
            <summary>
            The '^' character
            </summary>
        </member>
        <member name="F:Z0.Chars.Colon">
            <summary>
            The ':' character
            </summary>
        </member>
        <member name="F:Z0.Chars.Comma">
            <summary>
            The ',' character
            </summary>
        </member>
        <member name="F:Z0.Chars.Dash">
            <summary>
            The '-' character
            </summary>
        </member>
        <member name="F:Z0.Chars.Dollar">
            <summary>
            The '$' character
            </summary>
        </member>
        <member name="F:Z0.Chars.Dot">
            <summary>
            The '.' character
            </summary>
        </member>
        <member name="F:Z0.Chars.Eq">
            <summary>
            The '=' character
            </summary>
        </member>
        <member name="F:Z0.Chars.FSlash">
            <summary>
            The '/' character
            </summary>
        </member>
        <member name="F:Z0.Chars.Gt">
            <summary>
            The '>' character
            </summary>
        </member>
        <member name="F:Z0.Chars.Hash">
            <summary>
            The '#' character
            </summary>
        </member>
        <member name="F:Z0.Chars.LBrace">
            <summary>
            The '{' character
            </summary>
        </member>
        <member name="F:Z0.Chars.LBracket">
            <summary>
            The '[' character
            </summary>
        </member>
        <member name="F:Z0.Chars.LParen">
            <summary>
            The '(' character
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Z0.Chars.Lt" -->
        <member name="F:Z0.Chars.Percent">
            <summary>
            The '%' character
            </summary>
        </member>
        <member name="F:Z0.Chars.Pipe">
            <summary>
            The '|' character
            </summary>
        </member>
        <member name="F:Z0.Chars.Plus">
            <summary>
            The '+' character
            </summary>
        </member>
        <member name="F:Z0.Chars.Question">
            <summary>
            The '?' character
            </summary>
        </member>
        <member name="F:Z0.Chars.Quote">
            <summary>
            The '"' character
            </summary>
        </member>
        <member name="F:Z0.Chars.RParen">
            <summary>
            The ')' character
            </summary>
        </member>
        <member name="F:Z0.Chars.RBrace">
            <summary>
            The '}' character
            </summary>
        </member>
        <member name="F:Z0.Chars.RBracket">
            <summary>
            The ']' character
            </summary>
        </member>
        <member name="F:Z0.Chars.Semicolon">
            <summary>
            The ';' character
            </summary>
        </member>
        <member name="F:Z0.Chars.Space">
            <summary>
            The ' ' character
            </summary>
        </member>
        <member name="F:Z0.Chars.SQuote">
            <summary>
            The ''' character
            </summary>
        </member>
        <member name="F:Z0.Chars.Star">
            <summary>
            The '*' character
            </summary>
        </member>
        <member name="F:Z0.Chars.Tilde">
            <summary>
            The '~' character
            </summary>
        </member>
        <member name="F:Z0.Chars.Underscore">
            <summary>
            The '~' character
            </summary>
        </member>
        <member name="F:Z0.Chars.D0">
            <summary>
            The '0' character
            </summary>
        </member>
        <member name="F:Z0.Chars.D1">
            <summary>
            The '1' character
            </summary>
        </member>
        <member name="F:Z0.Chars.D2">
            <summary>
            The '2' character
            </summary>
        </member>
        <member name="F:Z0.Chars.D3">
            <summary>
            The '3' character
            </summary>
        </member>
        <member name="F:Z0.Chars.D4">
            <summary>
            The '4' character
            </summary>
        </member>
        <member name="F:Z0.Chars.D5">
            <summary>
            The '5' character
            </summary>
        </member>
        <member name="F:Z0.Chars.D6">
            <summary>
            The '6' character
            </summary>
        </member>
        <member name="F:Z0.Chars.D7">
            <summary>
            The '7' character
            </summary>
        </member>
        <member name="F:Z0.Chars.D8">
            <summary>
            The '8' character
            </summary>
        </member>
        <member name="F:Z0.Chars.D9">
            <summary>
            The '9' character
            </summary>
        </member>
        <member name="F:Z0.Chars.Tab">
            <summary>
            The tab character
            </summary>
        </member>
        <member name="F:Z0.Chars.NL">
            <summary>
            The new-line character
            </summary>
        </member>
        <member name="F:Z0.Chars.LineFeed">
            <summary>
            The line-feed character
            </summary>
        </member>
        <member name="F:Z0.Chars.Eol">
            <summary>
            The end-of-line escape sequence
            </summary>
        </member>
        <member name="F:Z0.Chars.MapsTo">
            <summary>
            The '↦' character
            </summary>
        </member>
        <member name="F:Z0.Chars.Null">
            <summary>
            The asci null character '\0'
            </summary>
        </member>
        <member name="T:Z0.CharText">
            <summary>
            Defines an arbitrary collection of text literals
            </summary>
        </member>
        <member name="F:Z0.CharText.Colon">
            <summary>
            The ':' character text
            </summary>
        </member>
        <member name="F:Z0.CharText.Eq">
            <summary>
            The '=' character text
            </summary>
        </member>
        <member name="F:Z0.CharText.Pipe">
            <summary>
            The '|' character text
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Z0.CharText.Space" -->
        <member name="F:Z0.CharText.SQuote">
            <summary>
            The ''' character text
            </summary>
        </member>
        <member name="T:Z0.DecimalCode">
            <summary>
            Defines the symbols that represent the base-10 digits
            </summary>
        </member>
        <member name="F:Z0.DecimalCode.d0">
            <summary>
            Specifies the asci code for the digit '0'
            </summary>
        </member>
        <member name="F:Z0.DecimalCode.d1">
            <summary>
            Specifies the asci code for the digit '1'
            </summary>
        </member>
        <member name="F:Z0.DecimalCode.d2">
            <summary>
            Specifies the asci code for the digit '2'
            </summary>
        </member>
        <member name="F:Z0.DecimalCode.d3">
            <summary>
            Specifies the asci code for the digit '3'
            </summary>
        </member>
        <member name="F:Z0.DecimalCode.d4">
            <summary>
            Specifies the asci code for the digit '4'
            </summary>
        </member>
        <member name="F:Z0.DecimalCode.d5">
            <summary>
            Specifies the asci code for the digit '5'
            </summary>
        </member>
        <member name="F:Z0.DecimalCode.d6">
            <summary>
            Specifies the asci code for the digit '6'
            </summary>
        </member>
        <member name="F:Z0.DecimalCode.d7">
            <summary>
            Specifies the asci code for the digit '7'
            </summary>
        </member>
        <member name="F:Z0.DecimalCode.d8">
            <summary>
            Specifies the asci code for the digit '8'
            </summary>
        </member>
        <member name="F:Z0.DecimalCode.d9">
            <summary>
            Specifies the asci code for the digit '9'
            </summary>
        </member>
        <member name="T:Z0.DecimalDigit">
            <summary>
            Defines literals that correspond to base-10 digits
            </summary>
        </member>
        <member name="F:Z0.DecimalDigit.d0">
            <summary>
            Specifies 0 base 10
            </summary>
        </member>
        <member name="F:Z0.DecimalDigit.d1">
            <summary>
            Specifies 1 base 10
            </summary>
        </member>
        <member name="F:Z0.DecimalDigit.d2">
            <summary>
            Specifies 2 base 10
            </summary>
        </member>
        <member name="F:Z0.DecimalDigit.d3">
            <summary>
            Specifies 3 base 10
            </summary>
        </member>
        <member name="F:Z0.DecimalDigit.d4">
            <summary>
            Specifies 4 base 10
            </summary>
        </member>
        <member name="F:Z0.DecimalDigit.d5">
            <summary>
            Specifies 5 base 10
            </summary>
        </member>
        <member name="F:Z0.DecimalDigit.d6">
            <summary>
            Specifies 6 base 10
            </summary>
        </member>
        <member name="F:Z0.DecimalDigit.d7">
            <summary>
            Specifies 7 base 10
            </summary>
        </member>
        <member name="F:Z0.DecimalDigit.d8">
            <summary>
            Specifies 8 base 10
            </summary>
        </member>
        <member name="F:Z0.DecimalDigit.d9">
            <summary>
            Specifies 9 base 10
            </summary>
        </member>
        <member name="T:Z0.DecimalSym">
            <summary>
            Defines the symbols that represent the base-10 digits
            </summary>
        </member>
        <member name="F:Z0.DecimalSym.Null">
            <summary>
            The code with no substance
            </summary>
        </member>
        <member name="F:Z0.DecimalSym.d0">
            <summary>
            Specifies 0 base 10, asci code 48
            </summary>
        </member>
        <member name="F:Z0.DecimalSym.d1">
            <summary>
            Specifies 1 base 10, asci code 49
            </summary>
        </member>
        <member name="F:Z0.DecimalSym.d2">
            <summary>
            Specifies 2 base 10, asci code 50
            </summary>
        </member>
        <member name="F:Z0.DecimalSym.d3">
            <summary>
            Specifies 3 base 10, asci code 51
            </summary>
        </member>
        <member name="F:Z0.DecimalSym.d4">
            <summary>
            Specifies 4 base 10, asci code 52
            </summary>
        </member>
        <member name="F:Z0.DecimalSym.d5">
            <summary>
            Specifies 5 base 10, asci code 53
            </summary>
        </member>
        <member name="F:Z0.DecimalSym.d6">
            <summary>
            Specifies 6 base 10, asci code 54
            </summary>
        </member>
        <member name="F:Z0.DecimalSym.d7">
            <summary>
            Specifies 7 base 10, asci code 55
            </summary>
        </member>
        <member name="F:Z0.DecimalSym.d8">
            <summary>
            Specifies 8 base 10, asci code 56
            </summary>
        </member>
        <member name="F:Z0.DecimalSym.d9">
            <summary>
            Specifies 9 base 10, asci code 57
            </summary>
        </member>
        <member name="T:Z0.DecimalSymFacet">
            <summary>
            Defines <see cref='T:Z0.DecimalSym' /> characteristics
            </summary>
        </member>
        <member name="F:Z0.DecimalSymFacet.First">
            <summary>
            The first declared symbol
            </summary>
        </member>
        <member name="F:Z0.DecimalSymFacet.Last">
            <summary>
            The last declared symbol
            </summary>
        </member>
        <member name="T:Z0.HexCode">
            <summary>
            Defines identifiers for the ASCI codes that correspond to both upper/lower-case hex digits
            </summary>
        </member>
        <member name="F:Z0.HexCode.None">
            <summary>
            The hex code with no code
            </summary>
        </member>
        <member name="F:Z0.HexCode.x0">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCode.x1">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCode.x2">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCode.x3">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCode.x4">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCode.x5">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCode.x6">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCode.x7">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCode.x8">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCode.x9">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCode.A">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCode.B">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCode.C">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCode.D">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCode.E">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCode.F">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCode.a">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCode.b">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCode.c">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCode.d">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCode.e">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCode.f">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="T:Z0.HexCodeLo">
            <summary>
            Defines identiiers for the ASCI codes that correspond to the lowercase hex digits
            </summary>
        </member>
        <member name="F:Z0.HexCodeLo.None">
            <summary>
            The hex code with no code
            </summary>
        </member>
        <member name="F:Z0.HexCodeLo.x0">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCodeLo.x1">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCodeLo.x2">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCodeLo.x3">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCodeLo.x4">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCodeLo.x5">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCodeLo.x6">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCodeLo.x7">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCodeLo.x8">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCodeLo.x9">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCodeLo.a">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCodeLo.b">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCodeLo.c">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCodeLo.d">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCodeLo.e">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCodeLo.f">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="T:Z0.HexCodeUp">
            <summary>
            Defines identifiers for the ASCI codes that correspond to the uppercase hex digits
            </summary>
        </member>
        <member name="F:Z0.HexCodeUp.None">
            <summary>
            The code with no name
            </summary>
        </member>
        <member name="F:Z0.HexCodeUp.x0">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCodeUp.x1">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCodeUp.x2">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCodeUp.x3">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCodeUp.x4">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCodeUp.x5">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCodeUp.x6">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCodeUp.x7">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCodeUp.x8">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCodeUp.x9">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCodeUp.A">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCodeUp.B">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCodeUp.C">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCodeUp.D">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCodeUp.E">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.HexCodeUp.F">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="T:Z0.HexDigit">
            <summary>
            Defines literals that correspond to the base-16 digits
            </summary>
        </member>
        <member name="F:Z0.HexDigit.x0">
            <summary>
            Specifies 0 base 16
            </summary>
        </member>
        <member name="F:Z0.HexDigit.x1">
            <summary>
            Specifies 1 base 16
            </summary>
        </member>
        <member name="F:Z0.HexDigit.x2">
            <summary>
            Specifies 2 base 16
            </summary>
        </member>
        <member name="F:Z0.HexDigit.x3">
            <summary>
            Specifies 3 base 16
            </summary>
        </member>
        <member name="F:Z0.HexDigit.x4">
            <summary>
            Specifies 4 base 16
            </summary>
        </member>
        <member name="F:Z0.HexDigit.x5">
            <summary>
            Specifies 5 base 16
            </summary>
        </member>
        <member name="F:Z0.HexDigit.x6">
            <summary>
            Specifies 6 base 16
            </summary>
        </member>
        <member name="F:Z0.HexDigit.x7">
            <summary>
            Specifies 7 base 16
            </summary>
        </member>
        <member name="F:Z0.HexDigit.x8">
            <summary>
            Specifies 8 base 16
            </summary>
        </member>
        <member name="F:Z0.HexDigit.x9">
            <summary>
            Specifies 9 base 16
            </summary>
        </member>
        <member name="F:Z0.HexDigit.A">
            <summary>
            Specifies 10 base 16
            </summary>
        </member>
        <member name="F:Z0.HexDigit.B">
            <summary>
            Specifies 11 base 16
            </summary>
        </member>
        <member name="F:Z0.HexDigit.C">
            <summary>
            Specifies 12 base 16
            </summary>
        </member>
        <member name="F:Z0.HexDigit.D">
            <summary>
            Specifies 13 base 16
            </summary>
        </member>
        <member name="F:Z0.HexDigit.E">
            <summary>
            Specifies 14 base 16
            </summary>
        </member>
        <member name="F:Z0.HexDigit.F">
            <summary>
            Specifies 15 base 16
            </summary>
        </member>
        <member name="T:Z0.HexDigitKind">
            <summary>
            Defines a parition over hex digits
            </summary>
        </member>
        <member name="F:Z0.HexDigitKind.Number">
            <summary>
            Classifies digits from the sequence '0',..,'9'
            </summary>
        </member>
        <member name="F:Z0.HexDigitKind.LowerLetter">
            <summary>
            Classifies digits from the sequence 'a',..,'b'
            </summary>
        </member>
        <member name="F:Z0.HexDigitKind.UpperLetter">
            <summary>
            Classifies digits from the sequence 'A',..,'F'
            </summary>
        </member>
        <member name="T:Z0.HexSym">
            <summary>
            Defines the symbols that represent both upper and lower-case base-16 digits
            </summary>
        </member>
        <member name="F:Z0.HexSym.x0">
            <summary>
            Specifies 0 base 16, asci code 48
            </summary>
        </member>
        <member name="F:Z0.HexSym.x1">
            <summary>
            Specifies 1 base 16, asci code 49
            </summary>
        </member>
        <member name="F:Z0.HexSym.x2">
            <summary>
            Specifies 2 base 16, asci code 50
            </summary>
        </member>
        <member name="F:Z0.HexSym.x3">
            <summary>
            Specifies 3 base 16, asci code 51
            </summary>
        </member>
        <member name="F:Z0.HexSym.x4">
            <summary>
            Specifies 4 base 16, asci code 52
            </summary>
        </member>
        <member name="F:Z0.HexSym.x5">
            <summary>
            Specifies 5 base 16
            </summary>
        </member>
        <member name="F:Z0.HexSym.x6">
            <summary>
            Specifies 6 base 16
            </summary>
        </member>
        <member name="F:Z0.HexSym.x7">
            <summary>
            Specifies 7 base 16
            </summary>
        </member>
        <member name="F:Z0.HexSym.x8">
            <summary>
            Specifies 8 base 16
            </summary>
        </member>
        <member name="F:Z0.HexSym.x9">
            <summary>
            Specifies 9 base 16
            </summary>
        </member>
        <member name="F:Z0.HexSym.A">
            <summary>
            Specifies 10 base 16, asci code 65
            </summary>
        </member>
        <member name="F:Z0.HexSym.B">
            <summary>
            Specifies 11 base 16, asci code 66
            </summary>
        </member>
        <member name="F:Z0.HexSym.C">
            <summary>
            Specifies 12 base 16, asci code 67
            </summary>
        </member>
        <member name="F:Z0.HexSym.D">
            <summary>
            Specifies 13 base 16, asci code 68
            </summary>
        </member>
        <member name="F:Z0.HexSym.E">
            <summary>
            Specifies 14 base 16, asci code 69
            </summary>
        </member>
        <member name="F:Z0.HexSym.F">
            <summary>
            Specifies 15 base 16, asci code 70
            </summary>
        </member>
        <member name="F:Z0.HexSym.a">
            <summary>
            Specifies 10 base 16, asci code 97
            </summary>
        </member>
        <member name="F:Z0.HexSym.b">
            <summary>
            Specifies 10 base 16, asci code 98
            </summary>
        </member>
        <member name="F:Z0.HexSym.c">
            <summary>
            Specifies 10 base 16, asci code 99
            </summary>
        </member>
        <member name="F:Z0.HexSym.d">
            <summary>
            Specifies 10 base 16, asci code 100
            </summary>
        </member>
        <member name="F:Z0.HexSym.e">
            <summary>
            Specifies 10 base 16, asci code 101
            </summary>
        </member>
        <member name="F:Z0.HexSym.f">
            <summary>
            Specifies 10 base 16, asci code 102
            </summary>
        </member>
        <member name="T:Z0.HexSymData">
            <summary>
            Defines codes and symbol datasets for hex digits
            </summary>
        </member>
        <member name="P:Z0.HexSymData.UpperCodes">
            <summary>
            Defines a 16-byte sequence with terms that correspond to the ASCI codes the hex digits {0..9,A..F}
            </summary>
        </member>
        <member name="P:Z0.HexSymData.LowerCodes">
            <summary>
            Defines a 16-byte sequence with terms that correspond to the ASCI codes for hex digits {0..9,a..f}
            </summary>
        </member>
        <member name="P:Z0.HexSymData.UpperSymbols">
            <summary>
            Defines a 16-element sequence with terms that correspond to the uppercase hex symbolic literals
            </summary>
        </member>
        <member name="P:Z0.HexSymData.LowerSymbols">
            <summary>
            Defines a 16-element sequence with terms that correspond to the lowercase hex symbolic literals
            </summary>
        </member>
        <member name="F:Z0.HexSymFacet.FirstNumber">
            <summary>
            The 'x0' code
            </summary>
        </member>
        <member name="F:Z0.HexSymFacet.LastNumber">
            <summary>
            The 'x9' code
            </summary>
        </member>
        <member name="F:Z0.HexSymFacet.FirstLetterLo">
            <summary>
            The 'a' code
            </summary>
        </member>
        <member name="F:Z0.HexSymFacet.LastLetterLo">
            <summary>
            The 'f' code
            </summary>
        </member>
        <member name="F:Z0.HexSymFacet.FirstLetterUp">
            <summary>
            The 'a' code
            </summary>
        </member>
        <member name="F:Z0.HexSymFacet.LastLetterUp">
            <summary>
            The 'f' code
            </summary>
        </member>
        <member name="F:Z0.HexSymFacet.LetterOffsetLo">
            <summary>
            The value to subtract from a symbolic digit [a..b] to compute an index in the range [0..15]
            </summary>
        </member>
        <member name="F:Z0.HexSymFacet.LetterOffsetUp">
            <summary>
            The value to subtract from a symbolic digit [A..F] to compute an index in the range [0..15]
            </summary>
        </member>
        <member name="F:Z0.HexSymFacet.NumberOffset">
            <summary>
            The value to subtract from a symbolic digit [0..9] to compute an index in the range [0..15]
            </summary>
        </member>
        <member name="F:Z0.HexSymFacet.NumberCount">
            <summary>
            The numeral declaration count
            </summary>
        </member>
        <member name="F:Z0.HexSymFacet.LetterCount">
            <summary>
            The lettr declaration count
            </summary>
        </member>
        <member name="T:Z0.HexSymLo">
            <summary>
            Defines the symbols that represent lowercase base-16 digits
            </summary>
        </member>
        <member name="F:Z0.HexSymLo.None">
            <summary>
            The unprintable symbol
            </summary>
        </member>
        <member name="F:Z0.HexSymLo.x0">
            <summary>
            Specifies 0 base 16, asci code 48
            </summary>
        </member>
        <member name="F:Z0.HexSymLo.x1">
            <summary>
            Specifies 1 base 16, asci code 49
            </summary>
        </member>
        <member name="F:Z0.HexSymLo.x2">
            <summary>
            Specifies 2 base 16, asci code 50
            </summary>
        </member>
        <member name="F:Z0.HexSymLo.x3">
            <summary>
            Specifies 3 base 16, asci code 51
            </summary>
        </member>
        <member name="F:Z0.HexSymLo.x4">
            <summary>
            Specifies 4 base 16, asci code 52
            </summary>
        </member>
        <member name="F:Z0.HexSymLo.x5">
            <summary>
            Specifies 5 base 16
            </summary>
        </member>
        <member name="F:Z0.HexSymLo.x6">
            <summary>
            Specifies 6 base 16
            </summary>
        </member>
        <member name="F:Z0.HexSymLo.x7">
            <summary>
            Specifies 7 base 16
            </summary>
        </member>
        <member name="F:Z0.HexSymLo.x8">
            <summary>
            Specifies 8 base 16
            </summary>
        </member>
        <member name="F:Z0.HexSymLo.x9">
            <summary>
            Specifies 9 base 16
            </summary>
        </member>
        <member name="F:Z0.HexSymLo.a">
            <summary>
            Specifies 10 base 16, asci code 97
            </summary>
        </member>
        <member name="F:Z0.HexSymLo.b">
            <summary>
            Specifies 10 base 16, asci code 98
            </summary>
        </member>
        <member name="F:Z0.HexSymLo.c">
            <summary>
            Specifies 10 base 16, asci code 99
            </summary>
        </member>
        <member name="F:Z0.HexSymLo.d">
            <summary>
            Specifies 10 base 16, asci code 100
            </summary>
        </member>
        <member name="F:Z0.HexSymLo.e">
            <summary>
            Specifies 10 base 16, asci code 101
            </summary>
        </member>
        <member name="F:Z0.HexSymLo.f">
            <summary>
            Specifies 10 base 16, asci code 102
            </summary>
        </member>
        <member name="T:Z0.HexSymUp">
            <summary>
            Defines the symbols that represent the uppercase base-16 digits
            </summary>
        </member>
        <member name="F:Z0.HexSymUp.x0">
            <summary>
            Specifies 0 base 16, asci code 48
            </summary>
        </member>
        <member name="F:Z0.HexSymUp.x1">
            <summary>
            Specifies 1 base 16, asci code 49
            </summary>
        </member>
        <member name="F:Z0.HexSymUp.x2">
            <summary>
            Specifies 2 base 16, asci code 50
            </summary>
        </member>
        <member name="F:Z0.HexSymUp.x3">
            <summary>
            Specifies 3 base 16, asci code 51
            </summary>
        </member>
        <member name="F:Z0.HexSymUp.x4">
            <summary>
            Specifies 4 base 16, asci code 52
            </summary>
        </member>
        <member name="F:Z0.HexSymUp.x5">
            <summary>
            Specifies 5 base 16
            </summary>
        </member>
        <member name="F:Z0.HexSymUp.x6">
            <summary>
            Specifies 6 base 16
            </summary>
        </member>
        <member name="F:Z0.HexSymUp.x7">
            <summary>
            Specifies 7 base 16
            </summary>
        </member>
        <member name="F:Z0.HexSymUp.x8">
            <summary>
            Specifies 8 base 16
            </summary>
        </member>
        <member name="F:Z0.HexSymUp.x9">
            <summary>
            Specifies 9 base 16
            </summary>
        </member>
        <member name="F:Z0.HexSymUp.A">
            <summary>
            Specifies 10 base 16, asci code 65
            </summary>
        </member>
        <member name="F:Z0.HexSymUp.B">
            <summary>
            Specifies 11 base 16, asci code 66
            </summary>
        </member>
        <member name="F:Z0.HexSymUp.C">
            <summary>
            Specifies 12 base 16, asci code 67
            </summary>
        </member>
        <member name="F:Z0.HexSymUp.D">
            <summary>
            Specifies 13 base 16, asci code 68
            </summary>
        </member>
        <member name="F:Z0.HexSymUp.E">
            <summary>
            Specifies 14 base 16, asci code 69
            </summary>
        </member>
        <member name="F:Z0.HexSymUp.F">
            <summary>
            Specifies 15 base 16, asci code 70
            </summary>
        </member>
        <member name="T:Z0.Log2x8">
            <summary>
            Defines primal type widths via powers-of-two
            </summary>
        </member>
        <member name="F:Z0.Log2x8.w0">
            <summary>
            Witless
            </summary>
        </member>
        <member name="F:Z0.Log2x8.w1">
            <summary>
            W1 := 2^(w0) = 1, an imaginary but conceptually useful primal width
            </summary>
        </member>
        <member name="F:Z0.Log2x8.w8">
            <summary>
            W8 := 2^(W8) = 2^3 = 8
            </summary>
        </member>
        <member name="F:Z0.Log2x8.w16">
            <summary>
            W16 := 2^(W16) = 2^4 = 16
            </summary>
        </member>
        <member name="F:Z0.Log2x8.w32">
            <summary>
            W16 := 2^(W32) = 2^5 = 32
            </summary>
        </member>
        <member name="F:Z0.Log2x8.w64">
            <summary>
            W64 := 2^(W64) = 2^6 = 64
            </summary>
        </member>
        <member name="F:Z0.Log2x8.w128">
            <summary>
            W128 := 2^(W128) = 2^7 = 128
            </summary>
        </member>
        <member name="F:Z0.Log2x8.wMax">
            <summary>
            The maximum specified width
            </summary>
        </member>
        <member name="T:Z0.MathSym">
            <summary>
            Random selection of math-related unicode symbols
            </summary>
            <remarks>
            See https://en.wikipedia.org/wiki/Mathematical_operators_and_symbols_in_Unicode for a comprehensive list
            </remarks>
        </member>
        <member name="F:Z0.OctalCode.o0">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.OctalCode.o1">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.OctalCode.o2">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.OctalCode.o3">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.OctalCode.o4">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.OctalCode.o5">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.OctalCode.o6">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.OctalCode.o7">
            <summary>
            Specifies the asci code for the eponymous hex digit
            </summary>
        </member>
        <member name="F:Z0.OctalCode.First">
            <summary>
            The first declared code
            </summary>
        </member>
        <member name="F:Z0.OctalCode.Last">
            <summary>
            The last declared code
            </summary>
        </member>
        <member name="F:Z0.OctalCode.Count">
            <summary>
            The code declaration count
            </summary>
        </member>
        <member name="T:Z0.OctalDigit">
            <summary>
            Defines literals corresponding to base-8 digits
            </summary>
        </member>
        <member name="F:Z0.OctalDigit.o0">
            <summary>
            Specifies 0 base 8
            </summary>
        </member>
        <member name="F:Z0.OctalDigit.o1">
            <summary>
            Specifies 1 base 8
            </summary>
        </member>
        <member name="F:Z0.OctalDigit.o2">
            <summary>
            Specifies 2 base 8
            </summary>
        </member>
        <member name="F:Z0.OctalDigit.o3">
            <summary>
            Specifies 3 base 8
            </summary>
        </member>
        <member name="F:Z0.OctalDigit.o4">
            <summary>
            Specifies 4 base 8
            </summary>
        </member>
        <member name="F:Z0.OctalDigit.o5">
            <summary>
            Specifies 5 base 8
            </summary>
        </member>
        <member name="F:Z0.OctalDigit.o6">
            <summary>
            Specifies 6 base 8
            </summary>
        </member>
        <member name="F:Z0.OctalDigit.o7">
            <summary>
            Specifies 7 base 8
            </summary>
        </member>
        <member name="F:Z0.OctalDigit.First">
            <summary>
            The first declared digit
            </summary>
        </member>
        <member name="F:Z0.OctalDigit.Last">
            <summary>
            The last declared digit
            </summary>
        </member>
        <member name="F:Z0.OctalDigit.Count">
            <summary>
            The digit declaration count
            </summary>
        </member>
        <member name="T:Z0.OctalSym">
            <summary>
            Defines the symbols that represent base-8 digits
            </summary>
        </member>
        <member name="F:Z0.OctalSym.o0">
            <summary>
            Specifies 0 base 8, asci code 48
            </summary>
        </member>
        <member name="F:Z0.OctalSym.o1">
            <summary>
            Specifies 1 base 8, asci code 49
            </summary>
        </member>
        <member name="F:Z0.OctalSym.o2">
            <summary>
            Specifies 2 base 8, asci code 50
            </summary>
        </member>
        <member name="F:Z0.OctalSym.o3">
            <summary>
            Specifies 3 base 8, asci code 51
            </summary>
        </member>
        <member name="F:Z0.OctalSym.o4">
            <summary>
            Specifies 4 base 8, asci code 52
            </summary>
        </member>
        <member name="F:Z0.OctalSym.o5">
            <summary>
            Specifies 5 base 8
            </summary>
        </member>
        <member name="F:Z0.OctalSym.o6">
            <summary>
            Specifies 6 base 8
            </summary>
        </member>
        <member name="F:Z0.OctalSym.o7">
            <summary>
            Specifies 7 base 8
            </summary>
        </member>
        <member name="F:Z0.OctalSym.First">
            <summary>
            The first declared symbol
            </summary>
        </member>
        <member name="F:Z0.OctalSym.Last">
            <summary>
            The last declared symbol
            </summary>
        </member>
        <member name="F:Z0.OctalSym.Count">
            <summary>
            The symbol declaration count
            </summary>
        </member>
        <member name="T:Z0.Pow2x1">
            <summary>
            Defines 1
            </summary>
        </member>
        <member name="F:Z0.Pow2x1.P2ᐞ00">
            <summary>
            2^0 = 1
            </summary>
        </member>
        <member name="T:Z0.Pow2x16">
            <summary>
            Defines integers of the form 2^n where n = 0,..,15
            </summary>
        </member>
        <member name="F:Z0.Pow2x16.P2ᐞ00">
            <summary>
            2^0 = 1
            </summary>
        </member>
        <member name="F:Z0.Pow2x16.P2ᐞ01">
            <summary>
            2^1 = 2
            </summary>
        </member>
        <member name="F:Z0.Pow2x16.P2ᐞ02">
            <summary>
            2^2 = 4
            </summary>
        </member>
        <member name="F:Z0.Pow2x16.P2ᐞ03">
            <summary>
            2^3 = 8
            </summary>
        </member>
        <member name="F:Z0.Pow2x16.P2ᐞ04">
            <summary>
            2^4 = 16
            </summary>
        </member>
        <member name="F:Z0.Pow2x16.P2ᐞ05">
            <summary>
            2^5 = 32
            </summary>
        </member>
        <member name="F:Z0.Pow2x16.P2ᐞ06">
            <summary>
            2^6 = 64
            </summary>
        </member>
        <member name="F:Z0.Pow2x16.P2ᐞ07">
            <summary>
            2^7 = 128
            </summary>
        </member>
        <member name="F:Z0.Pow2x16.P2ᐞ08">
            <summary>
            2^8 = 256
            </summary>
        </member>
        <member name="F:Z0.Pow2x16.P2ᐞ09">
            <summary>
            2^9 = 512
            </summary>
        </member>
        <member name="F:Z0.Pow2x16.P2ᐞ10">
            <summary>
            2^10 = 1024
            </summary>
        </member>
        <member name="F:Z0.Pow2x16.P2ᐞ11">
            <summary>
            2^11 = 2048
            </summary>
        </member>
        <member name="F:Z0.Pow2x16.P2ᐞ12">
            <summary>
            2^12 = 4096
            </summary>
        </member>
        <member name="F:Z0.Pow2x16.P2ᐞ13">
            <summary>
            2^13 = 8192
            </summary>
        </member>
        <member name="F:Z0.Pow2x16.P2ᐞ14">
            <summary>
            2^14 = 16,384
            </summary>
        </member>
        <member name="F:Z0.Pow2x16.P2ᐞ15">
            <summary>
            2^15 = 32,768
            </summary>
        </member>
        <member name="T:Z0.Pow2x2">
            <summary>
            Defines integers of the form 2^n where n = 0,1
            </summary>
        </member>
        <member name="F:Z0.Pow2x2.P2ᐞ00">
            <summary>
            2^0 = 1
            </summary>
        </member>
        <member name="F:Z0.Pow2x2.P2ᐞ01">
            <summary>
            2^1 = 2
            </summary>
        </member>
        <member name="T:Z0.Pow2x3">
            <summary>
            Defines integers of the form 2^n where n = 0,..,2
            </summary>
        </member>
        <member name="F:Z0.Pow2x3.P2ᐞ00">
            <summary>
            2^0 = 1
            </summary>
        </member>
        <member name="F:Z0.Pow2x3.P2ᐞ01">
            <summary>
            2^1 = 2
            </summary>
        </member>
        <member name="F:Z0.Pow2x3.P2ᐞ02">
            <summary>
            2^2 = 4
            </summary>
        </member>
        <member name="T:Z0.Pow2x32">
            <summary>
            Defines integers of the form 2^n where n = 0,..,31
            </summary>
        </member>
        <member name="F:Z0.Pow2x32.P2ᐞ00">
            <summary>
            2^0 = 1
            </summary>
        </member>
        <member name="F:Z0.Pow2x32.P2ᐞ01">
            <summary>
            2^1 = 2
            </summary>
        </member>
        <member name="F:Z0.Pow2x32.P2ᐞ02">
            <summary>
            2^2 = 4
            </summary>
        </member>
        <member name="F:Z0.Pow2x32.P2ᐞ03">
            <summary>
            2^3 = 8
            </summary>
        </member>
        <member name="F:Z0.Pow2x32.P2ᐞ04">
            <summary>
            2^4 = 16
            </summary>
        </member>
        <member name="F:Z0.Pow2x32.P2ᐞ05">
            <summary>
            2^5 = 32
            </summary>
        </member>
        <member name="F:Z0.Pow2x32.P2ᐞ06">
            <summary>
            2^6 = 64
            </summary>
        </member>
        <member name="F:Z0.Pow2x32.P2ᐞ07">
            <summary>
            2^7 = 128
            </summary>
        </member>
        <member name="F:Z0.Pow2x32.P2ᐞ08">
            <summary>
            2^8 = 256
            </summary>
        </member>
        <member name="F:Z0.Pow2x32.P2ᐞ09">
            <summary>
            2^9 = 512
            </summary>
        </member>
        <member name="F:Z0.Pow2x32.P2ᐞ10">
            <summary>
            2^10 = 1024
            </summary>
        </member>
        <member name="F:Z0.Pow2x32.P2ᐞ11">
            <summary>
            2^11 = 2048
            </summary>
        </member>
        <member name="F:Z0.Pow2x32.P2ᐞ12">
            <summary>
            2^12 = 4096
            </summary>
        </member>
        <member name="F:Z0.Pow2x32.P2ᐞ13">
            <summary>
            2^13 = 8192
            </summary>
        </member>
        <member name="F:Z0.Pow2x32.P2ᐞ14">
            <summary>
            2^14 = 16,384
            </summary>
        </member>
        <member name="F:Z0.Pow2x32.P2ᐞ15">
            <summary>
            2^15 = 32,768
            </summary>
        </member>
        <member name="F:Z0.Pow2x32.P2ᐞ16">
            <summary>
            2^16 = 65,536
            </summary>
        </member>
        <member name="F:Z0.Pow2x32.P2ᐞ17">
            <summary>
            2^17 = 131,072
            </summary>
        </member>
        <member name="F:Z0.Pow2x32.P2ᐞ18">
            <summary>
            2^18 = 262,144
            </summary>
        </member>
        <member name="F:Z0.Pow2x32.P2ᐞ19">
            <summary>
            2^19 = 524,288
            </summary>
        </member>
        <member name="F:Z0.Pow2x32.P2ᐞ20">
            <summary>
            2^20 = 1,048,576
            </summary>
        </member>
        <member name="F:Z0.Pow2x32.P2ᐞ21">
            <summary>
            2^21 = 2,097,152
            </summary>
        </member>
        <member name="F:Z0.Pow2x32.P2ᐞ22">
            <summary>
            2^22 = 4,194,304
            </summary>
        </member>
        <member name="F:Z0.Pow2x32.P2ᐞ23">
            <summary>
            2^23 = 8,388,608
            </summary>
        </member>
        <member name="F:Z0.Pow2x32.P2ᐞ24">
            <summary>
            2^24 = 16,777,216
            </summary>
        </member>
        <member name="F:Z0.Pow2x32.P2ᐞ25">
            <summary>
            2^25 = 33,554,432
            </summary>
        </member>
        <member name="F:Z0.Pow2x32.P2ᐞ26">
            <summary>
            2^26 = 67,108,864 = 0x4000000
            </summary>
        </member>
        <member name="F:Z0.Pow2x32.P2ᐞ27">
            <summary>
            2^27 = 134,217,728 = 0x8000000
            </summary>
        </member>
        <member name="F:Z0.Pow2x32.P2ᐞ28">
            <summary>
            2^28 = 268,435,456 = 0x10000000
            </summary>
        </member>
        <member name="F:Z0.Pow2x32.P2ᐞ29">
            <summary>
            2^29 = 536,870,912 = 0x20000000,
            </summary>
        </member>
        <member name="F:Z0.Pow2x32.P2ᐞ30">
            <summary>
            2^30 = 1,073,741,824 = 0x40000000
            </summary>
        </member>
        <member name="F:Z0.Pow2x32.P2ᐞ31">
            <summary>
            2^31 = 2,147,483,648 = 0x80000000
            </summary>
        </member>
        <member name="T:Z0.Pow2x4">
            <summary>
            Defines integers of the form 2^n where n = 0,..,3
            </summary>
        </member>
        <member name="F:Z0.Pow2x4.P2ᐞ00">
            <summary>
            2^0 = 1
            </summary>
        </member>
        <member name="F:Z0.Pow2x4.P2ᐞ01">
            <summary>
            2^1 = 2
            </summary>
        </member>
        <member name="F:Z0.Pow2x4.P2ᐞ02">
            <summary>
            2^2 = 4
            </summary>
        </member>
        <member name="F:Z0.Pow2x4.P2ᐞ03">
            <summary>
            2^3 = 8
            </summary>
        </member>
        <member name="T:Z0.Pow2x64">
            <summary>
            Defines primal-representable powers of 2 and integers of the form 2^n - 1 where n = 0,..,64
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ00">
            <summary>
            2^0 = 1
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ01">
            <summary>
            2^1 = 2
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ02">
            <summary>
            2^2 = 4
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ03">
            <summary>
            2^3 = 8
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ04">
            <summary>
            2^4 = 16
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ05">
            <summary>
            2^5 = 32
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ06">
            <summary>
            2^6 = 64
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ07">
            <summary>
            2^7 = 128
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ08">
            <summary>
            2^8 = 256
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ09">
            <summary>
            2^9 = 512
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ10">
            <summary>
            2^10 = 1024
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ11">
            <summary>
            2^11 = 2048
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ12">
            <summary>
            2^12 = 4096
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ13">
            <summary>
            2^13 = 8192
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ14">
            <summary>
            2^14 = 16,384
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ15">
            <summary>
            2^15 = 32,768
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ16">
            <summary>
            2^16 = 65,536
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ17">
            <summary>
            2^17 = 131,072
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ18">
            <summary>
            2^18 = 262,144
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ19">
            <summary>
            2^19 = 524,288
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ20">
            <summary>
            2^20 = 1,048,576
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ21">
            <summary>
            2^21 = 2,097,152
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ22">
            <summary>
            2^22 = 4,194,304
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ23">
            <summary>
            2^23 = 8,388,608
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ24">
            <summary>
            2^24 = 16,777,216
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ25">
            <summary>
            2^25 = 33,554,432
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ26">
            <summary>
            2^26 = 67,108,864 = 0x4000000
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ27">
            <summary>
            2^27 = 134,217,728 = 0x8000000
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ28">
            <summary>
            2^28 = 268,435,456 = 0x10000000
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ29">
            <summary>
            2^29 = 536,870,912 = 0x20000000,
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ30">
            <summary>
            2^30 = 1,073,741,824 = 0x40000000
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ31">
            <summary>
            2^31 = 2,147,483,648 = 0x80000000
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ32">
            <summary>
            2^32 = 4,294,967,296 = 0x100000000
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ33">
            <summary>
            2^33
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ34">
            <summary>
            2^34
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ35">
            <summary>
            2^35
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ36">
            <summary>
            2^36
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ37">
            <summary>
            2^37
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ38">
            <summary>
            2^38
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ39">
            <summary>
            2^39
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ40">
            <summary>
            2^40
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ41">
            <summary>
            2^41
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ42">
            <summary>
            2^42
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ43">
            <summary>
            2^43
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ44">
            <summary>
            2^44
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ45">
            <summary>
            2^45
            </summary>
        </member>
        <member name="F:Z0.Pow2x64.P2ᐞ63">
            <summary>
            T63 = 9223372036854775808 
            </summary>
        </member>
        <member name="T:Z0.Pow2x8">
            <summary>
            Defines integers of the form 2^n where n = 0,..,7
            </summary>
        </member>
        <member name="F:Z0.Pow2x8.P2ᐞ00">
            <summary>
            2^0 = 1
            </summary>
        </member>
        <member name="F:Z0.Pow2x8.P2ᐞ01">
            <summary>
            2^1 = 2
            </summary>
        </member>
        <member name="F:Z0.Pow2x8.P2ᐞ02">
            <summary>
            2^2 = 4
            </summary>
        </member>
        <member name="F:Z0.Pow2x8.P2ᐞ03">
            <summary>
            2^3 = 8
            </summary>
        </member>
        <member name="F:Z0.Pow2x8.P2ᐞ04">
            <summary>
            2^4 = 16
            </summary>
        </member>
        <member name="F:Z0.Pow2x8.P2ᐞ05">
            <summary>
            2^5 = 32
            </summary>
        </member>
        <member name="F:Z0.Pow2x8.P2ᐞ06">
            <summary>
            2^6 = 64
            </summary>
        </member>
        <member name="F:Z0.Pow2x8.P2ᐞ07">
            <summary>
            2^7 = 128
            </summary>
        </member>
        <member name="T:Z0.SymNotKind">
            <summary>
            Defines symbols that aren't symbols
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Eq">
            <summary>
            ᙿ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ᙿ">
            <summary>
            Eq
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Gt">
            <summary>
            ᐳ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ᐳ">
            <summary>
            Gt
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Lt">
            <summary>
            ᐸ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ᐸ">
            <summary>
            Lt
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.And">
            <summary>
            Λ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Λ">
            <summary>
            And
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.SmallAnd">
            <summary>
            Ʌ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Ʌ">
            <summary>
            SmallAnd
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Or">
            <summary>
            V
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.V">
            <summary>
            Or
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.OrAlt">
            <summary>
            ᐯ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ᐯ">
            <summary>
            OrAlt
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Dagger">
            <summary>
            ተ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ተ">
            <summary>
            Dagger
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Plus">
            <summary>
            ᕀ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ᕀ">
            <summary>
            Plus
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Star">
            <summary>
            ᛡ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ᛡ">
            <summary>
            Star
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Tick">
            <summary>
            ᐟ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ᐟ">
            <summary>
            Tick
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.LeftTick">
            <summary>
            ヽ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ヽ">
            <summary>
            LeftTick
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Dash">
            <summary>
            ー
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ー">
            <summary>
            Dash
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.HalfDash">
            <summary>
            ｰ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ｰ">
            <summary>
            HalfDash
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.UpperDash">
            <summary>
            ᐨ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ᐨ">
            <summary>
            UpperDash
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Dot">
            <summary>
            ㆍ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ㆍ">
            <summary>
            Dot
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.TinyDot">
            <summary>
            ᐧ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ᐧ">
            <summary>
            TinyDot
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.SQuote">
            <summary>
            '
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ᑊ">
            <summary>
            SQuote
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.DQuote">
            <summary>
            ʺ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ʺ">
            <summary>
            DQuote
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Circle">
            <summary>
            ᐤ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ᐤ">
            <summary>
            Circle
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.HashExp">
            <summary>
            ᙾ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ᙾ">
            <summary>
            HashExp
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Up">
            <summary>
            ᐃ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ᐃ">
            <summary>
            Up
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Down">
            <summary>
            ᐁ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ᐁ">
            <summary>
            DeltaNot
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Left">
            <summary>
            ᐊ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ᐊ">
            <summary>
            Left
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Right">
            <summary>
            ᐅ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ᐅ">
            <summary>
            Right
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.FSlash">
            <summary>
            ノ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ノ">
            <summary>
            FSlash
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.FSlashSmall">
            <summary>
            ﾉ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ﾉ">
            <summary>
            FSlashSmall
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ArrowUp">
            <summary>
            ᛏ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ᛏ">
            <summary>
            ArrowUp
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.PlusSlant">
            <summary>
            ᚾ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ᚾ">
            <summary>
            PlusSlant
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ArrowDown">
            <summary>
            ᛎ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ᛎ">
            <summary>
            ArrowDown
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Q">
            <summary>
            ॽ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ॽ">
            <summary>
            Q
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Diamond">
            <summary>
            ᛜ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ᛜ">
            <summary>
            Diamond
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Two">
            <summary>
            ᒿ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ᒿ">
            <summary>
            Tow
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Three">
            <summary>
            З
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.З">
            <summary>
            Three
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Pipe">
            <summary>
            ᛁ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.LeftPipe">
            <summary>
            ǀ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ǀ">
            <summary>
            LeftPipe
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ForAll">
            <summary>
            ᗄ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ᗄ">
            <summary>
            ForAll
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ForSome">
            <summary>
            ヨ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ヨ">
            <summary>
            ForSome
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Box">
            <summary>
            ロ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ロ">
            <summary>
            Box
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Subset">
            <summary>
            ᑕ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ᑕ">
            <summary>
            Subset
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Superset">
            <summary>
            ᑐ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ᑐ">
            <summary>
            Superset
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.UpperSuperset">
            <summary>
            UpperSuperset
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ᐣ">
            <summary>
            UpperSuperset
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.RightIn">
            <summary>
            є
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.є">
            <summary>
            RightIn
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.LeftIn">
            <summary>
            э
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.э">
            <summary>
            LeftIn
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.CapX">
            <summary>
            П
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.П">
            <summary>
            Cap
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.CapGreek">
            <summary>
            Π
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Π">
            <summary>
            CapGreek
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Alpha">
            <summary>
            α
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.α">
            <summary>
            alpha
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Beta">
            <summary>
            β
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.β">
            <summary>
            beta
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Gamma">
            <summary>
            γ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.GammaUpper">
            <summary>
            Γ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Γ">
            <summary>
            GammaUpper
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Epsilon">
            <summary>
            ε
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ε">
            <summary>
            Epsilon
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.DeltaEps">
            <summary>
            δ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.δ">
            <summary>
            The delta of epsilon fame
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Delta">
            <summary>
            Δ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Δ">
            <summary>
            Delta
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Eta">
            <summary>
            η
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.η">
            <summary>
            Eta
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Omega">
            <summary>
            ω
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ω">
            <summary>
            Omega
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Ohm">
            <summary>
            Ω
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Ω">
            <summary>
            Ohm
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Lambda">
            <summary>
            λ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.λ">
            <summary>
            Lambda
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Pi">
            <summary>
            π
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.π">
            <summary>
            Pi
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.BigPi">
            <summary>
            ℿ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ℿ">
            <summary>
            BigPi
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Mu">
            <summary>
            μ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.μ">
            <summary>
            Mu
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Psi">
            <summary>
            ψ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ψ">
            <summary>
            Psi
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Rho">
            <summary>
            ρ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ρ">
            <summary>
            Rho
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Sigma">
            <summary>
            σ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.σ">
            <summary>
            Sigma
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Sum">
            <summary>
            Σ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Σ">
            <summary>
            Sum
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Tau">
            <summary>
            τ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.τ">
            <summary>
            Tau
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Chi">
            <summary>
            χ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.χ">
            <summary>
            Chi
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Iota">
            <summary>
            ι
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ι">
            <summary>
            Iota
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Oh">
            <summary>
            Ο
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Ο">
            <summary>
            Oh
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Nu">
            <summary>
            ν
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ν">
            <summary>
            Nu
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Natural">
            <summary>
            ℕ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ℕ">
            <summary>
            Natural
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Integral">
            <summary>
            ℤ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ℤ">
            <summary>
            Integral
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Real">
            <summary>
            ℝ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ℝ">
            <summary>
            Real
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Rational">
            <summary>
            ℚ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ℚ">
            <summary>
            Rational
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Prime">
            <summary>
            ℙ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ℙ">
            <summary>
            Prime
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Complex">
            <summary>
            ℂ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ℂ">
            <summary>
            Complex
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Half">
            <summary>
            Half (Quaternions)
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ℍ">
            <summary>
            Half (Quaternions)
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Aleph">
            <summary>
            ℵ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ℵ">
            <summary>
            Aleph
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ℷ">
            <summary>
            Gimel
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.DSmall">
            <summary>
            ⅆ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ⅆ">
            <summary>
            DSmall
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ⅇ">
            <summary>
            ESmall
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ⅈ">
            <summary>
            ISmall
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ℹ">
            <summary>
            IThick
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.JSmall">
            <summary>
            ⅉ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ⅉ">
            <summary>
            JSmall
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.HSmall">
            <summary>
            ℎ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ℎ">
            <summary>
            HSmall
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.OSmall">
            <summary>
            ο
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ο">
            <summary>
            OSmall
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.USmall">
            <summary>
            υ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.υ">
            <summary>
            USmall
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ExpDelta">
            <summary>
            ᐞ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ᐞ">
            <summary>
            ExpDelta
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ExpW">
            <summary>
            ᐜ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ᐜ">
            <summary>
            ExpW
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ExpPlus">
            <summary>
            ᐩ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ᐩ">
            <summary>
            ExpPlus
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ExpT">
            <summary>
            ᐪ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ᐪ">
            <summary>
            ExpT
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Cup">
            <summary>
            ᑌ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ᑌ">
            <summary>
            Cup
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Cap">
            <summary>
            ᑎ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ᑎ">
            <summary>
            Cap
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ExpCup">
            <summary>
            ᐡ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ᐡ">
            <summary>
            ExpCup
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ᐢ">
            <summary>
            ExpCap
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.Exp2">
            <summary>
            ᒾ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ExpZ">
            <summary>
            ᙆ
            </summary>
        </member>
        <member name="F:Z0.SymNotKind.ExpS">
            <summary>
            ᙚ
            </summary>
        </member>
        <member name="T:Z0.SymNot">
            <summary>
            Defines an arbitrary collection of legal identifies that look like symbols
            </summary>
        </member>
        <member name="T:Z0.Pow2">
            <summary>
            Defines power-of-2 literals raning from 2^0 - 2^63
            </summary>
        </member>
        <member name="M:Z0.Pow2.pow(System.Byte)">
            <summary>
            Computes 2^i where i is an integer value in the interval [0,63]
            </summary>
            <param name="i">The exponent</param>
        </member>
        <member name="M:Z0.Pow2.pow(System.Int32)">
            <summary>
            Computes 2^i where i is an integer value in the interval [0,63]
            </summary>
            <param name="i">The exponent</param>
        </member>
        <member name="M:Z0.Pow2.log2(System.Byte)">
            <summary>
            Computes floor(log(src,2))
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.Pow2.log2(System.UInt16)">
            <summary>
            Computes floor(log(src,2))
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.Pow2.log2(System.UInt32)">
            <summary>
            Computes floor(log(src,2))
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="M:Z0.Pow2.log2(System.UInt64)">
            <summary>
            Computes floor(log(src,2))
            </summary>
            <param name="src">The source value</param>
        </member>
        <member name="F:Z0.Pow2.T00">
            <summary>
            2^0 = 1
            </summary>
        </member>
        <member name="F:Z0.Pow2.T01">
            <summary>
            2^1 = 2
            </summary>
        </member>
        <member name="F:Z0.Pow2.T02">
            <summary>
            2^2 = 4
            </summary>
        </member>
        <member name="F:Z0.Pow2.T03">
            <summary>
            2^3 = 8
            </summary>
        </member>
        <member name="F:Z0.Pow2.T04">
            <summary>
            2^4 = 16
            </summary>
        </member>
        <member name="F:Z0.Pow2.T05">
            <summary>
            2^5 = 32
            </summary>
        </member>
        <member name="F:Z0.Pow2.T06">
            <summary>
            2^6 = 64
            </summary>
        </member>
        <member name="F:Z0.Pow2.T07">
            <summary>
            2^7 = 128
            </summary>
        </member>
        <member name="F:Z0.Pow2.T08">
            <summary>
            2^8 = 256 = UInt8.MaxValue + 1
            </summary>
        </member>
        <member name="F:Z0.Pow2.T09">
            <summary>
            2^9 = 512
            </summary>
        </member>
        <member name="F:Z0.Pow2.T10">
            <summary>
            2^10 = 1024
            </summary>
        </member>
        <member name="F:Z0.Pow2.T11">
            <summary>
            2^11 = 2048
            </summary>
        </member>
        <member name="F:Z0.Pow2.T12">
            <summary>
            2^12 = 4096
            </summary>
        </member>
        <member name="F:Z0.Pow2.T13">
            <summary>
            2^13 = 8192
            </summary>
        </member>
        <member name="F:Z0.Pow2.T14">
            <summary>
            2^14 = 16,384
            </summary>
        </member>
        <member name="F:Z0.Pow2.T15">
            <summary>
            2^15 = 32,768
            </summary>
        </member>
        <member name="F:Z0.Pow2.T16">
            <summary>
            2^16 = 65,536
            </summary>
        </member>
        <member name="F:Z0.Pow2.T17">
            <summary>
            2^17 = 131,072
            </summary>
        </member>
        <member name="F:Z0.Pow2.T18">
            <summary>
            2^18 = 262,144
            </summary>
        </member>
        <member name="F:Z0.Pow2.T19">
            <summary>
            2^19 = 524,288
            </summary>
        </member>
        <member name="F:Z0.Pow2.T20">
            <summary>
            2^20 = 1,048,576
            </summary>
        </member>
        <member name="F:Z0.Pow2.T21">
            <summary>
            2^21 = 2_097_152
            </summary>
        </member>
        <member name="F:Z0.Pow2.T22">
            <summary>
            2^22 = 4_194_304
            </summary>
        </member>
        <member name="F:Z0.Pow2.T23">
            <summary>
            2^23 = 8,388,608
            </summary>
        </member>
        <member name="F:Z0.Pow2.T24">
            <summary>
            2^24 = 16,777,216
            </summary>
        </member>
        <member name="F:Z0.Pow2.T25">
            <summary>
            2^25 = 33,554,432
            </summary>
        </member>
        <member name="F:Z0.Pow2.T26">
            <summary>
            2^26 = 67,108,864 = 0x4000000
            </summary>
        </member>
        <member name="F:Z0.Pow2.T27">
            <summary>
            2^27 = 134,217,728 = 0x8000000
            </summary>
        </member>
        <member name="F:Z0.Pow2.T28">
            <summary>
            2^28 = 268,435,456 = 0x10000000
            </summary>
        </member>
        <member name="F:Z0.Pow2.T29">
            <summary>
            2^29 = 536_870_912 = 0x20000000;
            </summary>
        </member>
        <member name="F:Z0.Pow2.T30">
            <summary>
            2^30 = 1,073,741,824 = 0x40000000
            </summary>
        </member>
        <member name="F:Z0.Pow2.T31">
            <summary>
            2^31 = 2,147,483,648 = 0x80000000
            </summary>
        </member>
        <member name="F:Z0.Pow2.T32">
            <summary>
            2^32 = 4,294,967,296 = 0x100000000
            </summary>
        </member>
        <member name="F:Z0.Pow2.T63">
            <summary>
            T63 = 9223372036854775808
            </summary>
        </member>
        <member name="M:Z0.SymbolQuery.space(System.Char)">
            <summary>
            Tests whether a character is a space
            </summary>
            <param name="src">The symbol to test</param>
        </member>
        <member name="M:Z0.SymbolQuery.tab(System.Char)">
            <summary>
            Tests whether a character is a space
            </summary>
            <param name="src">The symbol to test</param>
        </member>
        <member name="M:Z0.SymbolQuery.whitespace(System.Char)">
            <summary>
            Tests whether a character is designated as whitespace
            </summary>
            <param name="c">The character to test</param>
        </member>
        <member name="F:Z0.RP.Dash4">
            <summary>
            Defines a literal consisting of 4 '-' characters
            </summary>
        </member>
        <member name="F:Z0.RP.Dash5">
            <summary>
            Defines a literal consisting of 5 '-' characters
            </summary>
        </member>
        <member name="F:Z0.RP.Dash40">
            <summary>
            Defines a literal consisting of 40 '-' characters
            </summary>
        </member>
        <member name="F:Z0.RP.Dash80">
            <summary>
            Defines the default extension for structured data
            </summary>
        </member>
        <member name="F:Z0.RP.SegSep">
            <summary>
            Delimiter between total/segment widths of a segmented type
            </summary>
        </member>
        <member name="F:Z0.RP.Plural">
            <summary>
            Pluralizes something
            </summary>
        </member>
        <member name="F:Z0.RP.PluralPosses">
            <summary>
            Suffix used to pluralize a possessive
            </summary>
        </member>
        <member name="F:Z0.RP.FieldSep">
            <summary>
            Defines the default field delimiter
            </summary>
        </member>
        <member name="F:Z0.RP.Pipe">
            <summary>
            Defines the literal '|'
            </summary>
        </member>
        <member name="F:Z0.RP.Dot">
            <summary>
            Defines the literal '.'
            </summary>
        </member>
        <member name="F:Z0.RP.ExtSep">
            <summary>
            Defines the default extension delimiter
            </summary>
        </member>
        <member name="F:Z0.RP.DataExt">
            <summary>
            Defines the default extension for structured data
            </summary>
        </member>
        <member name="F:Z0.RP.QSlot1">
            <summary>
            Defines the literal '"{1}"'
            </summary>
        </member>
        <member name="F:Z0.RP.QSlot2">
            <summary>
            Defines the literal '"{2}"'
            </summary>
        </member>
        <member name="F:Z0.RP.QSlot3">
            <summary>
            Defines the literal '"{3}"'
            </summary>
        </member>
        <member name="F:Z0.RP.QSlot4">
            <summary>
            Defines the literal '"{4}"'
            </summary>
        </member>
        <member name="F:Z0.RP.OpenSlot">
            <summary>
            Defines the literal '{'
            </summary>
        </member>
        <member name="F:Z0.RP.CloseSlot">
            <summary>
            Defines the literal '}'
            </summary>
        </member>
        <member name="F:Z0.RP.OpenQSlot">
            <summary>
            Defines the literal '"{'
            </summary>
        </member>
        <member name="F:Z0.RP.CloseQSlot">
            <summary>
            Defines the literal '"}'
            </summary>
        </member>
        <member name="F:Z0.RP.QSlot0">
            <summary>
            Defines the literal '"{0}"'
            </summary>
        </member>
        <member name="F:Z0.RP.Slot0">
            <summary>
            Defines the literal '{0}'
            </summary>
        </member>
        <member name="F:Z0.RP.Slot1">
            <summary>
            Defines the literal '{1}'
            </summary>
        </member>
        <member name="F:Z0.RP.Slot2">
            <summary>
            Defines the literal '{2}'
            </summary>
        </member>
        <member name="F:Z0.RP.Slot3">
            <summary>
            Defines the literal '{3}'
            </summary>
        </member>
        <member name="F:Z0.RP.Slot4">
            <summary>
            Defines the literal '{4}'
            </summary>
        </member>
        <member name="F:Z0.RP.Slot5">
            <summary>
            Defines the literal {5}'
            </summary>
        </member>
        <member name="F:Z0.RP.Slot6">
            <summary>
            Defines the literal "{6}"
            </summary>
        </member>
        <member name="F:Z0.RP.Slot7">
            <summary>
            Defines the literal "{7}"
            </summary>
        </member>
        <member name="F:Z0.RP.Slot8">
            <summary>
            Defines the literal "{8}"
            </summary>
        </member>
        <member name="F:Z0.RP.Slot0Space">
            <summary>
            Defines the literal "{0} "
            </summary>
        </member>
        <member name="F:Z0.RP.Slot1Space">
            <summary>
            Defines the literal "{1} "
            </summary>
        </member>
        <member name="F:Z0.RP.Slot2Space">
            <summary>
            Defines the literal "{2} "
            </summary>
        </member>
        <member name="F:Z0.RP.Slot3Space">
            <summary>
            Defines the literal "{3} "
            </summary>
        </member>
        <member name="F:Z0.RP.Slot4Space">
            <summary>
            Defines the literal "{4} "
            </summary>
        </member>
        <member name="F:Z0.RP.Slot5Space">
            <summary>
            Defines the literal "{5} "
            </summary>
        </member>
        <member name="F:Z0.RP.SlottedSpacePipe">
            <summary>
            Defines the literal '| {0}'
            </summary>
        </member>
        <member name="F:Z0.RP.PSx2">
            <summary>
            Defines the literal '{0} | {1}'
            </summary>
        </member>
        <member name="F:Z0.RP.PSx3">
            <summary>
            Defines the literal '{0} | {1} | {2}'
            </summary>
        </member>
        <member name="F:Z0.RP.PSx4">
            <summary>
            Defines the literal '{0} | {1} | {2} | {3}'
            </summary>
        </member>
        <member name="F:Z0.RP.PSx5">
            <summary>
            Defines the literal '{0} | {1} | {2} | {3} | {4}'
            </summary>
        </member>
        <member name="F:Z0.RP.PSx6">
            <summary>
            Defines the literal '| {0} | {1} | {2} | {3} | {4} | {5}'
            </summary>
        </member>
        <member name="F:Z0.RP.PSx7">
            <summary>
            Defines the literal '| {0} | {1} | {2} | {3} | {4} | {5} | {6}'
            </summary>
        </member>
        <member name="F:Z0.RP.JsonProp">
            <summary>
            Defines the literal '"{0}": "{1}"'
            </summary>
        </member>
        <member name="F:Z0.RP.SlotPad0x4">
            <summary>
            Defines a right-padded slot of width 4
            </summary>
        </member>
        <member name="F:Z0.RP.SlotPad0x8">
            <summary>
            Defines a right-padded slot of width 8
            </summary>
        </member>
        <member name="F:Z0.RP.SlotPad0x12">
            <summary>
            Defines a right-padded slot of width 12
            </summary>
        </member>
        <member name="F:Z0.RP.SlotPad0x16">
            <summary>
            Defines a right-padded slot of width 16
            </summary>
        </member>
        <member name="F:Z0.RP.SlotPad0x32">
            <summary>
            Defines a right-padded slot of width 32
            </summary>
        </member>
        <member name="F:Z0.RP.SS0">
            <summary>
            Defines the literal " {0}"
            </summary>
        </member>
        <member name="F:Z0.RP.SS1">
            <summary>
            Defines the literal " {1}"
            </summary>
        </member>
        <member name="F:Z0.RP.SS2">
            <summary>
            Defines the literal " {2}"
            </summary>
        </member>
        <member name="F:Z0.RP.SS3">
            <summary>
            Defines the literal " {3}"
            </summary>
        </member>
        <member name="F:Z0.RP.SS4">
            <summary>
            Defines the literal ' {4}'
            </summary>
        </member>
        <member name="F:Z0.RP.SS5">
            <summary>
            Defines the literal ' {5}'
            </summary>
        </member>
        <member name="F:Z0.RP.SSx2">
            <summary>
            Defines the literal '{0} {1}'
            </summary>
        </member>
        <member name="F:Z0.RP.SSx3">
            <summary>
            Defines the literal '{0} {1} {2}'
            </summary>
        </member>
        <member name="F:Z0.RP.SSx4">
            <summary>
            Defines the literal '{0} {1} {2} {3}'
            </summary>
        </member>
        <member name="F:Z0.RP.SSx5">
            <summary>
            Defines the literal '{0} {1} {2} {3} {4}'
            </summary>
        </member>
        <member name="F:Z0.RP.SS1x2">
            <summary>
            Defines the literal "{1} {2}"
            </summary>
        </member>
        <member name="F:Z0.RP.SlotDot2">
            <summary>
            Defines the literal '{0}.{1}'
            </summary>
        </member>
        <member name="F:Z0.RP.SlotDot3">
            <summary>
            Defines the literal '{0}.{1}.{2}'
            </summary>
        </member>
        <member name="F:Z0.RP.SlotDot4">
            <summary>
            Defines the literal '{0}.{1}.{2}.{3}'
            </summary>
        </member>
        <member name="F:Z0.RP.SlotDot5">
            <summary>
            Defines the literal '{0}.{1}.{2}.{3}.{4}'
            </summary>
        </member>
        <member name="F:Z0.RP.Setting">
            <summary>
            Defines the canonical setting format
            </summary>
        </member>
        <member name="F:Z0.RP.SpacedPipe">
            <summary>
            Defines the literal ' | '
            </summary>
        </member>
        <member name="F:Z0.RP.Spaced2">
            <summary>
            Defines a string consisting of 2 spaces
            </summary>
        </member>
        <member name="F:Z0.RP.Spaced3">
            <summary>
            Defines a string consisting of 3 spaces
            </summary>
        </member>
        <member name="F:Z0.RP.Spaced4">
            <summary>
            Defines a string consisting of 4 spaces
            </summary>
        </member>
        <member name="F:Z0.RP.Spaced5">
            <summary>
            Defines a string consisting of 5 spaces
            </summary>
        </member>
        <member name="F:Z0.RP.Spaced6">
            <summary>
            Defines a string consisting of 6 spaces
            </summary>
        </member>
        <member name="F:Z0.RP.Spaced7">
            <summary>
            Defines a string consisting of 7 spaces
            </summary>
        </member>
        <member name="F:Z0.RP.Spaced8">
            <summary>
            Defines a string consisting of 8 spaces
            </summary>
        </member>
        <member name="F:Z0.RP.Spaced9">
            <summary>
            Defines a string consisting of 9 spaces
            </summary>
        </member>
        <member name="F:Z0.RP.Spaced10">
            <summary>
            Defines a string consisting of 10 spaces
            </summary>
        </member>
        <member name="F:Z0.RP.Spaced11">
            <summary>
            Defines a string consisting of 11 spaces
            </summary>
        </member>
        <member name="F:Z0.RP.Spaced12">
            <summary>
            Defines a string consisting of 12 spaces
            </summary>
        </member>
        <member name="F:Z0.RP.Spaced13">
            <summary>
            Defines a string consisting of 13 spaces
            </summary>
        </member>
        <member name="F:Z0.RP.Spaced16">
            <summary>
            Defines a string consisting of 16 spaces
            </summary>
        </member>
        <member name="F:Z0.RP.Spaced32">
            <summary>
            Defines a string consisting of 32 spaces
            </summary>
        </member>
        <member name="F:Z0.RP.Spaced48">
            <summary>
            Defines a string consisting of 48 spaces
            </summary>
        </member>
        <member name="F:Z0.RP.Spaced64">
            <summary>
            Defines a string consisting of 64 spaces
            </summary>
        </member>
        <member name="F:Z0.RP.Spaced128">
            <summary>
            Defines a string consisting of 128 spaces
            </summary>
        </member>
        <member name="F:Z0.RP.Spaced256">
            <summary>
            Defines a string consisting of 256 spaces
            </summary>
        </member>
        <member name="F:Z0.RP.Spaced512">
            <summary>
            Defines a string consisting of 512 spaces
            </summary>
        </member>
        <member name="F:Z0.RP.OpenTuple">
            <summary>
            Defines the literal '('
            </summary>
        </member>
        <member name="F:Z0.RP.CloseTuple">
            <summary>
            Defines the literal ')'
            </summary>
        </member>
        <member name="F:Z0.RP.SpacePipe">
            <summary>
            Defines the literal " |"
            </summary>
        </member>
        <member name="F:Z0.RP.ArrowAxB">
            <summary>
            Defines the literal '{0} -> {1}'
            </summary>
        </member>
        <member name="M:Z0.text.concat(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Concatenates a sequence of values with no intervening delimiter
            </summary>
            <param name="src">The characters to concatenate</param>
        </member>
        <member name="M:Z0.text.concat(System.String,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Joins the string representation of a sequence of items interspersed by a separator
            </summary>
            <param name="sep">The value delimiter</param>
            <param name="src">The values to be joined</param>
        </member>
        <member name="M:Z0.text.concat(System.Char,System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Concatenates a sequence of strings interspersed by a character delimiter with a space on either side
            </summary>
            <param name="src">The characters to concatenate</param>
        </member>
        <member name="M:Z0.text.count(System.ReadOnlySpan{System.String},System.ReadOnlySpan{System.Char})">
            <summary>
            Counts the number of source characters that exist an a specified match set
            </summary>
            <param name="src"></param>
            <param name="match"></param>
        </member>
        <member name="M:Z0.text.enquote(System.Object)">
            <summary>
            Encloses the supplied text in quotation marks
            </summary>
            <param name="content">The content to be quoted</param>
        </member>
        <member name="M:Z0.text.dots(System.Int32)">
            <summary>
            Produces "..." where count has the default value of 3
            </summary>
        </member>
        <member name="M:Z0.text.indented(System.String,System.Int32)">
            <summary>
            Produces an indented string
            </summary>
            <param name="offset">The left indentation offset </param>
        </member>
        <member name="M:Z0.text.spaces(System.Int32)">
            <summary>
            Produces a string containing a specified number of spaces
            </summary>
            <param name="count">The number of spaces the output string should contain</param>
        </member>
        <member name="M:Z0.text.quote(System.String)">
            <summary>
            Produces a quote
            </summary>
        </member>
        <member name="M:Z0.text.lspace(System.Object)">
            <summary>
            Prepends a space to the source content
            </summary>
            <param name="content">The source content</param>
        </member>
        <member name="M:Z0.text.ltrim(System.String,System.Char[])">
            <summary>
            Trims leading characters when matched
            </summary>
            <param name="src">The text to manipulate</param>
            <param name="chars">The leading characters to remove</param>
        </member>
        <member name="M:Z0.text.rtrim(System.String,System.Char[])">
            <summary>
            Trims trailing characters when matched
            </summary>
            <param name="src">The text to manipulate</param>
            <param name="chars">The leading characters to remove</param>
        </member>
        <member name="M:Z0.text.line(System.String)">
            <summary>
            Produces a line of content
            </summary>
            <param name="src">The line content</param>
        </member>
        <member name="M:Z0.text.line(System.Collections.Generic.IEnumerable{System.Object})">
            <summary>
            Renders each item from a sequence as list of values, delimited by end-of-line
            </summary>
            <param name="src">The content to enclose</param>
        </member>
        <member name="T:Z0.IBitWidth">
            <summary>
            Defines an aspect that specifies a bit width
            </summary>
        </member>
        <member name="P:Z0.ICellWidth.CellWidth">
            <summary>
            Defines a class specifier synonym to facilitate disambiguation
            </summary>
        </member>
        <member name="T:Z0.IDataType">
            <summary>
            Characterizes non-parametric aspects of a user-defined data type
            </summary>
        </member>
        <member name="T:Z0.IDataType`1">
            <summary>
            Characterizes the shape of a user-defined structural data type
            </summary>
            <typeparam name="F">The reifying type</typeparam>
        </member>
        <member name="T:Z0.IDataType`2">
            <summary>
            Characterizes the shape of a user-defined structural data type
            </summary>
            <typeparam name="F">The reifying type</typeparam>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:Z0.INumericWidth.NumericWidth">
            <summary>
            Defines a class specifier synonym to facilitate disambiguation
            </summary>
        </member>
        <member name="P:Z0.ITypeWidth.TypeWidth">
            <summary>
            Refines the specificity of the class specifier
            </summary>
        </member>
        <member name="P:Z0.IVectorWidth.VectorWidth">
            <summary>
            Defines a class specifier for use as a discriminator
            </summary>
        </member>
        <member name="T:Z0.CellWidth">
            <summary>
            Defines a <see cref="T:Z0.DataWidth"/> constrained to widths supported by available fixed-width types
            </summary>
        </member>
        <member name="F:Z0.CellWidth.None">
            <summary>
            Void
            </summary>
        </member>
        <member name="F:Z0.CellWidth.W1">
            <summary>
            Indicates a bit-width of 1
            </summary>
        </member>
        <member name="F:Z0.CellWidth.W2">
            <summary>
            Indicates a bit-width of 2
            </summary>
        </member>
        <member name="F:Z0.CellWidth.W4">
            <summary>
            Indicates a bit-width of 4
            </summary>
        </member>
        <member name="F:Z0.CellWidth.W8">
            <summary>
            Indicates a bit-width of 8
            </summary>
        </member>
        <member name="F:Z0.CellWidth.W16">
            <summary>
            Indicates a bit-width of 16
            </summary>
        </member>
        <member name="F:Z0.CellWidth.W32">
            <summary>
            Indicates a bit-width of 32
            </summary>
        </member>
        <member name="F:Z0.CellWidth.W64">
            <summary>
            Indicates a bit-width of 64
            </summary>
        </member>
        <member name="F:Z0.CellWidth.W128">
            <summary>
            Indicates a bit-width of 128
            </summary>
        </member>
        <member name="F:Z0.CellWidth.W256">
            <summary>
            Indicates a bit-width of 256
            </summary>
        </member>
        <member name="F:Z0.CellWidth.W512">
            <summary>
            Indicates a bit-width of 512
            </summary>
        </member>
        <member name="F:Z0.CellWidth.W1024">
            <summary>
            Indicates a bit-width of 1024
            </summary>
        </member>
        <member name="F:Z0.CellWidth.Numeric">
            <summary>
            Classifies widths that correspond numeric primitives
            </summary>
        </member>
        <member name="F:Z0.CellWidth.Vector">
            <summary>
            Classifies widths that correspond to vector primitives
            </summary>
        </member>
        <member name="F:Z0.CellWidth.TypeWidths">
            <summary>
            Classifies widths that correspond to numeric and vector primitives
            </summary>
        </member>
        <member name="T:Z0.DataWidth">
            <summary>
            Defines reference literals that specify data bit-widths
            </summary>
        </member>
        <member name="F:Z0.DataWidth.None">
            <summary>
            Nothingness
            </summary>
        </member>
        <member name="F:Z0.DataWidth.W1">
            <summary>
            Indicates a bit-width of 1
            </summary>
        </member>
        <member name="F:Z0.DataWidth.W2">
            <summary>
            Indicates a bit-width of 2
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Z0.DataWidth.W3" -->
        <member name="F:Z0.DataWidth.W4">
            <summary>
            Indicates a bit-width of 4
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "F:Z0.DataWidth.W5" -->
        <!-- Badly formed XML comment ignored for member "F:Z0.DataWidth.W6" -->
        <!-- Badly formed XML comment ignored for member "F:Z0.DataWidth.W7" -->
        <member name="F:Z0.DataWidth.W8">
            <summary>
            Indicates a bit-width of 8
            </summary>
        </member>
        <member name="F:Z0.DataWidth.W9">
            <summary>
            Indicates a bit-width of 9
            </summary>
        </member>
        <member name="F:Z0.DataWidth.W10">
            <summary>
            Indicates a bit-width of 10
            </summary>
        </member>
        <member name="F:Z0.DataWidth.W11">
            <summary>
            Indicates a bit-width of 11
            </summary>
        </member>
        <member name="F:Z0.DataWidth.W12">
            <summary>
            Indicates a bit-width of 12
            </summary>
        </member>
        <member name="F:Z0.DataWidth.W13">
            <summary>
            Indicates a bit-width of 13
            </summary>
        </member>
        <member name="F:Z0.DataWidth.W14">
            <summary>
            Indicates a bit-width of 14
            </summary>
        </member>
        <member name="F:Z0.DataWidth.W15">
            <summary>
            Indicates a bit-width of 15
            </summary>
        </member>
        <member name="F:Z0.DataWidth.W16">
            <summary>
            Indicates a bit-width of 16
            </summary>
        </member>
        <member name="F:Z0.DataWidth.W17">
            <summary>
            Indicates a bit-width of 17
            </summary>
        </member>
        <member name="F:Z0.DataWidth.W18">
            <summary>
            Indicates a bit-width of 18
            </summary>
        </member>
        <member name="F:Z0.DataWidth.W19">
            <summary>
            Indicates a bit-width of 19
            </summary>
        </member>
        <member name="F:Z0.DataWidth.W20">
            <summary>
            Indicates a bit-width of 20
            </summary>
        </member>
        <member name="F:Z0.DataWidth.W21">
            <summary>
            Indicates a bit-width of 21
            </summary>
        </member>
        <member name="F:Z0.DataWidth.W22">
            <summary>
            Indicates a bit-width of 22
            </summary>
        </member>
        <member name="F:Z0.DataWidth.W23">
            <summary>
            Indicates a bit-width of 23
            </summary>
        </member>
        <member name="F:Z0.DataWidth.W24">
            <summary>
            Indicates a bit-width of 24
            </summary>
        </member>
        <member name="F:Z0.DataWidth.W32">
            <summary>
            Indicates a bit-width of 32
            </summary>
        </member>
        <member name="F:Z0.DataWidth.W40">
            <summary>
            Indicates a bit-width of 40
            </summary>
        </member>
        <member name="F:Z0.DataWidth.W48">
            <summary>
            Indicates a bit-width of 48
            </summary>
        </member>
        <member name="F:Z0.DataWidth.W56">
            <summary>
            Indicates a bit-width of 56
            </summary>
        </member>
        <member name="F:Z0.DataWidth.W64">
            <summary>
            Indicates a bit-width of 64
            </summary>
        </member>
        <member name="F:Z0.DataWidth.W80">
            <summary>
            Indicates a bit-width of 80
            </summary>
        </member>
        <member name="F:Z0.DataWidth.W128">
            <summary>
            Indicates a bit-width of 128
            </summary>
        </member>
        <member name="F:Z0.DataWidth.W256">
            <summary>
            Indicates a bit-width of 256
            </summary>
        </member>
        <member name="F:Z0.DataWidth.W512">
            <summary>
            Indicates a bit-width of 512
            </summary>
        </member>
        <member name="F:Z0.DataWidth.W1024">
            <summary>
            Indicates a bit-width of 1024
            </summary>
        </member>
        <member name="T:Z0.NumericWidth">
            <summary>
            Defines a <see cref="T:Z0.DataWidth"/> subset that is constrained to widths of numeric primitives
            </summary>
        </member>
        <member name="F:Z0.NumericWidth.None">
            <summary>
            A width without substance
            </summary>
        </member>
        <member name="F:Z0.NumericWidth.W1">
            <summary>
            Indicates a synthetic, but useful, bit-width of 1
            </summary>
        </member>
        <member name="F:Z0.NumericWidth.W8">
            <summary>
            Indicates a bit-width of 8
            </summary>
        </member>
        <member name="F:Z0.NumericWidth.W16">
            <summary>
            Indicates a bit-width of 16
            </summary>
        </member>
        <member name="F:Z0.NumericWidth.W32">
            <summary>
            Indicates a bit-width of 32
            </summary>
        </member>
        <member name="F:Z0.NumericWidth.W64">
            <summary>
            Indicates a bit-width of 64
            </summary>
        </member>
        <member name="T:Z0.TypeWidth">
            <summary>
            Defines a <see cref="T:Z0.DataWidth"/> subset that is constrained to widths that correspond
            to scalar primitives or vectorized registers
            </summary>
        </member>
        <member name="F:Z0.TypeWidth.None">
            <summary>
            Vapid
            </summary>
        </member>
        <member name="F:Z0.TypeWidth.W1">
            <summary>
            Indicates a bit-width of 1
            </summary>
            <remarks>
            Ok, this one is synthetic; but it is useful to pretend that the type system
            supports 1-bit types
            </remarks>
        </member>
        <member name="F:Z0.TypeWidth.W8">
            <summary>
            Indicates a bit-width of 8
            </summary>
        </member>
        <member name="F:Z0.TypeWidth.W16">
            <summary>
            Indicates a bit-width of 16
            </summary>
        </member>
        <member name="F:Z0.TypeWidth.W32">
            <summary>
            Indicates a bit-width of 32
            </summary>
        </member>
        <member name="F:Z0.TypeWidth.W64">
            <summary>
            Indicates a bit-width of 64
            </summary>
        </member>
        <member name="F:Z0.TypeWidth.W128">
            <summary>
            Indicates a bit-width of 128
            </summary>
        </member>
        <member name="F:Z0.TypeWidth.W256">
            <summary>
            Indicates a bit-width of 256
            </summary>
        </member>
        <member name="F:Z0.TypeWidth.W512">
            <summary>
            Indicates a bit-width of 512
            </summary>
        </member>
        <member name="F:Z0.TypeWidth.W1024">
            <summary>
            Indicates a bit-width of 1024
            </summary>
        </member>
        <member name="T:Z0.VectorWidth">
            <summary>
            Defines a <see cref="T:Z0.DataWidth"/> subset that is constrained to widths that correspond to x86 vectorized registers
            </summary>
        </member>
        <member name="F:Z0.VectorWidth.None">
            <summary>
            Empty
            </summary>
        </member>
        <member name="F:Z0.VectorWidth.W64">
            <summary>
            Indicates a bit-width of 64
            </summary>
        </member>
        <member name="F:Z0.VectorWidth.W128">
            <summary>
            Indicates a bit-width of 128
            </summary>
        </member>
        <member name="F:Z0.VectorWidth.W256">
            <summary>
            Indicates a bit-width of 256
            </summary>
        </member>
        <member name="F:Z0.VectorWidth.W512">
            <summary>
            Indicates a bit-width of 512
            </summary>
        </member>
        <member name="T:PartId">
            <summary>
            Defines identifiers for assemblies that comprise this ... monstrosity?
            </summary>
        </member>
        <member name="T:ExternId">
            <summary>
            Defines identifiers for external library dependencies, probably native
            </summary>
        </member>
    </members>
</doc>
